// Auto-generated from md directory. Update this file when Markdown content changes.
window.DOCS_DATA = {"md/Parts-A-Open.md": "# 附录A - 开发环境搭建详细指南\n\n**文档版本**: v1.0\n**适用人员**: 全体开发人员（新人必读）\n**预计搭建时间**: 4-8 小时\n**最后更新**: 2025-12-21\n\n---\n\n## 目录\n\n1. [硬件要求](#一硬件要求)\n2. [操作系统准备](#二操作系统准备)\n3. [基础工具安装](#三基础工具安装)\n4. [Rust 开发环境](#四rust-开发环境)\n5. [IDE 配置](#五ide-配置)\n6. [数据库环境](#六数据库环境)\n7. [消息队列环境](#七消息队列环境)\n8. [容器环境](#八容器环境)\n9. [项目代码获取](#九项目代码获取)\n10. [环境验证](#十环境验证)\n11. [常见问题](#十一常见问题)\n\n---\n\n## 一、硬件要求\n\n### 最低配置\n- **CPU**: 4核（Intel i5 或 AMD Ryzen 5）\n- **内存**: 16GB RAM\n- **硬盘**: 256GB SSD（至少50GB可用空间）\n- **网络**: 稳定的互联网连接\n\n### 推荐配置\n- **CPU**: 8核或以上（Intel i7/i9 或 AMD Ryzen 7/9）\n- **内存**: 32GB RAM\n- **硬盘**: 512GB SSD 或更大\n- **网络**: 100Mbps 或更快\n\n### 为什么需要这些配置？\n- **内存**: Rust 编译器内存占用较大，并行编译需要更多内存\n- **CPU**: 多核可加速 Cargo 并行编译\n- **SSD**: 加快依赖下载和编译速度\n- **网络**: 下载 Rust 依赖、Docker 镜像需要良好网络\n\n---\n\n## 二、操作系统准备\n\n### macOS（推荐）\n\n**支持版本**: macOS 12 (Monterey) 或更高\n\n**前置准备**:\n```bash\n# 1. 安装 Xcode Command Line Tools\nxcode-select --install\n\n# 2. 安装 Homebrew（包管理器）\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n\n# 3. 验证 Homebrew 安装\nbrew --version\n```\n\n### Linux（Ubuntu/Debian）\n\n**支持版本**: Ubuntu 22.04 LTS 或更高\n\n**前置准备**:\n```bash\n# 1. 更新系统\nsudo apt update && sudo apt upgrade -y\n\n# 2. 安装基础工具\nsudo apt install -y build-essential curl wget git \\\n    pkg-config libssl-dev protobuf-compiler\n\n# 3. 验证 GCC 版本（需要 GCC 9+）\ngcc --version\n```\n\n### Windows（使用 WSL2）\n\n**不推荐直接在 Windows 上开发**，建议使用 WSL2 (Windows Subsystem for Linux)\n\n**WSL2 安装步骤**:\n```powershell\n# 1. 以管理员身份打开 PowerShell\n\n# 2. 启用 WSL\nwsl --install\n\n# 3. 重启计算机\n\n# 4. 安装 Ubuntu 22.04\nwsl --install -d Ubuntu-22.04\n\n# 5. 进入 WSL，设置用户名和密码\nwsl\n\n# 6. 在 WSL 内按照 Linux 步骤继续\n```\n\n---\n\n## 三、基础工具安装\n\n### Git（版本控制）\n\n**macOS**:\n```bash\nbrew install git\ngit --version  # 应该是 2.30+\n```\n\n**Linux**:\n```bash\nsudo apt install git\ngit --version\n```\n\n**Git 配置**:\n```bash\n# 配置用户信息\ngit config --global user.name \"你的姓名\"\ngit config --global user.email \"your.email@example.com\"\n\n# 配置默认分支名\ngit config --global init.defaultBranch main\n\n# 配置自动换行（macOS/Linux）\ngit config --global core.autocrlf input\n\n# 配置 SSH Key（用于 GitHub）\nssh-keygen -t ed25519 -C \"your.email@example.com\"\n# 按提示操作，默认路径即可，可设置密码或留空\n\n# 添加 SSH Key 到 ssh-agent\neval \"$(ssh-agent -s)\"\nssh-add ~/.ssh/id_ed25519\n\n# 查看公钥并复制到 GitHub\ncat ~/.ssh/id_ed25519.pub\n# 访问 https://github.com/settings/keys 添加 SSH Key\n```\n\n### Protobuf 编译器（gRPC 必需）\n\n**macOS**:\n```bash\nbrew install protobuf\nprotoc --version  # 应该是 3.20+\n```\n\n**Linux**:\n```bash\n# 方法1: 使用包管理器（可能版本较旧）\nsudo apt install protobuf-compiler\n\n# 方法2: 手动安装最新版本\nPROTOC_VERSION=25.1\ncurl -LO https://github.com/protocolbuffers/protobuf/releases/download/v${PROTOC_VERSION}/protoc-${PROTOC_VERSION}-linux-x86_64.zip\nunzip protoc-${PROTOC_VERSION}-linux-x86_64.zip -d $HOME/.local\necho 'export PATH=\"$HOME/.local/bin:$PATH\"' >> ~/.bashrc\nsource ~/.bashrc\nprotoc --version\n```\n\n---\n\n## 四、Rust 开发环境\n\n### 安装 Rust\n\n**所有平台（使用 rustup）**:\n```bash\n# 1. 安装 rustup（Rust 版本管理器）\ncurl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n\n# 2. 选择安装选项\n# - 选择 1（默认安装）\n\n# 3. 配置环境变量（自动添加到 shell 配置文件）\nsource $HOME/.cargo/env\n\n# 4. 验证安装\nrustc --version  # 应该是 1.75+\ncargo --version\nrustup --version\n```\n\n### 配置 Cargo 镜像源（中国大陆用户）\n\n```bash\n# 创建 Cargo 配置文件\nmkdir -p ~/.cargo\ncat > ~/.cargo/config.toml << 'EOF'\n[source.crates-io]\nreplace-with = 'ustc'\n\n[source.ustc]\nregistry = \"sparse+https://mirrors.ustc.edu.cn/crates.io-index/\"\n\n[net]\ngit-fetch-with-cli = true\nEOF\n```\n\n### 安装常用 Rust 工具\n\n```bash\n# 代码格式化工具\nrustup component add rustfmt\n\n# 代码检查工具\nrustup component add clippy\n\n# Rust 文档工具\nrustup component add rust-docs\n\n# 代码覆盖率工具\ncargo install cargo-tarpaulin\n\n# 依赖安全审计工具\ncargo install cargo-audit\n\n# 监控文件变化自动编译\ncargo install cargo-watch\n\n# SQL 迁移工具\ncargo install sqlx-cli --no-default-features --features postgres\n\n# 验证安装\ncargo fmt --version\ncargo clippy --version\ncargo tarpaulin --version\ncargo audit --version\nsqlx --version\n```\n\n---\n\n## 五、IDE 配置\n\n### VS Code（推荐）\n\n**1. 安装 VS Code**:\n- 下载地址: https://code.visualstudio.com/\n- macOS: `brew install --cask visual-studio-code`\n- Linux: 下载 `.deb` 或 `.rpm` 包安装\n\n**2. 安装必需扩展**:\n\n在 VS Code 中按 `Cmd+Shift+X`（macOS）或 `Ctrl+Shift+X`（Linux/Windows），搜索并安装：\n\n| 扩展名 | 用途 | 必需程度 |\n|-------|------|---------|\n| rust-analyzer | Rust 语言支持（代码补全、跳转、重构） | ⭐⭐⭐⭐⭐ |\n| CodeLLDB | Rust 调试器 | ⭐⭐⭐⭐⭐ |\n| Even Better TOML | TOML 文件支持（Cargo.toml） | ⭐⭐⭐⭐ |\n| Error Lens | 行内显示错误和警告 | ⭐⭐⭐⭐ |\n| GitLens | Git 增强（查看提交历史、作者） | ⭐⭐⭐⭐ |\n| Docker | Docker 文件支持 | ⭐⭐⭐ |\n| Markdown All in One | Markdown 编辑增强 | ⭐⭐⭐ |\n| REST Client | API 测试（发送 HTTP 请求） | ⭐⭐⭐ |\n| PostgreSQL | PostgreSQL 查询和管理 | ⭐⭐⭐ |\n\n**3. 配置 VS Code 设置**:\n\n打开设置（`Cmd+,` 或 `Ctrl+,`），搜索并配置：\n\n```json\n{\n    // Rust-Analyzer 配置\n    \"rust-analyzer.check.command\": \"clippy\",\n    \"rust-analyzer.check.extraArgs\": [\"--\", \"-D\", \"warnings\"],\n    \"rust-analyzer.cargo.features\": \"all\",\n\n    // 保存时自动格式化\n    \"editor.formatOnSave\": true,\n    \"[rust]\": {\n        \"editor.defaultFormatter\": \"rust-lang.rust-analyzer\"\n    },\n\n    // 保存时自动运行 Clippy\n    \"rust-analyzer.checkOnSave\": true,\n\n    // 显示提示类型\n    \"editor.inlayHints.enabled\": \"on\",\n\n    // 文件保存时自动修复\n    \"editor.codeActionsOnSave\": {\n        \"source.fixAll\": true\n    },\n\n    // Git 配置\n    \"git.autofetch\": true,\n    \"git.confirmSync\": false,\n\n    // 终端配置\n    \"terminal.integrated.defaultProfile.osx\": \"zsh\",\n    \"terminal.integrated.fontSize\": 14\n}\n```\n\n**4. 配置调试（launch.json）**:\n\n创建 `.vscode/launch.json`:\n```json\n{\n    \"version\": \"0.2.0\",\n    \"configurations\": [\n        {\n            \"type\": \"lldb\",\n            \"request\": \"launch\",\n            \"name\": \"Debug executable\",\n            \"cargo\": {\n                \"args\": [\n                    \"build\",\n                    \"--bin=financial-service\",\n                    \"--package=financial-service\"\n                ],\n                \"filter\": {\n                    \"name\": \"financial-service\",\n                    \"kind\": \"bin\"\n                }\n            },\n            \"args\": [],\n            \"cwd\": \"${workspaceFolder}\"\n        },\n        {\n            \"type\": \"lldb\",\n            \"request\": \"launch\",\n            \"name\": \"Debug unit tests\",\n            \"cargo\": {\n                \"args\": [\n                    \"test\",\n                    \"--no-run\",\n                    \"--lib\",\n                    \"--package=financial-service\"\n                ],\n                \"filter\": {\n                    \"name\": \"financial-service\",\n                    \"kind\": \"lib\"\n                }\n            },\n            \"args\": [],\n            \"cwd\": \"${workspaceFolder}\"\n        }\n    ]\n}\n```\n\n### 其他 IDE 选项\n\n**JetBrains RustRover**:\n- 专业 Rust IDE（付费，有免费试用）\n- 下载: https://www.jetbrains.com/rust/\n- 功能强大但资源占用较大\n\n**Vim/Neovim**:\n- 适合 Vim 高手\n- 需要配置 coc.nvim + rust-analyzer\n- 配置复杂但性能优秀\n\n---\n\n## 六、数据库环境\n\n### 安装 Docker（推荐方式）\n\n**macOS**:\n```bash\n# 1. 安装 Docker Desktop\nbrew install --cask docker\n\n# 2. 启动 Docker Desktop（从应用程序中打开）\n\n# 3. 验证安装\ndocker --version\ndocker-compose --version\n```\n\n**Linux**:\n```bash\n# 1. 安装 Docker Engine\ncurl -fsSL https://get.docker.com -o get-docker.sh\nsudo sh get-docker.sh\n\n# 2. 将当前用户添加到 docker 组（避免每次 sudo）\nsudo usermod -aG docker $USER\nnewgrp docker\n\n# 3. 启动 Docker 服务\nsudo systemctl start docker\nsudo systemctl enable docker\n\n# 4. 验证安装\ndocker --version\n\n# 5. 安装 Docker Compose\nsudo curl -L \"https://github.com/docker/compose/releases/download/v2.23.0/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose\nsudo chmod +x /usr/local/bin/docker-compose\ndocker-compose --version\n```\n\n### 启动 PostgreSQL（Docker）\n\n**创建 docker-compose.yml**:\n```yaml\n# 在项目根目录创建 docker-compose.dev.yml\nversion: '3.8'\n\nservices:\n  postgres:\n    image: postgres:16\n    container_name: erp-postgres-dev\n    environment:\n      POSTGRES_USER: erp_user\n      POSTGRES_PASSWORD: erp_password\n      POSTGRES_DB: erp_dev\n    ports:\n      - \"5432:5432\"\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n      - ./init-scripts:/docker-entrypoint-initdb.d\n    healthcheck:\n      test: [\"CMD-SHELL\", \"pg_isready -U erp_user\"]\n      interval: 10s\n      timeout: 5s\n      retries: 5\n\n  pgadmin:\n    image: dpage/pgadmin4:latest\n    container_name: erp-pgadmin-dev\n    environment:\n      PGADMIN_DEFAULT_EMAIL: admin@example.com\n      PGADMIN_DEFAULT_PASSWORD: admin\n    ports:\n      - \"5050:80\"\n    depends_on:\n      - postgres\n\nvolumes:\n  postgres_data:\n```\n\n**启动数据库**:\n```bash\n# 启动\ndocker-compose -f docker-compose.dev.yml up -d\n\n# 查看日志\ndocker-compose -f docker-compose.dev.yml logs -f postgres\n\n# 停止\ndocker-compose -f docker-compose.dev.yml down\n\n# 停止并删除数据（慎用！）\ndocker-compose -f docker-compose.dev.yml down -v\n```\n\n**访问数据库**:\n- PostgreSQL: `localhost:5432`\n- 用户名: `erp_user`\n- 密码: `erp_password`\n- 数据库: `erp_dev`\n- pgAdmin: http://localhost:5050\n\n**使用 psql 连接**:\n```bash\n# 方法1: 使用 Docker exec\ndocker exec -it erp-postgres-dev psql -U erp_user -d erp_dev\n\n# 方法2: 安装本地 psql 客户端\n# macOS\nbrew install postgresql@16\npsql -h localhost -U erp_user -d erp_dev\n```\n\n---\n\n## 七、消息队列环境\n\n### 启动 Kafka（Docker）\n\n**添加到 docker-compose.dev.yml**:\n```yaml\n  zookeeper:\n    image: confluentinc/cp-zookeeper:7.5.0\n    container_name: erp-zookeeper-dev\n    environment:\n      ZOOKEEPER_CLIENT_PORT: 2181\n      ZOOKEEPER_TICK_TIME: 2000\n    ports:\n      - \"2181:2181\"\n\n  kafka:\n    image: confluentinc/cp-kafka:7.5.0\n    container_name: erp-kafka-dev\n    depends_on:\n      - zookeeper\n    ports:\n      - \"9092:9092\"\n    environment:\n      KAFKA_BROKER_ID: 1\n      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181\n      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://localhost:9092\n      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1\n      KAFKA_TRANSACTION_STATE_LOG_MIN_ISR: 1\n      KAFKA_TRANSACTION_STATE_LOG_REPLICATION_FACTOR: 1\n    healthcheck:\n      test: [\"CMD-SHELL\", \"kafka-broker-api-versions --bootstrap-server localhost:9092\"]\n      interval: 10s\n      timeout: 10s\n      retries: 5\n\n  kafka-ui:\n    image: provectuslabs/kafka-ui:latest\n    container_name: erp-kafka-ui-dev\n    depends_on:\n      - kafka\n    ports:\n      - \"8080:8080\"\n    environment:\n      KAFKA_CLUSTERS_0_NAME: local\n      KAFKA_CLUSTERS_0_BOOTSTRAPSERVERS: kafka:9092\n```\n\n**启动 Kafka**:\n```bash\ndocker-compose -f docker-compose.dev.yml up -d kafka kafka-ui\n```\n\n**访问 Kafka UI**: http://localhost:8080\n\n**创建测试 Topic**:\n```bash\n# 进入 Kafka 容器\ndocker exec -it erp-kafka-dev bash\n\n# 创建 Topic\nkafka-topics --create --topic test-topic \\\n  --bootstrap-server localhost:9092 \\\n  --partitions 3 \\\n  --replication-factor 1\n\n# 列出所有 Topic\nkafka-topics --list --bootstrap-server localhost:9092\n\n# 退出容器\nexit\n```\n\n### 启动 Redis（Docker）\n\n**添加到 docker-compose.dev.yml**:\n```yaml\n  redis:\n    image: redis:7-alpine\n    container_name: erp-redis-dev\n    command: redis-server --appendonly yes\n    ports:\n      - \"6379:6379\"\n    volumes:\n      - redis_data:/data\n    healthcheck:\n      test: [\"CMD\", \"redis-cli\", \"ping\"]\n      interval: 10s\n      timeout: 3s\n      retries: 5\n\n  redis-commander:\n    image: rediscommander/redis-commander:latest\n    container_name: erp-redis-ui-dev\n    depends_on:\n      - redis\n    environment:\n      - REDIS_HOSTS=local:redis:6379\n    ports:\n      - \"8081:8081\"\n\nvolumes:\n  redis_data:\n```\n\n**访问 Redis**:\n- Redis: `localhost:6379`\n- Redis Commander: http://localhost:8081\n\n---\n\n## 八、容器环境\n\n### 本地 Kubernetes（可选，用于测试部署）\n\n**macOS（使用 Docker Desktop 内置 K8s）**:\n1. 打开 Docker Desktop\n2. Settings → Kubernetes → Enable Kubernetes\n3. 等待启动完成\n\n**或使用 k3d（轻量级 K8s）**:\n```bash\n# macOS\nbrew install k3d\n\n# Linux\nwget -q -O - https://raw.githubusercontent.com/k3d-io/k3d/main/install.sh | bash\n\n# 创建集群\nk3d cluster create erp-dev --agents 2\n\n# 验证\nkubectl get nodes\n```\n\n**安装 kubectl**:\n```bash\n# macOS\nbrew install kubectl\n\n# Linux\ncurl -LO \"https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl\"\nsudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl\n\n# 验证\nkubectl version --client\n```\n\n---\n\n## 九、项目代码获取\n\n### 1. Clone 代码仓库\n\n```bash\n# 创建工作目录\nmkdir -p ~/projects\ncd ~/projects\n\n# Clone 项目（使用 SSH）\ngit clone git@github.com:your-org/rust-erp.git\ncd rust-erp\n\n# 查看分支\ngit branch -a\n\n# 切换到开发分支\ngit checkout develop\n```\n\n### 2. 安装项目依赖\n\n```bash\n# 下载并编译所有依赖（首次较慢，10-30分钟）\ncargo build\n\n# 只检查编译（不生成二进制，更快）\ncargo check\n```\n\n### 3. 配置环境变量\n\n```bash\n# 复制环境变量模板\ncp .env.example .env\n\n# 编辑环境变量\nvim .env  # 或使用你喜欢的编辑器\n```\n\n**.env 示例**:\n```bash\n# 数据库\nDATABASE_URL=postgres://erp_user:erp_password@localhost:5432/erp_dev\n\n# Redis\nREDIS_URL=redis://localhost:6379\n\n# Kafka\nKAFKA_BROKERS=localhost:9092\n\n# 日志级别\nRUST_LOG=info,financial_service=debug\n\n# 服务端口\nSERVICE_PORT=8001\n```\n\n### 4. 运行数据库迁移\n\n```bash\n# 进入某个服务目录\ncd services/financial-service\n\n# 运行迁移\nsqlx migrate run\n\n# 验证迁移\nsqlx migrate info\n```\n\n---\n\n## 十、环境验证\n\n### 全自动验证脚本\n\n创建 `scripts/verify-env.sh`:\n```bash\n#!/bin/bash\n\necho \"=== Rust ERP 开发环境验证脚本 ===\"\necho \"\"\n\n# 颜色定义\nGREEN='\\033[0;32m'\nRED='\\033[0;31m'\nNC='\\033[0m' # No Color\n\ncheck_command() {\n    if command -v $1 &> /dev/null; then\n        echo -e \"${GREEN}✓${NC} $1 已安装: $($1 --version | head -n 1)\"\n    else\n        echo -e \"${RED}✗${NC} $1 未安装\"\n        return 1\n    fi\n}\n\ncheck_port() {\n    if nc -z localhost $1 2>/dev/null; then\n        echo -e \"${GREEN}✓${NC} 端口 $1 ($2) 可访问\"\n    else\n        echo -e \"${RED}✗${NC} 端口 $1 ($2) 不可访问\"\n        return 1\n    fi\n}\n\necho \"--- 检查基础工具 ---\"\ncheck_command git\ncheck_command docker\ncheck_command docker-compose\ncheck_command rustc\ncheck_command cargo\ncheck_command protoc\ncheck_command sqlx\n\necho \"\"\necho \"--- 检查 Cargo 工具 ---\"\ncheck_command cargo-fmt\ncheck_command cargo-clippy\ncheck_command cargo-tarpaulin\ncheck_command cargo-audit\n\necho \"\"\necho \"--- 检查服务端口 ---\"\ncheck_port 5432 \"PostgreSQL\"\ncheck_port 6379 \"Redis\"\ncheck_port 9092 \"Kafka\"\n\necho \"\"\necho \"--- 检查 Docker 容器 ---\"\ndocker ps --format \"table {{.Names}}\\t{{.Status}}\" | grep erp-\n\necho \"\"\necho \"--- 测试数据库连接 ---\"\nif psql $DATABASE_URL -c \"SELECT 1\" &> /dev/null; then\n    echo -e \"${GREEN}✓${NC} PostgreSQL 连接成功\"\nelse\n    echo -e \"${RED}✗${NC} PostgreSQL 连接失败\"\nfi\n\necho \"\"\necho \"=== 验证完成 ===\"\n```\n\n**运行验证**:\n```bash\nchmod +x scripts/verify-env.sh\n./scripts/verify-env.sh\n```\n\n### 手动验证步骤\n\n**1. 验证 Rust 环境**:\n```bash\n# 编译测试项目\ncargo new hello-rust\ncd hello-rust\ncargo run\n# 应该输出 \"Hello, world!\"\n```\n\n**2. 验证数据库**:\n```bash\n# 连接数据库\npsql -h localhost -U erp_user -d erp_dev\n\n# 在 psql 中执行\nCREATE TABLE test (id SERIAL PRIMARY KEY, name VARCHAR(50));\nINSERT INTO test (name) VALUES ('Hello');\nSELECT * FROM test;\nDROP TABLE test;\n\\q\n```\n\n**3. 验证 Redis**:\n```bash\n# 使用 redis-cli\ndocker exec -it erp-redis-dev redis-cli\n\n# 在 redis-cli 中执行\nPING\n# 应该返回 PONG\n\nSET test \"Hello Redis\"\nGET test\n# 应该返回 \"Hello Redis\"\n\nDEL test\nEXIT\n```\n\n**4. 验证 Kafka**:\n```bash\n# 发送测试消息\ndocker exec -it erp-kafka-dev kafka-console-producer \\\n  --broker-list localhost:9092 \\\n  --topic test-topic\n# 输入一些消息，按 Ctrl+C 退出\n\n# 消费测试消息\ndocker exec -it erp-kafka-dev kafka-console-consumer \\\n  --bootstrap-server localhost:9092 \\\n  --topic test-topic \\\n  --from-beginning\n# 应该看到刚才发送的消息\n```\n\n**5. 验证项目编译**:\n```bash\n# 在项目根目录\ncd ~/projects/rust-erp\n\n# 检查所有服务\ncargo check --workspace\n\n# 运行测试\ncargo test --workspace\n\n# 运行某个服务\ncargo run --bin financial-service\n# 应该看到服务启动日志\n```\n\n---\n\n## 十一、常见问题\n\n### Q1: Cargo 下载依赖很慢\n\n**A1**: 配置国内镜像源（见第四章），或使用代理：\n```bash\n# 设置代理（临时）\nexport https_proxy=http://127.0.0.1:7890\nexport http_proxy=http://127.0.0.1:7890\n\n# 或在 ~/.cargo/config.toml 中配置\n[http]\nproxy = \"127.0.0.1:7890\"\n```\n\n### Q2: rust-analyzer 很慢或卡死\n\n**A2**:\n```bash\n# 1. 清理 target 目录\ncargo clean\n\n# 2. 重启 rust-analyzer\n# 在 VS Code 中: Cmd+Shift+P → \"Reload Window\"\n\n# 3. 禁用部分检查（在 VS Code 设置中）\n\"rust-analyzer.checkOnSave.allTargets\": false\n```\n\n### Q3: Docker 容器无法启动\n\n**A3**:\n```bash\n# 查看容器日志\ndocker-compose -f docker-compose.dev.yml logs postgres\n\n# 查看容器状态\ndocker ps -a | grep erp\n\n# 删除所有容器重新开始\ndocker-compose -f docker-compose.dev.yml down -v\ndocker-compose -f docker-compose.dev.yml up -d\n```\n\n### Q4: 数据库连接被拒绝\n\n**A4**:\n```bash\n# 1. 检查容器是否运行\ndocker ps | grep postgres\n\n# 2. 检查端口是否被占用\nlsof -i :5432  # macOS/Linux\nnetstat -ano | findstr :5432  # Windows\n\n# 3. 检查 DATABASE_URL 是否正确\necho $DATABASE_URL\n\n# 4. 测试连接\ndocker exec -it erp-postgres-dev psql -U erp_user -d erp_dev\n```\n\n### Q5: 编译错误：链接器错误\n\n**A5**:\n```bash\n# macOS: 安装 Xcode Command Line Tools\nxcode-select --install\n\n# Linux: 安装 build-essential\nsudo apt install build-essential\n\n# 检查链接器\nwhich ld\nld --version\n```\n\n### Q6: 内存不足，编译失败\n\n**A6**:\n```bash\n# 减少并行编译任务数\nexport CARGO_BUILD_JOBS=2\n\n# 或在 ~/.cargo/config.toml 中配置\n[build]\njobs = 2\n\n# 增加交换空间（Linux）\nsudo fallocate -l 8G /swapfile\nsudo chmod 600 /swapfile\nsudo mkswap /swapfile\nsudo swapon /swapfile\n```\n\n### Q7: SQLx 编译时检查失败\n\n**A7**:\n```bash\n# 1. 确保数据库正在运行\ndocker ps | grep postgres\n\n# 2. 确保 DATABASE_URL 正确\necho $DATABASE_URL\n\n# 3. 运行迁移\ncd services/financial-service\nsqlx migrate run\n\n# 4. 准备 SQLx 离线模式（可选）\ncargo sqlx prepare\n```\n\n---\n\n", "md/Parts-B-Bom.md": "# 附录B - 代码评审检查清单\n\n**文档版本**: v1.0\n**适用人员**: 全体开发人员（代码评审者必读）\n**最后更新**: 2025-12-21\n\n---\n\n## 📋 使用说明\n\n### 为什么需要检查清单？\n- ✅ 确保评审质量一致性\n- ✅ 避免遗漏重要检查项\n- ✅ 新人快速掌握评审要点\n- ✅ 减少返工和缺陷\n\n### 如何使用本清单？\n1. 打开 Pull Request\n2. 逐项检查本清单\n3. 在 PR 评论中标注检查结果\n4. 所有 ❌ 项修复后再批准\n\n### 评审原则\n- **善意推定**: 假设作者做了最好的决策\n- **具体建议**: 不只指出问题，还要提供解决方案\n- **及时反馈**: 24小时内完成评审\n- **持续学习**: 从每次评审中学习\n\n---\n\n## 一、形式检查（5分钟）\n\n### ✅ PR 信息完整性\n\n- [ ] **标题清晰**\n  - 格式: `[模块] 简短描述 (#任务编号)`\n  - 示例: `[Financial] 实现会计科目创建功能 (#FIN-001)`\n  - ❌ 不好: \"修复 bug\"、\"更新代码\"\n\n- [ ] **描述完整**\n  - 变更内容说明（做了什么）\n  - 变更原因说明（为什么这样做）\n  - 测试覆盖情况\n  - 截图/录屏（UI 变更）\n  - 相关文档链接\n\n- [ ] **关联任务**\n  - Jira Ticket 已关联\n  - Issue 已引用\n  - 相关 PR 已链接\n\n### ✅ 分支和提交\n\n- [ ] **分支命名规范**\n  - ✅ `feature/financial-account-creation-FIN-001`\n  - ✅ `bugfix/fix-null-pointer-ISS-123`\n  - ❌ `my-branch`、`test`、`temp`\n\n- [ ] **提交信息规范**\n  - 遵循 Conventional Commits\n  - ✅ `feat: add account creation API`\n  - ✅ `fix: resolve null pointer in balance calculation`\n  - ✅ `refactor: extract validation logic to domain service`\n  - ❌ \"update\"、\"wip\"、\"临时提交\"\n\n- [ ] **提交粒度合理**\n  - 每个提交是独立的逻辑单元\n  - 避免巨大提交（> 1000 行）\n  - 避免混合无关改动\n\n### ✅ CI 检查通过\n\n- [ ] **编译成功** (`cargo build`)\n- [ ] **测试通过** (`cargo test`)\n- [ ] **代码格式** (`cargo fmt --check`)\n- [ ] **Clippy 无警告** (`cargo clippy`)\n- [ ] **安全审计** (`cargo audit`)\n- [ ] **代码覆盖率** (未降低)\n\n---\n\n## 二、代码质量检查（15分钟）\n\n### ✅ 代码可读性\n\n- [ ] **命名清晰**\n  - 变量名见名知意\n  - 函数名动词开头（`create_account`、`calculate_balance`）\n  - 类型名名词（`Account`、`Transaction`）\n  - 常量大写（`MAX_RETRY_COUNT`）\n  - ❌ 避免: `a`、`tmp`、`data`、`handle`\n\n- [ ] **函数长度适中**\n  - 单个函数 < 50 行（理想 < 30 行）\n  - 如超过，考虑拆分\n\n- [ ] **注释恰当**\n  - 复杂逻辑有注释说明\n  - 公开 API 有文档注释（`///`）\n  - 避免无用注释（不要重复代码）\n  - ❌ 不好: `// 加 1`  `x = x + 1;`\n  - ✅ 好: `// 重试次数加 1，最大重试 3 次`\n\n- [ ] **代码结构清晰**\n  - 逻辑分块，用空行分隔\n  - 相关代码放在一起\n  - 避免深度嵌套（> 4 层）\n\n### ✅ Rust 代码规范\n\n- [ ] **错误处理**\n  - 禁止 `unwrap()` 和 `expect()`（除非有明确理由）\n  - 使用 `Result` 和 `?` 操作符\n  - 自定义错误类型（使用 `thiserror`）\n  - ```rust\n    // ❌ 不好\n    let config = load_config().unwrap();\n\n    // ✅ 好\n    let config = load_config()\n        .context(\"Failed to load configuration\")?;\n    ```\n\n- [ ] **所有权和借用**\n  - 避免不必要的 `.clone()`\n  - 优先使用引用（`&T`）\n  - 考虑使用 `Cow<T>` 优化克隆\n  - ```rust\n    // ❌ 不好\n    fn process(data: String) { ... }\n\n    // ✅ 好（如不需要所有权）\n    fn process(data: &str) { ... }\n    ```\n\n- [ ] **生命周期**\n  - 生命周期标注清晰\n  - 避免不必要的 `'static`\n  - 优先使用生命周期省略规则\n\n- [ ] **并发安全**\n  - 正确使用 `Arc` / `Mutex` / `RwLock`\n  - 避免死锁（注意锁顺序）\n  - 使用 `Send` + `Sync` trait 约束\n\n- [ ] **类型系统**\n  - 优先使用强类型（避免 `String` 滥用）\n  - 使用 NewType 模式（如 `AccountId(Uuid)`）\n  - 利用类型系统保证业务规则\n\n### ✅ 性能考虑\n\n- [ ] **避免不必要的分配**\n  - 使用 `&str` 而非 `String`（当不需要所有权）\n  - 使用 `Vec::with_capacity` 预分配\n  - 避免循环中重复分配\n\n- [ ] **数据库查询优化**\n  - 避免 N+1 查询\n  - 使用批量查询\n  - 添加必要的索引\n  - 查询只返回需要的字段\n\n- [ ] **算法复杂度**\n  - 时间复杂度合理（避免 O(n²) 以上）\n  - 空间复杂度合理\n  - 大数据量考虑分页\n\n---\n\n## 三、业务逻辑检查（15分钟）\n\n### ✅ DDD 设计原则\n\n- [ ] **领域层独立**\n  - 领域层不依赖基础设施层\n  - 领域层不包含框架代码（Axum、SQLx）\n  - ```rust\n    // ❌ 不好（领域层依赖 SQLx）\n    impl Account {\n        async fn save(&self, pool: &PgPool) { ... }\n    }\n\n    // ✅ 好（通过仓储接口）\n    #[async_trait]\n    trait AccountRepository {\n        async fn save(&self, account: &Account) -> Result<()>;\n    }\n    ```\n\n- [ ] **聚合根完整性**\n  - 聚合根保证一致性边界\n  - 外部只能通过聚合根修改内部实体\n  - 聚合根方法返回领域事件\n  - ```rust\n    // ✅ 好\n    impl Order {\n        pub fn add_item(&mut self, item: OrderLine) -> Result<OrderItemAdded> {\n            // 验证业务规则\n            if self.status != OrderStatus::Pending {\n                return Err(DomainError::CannotModifyConfirmedOrder);\n            }\n            // 修改状态\n            self.items.push(item.clone());\n            // 返回事件\n            Ok(OrderItemAdded { order_id: self.id, item })\n        }\n    }\n    ```\n\n- [ ] **值对象不可变**\n  - 值对象字段为 `pub` 或私有\n  - 没有 `set_xxx` 方法\n  - 通过构造函数创建新实例\n  - ```rust\n    // ✅ 好\n    #[derive(Clone, Copy)]\n    pub struct Money {\n        amount: Decimal,\n        currency: Currency,\n    }\n\n    impl Money {\n        pub fn new(amount: Decimal, currency: Currency) -> Result<Self> {\n            if amount < Decimal::ZERO {\n                return Err(MoneyError::NegativeAmount);\n            }\n            Ok(Self { amount, currency })\n        }\n    }\n    ```\n\n### ✅ 业务规则验证\n\n- [ ] **业务规则在领域层**\n  - 不在 API 层或应用层验证复杂业务规则\n  - 领域层方法包含所有业务逻辑\n  - ```rust\n    // ❌ 不好（业务规则在 API 层）\n    async fn create_order_handler(payload: CreateOrderRequest) {\n        if payload.items.is_empty() {\n            return Err(\"订单必须有商品\");\n        }\n        // ...\n    }\n\n    // ✅ 好（业务规则在领域层）\n    impl Order {\n        pub fn create(items: Vec<OrderLine>) -> Result<Self> {\n            if items.is_empty() {\n                return Err(DomainError::EmptyOrder);\n            }\n            // ...\n        }\n    }\n    ```\n\n- [ ] **数据一致性**\n  - 金额计算无精度丢失（使用 `Decimal`）\n  - 状态转换合法（状态机模式）\n  - 外键关联完整\n\n- [ ] **边界条件处理**\n  - 空值、零值、负值\n  - 最大值、最小值\n  - 并发冲突\n\n### ✅ CQRS 模式\n\n- [ ] **命令和查询分离**\n  - Command Handler 返回 `Result<(), Error>`（不返回数据）\n  - Query Handler 返回 `Result<DTO, Error>`\n  - ```rust\n    // ✅ 命令（修改数据，不返回业务数据）\n    pub async fn handle_create_account(\n        cmd: CreateAccountCommand\n    ) -> Result<(), ApplicationError> {\n        // ...\n        Ok(())\n    }\n\n    // ✅ 查询（只读，返回数据）\n    pub async fn handle_get_account(\n        query: GetAccountQuery\n    ) -> Result<AccountDto, ApplicationError> {\n        // ...\n        Ok(dto)\n    }\n    ```\n\n- [ ] **读写模型分离**\n  - 写模型：标准化数据库表\n  - 读模型：反规范化视图或缓存\n  - 异步投影事件到读模型\n\n---\n\n## 四、安全性检查（10分钟）\n\n### ✅ 输入验证\n\n- [ ] **参数验证**\n  - 所有外部输入已验证（使用 `validator` crate）\n  - 字符串长度限制\n  - 数值范围检查\n  - 正则表达式匹配（邮箱、手机）\n\n- [ ] **SQL 注入防护**\n  - 使用参数化查询（SQLx 宏）\n  - 禁止字符串拼接 SQL\n  - ```rust\n    // ❌ 不好\n    let sql = format!(\"SELECT * FROM users WHERE name = '{}'\", name);\n\n    // ✅ 好\n    let users = sqlx::query_as!(\n        User,\n        \"SELECT * FROM users WHERE name = $1\",\n        name\n    ).fetch_all(pool).await?;\n    ```\n\n- [ ] **XSS 防护**\n  - 用户输入内容转义\n  - 使用模板引擎自动转义\n\n### ✅ 认证授权\n\n- [ ] **权限检查**\n  - 所有受保护接口验证 Token\n  - 检查用户权限（RBAC）\n  - 资源级权限（用户只能访问自己的数据）\n\n- [ ] **敏感信息保护**\n  - 密码已哈希（bcrypt）\n  - 敏感字段加密存储\n  - 日志不输出敏感信息\n  - ```rust\n    // ❌ 不好\n    tracing::info!(\"User login: {}\", password);\n\n    // ✅ 好\n    tracing::info!(\"User login attempt for: {}\", username);\n    ```\n\n### ✅ 依赖安全\n\n- [ ] **无已知漏洞**\n  - `cargo audit` 通过\n  - 依赖版本非过时版本\n  - 定期更新依赖\n\n---\n\n## 五、测试检查（10分钟）\n\n### ✅ 测试覆盖\n\n- [ ] **单元测试充分**\n  - 领域层 100% 覆盖\n  - 应用层关键逻辑覆盖\n  - 边界条件测试\n  - 错误分支测试\n\n- [ ] **测试命名清晰**\n  - `test_<功能>_<场景>_<预期结果>`\n  - 示例: `test_create_account_with_negative_balance_should_fail`\n\n- [ ] **测试独立性**\n  - 测试间无依赖\n  - 每个测试清理数据\n  - 可并行运行\n\n- [ ] **集成测试**\n  - 端到端业务流程测试\n  - 数据库事务测试\n  - 外部服务 Mock\n\n### ✅ 测试质量\n\n- [ ] **断言充分**\n  - 不只验证无错误，还验证结果正确\n  - ```rust\n    // ❌ 不好\n    assert!(result.is_ok());\n\n    // ✅ 好\n    let account = result.unwrap();\n    assert_eq!(account.balance, expected_balance);\n    assert_eq!(account.status, AccountStatus::Active);\n    ```\n\n- [ ] **Mock 合理**\n  - 使用 `mockall` crate\n  - Mock 外部依赖（数据库、HTTP 调用）\n  - 不过度 Mock（避免测试失去意义）\n\n---\n\n## 六、文档检查（5分钟）\n\n### ✅ 代码文档\n\n- [ ] **公开 API 有文档**\n  - 所有 `pub` 函数/结构体有 `///` 注释\n  - 参数说明\n  - 返回值说明\n  - 示例代码（可选）\n  - ```rust\n    /// 创建新的会计科目\n    ///\n    /// # 参数\n    /// - `account_number`: 科目编号（4-10位数字）\n    /// - `name`: 科目名称\n    /// - `account_type`: 科目类型（资产、负债、权益、收入、费用）\n    ///\n    /// # 返回\n    /// - `Ok(Account)`: 创建成功的科目\n    /// - `Err(DomainError)`: 业务规则验证失败\n    ///\n    /// # 示例\n    /// ```rust\n    /// let account = Account::create(\n    ///     \"1001\",\n    ///     \"现金\",\n    ///     AccountType::Asset\n    /// )?;\n    /// ```\n    pub fn create(...) -> Result<Self, DomainError> { ... }\n    ```\n\n- [ ] **复杂逻辑有注释**\n  - 算法说明\n  - 业务规则引用\n  - 临时方案说明（TODO/FIXME）\n\n### ✅ 相关文档更新\n\n- [ ] **API 文档更新**（如有接口变更）\n- [ ] **架构文档更新**（如有设计变更）\n- [ ] **CHANGELOG 更新**\n- [ ] **README 更新**（如有新功能）\n\n---\n\n## 七、其他检查（5分钟）\n\n### ✅ 配置管理\n\n- [ ] **无硬编码**\n  - 配置通过环境变量或配置文件\n  - 禁止硬编码 URL、密码、API Key\n  - ```rust\n    // ❌ 不好\n    let db_url = \"postgres://user:pass@localhost/db\";\n\n    // ✅ 好\n    let db_url = env::var(\"DATABASE_URL\")?;\n    ```\n\n- [ ] **默认值合理**\n  - 配置有默认值（开发环境）\n  - 生产环境必须显式配置\n\n### ✅ 日志和监控\n\n- [ ] **日志级别合理**\n  - ERROR: 系统错误、业务异常\n  - WARN: 潜在问题\n  - INFO: 关键业务操作\n  - DEBUG: 调试信息（生产环境关闭）\n\n- [ ] **日志结构化**\n  - 使用 `tracing` 宏\n  - 包含上下文（trace_id、user_id 等）\n  - ```rust\n    tracing::info!(\n        transaction_id = %tx_id,\n        amount = %amount,\n        user_id = %user_id,\n        \"Transaction posted successfully\"\n    );\n    ```\n\n- [ ] **指标埋点**\n  - 关键操作埋点（Prometheus metrics）\n  - 业务指标（交易量、金额）\n  - 技术指标（延迟、错误率）\n\n### ✅ 向后兼容性\n\n- [ ] **API 兼容**\n  - 不破坏现有 API（除非大版本升级）\n  - 废弃功能标记 `#[deprecated]`\n  - 提供迁移指南\n\n- [ ] **数据库兼容**\n  - 迁移脚本向后兼容\n  - 不删除正在使用的列（先废弃再删除）\n  - 提供回滚脚本\n\n---\n\n## 八、评审意见模板\n\n### 批准 (Approve)\n```markdown\n✅ LGTM! (Looks Good To Me)\n\n检查项:\n- [x] 代码质量\n- [x] 业务逻辑\n- [x] 测试覆盖\n- [x] 文档完整\n\n优点:\n- 代码清晰易懂\n- DDD 分层合理\n- 测试覆盖充分\n\n建议（非阻塞）:\n- 可以考虑使用 `Cow<str>` 优化第 123 行的性能\n\n已批准合并 👍\n```\n\n### 请求修改 (Request Changes)\n```markdown\n❌ 发现一些问题，需要修改\n\n**必须修改**:\n1. [第 45 行] 使用了 `unwrap()`，应改为 `?` 操作符\n2. [第 78 行] SQL 注入风险，应使用参数化查询\n3. [缺失] 缺少 `create_account` 方法的单元测试\n\n**建议优化**:\n1. [第 123 行] 可以提取为独立函数，提高可读性\n2. [第 156 行] 建议添加注释说明业务规则\n\n修改后请再次提交评审。\n```\n\n### 评论 (Comment)\n```markdown\n💡 有一些疑问和建议\n\n**疑问**:\n1. [第 67 行] 为什么使用 `clone()` 而不是引用？性能考虑？\n2. [第 89 行] `MAX_RETRY_COUNT` 为什么是 5？有业务依据吗？\n\n**建议**:\n1. 可以考虑使用 Builder 模式简化 `Account` 的构造\n2. `calculate_balance` 方法建议添加缓存\n\n期待你的回复 🙂\n```\n\n---\n\n## 九、快速检查模式\n\n**时间紧急时（< 10 分钟），重点检查**:\n\n1. ⚠️ **安全问题**（SQL注入、XSS、权限）\n2. ⚠️ **数据一致性**（金额计算、状态转换）\n3. ⚠️ **严重 Bug**（空指针、数组越界、死锁）\n4. ⚠️ **性能问题**（N+1查询、大循环）\n5. ✅ **CI 通过**（编译、测试、Clippy）\n\n其他细节可以后续 Follow-up Review。\n\n---\n\n## 十、评审者自检\n\n评审完成后，问自己：\n\n- [ ] 我理解这段代码在做什么吗？\n- [ ] 我能在半年后维护这段代码吗？\n- [ ] 如果我是作者，我会接受自己的评审意见吗？\n- [ ] 我的评审意见是建设性的吗？\n- [ ] 我学到了什么新东西吗？\n\n---\n\n**记住**: 代码评审不是找茬，而是团队共同提升代码质量的过程。保持友善、专业、有建设性！\n\n**问题反馈**: 如对本清单有建议，请在 Slack `#development` 频道讨论。\n", "md/README-Nav.md": "# Rust ERP 系统 - 项目文档导航\n\n**项目名称**: Rust ERP 微服务系统\n**文档版本**: v1.0\n**创建日期**: 2025-12-21\n**团队规模**: 5人\n**开发周期**: 12个月\n\n---\n\n## 📚 文档体系总览\n\n本项目文档分为**技术文档**和**管理文档**两大类，共计8份核心文档，覆盖从架构设计到项目交付的全生命周期。\n\n### 文档阅读顺序建议\n\n#### 🎯 项目启动阶段（第1周）\n1. **必读**：《Rust-ERP系统-5人团队12个月开发计划.md》\n   - 了解项目全貌、团队分工、时间表\n2. **必读**：《Rust-DDD-微服务架构最佳实践.md》\n   - 理解技术架构、DDD设计原则\n3. **必读**：《KILLER模块列表.md》\n   - 熟悉业务需求和功能范围\n\n#### 🏗️ 开发阶段（第1-10个月）\n4. **参考**：《Rust-ERP系统架构设计文档.md》\n   - 详细的架构设计、数据流、服务划分\n5. **参考**：《Rust-ERP系统API设计文档.md》\n   - REST/gRPC接口规范\n6. **参考**：《Rust-ERP系统项目目录结构.md》\n   - 代码组织、文件命名规范\n\n#### 📋 项目管理（全程）\n7. **常用**：《Rust-ERP系统-项目管理与协作补充文档.md》\n   - 会议制度、协作流程、培训计划、预算管理\n\n#### 🚀 上线准备阶段（第11-12个月）\n8. **关键**：《Rust-ERP系统-上线运维与演进计划补充文档.md》\n   - 上线检查清单、应急预案、运维交接、长期演进\n\n---\n\n## 📖 核心文档详解\n\n### 1️⃣ 主计划文档\n\n#### 《Rust-ERP系统-5人团队12个月开发计划.md》\n**文档类型**: 项目总体计划\n**页数**: 约150页\n**关键内容**:\n- ✅ 团队角色与职责（5人分工）\n- ✅ 12个月开发计划（240天逐日任务）\n- ✅ 15个微服务开发时间表\n- ✅ 关键里程碑（每月交付物）\n- ✅ 风险管理矩阵\n- ✅ 质量保证策略（测试金字塔）\n- ✅ 成功指标（KPI）\n\n**适用人员**: 全体团队成员、项目经理、技术总监\n\n**使用场景**:\n- 每日站会前查看当天任务\n- Sprint计划会议前查看本周/本月计划\n- 进度汇报时查看里程碑完成情况\n\n---\n\n### 2️⃣ 技术文档系列\n\n#### 《Rust-DDD-微服务架构最佳实践.md》\n**文档类型**: 技术规范\n**页数**: 约80页\n**关键内容**:\n- ✅ DDD四层架构（领域层、应用层、API层、基础设施层）\n- ✅ CQRS模式（命令查询分离）\n- ✅ Event Sourcing（事件溯源）\n- ✅ 微服务通信（gRPC同步、Kafka异步）\n- ✅ Saga模式（分布式事务）\n- ✅ Rust项目结构（Cargo Workspace）\n- ✅ CI/CD流程（GitHub Actions）\n- ✅ Kubernetes部署（Helm Charts）\n\n**适用人员**: 开发者A（架构师）、全体开发人员\n\n**使用场景**:\n- 架构设计评审前必读\n- 新服务开发前参考\n- 代码评审时对照规范\n\n#### 《Rust-ERP系统架构设计文档.md》\n**文档类型**: 架构设计\n**页数**: 约70页\n**关键内容**:\n- ✅ 系统整体架构图\n- ✅ 15个微服务划分（对应KILLER模块）\n- ✅ DDD限界上下文\n- ✅ 数据库设计原则（每服务独立DB）\n- ✅ 事件存储表设计\n- ✅ 可观测性设计（Prometheus、Grafana、Jaeger）\n- ✅ 安全设计（认证、授权、加密）\n- ✅ 部署架构（Kubernetes拓扑）\n\n**适用人员**: 架构师、各模块负责人、DevOps工程师\n\n#### 《Rust-ERP系统API设计文档.md》\n**文档类型**: 接口规范\n**页数**: 约50页\n**关键内容**:\n- ✅ REST API规范（OpenAPI 3.0）\n- ✅ gRPC接口定义（Protobuf）\n- ✅ 接口版本管理\n- ✅ 错误码规范\n- ✅ 请求/响应示例\n- ✅ 认证授权流程\n\n**适用人员**: 全体开发人员、前端集成团队\n\n#### 《Rust-ERP系统项目目录结构.md》\n**文档类型**: 代码规范\n**页数**: 约30页\n**关键内容**:\n- ✅ Monorepo结构（Cargo Workspace）\n- ✅ 单个微服务目录结构\n- ✅ 文件命名规范\n- ✅ 模块组织原则\n- ✅ 测试目录结构\n\n**适用人员**: 全体开发人员\n\n---\n\n### 3️⃣ 业务需求文档\n\n#### 《KILLER模块列表.md》\n**文档类型**: 业务需求\n**页数**: 约200页（详细）\n**关键内容**:\n- ✅ KILLER完整模块列表（200+子模块）\n- ✅ 功能模块（FI、CO、MM、SD、PP、HR、QM、PM等）\n- ✅ 物流供应链模块\n- ✅ 客户关系模块\n- ✅ 项目管理模块\n- ✅ 技术模块\n\n**适用人员**: 全体开发人员（业务理解）、产品经理\n\n**使用场景**:\n- 需求分析阶段\n- 功能开发前理解业务\n- 业务培训\n\n---\n\n### 4️⃣ 管理文档系列\n\n#### 《Rust-ERP系统-项目管理与协作补充文档.md》\n**文档类型**: 项目管理\n**页数**: 约110页\n**关键内容**:\n\n**第一章：团队协作与沟通机制**\n- 沟通渠道分层（即时、异步、文档）\n- Git工作流（分支策略、PR流程）\n- 任务管理（看板、优先级定义）\n- 跨团队协作\n\n**第二章：会议制度详细说明**\n- 每日站会（15分钟，三问题）\n- Sprint计划会议（2小时）\n- Sprint评审会议（90分钟）\n- Sprint回顾会议（60分钟）\n- 技术分享会（每周）\n- 架构评审会议（按需）\n- Post-mortem会议（事故复盘）\n\n**第三章：知识管理与文档体系**\n- 文档金字塔（战略→架构→规范→操作→代码）\n- 文档分类与存储\n- ADR模板（架构决策记录）\n- API文档模板\n- Runbook模板（操作手册）\n- 知识库建设（Confluence空间）\n- 新人入职知识路径（4周）\n\n**第四章：培训与能力建设**\n- 团队技能矩阵（5x9评估表）\n- 培训计划\n  - 第1-2月：Rust + DDD培训\n  - 第3-4月：微服务 + K8s培训\n  - 第5-6月：业务知识培训\n- 导师制度（1对1配对）\n- 持续学习（读书会、技术会议）\n\n**第五章：预算与资源规划**\n- 人力成本：247万元/年（5人）\n- 基础设施：72.6万元/年（云服务）\n- 软件工具：5.7万元/年\n- 总预算：约356万元/年\n- 成本优化策略\n\n**第六章：供应商与第三方管理**\n- 云服务提供商选型\n- SaaS服务管理\n- 供应商评估维度（技术、商务、稳定性、生态）\n- 合同管理清单\n- 风险管理（锁定风险、中断风险）\n\n**第七章：数据迁移策略**\n- 迁移范围（主数据、交易数据、历史数据）\n- 迁移策略（Big Bang vs 渐进式）\n- 迁移实施计划（第11-12个月）\n- 数据验证（4个维度：数量、完整性、准确性、一致性）\n- 回滚方案（< 1小时）\n- 历史数据归档（3年、7年策略）\n\n**第八章：用户培训与推广**\n- 用户分层（9类角色）\n- 培训计划（第12个月）\n  - Week 1: 系统管理员\n  - Week 2: 核心用户\n  - Week 3: 全员培训\n  - Week 4: 强化训练\n- 培训方式（线下、在线、实操、导师）\n- 培训考核（理论80分、实操合格、上岗认证）\n- 持续支持（帮助中心、一线支持、二线支持）\n\n**适用人员**: 项目经理、架构师、全体团队成员\n\n**使用场景**:\n- 项目启动会\n- 每日/每周例会\n- 培训计划执行\n- 预算审批\n- 数据迁移准备\n\n---\n\n#### 《Rust-ERP系统-上线运维与演进计划补充文档.md》\n**文档类型**: 上线运维\n**页数**: 约90页\n**关键内容**:\n\n**第九章：上线检查清单**\n- 上线前4周：环境准备（100+检查项）\n  - 基础设施（K8s、PG、Kafka、Redis）\n  - 数据库配置（主从复制、备份恢复）\n  - 消息队列（Topic创建、监控）\n- 上线前2周：应用部署\n  - 微服务部署（15个服务）\n  - 配置管理（ConfigMap、Secret）\n  - 监控告警（Prometheus、Grafana）\n- 上线前1周：数据与业务\n  - 数据迁移验证\n  - 端到端测试（P2P、O2C、P2M）\n  - 用户培训考核\n  - 安全审计\n- 上线前3天：最后准备\n  - 文档准备（上线方案、回滚方案）\n  - 团队准备（值班排班）\n  - 备份准备\n- **上线当天执行清单**（分时段详细步骤）\n  - 00:00-01:00: 系统切换准备\n  - 01:00-04:00: 数据迁移\n  - 04:00-06:00: 数据验证与系统启动\n  - 06:00-07:00: 烟雾测试\n  - 07:00-08:00: 流量切换（灰度5% → 100%）\n- 上线后检查（第1天、第1周、第1个月）\n\n**第十章：应急响应预案**\n- 应急指挥体系（总指挥、技术组、运维组、业务组）\n- 7x24值班制度（轮班表）\n- 故障等级定义\n  - P0 致命（5分钟响应、1小时恢复）\n  - P1 严重（30分钟响应、4小时恢复）\n  - P2 一般（2小时响应、1天恢复）\n  - P3 低优先级（1周响应）\n- **4个常见故障应急预案**（详细操作步骤）\n  1. 数据库主库宕机（20分钟恢复）\n  2. Kafka集群故障（45分钟恢复）\n  3. 内存泄漏导致OOM（4小时解决）\n  4. DDoS攻击（1小时恢复）\n- 应急演练计划（每季度）\n\n**第十一章：运维交接计划**\n- 运维团队组建（6人：负责人1、系统运维2、DBA1、SRE2）\n- 运维培训（第11-12个月）\n  - Week 1-2: 系统架构培训\n  - Week 3-4: 实操培训\n  - 跟随实习（4周）\n- 运维交接清单\n  - 系统文档（5类）\n  - 运维手册（7本）\n  - 配置清单（5类）\n  - 运维工具（5套脚本）\n  - 访问权限（6类）\n- 双周陪跑期（开发+运维共同值守）\n- 长期协作机制（周会、月会、发布协作）\n\n**第十二章：长期演进路线图**\n- **第一阶段（第13-18个月）**：功能完善与优化\n  - 13-15月: 用户反馈驱动优化\n  - 16-18月: 移动化与国际化\n- **第二阶段（第19-24个月）**：智能化与生态建设\n  - 19-21月: AI与大数据分析\n  - 22-24月: 行业定制与生态集成\n- **第三阶段（第25-36个月）**：SaaS化与云原生演进\n  - 25-27月: 多租户架构改造\n  - 28-30月: 云原生能力提升（Serverless、Service Mesh）\n  - 31-36月: 生态与商业化（ISV合作、定价策略）\n- 技术债务管理（每季度评估）\n\n**第十三章：附录**\n- 术语表（30+术语）\n- 缩写词汇表（40+缩写）\n- 关键联系人（9个角色）\n- 重要日期（7个里程碑）\n- 相关文档链接\n- 工具与平台访问地址\n\n**适用人员**: 项目经理、运维负责人、架构师、全体团队\n\n**使用场景**:\n- 上线前1个月开始逐项检查\n- 上线当天严格执行\n- 故障发生时快速查阅应急预案\n- 运维交接时培训材料\n- 长期规划时参考演进路线\n\n---\n\n## 🗂️ 文档使用矩阵\n\n| 文档 | 开发者A | 开发者B | 开发者C | 开发者D | 开发者E | 产品经理 | 运维团队 |\n|-----|--------|--------|--------|--------|--------|---------|---------|\n| 12个月开发计划 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ |\n| DDD最佳实践 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐ | ⭐⭐ |\n| 架构设计文档 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ |\n| API设计文档 | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐ |\n| 项目目录结构 | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐ | ⭐⭐ |\n| KILLER模块列表 | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐ |\n| 项目管理补充 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ |\n| 上线运维补充 | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |\n\n**图例**:\n- ⭐⭐⭐⭐⭐ 必读，日常参考\n- ⭐⭐⭐⭐ 重要，定期查阅\n- ⭐⭐⭐ 相关，按需查阅\n- ⭐⭐ 了解即可\n- ⭐ 可不读\n\n---\n\n## 📅 文档维护计划\n\n### 文档审阅周期\n\n| 文档 | 审阅周期 | 责任人 | 触发条件 |\n|-----|---------|-------|---------|\n| 12个月开发计划 | 每月 | 架构师 | 里程碑变更、风险更新 |\n| DDD最佳实践 | 每季度 | 架构师 | 技术栈升级、新模式引入 |\n| 架构设计文档 | 每季度 | 架构师 | 架构重大变更 |\n| API设计文档 | 实时 | 各模块负责人 | 接口变更 |\n| 项目目录结构 | 每季度 | 架构师 | 项目结构调整 |\n| 项目管理补充 | 每月 | 项目经理 | 流程优化 |\n| 上线运维补充 | 每月 | 运维负责人 | 应急预案更新 |\n\n### 文档变更流程\n\n```\n发现变更需求 → 提交变更申请（Jira Ticket）→ 架构师/项目经理审核 →\n更新文档（PR流程）→ 评审通过 → 合并发布 → 通知相关方 → 归档旧版本\n```\n\n### 文档版本管理\n\n- **大版本**（v1.0 → v2.0）：架构重大调整、流程重大变更\n- **小版本**（v1.0 → v1.1）：内容补充、细节优化\n- **补丁版本**（v1.1 → v1.1.1）：错误修正、格式调整\n\n---\n\n## 🔍 快速查找指南\n\n### 按场景查找\n\n| 场景 | 查找文档 | 章节 |\n|-----|---------|------|\n| 新人入职 | 项目管理补充 | 第三章 3.3 新人入职知识路径 |\n| 每日站会 | 项目管理补充 | 第二章 2.1 每日站会 |\n| Sprint计划 | 12个月开发计划 | 第三章详细开发计划 |\n| 需求分析 | KILLER模块列表 | 全文 |\n| 架构设计 | DDD最佳实践 | 第二章DDD领域驱动设计 |\n| 接口开发 | API设计文档 | 全文 |\n| 代码评审 | DDD最佳实践 | 第十三章测试策略 |\n| 数据迁移 | 项目管理补充 | 第七章数据迁移策略 |\n| 上线准备 | 上线运维补充 | 第九章上线检查清单 |\n| 故障处理 | 上线运维补充 | 第十章应急响应预案 |\n| 运维交接 | 上线运维补充 | 第十一章运维交接计划 |\n| 长期规划 | 上线运维补充 | 第十二章长期演进路线图 |\n\n### 按关键词查找\n\n| 关键词 | 文档 | 位置 |\n|-------|------|------|\n| 团队分工 | 12个月开发计划 | 第一章团队角色与职责 |\n| 时间表 | 12个月开发计划 | 第三章详细开发计划 |\n| 预算 | 项目管理补充 | 第五章预算与资源规划 |\n| 培训 | 项目管理补充 | 第四章培训与能力建设 |\n| Git流程 | 项目管理补充 | 第一章 1.2 代码协作流程 |\n| 会议 | 项目管理补充 | 第二章会议制度 |\n| DDD | DDD最佳实践 | 第二章DDD领域驱动设计 |\n| CQRS | DDD最佳实践 | 第二章DDD领域驱动设计 |\n| 微服务 | DDD最佳实践 | 第三章微服务架构设计 |\n| Kubernetes | DDD最佳实践 | 第九章容器化与Kubernetes |\n| 监控 | DDD最佳实践 | 第十章可观测性 |\n| 上线 | 上线运维补充 | 第九章上线检查清单 |\n| 应急 | 上线运维补充 | 第十章应急响应预案 |\n\n---\n\n## 📞 文档问题反馈\n\n### 如何反馈文档问题\n\n**方式一：GitHub Issue**\n1. 访问项目仓库\n2. 创建 Issue，选择 \"Documentation\" 标签\n3. 描述问题（页码、章节、具体内容）\n4. 提交，等待文档维护者响应\n\n**方式二：Slack/企业微信**\n- 频道: `#documentation`\n- @文档维护者\n- 说明问题和建议\n\n**方式三：邮件**\n- 发送至: docs@rust-erp.example.com\n- 主题格式: [文档反馈] 文档名称 - 问题简述\n\n### 常见问题（FAQ）\n\n**Q1: 文档太多，我应该先看哪些？**\nA1: 根据你的角色：\n- 开发者：12个月计划 + DDD最佳实践 + API设计\n- 项目经理：12个月计划 + 项目管理补充\n- 运维：架构设计 + 上线运维补充\n\n**Q2: 文档内容有冲突怎么办？**\nA2: 以最新版本为准，查看文档版本号和更新日期。如有疑问，咨询架构师。\n\n**Q3: 文档有错误怎么办？**\nA3: 立即反馈（见上方反馈方式），同时在团队群提醒，避免其他人受影响。\n\n**Q4: 我可以修改文档吗？**\nA4: 可以！提交PR，经过评审后合并。鼓励所有人完善文档。\n\n**Q5: 文档会过时吗？**\nA5: 会。我们有定期审阅机制（见上方文档维护计划），确保文档与实际一致。\n\n---\n\n## 📥 文档下载\n\n### 在线查看\n- GitHub仓库: https://github.com/your-org/rust-erp/docs\n- 内部Wiki: https://wiki.your-domain.com/rust-erp\n\n### 离线下载\n```bash\n# Clone整个文档仓库\ngit clone https://github.com/your-org/rust-erp.git\ncd rust-erp/docs\n\n# 或下载单个文档\nwget https://raw.githubusercontent.com/your-org/rust-erp/main/docs/文档名.md\n```\n\n### PDF版本\n（计划在项目启动后1个月生成所有文档的PDF版本）\n\n---\n\n## ✅ 文档完整性自检清单\n\n在项目启动会之前，请确保：\n- [ ] 所有8份文档已创建\n- [ ] 文档版本号一致（v1.0）\n- [ ] 文档日期一致（2025-12-21）\n- [ ] 交叉引用正确（文档间链接有效）\n- [ ] 所有团队成员已下载/访问文档\n- [ ] 关键人员已阅读对应文档\n- [ ] 文档存储位置已明确（Git + Wiki）\n- [ ] 文档权限已配置（谁可查看、谁可编辑）\n\n---\n\n## 🎓 文档学习建议\n\n### 第1周：快速浏览\n- Day 1-2: 通读《12个月开发计划》，了解全貌\n- Day 3-4: 浏览《项目管理补充》，熟悉流程\n- Day 5: 查阅《KILLER模块列表》，理解业务\n\n### 第2周：深度学习\n- Day 6-8: 精读《DDD最佳实践》，做笔记\n- Day 9-10: 研究《架构设计文档》，画图加深理解\n\n### 第3周：实践应用\n- 按照文档规范开始第一个功能开发\n- 遇到问题时查阅文档\n- 记录文档不清楚的地方，及时反馈\n\n### 持续学习\n- 每个Sprint开始前，回顾相关章节\n- 每次遇到新问题，先查文档再问人\n- 定期更新自己的学习笔记\n\n---\n\n\n## 📋 目录结构说明\n\n### 🎯 核心设计原则\n\n1. **DDD四层架构**：每个微服务都严格遵循 `api` → `application` → `domain` → `infrastructure` 分层\n2. **CQRS分离**：应用层明确区分 `commands`（写）和 `queries`（读）\n3. **Event Sourcing**：领域层包含完整的事件定义，基础设施层负责事件存储\n4. **依赖倒置**：仓储接口定义在领域层，实现在基础设施层\n5. **独立部署**：每个服务拥有独立的数据库迁移和配置\n\n### 🗂️ KILLER模块映射关系\n\n| Rust服务 | KILLER模块 | 主要功能 |\n|---------|--------|---------|\n| financial-service | FI | 总账、应付、应收、资产 |\n| controlling-service | CO | 成本中心、产品成本、盈利分析 |\n| materials-service | MM | 采购、库存、发票校验 |\n| sales-service | SD | 销售订单、发货、计费 |\n| production-service | PP | 生产计划、MRP、车间控制 |\n| hr-service | HR/HCM | 人事、工资、时间管理 |\n| quality-service | QM | 质量计划、检验、通知 |\n| maintenance-service | PM | 设备管理、工单、预防维护 |\n| crm-service | CRM | 客户、商机、活动 |\n| project-service | PS | 项目、WBS、网络图 |\n| scm-service | SCM/APO | 需求计划、供应计划 |\n| treasury-service | TR | 现金管理、风险管理 |\n| warehouse-service | WM/EWM | 仓库管理、库位优化 |\n| shipping-service | TM | 运输管理、路径优化 |\n| analytics-service | BW/BI | 报表、仪表盘、KPI |\n\n---\n\n**文档体系维护者**: 架构师（开发者A）、项目经理\n**最后更新**: 2025-12-21\n**下次全面审阅**: 2026-01-21\n\n---\n\n**祝项目顺利！文档是团队共同的知识库，让我们一起完善它！**\n", "md/Rust-Abc-Enhanced.md": "# Rust ERP 系统 - 5人团队12个月开发计划（增强版）\n\n**基于**: Rust-Abc.md + Rust-BOM.md 完整融合\n**版本**: v2.0 Enhanced\n**创建日期**: 2025-12-22\n**说明**: 本文档在原有 12 个月计划基础上，整合 BOM 非 MVP 版本的完整业务能力、验收标准和最佳实践\n\n---\n\n## 文档导航\n\n- **Rust-Abc.md**: 原始 12 个月计划（按天拆分的详细任务）\n- **Rust-BOM.md**: 完整 KILLER 替代清单（15 个波次的业务能力）\n- **本文档**: 融合版计划，补充缺失模块和验收标准\n\n---\n\n## 一、增强后的开发阶段划分（12个月）\n\n```\n阶段 0（Month 1 Week 1-2）  | 平台与主数据治理基线（新增）\n阶段 1（Month 1-2）        | 基础设施建设与共享库开发（原有）\n阶段 2（Month 3-5）        | 财务会计 FI + 资金管理 TR/FSCM（增强）\n阶段 3（Month 3-5）        | 管理会计 CO（原有）\n阶段 4（Month 6-8）        | 物料与采购 MM + 销售与分销 SD + 生产计划 PP（原有）\n阶段 5（Month 9-10）       | 仓储 WM/EWM + 运输 TM + 质量 QM + 设备维护 PM（原有）\n阶段 6（Month 9-10）       | 人力资本 HCM + 客户关系 CRM（原有）\n阶段 7（Month 10）         | 供应链计划 SCM/IBP（新增）\n阶段 8（Month 10）         | 项目系统 PS（新增）\n阶段 9（Month 11）         | 分析与报表 BI/BW（增强）\n阶段 10（Month 11-12）     | 集成测试、性能优化、上线准备（原有）\n```\n\n---\n\n## 二、阶段 0：平台与主数据治理（新增）\n\n### 时间：Month 1 Week 1-2（Day 1-10）\n\n### 目标\n在基础设施搭建的同时，建立主数据治理和平台能力基线，为所有后续模块提供统一的主数据服务、身份认证和审计能力。\n\n### Week 1（Day 1-5）：主数据治理服务启动\n\n#### Day 1-2: Master Data Governance Service 项目初始化\n**开发者A（领导）+ 全员协助**\n\n- **创建 mdg-service 项目结构**\n  ```\n  services/mdg-service/\n  ├── domain/\n  │   ├── aggregates/\n  │   │   ├── business_partner.rs     # 业务伙伴聚合根（客户/供应商）\n  │   │   ├── material_master.rs      # 物料主数据聚合根\n  │   │   ├── chart_of_accounts.rs    # 科目表聚合根\n  │   │   └── organization.rs         # 组织架构聚合根\n  │   ├── value_objects/\n  │   │   ├── partner_number.rs       # 业务伙伴编号\n  │   │   ├── material_number.rs      # 物料编号\n  │   │   ├── account_number.rs       # 科目编号\n  │   │   └── org_unit_id.rs          # 组织单元编号\n  │   ├── services/\n  │   │   ├── duplicate_check_service.rs    # 重复检测服务\n  │   │   ├── data_quality_service.rs       # 数据质量服务\n  │   │   └── change_management_service.rs  # 变更管理服务\n  │   └── events/\n  │       ├── business_partner_events.rs\n  │       ├── material_events.rs\n  │       └── organization_events.rs\n  ```\n\n- **主数据建模**（开发者A + B）\n  - 业务伙伴（BP）模型：客户/供应商统一主数据\n  - 物料主数据模型：SKU、计量单位、物料类型\n  - 科目表模型：会计科目、成本要素、利润中心\n  - 组织架构模型：公司代码、工厂、库存地点、成本中心\n\n#### Day 3-4: 主数据版本管理与审批流\n**开发者A + B**\n\n- **版本控制**\n  - `domain/aggregates/master_data_version.rs`: 主数据版本聚合根\n  - 支持：草稿版本、审批中、已激活、已失效\n  - 生效日期/失效日期控制\n  - 变更历史追溯\n\n- **审批工作流**\n  - `domain/services/approval_workflow_service.rs`: 审批流服务\n  - `application/commands/submit_for_approval.rs`: 提交审批\n  - `application/commands/approve_master_data.rs`: 审批主数据\n  - `application/commands/reject_master_data.rs`: 拒绝变更\n\n- **数据质量规则**\n  - `domain/services/data_quality_rules.rs`\n  - 唯一性检查：业务伙伴编号、物料编号\n  - 完整性检查：必填字段验证\n  - 一致性检查：跨字段逻辑校验\n  - 准确性检查：格式、范围验证\n\n#### Day 5: 重复检测与合并\n**开发者A + E**\n\n- **重复检测算法**\n  - `domain/services/duplicate_detection_service.rs`\n  - 模糊匹配：业务伙伴名称、地址\n  - 相似度评分：Levenshtein 距离\n  - 疑似重复记录标记\n\n- **主数据合并**\n  - `application/commands/merge_business_partners.rs`\n  - 合并策略：保留主记录、归档重复记录\n  - 关联数据自动更新（外键重定向）\n\n### Week 2（Day 6-10）：身份与访问管理（IAM）\n\n#### Day 6-7: 统一身份服务\n**开发者E（领导）+ A 协助**\n\n- **创建 iam-service 项目**\n  ```\n  services/iam-service/\n  ├── domain/\n  │   ├── aggregates/\n  │   │   ├── user.rs              # 用户聚合根\n  │   │   ├── role.rs              # 角色聚合根\n  │   │   ├── permission.rs        # 权限聚合根\n  │   │   └── session.rs           # 会话聚合根\n  │   ├── services/\n  │   │   ├── authentication_service.rs     # 认证服务\n  │   │   ├── authorization_service.rs      # 授权服务\n  │   │   └── sod_check_service.rs          # 职责分离检查服务\n  ```\n\n- **认证实现**\n  - OIDC/OAuth2 集成（Keycloak）\n  - JWT Token 签发与验证\n  - 单点登录（SSO）\n  - 多因素认证（MFA）支持\n\n#### Day 8-9: 授权与权限模型\n**开发者E + A**\n\n- **RBAC（基于角色的访问控制）**\n  - `domain/aggregates/role.rs`: 角色定义（财务会计、采购员、仓库管理员等）\n  - `domain/aggregates/permission.rs`: 权限粒度（创建、读取、更新、删除、审批）\n  - 用户-角色-权限映射\n\n- **ABAC（基于属性的访问控制）**\n  - 属性策略：组织维度（公司代码、工厂）、数据维度（成本中心、利润中心）\n  - 动态权限计算：用户属性 + 资源属性 + 环境属性\n\n- **职责分离（SoD）**\n  - `domain/services/sod_check_service.rs`\n  - 冲突规则定义：采购订单创建者不能审批、出纳不能记账\n  - 角色分配时 SoD 预检查\n  - 实时 SoD 违规告警\n\n#### Day 10: 审计追踪基线\n**开发者D + E**\n\n- **审计日志服务**\n  ```\n  services/audit-service/\n  ├── domain/\n  │   ├── aggregates/\n  │   │   └── audit_log.rs         # 审计日志聚合根\n  │   └── value_objects/\n  │       ├── audit_event.rs       # 审计事件\n  │       └── audit_metadata.rs    # 审计元数据\n  ```\n\n- **审计能力**\n  - 所有写操作（创建、更新、删除）记录审计日志\n  - 审计字段：操作人、操作时间、操作类型、IP 地址、设备信息\n  - 数据变更前后快照（JSON Diff）\n  - 审计日志不可篡改（Append-Only）\n\n- **审计日志存储**\n  - PostgreSQL 审计表（时间序列分区）\n  - ClickHouse 长期归档（WORM 存储）\n  - 留存策略：热数据 3 个月、温数据 1 年、冷数据 7 年\n\n### 验收标准（阶段 0）\n\n#### 功能验收\n- [ ] 业务伙伴主数据 CRUD + 版本管理 + 审批流\n- [ ] 物料主数据 CRUD + 重复检测 + 合并\n- [ ] 科目表主数据 CRUD + 数据质量规则\n- [ ] 组织架构主数据 CRUD + 层级关系管理\n- [ ] OIDC/OAuth2 认证集成（Keycloak）\n- [ ] RBAC/ABAC 授权模型实现\n- [ ] SoD 冲突检查服务\n- [ ] 审计日志记录所有主数据变更\n\n#### 数据质量验收\n- [ ] 唯一性检查：业务伙伴编号、物料编号 100% 唯一\n- [ ] 完整性检查：必填字段覆盖率 > 95%\n- [ ] 重复检测准确率 > 90%（人工抽样验证）\n- [ ] 数据质量评分机制上线（唯一性、完整性、一致性、准确性）\n\n#### 集成验收\n- [ ] 主数据变更事件发布到 Kafka（erp.mdg.business_partner.created 等）\n- [ ] 下游服务订阅主数据事件（FI、MM、SD、HR 缓存更新）\n- [ ] 幂等与重放验证通过\n- [ ] 主数据缓存一致性策略验证（Redis Write-Through）\n\n#### 安全与合规验收\n- [ ] SSO 登录流程验证\n- [ ] 权限模型渗透测试（越权访问验证）\n- [ ] SoD 冲突规则测试（采购+审批、出纳+记账）\n- [ ] 审计日志完整性测试（所有变更可追溯）\n- [ ] 加密密钥管理验证（Vault 集成）\n\n#### 性能验收\n- [ ] 主数据查询 P99 < 50ms（Redis 缓存命中率 > 90%）\n- [ ] 主数据创建 P99 < 150ms\n- [ ] 重复检测批处理：1000 条记录 < 30 秒\n- [ ] 审计日志写入延迟 < 10ms（异步写入）\n\n---\n\n## 三、阶段 2 增强：财务会计 FI + 资金管理 TR/FSCM\n\n### Month 3-5 原有计划补充\n\n在原有 Financial Service（FI-GL/AR/AP/AA）基础上，增加资金与财务供应链模块。\n\n### Month 4 Week 2（Day 46-50）：Treasury Service - TR 基础\n\n#### Day 46-48: 现金管理与流动性计划\n**开发者B（领导）**\n\n- **创建 treasury-service 项目**\n  ```\n  services/treasury-service/\n  ├── domain/\n  │   ├── aggregates/\n  │   │   ├── cash_pool.rs              # 现金池聚合根\n  │   │   ├── liquidity_forecast.rs     # 流动性预测聚合根\n  │   │   ├── bank_statement.rs         # 银行对账单聚合根\n  │   │   └── payment_factory.rs        # 付款工厂聚合根\n  │   ├── services/\n  │   │   ├── cash_positioning_service.rs    # 现金头寸服务\n  │   │   ├── liquidity_planning_service.rs  # 流动性计划服务\n  │   │   └── bank_reconciliation_service.rs # 银行对账服务\n  ```\n\n- **现金池与资金集中**\n  - `domain/aggregates/cash_pool.rs`\n  - 支持：虚拟现金池、实际现金池\n  - 头寸管理：实时现金头寸、预测头寸\n  - 资金归集策略：零余额账户、目标余额账户\n\n- **流动性预测**\n  - `domain/services/liquidity_planning_service.rs`\n  - 基于历史数据的滚动预测（7 天、30 天、90 天）\n  - 应收/应付预测集成（来自 FI-AR/AP）\n  - 流动性缺口告警\n\n#### Day 49-50: 交易管理（外汇与利率）\n**开发者B**\n\n- **外汇交易**\n  - `domain/aggregates/fx_deal.rs`: 外汇交易聚合根\n  - `domain/services/fx_valuation_service.rs`: 外汇估值服务\n  - 支持：即期交易、远期交易、掉期交易\n  - 市场数据集成（汇率源）\n\n- **利率管理**\n  - `domain/aggregates/interest_rate_swap.rs`: 利率互换聚合根\n  - `domain/services/hedge_accounting_service.rs`: 套期会计服务\n  - 支持：普通利率互换（IRS）、交叉货币互换（CCS）\n\n### Month 5 Week 1（Day 51-55）：财务供应链 FSCM\n\n#### Day 51-53: 信用管理（FSCM-CR）\n**开发者B**\n\n- **创建 credit-management-service 项目**\n  ```\n  services/credit-management-service/\n  ├── domain/\n  │   ├── aggregates/\n  │   │   ├── credit_limit.rs           # 信用额度聚合根\n  │   │   ├── credit_exposure.rs        # 信用暴露聚合根\n  │   │   └── credit_block.rs           # 信用冻结聚合根\n  │   ├── services/\n  │   │   ├── credit_scoring_service.rs      # 信用评分服务\n  │   │   ├── credit_check_service.rs        # 信用检查服务\n  │   │   └── credit_release_service.rs      # 信用放行服务\n  ```\n\n- **信用额度管理**\n  - `domain/aggregates/credit_limit.rs`\n  - 支持：客户级额度、信用控制区域级额度\n  - 额度审批流程\n  - 额度自动调整策略（基于支付历史）\n\n- **信用检查**\n  - `domain/services/credit_check_service.rs`\n  - 实时信用检查（销售订单创建时）\n  - 信用暴露计算：未清应收 + 未清订单\n  - 信用冻结与放行工作流\n\n- **信用评分**\n  - `domain/services/credit_scoring_service.rs`\n  - 评分模型：支付历史、账龄、订单履约率\n  - 风险等级：AAA、AA、A、BBB、BB、B、CCC\n  - 动态额度调整建议\n\n#### Day 54-55: 催收管理（FSCM-CM）\n**开发者B**\n\n- **催收策略**\n  - `domain/aggregates/collection_strategy.rs`: 催收策略聚合根\n  - `domain/aggregates/dunning_run.rs`: 催款运行聚合根\n  - 催收级别：友好提醒、正式催款、法律行动\n  - 催收行动：邮件、电话、暂停发货、法律诉讼\n\n- **催收工作列表**\n  - `application/queries/collection_worklist.rs`\n  - 按账龄、金额、客户风险等级排序\n  - 催收任务自动分配（催收专员）\n\n- **争议管理（FSCM-DM）**\n  - `domain/aggregates/dispute_case.rs`: 争议案件聚合根\n  - 争议类型：数量差异、质量问题、价格争议\n  - 争议生命周期：创建、调查、协商、解决、关闭\n  - 争议金额暂不收款处理\n\n### 验收标准（TR/FSCM 增强）\n\n#### 功能验收\n- [ ] 现金池与头寸管理功能完整\n- [ ] 流动性滚动预测（7/30/90 天）\n- [ ] 银行对账自动化（对账单导入 + 匹配）\n- [ ] 外汇交易生命周期管理（交易录入、估值、结算）\n- [ ] 利率互换交易与套期会计\n- [ ] 信用额度管理与审批流\n- [ ] 实时信用检查（销售订单 → 信用冻结/放行）\n- [ ] 信用评分与风险等级\n- [ ] 催收策略与工作列表\n- [ ] 争议案件管理闭环\n\n#### 集成验收\n- [ ] 与 FI-BL 共享银行账户与流水\n- [ ] 与 FI-AR/AP 集成（应收应付数据同步）\n- [ ] 与 Sales Service 集成（订单信用检查）\n- [ ] 银行接口集成（Swift/银企直连模拟）\n- [ ] 市场数据源集成（汇率/利率）\n\n#### 报表验收\n- [ ] 流动性滚动预测报表\n- [ ] 现金流差异分析\n- [ ] 信用暴露报表（按客户、区域、产品）\n- [ ] DSO（Days Sales Outstanding）/ DPO（Days Payable Outstanding）\n- [ ] 对冲效果评估报表\n\n#### 风控与合规验证\n- [ ] KYC/AML 钩子集成（Know Your Customer / Anti-Money Laundering）\n- [ ] 交易审批与双人复核（maker-checker）\n- [ ] 交易日志留存（7 年）\n- [ ] 限额与授权控制（交易金额分级审批）\n\n#### 性能验证\n- [ ] 信用检查响应时间 P99 < 100ms（Redis 缓存信用额度）\n- [ ] 流动性预测批处理 < 5 分钟（1000+ 交易）\n- [ ] 银行对账批处理 < 10 分钟（10000+ 流水）\n\n---\n\n## 四、阶段 7 新增：供应链计划 SCM/IBP\n\n### Month 10 Week 1-2（Day 191-200）：高级供应链计划\n\n在原有 Production Service 基础 MRP 之上，增加高级供应链计划能力。\n\n#### Day 191-195: 需求计划与预测\n**开发者C（领导）+ A 协助**\n\n- **创建 supply-chain-planning-service 项目**\n  ```\n  services/supply-chain-planning-service/\n  ├── domain/\n  │   ├── aggregates/\n  │   │   ├── demand_plan.rs              # 需求计划聚合根\n  │   │   ├── supply_plan.rs              # 供应计划聚合根\n  │   │   ├── inventory_policy.rs         # 库存策略聚合根\n  │   │   └── planning_scenario.rs        # 计划情景聚合根\n  │   ├── services/\n  │   │   ├── demand_forecasting_service.rs     # 需求预测服务\n  │   │   ├── supply_planning_service.rs        # 供应计划服务\n  │   │   ├── inventory_optimization_service.rs # 库存优化服务\n  │   │   └── scenario_simulation_service.rs    # 情景模拟服务\n  ```\n\n- **需求预测**\n  - `domain/services/demand_forecasting_service.rs`\n  - 统计预测：移动平均、指数平滑、ARIMA\n  - 因果预测：促销活动、季节性因素\n  - 机器学习预测（可选）：XGBoost、LSTM\n  - 预测层级：产品族、SKU、工厂、客户\n\n- **需求协同**\n  - `application/commands/collaborative_demand_planning.rs`\n  - 销售与运营计划（S&OP）流程\n  - 多方共识计划（销售、营销、供应链、财务）\n  - 版本管理与冻结窗口\n\n#### Day 196-198: 供应计划与库存优化\n**开发者C**\n\n- **约束型供应计划**\n  - `domain/services/supply_planning_service.rs`\n  - 约束识别：产能约束、物料约束、供应商约束\n  - 计划策略：MTS（Make-to-Stock）、MTO（Make-to-Order）、ATO（Assemble-to-Order）\n  - 分配与承诺（ATP/CTP）：可用量承诺、可生产量承诺\n\n- **库存优化**\n  - `domain/services/inventory_optimization_service.rs`\n  - 安全库存计算：服务水平、需求变异性、补货周期\n  - 再订货点（ROP）计算\n  - 库存定位策略：多级库存、配送网络优化\n  - 库存健康度评估：呆滞库存、过期库存、短缺风险\n\n#### Day 199-200: 响应与重计划\n**开发者C**\n\n- **事件驱动重计划**\n  - `domain/services/replanning_service.rs`\n  - 触发事件：需求突增、供应中断、产能变化\n  - 重计划策略：部分重计划、全量重计划\n  - 计划稳定性 vs. 响应性权衡\n\n- **情景模拟与假设分析**\n  - `domain/aggregates/planning_scenario.rs`\n  - 假设场景：需求 +20%、供应商停产、新工厂上线\n  - 情景对比分析：成本、服务水平、库存周转\n  - 最佳情景推荐\n\n### 验收标准（SCM/IBP）\n\n#### 功能验收\n- [ ] 需求预测算法实现（至少 2 种：移动平均、指数平滑）\n- [ ] 预测准确度评估（MAPE、Bias）\n- [ ] 需求协同与版本管理\n- [ ] 约束型供应计划（产能/物料约束识别）\n- [ ] 安全库存与再订货点计算\n- [ ] 库存优化建议（超储/缺货告警）\n- [ ] 事件驱动重计划（需求突变、供应中断）\n- [ ] 情景模拟与对比分析\n\n#### 集成验证\n- [ ] 与 Sales Service 集成（历史销售数据 → 需求预测）\n- [ ] 与 Production Service 集成（产能数据 → 供应计划）\n- [ ] 与 Materials Service 集成（库存数据 → 库存优化）\n- [ ] 与 BI Service 集成（计划版本 → 数据仓库）\n\n#### 报表验证\n- [ ] 预测准确度报表（MAPE by SKU/Product Family）\n- [ ] 计划履约率报表（计划 vs. 实际）\n- [ ] 库存周转率报表\n- [ ] 缺货率与超储率报表\n- [ ] 计划偏差分析（需求/供应/库存）\n\n#### 性能验证\n- [ ] 预测计算批处理：10000 SKU < 30 分钟\n- [ ] 供应计划运算：1000 工单 < 15 分钟\n- [ ] 库存优化批处理：10000 SKU < 20 分钟\n- [ ] 情景模拟响应时间 < 2 分钟\n\n---\n\n## 五、阶段 8 新增：项目系统 PS\n\n### Month 10 Week 3-4（Day 201-210）：项目系统\n\n#### Day 201-205: 项目结构与预算\n**开发者E（领导）**\n\n- **创建 project-system-service 项目**\n  ```\n  services/project-system-service/\n  ├── domain/\n  │   ├── aggregates/\n  │   │   ├── project.rs               # 项目聚合根\n  │   │   ├── wbs_element.rs           # WBS 元素聚合根\n  │   │   ├── network_activity.rs      # 网络活动聚合根\n  │   │   └── project_budget.rs        # 项目预算聚合根\n  │   ├── services/\n  │   │   ├── earned_value_service.rs         # 挣值分析服务\n  │   │   ├── revenue_recognition_service.rs  # 收入确认服务\n  │   │   └── change_management_service.rs    # 变更管理服务\n  ```\n\n- **WBS（工作分解结构）**\n  - `domain/aggregates/wbs_element.rs`\n  - WBS 层级结构：项目 → 阶段 → 任务 → 子任务\n  - WBS 版本管理与基线\n  - WBS 责任分配（项目经理、任务负责人）\n\n- **网络计划**\n  - `domain/aggregates/network_activity.rs`\n  - 活动定义：活动编号、描述、持续时间\n  - 活动关系：FS（Finish-to-Start）、SS（Start-to-Start）、FF、SF\n  - 关键路径计算（CPM）\n  - 里程碑管理\n\n- **预算与承诺**\n  - `domain/aggregates/project_budget.rs`\n  - 预算分配：按 WBS 分配预算\n  - 承诺管理：采购订单、生产订单承诺金额\n  - 预算控制：预警（80%、90%）、冻结（100%）\n  - 预算调整与审批\n\n#### Day 206-210: 执行与成本收入\n**开发者E + B 协助**\n\n- **成本归集**\n  - `application/commands/post_project_cost.rs`\n  - 成本来源：物料领用（MM）、工时（HR）、采购（MM）、外部服务\n  - 成本分配：直接成本、间接成本分摊\n  - 与 Controlling Service 集成（成本对象）\n\n- **挣值分析（EVM）**\n  - `domain/services/earned_value_service.rs`\n  - 计划值（PV）、挣值（EV）、实际成本（AC）\n  - 成本偏差（CV = EV - AC）\n  - 进度偏差（SV = EV - PV）\n  - 成本绩效指数（CPI = EV / AC）\n  - 进度绩效指数（SPI = EV / PV）\n  - 完工预估（EAC）、完工尚需（ETC）\n\n- **收入确认**\n  - `domain/services/revenue_recognition_service.rs`\n  - 完工百分比法（POC）：按成本百分比、按工作量百分比\n  - 完工合同法（Completed Contract）\n  - 与 Financial Service 集成（收入凭证）\n\n- **变更与索赔管理**\n  - `domain/aggregates/change_request.rs`: 变更请求聚合根\n  - 变更影响分析：成本、进度、资源\n  - 变更审批流程\n  - 索赔管理：客户索赔、向供应商索赔\n\n### 验收标准（PS）\n\n#### 功能验收\n- [ ] WBS 层级结构管理（创建、编辑、版本、基线）\n- [ ] 网络活动与关键路径计算\n- [ ] 里程碑管理与进度跟踪\n- [ ] 预算分配与承诺控制\n- [ ] 预算预警与冻结机制\n- [ ] 成本归集（物料、工时、采购、外部服务）\n- [ ] 挣值分析（CV、SV、CPI、SPI、EAC）\n- [ ] 收入确认（完工百分比法、完工合同法）\n- [ ] 变更请求管理与审批\n- [ ] 索赔管理闭环\n\n#### 集成验证\n- [ ] 与 Materials Service 集成（物料领用 → 项目成本）\n- [ ] 与 Production Service 集成（生产订单 → 项目成本）\n- [ ] 与 HR Service 集成（工时 → 项目成本）\n- [ ] 与 Financial Service 集成（成本凭证、收入凭证）\n- [ ] 与 Controlling Service 集成（成本对象、利润中心）\n- [ ] 与 CRM Service 集成（商机 → 项目交接）\n\n#### 报表验证\n- [ ] 项目进度报表（计划 vs. 实际）\n- [ ] 项目成本报表（预算 vs. 实际 vs. 承诺）\n- [ ] 挣值分析报表（CV、SV、CPI、SPI）\n- [ ] 现金流预测报表\n- [ ] 里程碑达成报表\n- [ ] 合同毛利报表\n\n#### 性能验证\n- [ ] 关键路径计算：1000 活动 < 5 秒\n- [ ] 挣值分析批处理：100 项目 < 2 分钟\n- [ ] 成本归集批处理：10000 凭证 < 10 分钟\n\n---\n\n## 六、阶段 9 增强：分析与报表 BI/BW\n\n### Month 11 Week 1-2（Day 211-220）：企业数据仓库与 BI\n\n在原有 Analytics Service 基础上，增强为完整的企业数据仓库与 BI 平台。\n\n#### Day 211-215: 数据仓库建模\n**开发者A（领导）+ D 协助**\n\n- **创建 data-warehouse-service 项目**\n  ```\n  services/data-warehouse-service/\n  ├── models/\n  │   ├── dimensions/\n  │   │   ├── dim_customer.sql         # 客户维度\n  │   │   ├── dim_material.sql         # 物料维度\n  │   │   ├── dim_vendor.sql           # 供应商维度\n  │   │   ├── dim_date.sql             # 日期维度\n  │   │   ├── dim_organization.sql     # 组织维度\n  │   │   └── dim_account.sql          # 科目维度\n  │   ├── facts/\n  │   │   ├── fact_financial_transaction.sql   # 财务交易事实表\n  │   │   ├── fact_sales_order.sql             # 销售订单事实表\n  │   │   ├── fact_purchase_order.sql          # 采购订单事实表\n  │   │   ├── fact_inventory_movement.sql      # 库存移动事实表\n  │   │   ├── fact_production_order.sql        # 生产订单事实表\n  │   │   └── fact_payroll.sql                 # 薪资事实表\n  │   └── aggregates/\n  │       ├── agg_monthly_financials.sql       # 月度财务汇总\n  │       ├── agg_daily_sales.sql              # 每日销售汇总\n  │       └── agg_inventory_snapshot.sql       # 库存快照\n  ```\n\n- **星型模型设计**\n  - 维度表设计：缓慢变化维度（SCD Type 2）\n  - 事实表设计：事务粒度、快照粒度、累积粒度\n  - 代理键策略（Surrogate Key）\n  - 历史快照策略（每日/每月库存快照）\n\n- **主数据对齐**\n  - 与 MDG Service 主数据同步\n  - 维度表与主数据表映射\n  - 主数据变更 → 维度表更新（SCD Type 2）\n\n#### Day 216-220: ETL 流程与数据质量\n**开发者D（领导）+ A 协助**\n\n- **数据采集**\n  - CDC（Change Data Capture）：Debezium + Kafka\n  - 事件总线采集：订阅所有服务领域事件\n  - 批量 ETL：每日全量/增量同步\n  - 准实时链路：Kafka → ClickHouse（< 1 分钟延迟）\n\n- **数据转换**\n  - 数据清洗：空值处理、格式标准化、异常值过滤\n  - 数据转换：单位转换、货币转换、时区转换\n  - 数据聚合：预计算聚合表（每日、每月、每年）\n  - 数据血缘：记录数据来源和转换过程\n\n- **数据质量**\n  - `domain/services/data_quality_service.rs`\n  - DQ 规则：完整性、唯一性、一致性、及时性、准确性\n  - DQ 评分：每个事实表/维度表质量评分（0-100）\n  - DQ 告警：质量阈值触发告警（完整性 < 95%）\n  - DQ 补救流程：数据修复、重跑 ETL\n\n- **语义层**\n  - 业务指标定义：收入、成本、毛利、库存周转率、DSO 等\n  - 计算字段：YoY（同比）、MoM（环比）、YTD（年初至今）\n  - 权限控制：行级权限（按组织）、列级权限（敏感字段）、指标级权限\n\n#### Day 216-220: BI 报表与仪表盘\n**开发者E + D**\n\n- **预定义报表**\n  - **财务主题**：\n    - 资产负债表、利润表、现金流量表\n    - 账龄分析报表（AR/AP）\n    - 成本中心报表、利润中心报表\n    - 预算 vs. 实际对比报表\n  - **供应链主题**：\n    - 采购周期分析、供应商绩效\n    - 销售漏斗、订单履约率\n    - 库存周转率、库龄分析\n    - 缺货率、超储率\n  - **生产主题**：\n    - 生产计划达成率\n    - 在制品（WIP）报表\n    - 工序效率、设备 OEE\n    - 物料齐套率\n  - **人力资源主题**：\n    - 员工成本分析\n    - 出勤率、加班统计\n    - 离职率、招聘漏斗\n    - 薪酬结构分析\n  - **CRM 主题**：\n    - 销售漏斗、转化率\n    - 客户满意度（CSAT/NPS）\n    - 活动 ROI\n    - 服务工单 SLA 达成率\n\n- **实时仪表盘**\n  - 管理驾驶舱：高层 KPI（收入、利润、现金流、库存）\n  - 财务仪表盘：实时凭证量、账龄分布、现金头寸\n  - 供应链仪表盘：订单履约率、库存健康度、运输在途\n  - 生产仪表盘：生产进度、设备状态、质量合格率\n  - 告警仪表盘：异常订单、超期应收、库存短缺、质量缺陷\n\n- **自助分析**\n  - 拖拽式报表构建器（Metabase/Superset）\n  - Ad-hoc 查询界面\n  - 数据导出（Excel、PDF、CSV）\n  - 报表订阅与定时推送\n\n### 验收标准（BI/BW）\n\n#### 功能验收\n- [ ] 星型模型完整（10+ 维度表、6+ 事实表）\n- [ ] SCD Type 2 历史追溯验证\n- [ ] 主数据对齐验证（维度表 vs. 主数据表）\n- [ ] CDC/事件/批量采集链路验证\n- [ ] 数据质量规则上线（5 类规则：完整性、唯一性、一致性、及时性、准确性）\n- [ ] DQ 评分与告警机制\n- [ ] 语义层与业务指标定义\n- [ ] 预定义报表上线（财务/供应链/生产/HR/CRM 至少 20 个报表）\n- [ ] 实时仪表盘上线（5+ 主题仪表盘）\n- [ ] 自助分析工具可用（Metabase/Superset）\n\n#### 数据一致性验证\n- [ ] 财务三表对账（资产负债表平衡、现金流量表勾稽）\n- [ ] FI 与 CO/CO-PA 对齐验证\n- [ ] 采购 P2P 对账（采购订单 → 收货 → 发票 → 付款）\n- [ ] 销售 O2C 对账（销售订单 → 发货 → 开票 → 收款）\n- [ ] 库存对账（物理库存 vs. 账面库存）\n- [ ] 生产对账（生产订单 → 领料 → 报工 → 成品入库）\n- [ ] 薪资对账（薪资核算 vs. 财务分录）\n\n#### 性能验证\n- [ ] CDC 延迟 < 30 秒（数据库变更 → Kafka → ClickHouse）\n- [ ] 事件采集延迟 < 1 分钟\n- [ ] 批量 ETL 窗口：每日全量 < 2 小时\n- [ ] 报表查询响应时间：简单查询 P95 < 2 秒、复杂查询 P95 < 10 秒\n- [ ] 并发查询支持：100 并发用户\n- [ ] 仪表盘刷新延迟 < 5 秒\n\n#### 数据质量验证\n- [ ] 完整性：事实表关键字段非空率 > 99%\n- [ ] 唯一性：维度表代理键唯一性 100%\n- [ ] 一致性：跨表关联一致性 > 99.9%（外键校验）\n- [ ] 及时性：T+1 数据可用性 > 99%（每日 8:00 前）\n- [ ] 准确性：抽样对账准确率 > 99.99%\n\n#### 运营验证\n- [ ] 数据血缘可追溯（源表 → 转换 → 目标表）\n- [ ] ETL 作业调度与重试机制\n- [ ] ETL 失败告警与通知\n- [ ] 数据备份与恢复演练（RTO < 4 小时、RPO < 1 小时）\n- [ ] 容量规划（存储增长预测、查询性能趋势）\n\n---\n\n## 七、通用交付检查清单（所有阶段复用）\n\n基于 BOM 文档的通用模块交付检查清单，适用于所有服务开发阶段。\n\n### 7.1 领域与流程验收\n\n- [ ] **限界上下文清晰定义**\n  - 领域边界明确，不与其他服务重叠\n  - 领域术语表（Ubiquitous Language）\n  - 上下文映射关系（Context Map）\n\n- [ ] **核心用例完整实现**\n  - 主流程用例 100% 覆盖\n  - 异常场景处理（补偿、重试、回滚）\n  - 边界条件测试\n\n- [ ] **状态机/生命周期**\n  - 聚合根状态迁移图\n  - 状态迁移规则验证\n  - 非法状态迁移拒绝\n\n- [ ] **审批流实现**\n  - 审批流程配置化\n  - 多级审批支持\n  - 审批历史记录\n\n### 7.2 数据模型与元数据验收\n\n- [ ] **主数据/交易数据建模**\n  - 数据库 ER 图\n  - 索引策略（查询优化）\n  - 分区策略（大表按日期/范围分区）\n\n- [ ] **版本与变更管理**\n  - 数据库迁移脚本（SQLx Migrations）\n  - Schema 版本控制\n  - 向后兼容性保证\n\n- [ ] **历史快照**\n  - 历史数据归档策略\n  - 快照表设计（SCD Type 2）\n  - 时间旅行查询支持\n\n- [ ] **数据血缘**\n  - 数据来源记录\n  - 数据转换过程记录\n  - 数据依赖关系图\n\n### 7.3 API/gRPC 与事件验收\n\n- [ ] **REST/gRPC 契约**\n  - OpenAPI/Protobuf 定义完整\n  - 错误码对齐（统一错误码表）\n  - API 版本策略（/v1, /v2）\n\n- [ ] **鉴权/鉴别**\n  - JWT Token 验证\n  - RBAC/ABAC 授权检查\n  - API 限流策略\n\n- [ ] **领域事件**\n  - 事件定义清晰（事件名称、载荷、版本）\n  - 事件发布幂等性\n  - 事件顺序性保证（同一聚合）\n\n- [ ] **集成事件**\n  - 跨服务事件订阅\n  - 事件消费幂等性（Idempotency Key）\n  - 事件重试策略（指数退避）\n\n- [ ] **事件溯源**\n  - Event Store 完整性\n  - 聚合重建验证\n  - 事件回放验证\n\n### 7.4 规则与工作流验收\n\n- [ ] **业务规则引擎**\n  - 定价规则配置化\n  - 税务规则配置化\n  - 信用检查规则配置化\n  - 合规规则配置化\n\n- [ ] **工作流引擎**\n  - 工作流定义（BPMN 可选）\n  - 工作流实例跟踪\n  - 工作流超时处理\n\n- [ ] **灰度发布**\n  - Feature Flag 支持\n  - 按用户/组织灰度\n  - 灰度监控与回滚\n\n### 7.5 集成验收\n\n- [ ] **跨服务调用矩阵**\n  - 服务依赖关系图\n  - 调用链路追踪（Jaeger）\n  - 熔断/降级策略（Circuit Breaker）\n\n- [ ] **外部系统接口**\n  - 银行接口（Swift/银企直连）\n  - 税务接口（电子发票/报税）\n  - 物流接口（承运商 API）\n  - 设备接口（IoT/传感器）\n\n- [ ] **批处理与实时链路**\n  - 批处理作业调度（Cron/Argo Workflows）\n  - 批处理监控与告警\n  - 实时事件处理延迟监控\n\n### 7.6 主数据与迁移验收\n\n- [ ] **对齐 MDG 模式**\n  - 主数据订阅 MDG 事件\n  - 主数据缓存策略（Write-Through）\n  - 主数据版本同步\n\n- [ ] **初始/增量迁移**\n  - 迁移脚本编写\n  - 迁移数据校验（抽样/全量）\n  - 迁移回滚预案\n\n- [ ] **双写/只读切换策略**\n  - 双写期验证（旧系统 vs. 新系统）\n  - 只读期配置（禁止写入旧系统）\n  - 切换检查清单\n\n### 7.7 报表与数据产品验收\n\n- [ ] **运营报表**\n  - 实时运营看板\n  - 日/周/月报表\n  - 异常告警报表\n\n- [ ] **法定报表**\n  - 财务三大表\n  - 税务申报表\n  - 审计报表\n\n- [ ] **管理看板**\n  - 管理驾驶舱（KPI 仪表盘）\n  - 下钻分析支持\n  - 数据导出功能\n\n- [ ] **自助分析语义层**\n  - 业务指标定义\n  - 计算字段配置\n  - 自助查询界面\n\n- [ ] **数据可见性权限**\n  - 行级权限（按组织、部门）\n  - 列级权限（敏感字段脱敏）\n  - 指标级权限（财务指标）\n\n### 7.8 权限与合规验收\n\n- [ ] **RBAC/ABAC**\n  - 角色定义完整\n  - 权限矩阵清晰\n  - 动态权限计算\n\n- [ ] **职责分离（SoD）**\n  - SoD 规则定义\n  - SoD 冲突检查\n  - SoD 违规告警\n\n- [ ] **审计日志**\n  - 所有写操作记录\n  - 审计字段完整（Who、When、What、Where）\n  - 审计日志不可篡改\n\n- [ ] **留存周期**\n  - 热数据留存策略（3 个月）\n  - 温数据留存策略（1 年）\n  - 冷数据归档策略（7 年）\n\n- [ ] **隐私与同意管理**\n  - PII 字段标识\n  - 数据脱敏策略\n  - 用户同意记录\n  - 数据删除权（GDPR Right to be Forgotten）\n\n### 7.9 可观测性与 SRE 验收\n\n- [ ] **指标/日志/追踪基线**\n  - Prometheus 指标暴露\n  - 结构化日志（JSON 格式）\n  - Jaeger 链路追踪集成\n\n- [ ] **SLI/SLO**\n  - 可用性 SLI（Uptime）\n  - 延迟 SLI（P99 响应时间）\n  - 错误率 SLI（Error Rate）\n  - SLO 定义与告警阈值\n\n- [ ] **告警路由**\n  - 告警分级（P0/P1/P2/P3）\n  - 告警路由规则（PagerDuty/Slack）\n  - 告警收敛（防止告警风暴）\n\n- [ ] **灰度/熔断/限流**\n  - Feature Flag 灰度发布\n  - Circuit Breaker 熔断策略\n  - Rate Limiting 限流策略\n\n### 7.10 性能与容量验收\n\n- [ ] **基准与压测场景**\n  - 性能基准定义（TPS、QPS、延迟）\n  - 压测脚本编写（k6/wrk）\n  - 压测环境配置\n\n- [ ] **容量模型**\n  - 按峰值 QPS 预估资源\n  - 预留 30-50% 余量\n  - 水平扩展验证（HPA）\n\n- [ ] **缓存/分片策略**\n  - Redis 缓存策略（热数据识别）\n  - 数据库分片策略（按时间/按范围）\n  - 缓存命中率监控（目标 > 85%）\n\n- [ ] **批处理窗口**\n  - 批处理时间窗口定义\n  - 批处理性能优化（并行、分片）\n  - 批处理失败重试机制\n\n### 7.11 测试策略验收\n\n- [ ] **单元/契约/集成/端到端/回归**\n  - 单元测试覆盖率 > 80%（领域层 100%）\n  - 契约测试（Pact/Spring Cloud Contract）\n  - 集成测试（跨服务交互）\n  - 端到端测试（完整业务流程）\n  - 回归测试套件\n\n- [ ] **金丝雀数据集**\n  - 测试数据集准备\n  - 金丝雀环境部署\n  - 金丝雀监控与回滚\n\n- [ ] **测试数据脱敏**\n  - 生产数据脱敏策略\n  - PII 字段脱敏规则\n  - 脱敏数据验证\n\n### 7.12 数据质量验收\n\n- [ ] **完整性/唯一性/一致性/及时性规则**\n  - 完整性规则：非空率、必填字段覆盖率\n  - 唯一性规则：主键、业务键唯一性\n  - 一致性规则：跨表关联一致性、外键完整性\n  - 及时性规则：数据延迟监控（T+1 可用性）\n\n- [ ] **DQ 告警与补救流程**\n  - 数据质量评分（0-100）\n  - DQ 阈值告警（< 95%）\n  - DQ 补救流程（数据修复、重跑 ETL）\n\n### 7.13 运维与自动化验收\n\n- [ ] **CI/CD**\n  - GitHub Actions 流程（Lint、Test、Build、Deploy）\n  - Docker 镜像构建与推送\n  - Kubernetes Deployment 自动化\n\n- [ ] **数据库迁移脚本**\n  - 迁移脚本版本控制\n  - 迁移脚本测试（Up/Down）\n  - 迁移脚本回滚验证\n\n- [ ] **回滚/热修**\n  - 蓝绿部署策略\n  - 金丝雀发布策略\n  - 快速回滚流程（< 5 分钟）\n\n- [ ] **作业调度与重试**\n  - Cron Job / Argo Workflows\n  - 作业失败重试（指数退避）\n  - 作业监控与告警\n\n- [ ] **运行手册（Runbook）**\n  - 服务启动/停止流程\n  - 故障排查手册\n  - 常见问题 FAQ\n  - 联系人与升级路径\n\n### 7.14 文档与培训验收\n\n- [ ] **ADR（架构决策记录）**\n  - 技术选型决策\n  - 架构模式决策\n  - 权衡分析记录\n\n- [ ] **接口与事件清单**\n  - REST API 文档（OpenAPI/Swagger）\n  - gRPC 接口文档（Protobuf）\n  - 事件目录（事件名称、载荷、版本）\n\n- [ ] **运维 Runbook**\n  - 部署流程\n  - 监控指标说明\n  - 告警处理流程\n  - 灾难恢复流程\n\n- [ ] **用户手册**\n  - 业务流程说明\n  - 功能操作指南\n  - 常见问题解答\n\n- [ ] **培训材料**\n  - 培训 PPT\n  - 视频教程\n  - 实操演练脚本\n\n### 7.15 Cutover 与 Rollout 验收\n\n- [ ] **黑暗发布/灰度/全量切换步骤**\n  - 黑暗发布：功能上线但不开放（Feature Flag Off）\n  - 灰度发布：5% → 25% → 50% → 100% 流量切换\n  - 全量发布：所有用户可用\n\n- [ ] **回滚方案**\n  - 回滚触发条件（错误率、延迟、用户反馈）\n  - 回滚流程步骤\n  - 回滚演练记录\n\n- [ ] **业务验收/双轨期支持**\n  - UAT（用户验收测试）通过\n  - 双轨运行期（旧系统并行）\n  - 双轨期数据对账\n  - 旧系统下线计划\n\n---\n\n## 八、事件载荷标准模板\n\n基于 BOM 文档的事件载荷最小字段模板，所有服务统一遵循。\n\n### 8.1 事件元信息（必填）\n\n```rust\npub struct EventMetadata {\n    /// 事件唯一标识（幂等键）\n    pub event_id: Uuid,\n\n    /// 事件版本（语义版本）\n    pub event_version: String,  // \"1.0.0\"\n\n    /// 事件发生时间（UTC）\n    pub occurred_at: DateTime<Utc>,\n\n    /// 事件生产者（服务名称）\n    pub producer: String,  // \"financial-service\"\n\n    /// 关联 ID（用于追踪同一业务流程）\n    pub correlation_id: Uuid,\n\n    /// 分布式追踪 ID（Jaeger Trace ID）\n    pub trace_id: String,\n}\n```\n\n### 8.2 事件业务主体（必填）\n\n```rust\npub struct EventPayload {\n    /// 聚合类型\n    pub aggregate_type: String,  // \"Transaction\", \"SalesOrder\", etc.\n\n    /// 聚合 ID\n    pub aggregate_id: Uuid,\n\n    /// 业务数据（具体事件载荷）\n    pub payload: serde_json::Value,\n\n    /// 载荷 Schema 引用（可选，用于 Schema Registry）\n    pub schema_ref: Option<String>,  // \"financial.transaction.v1\"\n}\n```\n\n### 8.3 事件上下文（必填）\n\n```rust\npub struct EventContext {\n    /// 操作人（用户 ID 或系统账号）\n    pub actor: String,\n\n    /// 租户 ID（多租户场景）\n    pub tenant_id: Option<String>,\n\n    /// 来源系统\n    pub source_system: String,  // \"ERP\", \"CRM\", \"External API\"\n\n    /// IP 地址（可选）\n    pub ip_address: Option<String>,\n\n    /// 设备信息（可选）\n    pub device: Option<String>,\n}\n```\n\n### 8.4 事件合规信息（可选）\n\n```rust\npub struct EventCompliance {\n    /// 敏感度级别\n    pub sensitivity: SensitivityLevel,  // Public, Internal, Confidential, Restricted\n\n    /// 数字签名（可选，用于防篡改）\n    pub signature: Option<String>,\n\n    /// 留存策略标识\n    pub retention: RetentionPolicy,  // ShortTerm(3m), MediumTerm(1y), LongTerm(7y)\n}\n\npub enum SensitivityLevel {\n    Public,         // 公开数据\n    Internal,       // 内部数据\n    Confidential,   // 机密数据（PII、财务）\n    Restricted,     // 限制级数据（高管薪资、审计数据）\n}\n```\n\n### 8.5 完整事件结构\n\n```rust\npub struct DomainEvent {\n    pub metadata: EventMetadata,\n    pub payload: EventPayload,\n    pub context: EventContext,\n    pub compliance: Option<EventCompliance>,\n}\n```\n\n### 8.6 事件示例：财务凭证过账事件\n\n```json\n{\n  \"metadata\": {\n    \"event_id\": \"550e8400-e29b-41d4-a716-446655440000\",\n    \"event_version\": \"1.0.0\",\n    \"occurred_at\": \"2025-12-22T10:30:00Z\",\n    \"producer\": \"financial-service\",\n    \"correlation_id\": \"9b1deb4d-3b7d-4bad-9bdd-2b0d7b3dcb6d\",\n    \"trace_id\": \"00-4bf92f3577b34da6a3ce929d0e0e4736-00f067aa0ba902b7-01\"\n  },\n  \"payload\": {\n    \"aggregate_type\": \"Transaction\",\n    \"aggregate_id\": \"7d9e3f42-8c8a-4e5b-9f3a-1a2b3c4d5e6f\",\n    \"payload\": {\n      \"transaction_number\": \"FI-2025-0001234\",\n      \"posting_date\": \"2025-12-22\",\n      \"document_date\": \"2025-12-20\",\n      \"company_code\": \"1000\",\n      \"fiscal_year\": 2025,\n      \"journal_entries\": [\n        {\n          \"account_number\": \"100000\",\n          \"debit_amount\": 10000.00,\n          \"credit_amount\": 0.00,\n          \"currency\": \"USD\"\n        },\n        {\n          \"account_number\": \"200000\",\n          \"debit_amount\": 0.00,\n          \"credit_amount\": 10000.00,\n          \"currency\": \"USD\"\n        }\n      ],\n      \"status\": \"Posted\"\n    },\n    \"schema_ref\": \"erp.financial.transaction.v1\"\n  },\n  \"context\": {\n    \"actor\": \"user:john.doe@example.com\",\n    \"tenant_id\": \"tenant-001\",\n    \"source_system\": \"ERP\",\n    \"ip_address\": \"192.168.1.100\",\n    \"device\": \"Web Browser - Chrome 120\"\n  },\n  \"compliance\": {\n    \"sensitivity\": \"Confidential\",\n    \"signature\": \"SHA256:abcdef1234567890...\",\n    \"retention\": \"LongTerm\"\n  }\n}\n```\n\n---\n\n## 九、性能与容量基准（增强版）\n\n基于 BOM 文档的性能基准，补充更详细的指标。\n\n### 9.1 API/事件性能基准\n\n| 指标 | 目标值 | 测量方法 |\n|-----|--------|---------|\n| 核心写接口 P99 延迟 | < 200-300ms | k6 压测 |\n| 核心读接口 P99 延迟 | < 150-200ms | k6 压测 |\n| 非核心接口 P99 延迟 | < 500ms | k6 压测 |\n| Kafka 事件处理滞留 | < 1 分钟 | Kafka Lag 监控 |\n| 事件发布幂等率 | ≥ 99% | 事件 ID 去重统计 |\n| API 可用性 | ≥ 99.9% | Uptime 监控 |\n| API 错误率 | < 0.1% | Error Rate 监控 |\n\n### 9.2 批处理性能基准\n\n| 批处理任务 | 目标窗口 | 数据量 | 备注 |\n|-----------|---------|--------|------|\n| 财务关账（月结） | 2-4 小时 | 100K+ 凭证 | 夜间批处理 |\n| 成本结算批次 | 1-2 小时 | 50K+ 成本对象 | 夜间批处理 |\n| 三单匹配批次 | 30-60 分钟 | 10K+ 发票 | 夜间批处理 |\n| 运费结算批次 | 30-60 分钟 | 5K+ 运输单 | 夜间批处理 |\n| MRP 运算 | < 2 小时 | 10K+ SKU, 1K+ BOM | 夜间批处理 |\n| IBP 需求预测 | < 30 分钟 | 10K+ SKU | 夜间批处理 |\n| 薪资核算批次 | < 30 分钟 | 1K+ 员工 | 月度批处理 |\n| BI ETL 批次 | < 2 小时 | 全量数据同步 | 夜间批处理 |\n\n### 9.3 容量规划基准\n\n| 资源 | 起步配置 | 扩展策略 | 备注 |\n|-----|---------|---------|------|\n| API 服务 | 2 副本 x 1 CPU x 2GB RAM | HPA: CPU > 70% → +1 副本 | 最大 10 副本 |\n| 批处理服务 | 1 副本 x 2 CPU x 4GB RAM | 手动扩展 | 峰值时临时扩容 |\n| PostgreSQL | 4 CPU x 16GB RAM | 垂直扩展 | 主从复制 |\n| Redis | 2GB 内存 | 垂直扩展 | 集群模式（3 主 3 从） |\n| Kafka | 3 Broker x 2 CPU x 8GB RAM | 增加 Broker | 分区数按主题调整 |\n| ClickHouse | 4 CPU x 32GB RAM | 增加节点 | 分布式表 |\n\n### 9.4 缓存性能基准\n\n| 缓存项 | 命中率目标 | TTL | 失效策略 |\n|-------|-----------|-----|---------|\n| 主数据（客户/供应商/物料） | > 90% | 1 小时 | Write-Through（主数据变更时失效） |\n| 科目余额 | > 85% | 5 分钟 | Write-Through（凭证过账时失效） |\n| 库存快照 | > 80% | 1 分钟 | Write-Through（库存事务时失效） |\n| 定价条件 | > 90% | 10 分钟 | Write-Through（定价条件变更时失效） |\n| 用户权限 | > 95% | 15 分钟 | Write-Through（权限变更时失效） |\n| 汇率 | > 95% | 1 小时 | 定时刷新（每小时拉取最新汇率） |\n\n### 9.5 数据库性能基准\n\n| 指标 | 目标值 | 优化手段 |\n|-----|--------|---------|\n| 连接池利用率 | < 80% | PgBouncer 连接池 |\n| 慢查询比例 | < 1% | 添加索引、查询优化 |\n| 死锁频率 | < 10 次/天 | 事务优化、锁粒度减小 |\n| 读写比 | 读:写 = 7:3 | 读写分离（主写从读） |\n| 备份恢复时间 | RTO < 5 分钟, RPO < 1 分钟 | WAL 归档 + PITR |\n\n### 9.6 可用性基准\n\n| 服务 | 可用性目标 | 容错策略 | 备注 |\n|-----|-----------|---------|------|\n| 核心服务（Financial、Materials、Sales） | 99.9% (43 分钟/月停机) | 多副本 + HPA + 健康检查 | P0 级别 |\n| 重要服务（Production、HR、Quality） | 99.5% (3.6 小时/月停机) | 多副本 + 健康检查 | P1 级别 |\n| 辅助服务（CRM、Analytics） | 99.0% (7.2 小时/月停机) | 单副本 + 手动恢复 | P2 级别 |\n| PostgreSQL | 99.99% (4 分钟/月停机) | 主从复制 + 自动故障转移 | P0 级别 |\n| Redis | 99.9% | 哨兵模式 + 自动故障转移 | P1 级别 |\n| Kafka | 99.95% | 3 副本 + ISR | P0 级别 |\n\n---\n\n## 十、跨模块关键事件与接口基线\n\n基于 BOM 文档，定义跨服务集成的关键事件和接口。\n\n### 10.1 P2P（采购到付款）事件链\n\n```\n1. 采购申请创建 → erp.mm.purchase_requisition.created\n2. 采购订单创建 → erp.mm.purchase_order.created\n3. 采购订单发布 → erp.mm.purchase_order.released\n4. 收货（GR） → erp.mm.goods_receipt.posted\n   - 触发质检：erp.qm.inspection_lot.created（如启用质检）\n   - 触发库存更新：Materials Service 内部处理\n   - 触发财务凭证：erp.fi.journal_entry.posted（库存凭证）\n5. 发票校验（三单匹配） → erp.mm.invoice.matched\n   - 匹配成功：erp.mm.invoice.approved\n   - 匹配失败：erp.mm.invoice.blocked\n6. 付款批次 → erp.fi.payment.posted\n   - 触发银行扣款：erp.tr.bank_statement.updated\n7. 供应商主数据同步 → erp.mdg.vendor.updated\n```\n\n### 10.2 O2C（订单到收款）事件链\n\n```\n1. 销售订单创建 → erp.sd.sales_order.created\n2. 信用检查 → erp.fscm.credit_check.completed\n   - 通过：erp.fscm.credit_released\n   - 拒绝：erp.fscm.credit_blocked\n3. 库存预留 → erp.mm.inventory.reserved\n4. 发货 → erp.sd.delivery.shipped\n   - 触发仓库出库：erp.wm.outbound_delivery.completed\n   - 触发运输创建：erp.tm.shipment.created\n5. 开票 → erp.sd.invoice.issued\n   - 触发财务应收：erp.fi.receivable.created\n   - 触发电子发票：外部税控接口\n6. 收款 → erp.fi.payment.received\n   - 触发银行到账：erp.tr.bank_statement.updated\n7. 退货/退款 → erp.sd.return.created → erp.fi.credit_memo.issued\n8. 客户主数据同步 → erp.mdg.customer.updated\n```\n\n### 10.3 MTS/MTO/生产事件链\n\n```\n1. MRP 运行 → erp.pp.mrp.completed\n   - 生成计划订单：erp.pp.planned_order.created\n2. 计划订单转生产订单 → erp.pp.production_order.created\n3. 物料预留 → erp.mm.inventory.reserved\n4. 领料 → erp.mm.goods_issue.posted\n   - 触发在制检验（可选）：erp.qm.inspection_lot.created\n5. 报工 → erp.pp.operation.confirmed\n   - 触发设备使用记录：erp.pm.equipment_usage.recorded\n6. 报废/返工 → erp.pp.scrap.recorded / erp.pp.rework.created\n7. 生产完工 → erp.pp.production_order.completed\n   - 触发成品入库：erp.mm.goods_receipt.posted\n   - 触发成品检验：erp.qm.inspection_lot.created\n8. 成本结算 → erp.co.production_cost.settled\n   - 触发财务凭证：erp.fi.journal_entry.posted\n9. 物料主数据同步 → erp.mdg.material.updated\n10. BOM 变更 → erp.pp.bom.updated\n```\n\n### 10.4 仓储/运输事件链\n\n```\n1. 入库通知 → erp.wm.inbound_delivery.created\n2. 上架任务 → erp.wm.putaway_task.created\n3. 上架完成 → erp.wm.putaway_task.completed\n   - 触发库存更新：erp.mm.inventory.updated\n4. 波次创建 → erp.wm.wave.created\n5. 拣货任务 → erp.wm.picking_task.created\n6. 拣货完成 → erp.wm.picking_task.completed\n7. 包装完成 → erp.wm.packing.completed\n8. 运输创建 → erp.tm.shipment.created\n9. 承运商分配 → erp.tm.carrier.assigned\n10. 在途更新 → erp.tm.shipment.in_transit\n11. 签收（POD） → erp.tm.pod.received\n    - 触发运费结算：erp.tm.freight.calculated\n    - 触发财务凭证：erp.fi.journal_entry.posted\n12. 盘点 → erp.wm.physical_inventory.completed\n    - 触发盘点差异：erp.wm.inventory_difference.posted\n```\n\n### 10.5 财务/成本事件链\n\n```\n1. 凭证过账 → erp.fi.journal_entry.posted\n2. 资产变动 → erp.fi.asset.updated\n3. 关账状态 → erp.fi.period.closed\n4. 成本分摊 → erp.co.allocation.posted\n5. 成本结算 → erp.co.settlement.posted\n6. CO-PA 分段 → erp.co.profitability.updated\n7. 付款运行 → erp.tr.payment_factory.executed\n8. 银行对账 → erp.tr.bank_reconciliation.completed\n9. 汇率变更 → erp.mdg.exchange_rate.updated\n10. 科目主数据变更 → erp.mdg.account.updated\n```\n\n### 10.6 主数据事件链\n\n```\n1. 业务伙伴创建 → erp.mdg.business_partner.created\n2. 业务伙伴更新 → erp.mdg.business_partner.updated\n   - 触发下游缓存失效：FI、MM、SD、CRM 订阅\n3. 物料创建 → erp.mdg.material.created\n4. 物料更新 → erp.mdg.material.updated\n   - 触发下游缓存失效：MM、SD、PP、WM 订阅\n5. 科目创建 → erp.mdg.account.created\n6. 科目更新 → erp.mdg.account.updated\n   - 触发下游缓存失效：FI、CO 订阅\n7. 组织变更 → erp.mdg.organization.updated\n   - 触发权限重新计算：IAM Service 订阅\n8. 版本激活 → erp.mdg.version.activated\n9. 重复检测 → erp.mdg.duplicate.detected\n10. 合并完成 → erp.mdg.merge.completed\n```\n\n### 10.7 分析与数仓事件链\n\n```\n1. 事件总线采集 → 所有服务领域事件订阅\n2. CDC 采集 → 数据库变更日志采集\n3. 批量 ETL → erp.dw.etl.completed\n4. 数据质量检查 → erp.dw.data_quality.checked\n   - 质量不合格：erp.dw.data_quality.failed\n5. 数据集发布 → erp.dw.dataset.published\n6. 报表刷新 → erp.dw.report.refreshed\n7. 告警触发 → erp.dw.alert.triggered\n8. 血缘更新 → erp.dw.lineage.updated\n```\n\n---\n\n## 十一、数据迁移与切换策略（增强版）\n\n基于 BOM 文档，补充详细的数据迁移策略。\n\n### 11.1 迁移范围与优先级\n\n#### 第一批：主数据（Day 1-10）\n- 业务伙伴主数据（客户、供应商）\n- 物料主数据\n- 科目表\n- 组织架构（公司代码、工厂、库存地点、成本中心、利润中心）\n- 币种、税码、计量单位\n- 员工主数据、组织架构\n\n#### 第二批：期初余额（Day 11-20）\n- 科目余额（按公司代码、会计期间）\n- 客户应收余额\n- 供应商应付余额\n- 库存余额（按物料、批次、库位）\n- 在制品（WIP）余额\n- 固定资产卡片与折旧余额\n\n#### 第三批：未结单据（Day 21-30）\n- 未结采购订单\n- 未结销售订单\n- 未结生产订单\n- 未结维护工单\n- 未结项目 WBS\n\n#### 第四批：历史交易（Day 31-40，可选）\n- 历史凭证（最近 2 年）\n- 历史订单（最近 1 年）\n- 历史库存事务（最近 6 个月）\n\n### 11.2 迁移工具与流程\n\n#### 11.2.1 迁移工具链\n```\n旧系统（KILLER/其他 ERP）\n  ↓\n数据抽取（SQL Export / RFC / API）\n  ↓\n数据清洗与映射（Python/Pandas/Spark）\n  ↓\n数据校验（数据质量检查）\n  ↓\n数据导入（Batch API / SQL Import）\n  ↓\n数据对账（四维度对账）\n```\n\n#### 11.2.2 抽取-清洗-映射脚本\n```python\n# 示例：业务伙伴迁移脚本\nimport pandas as pd\nfrom typing import Dict, List\n\nclass BusinessPartnerMigration:\n    def extract_from_KILLER(self) -> pd.DataFrame:\n        \"\"\"从 KILLER 抽取业务伙伴数据\"\"\"\n        # RFC 调用 or SQL 查询\n        pass\n\n    def clean_and_transform(self, df: pd.DataFrame) -> pd.DataFrame:\n        \"\"\"数据清洗与转换\"\"\"\n        # 1. 空值处理\n        df = df.fillna({\n            'phone': '',\n            'email': '',\n            'tax_number': ''\n        })\n\n        # 2. 格式标准化\n        df['phone'] = df['phone'].apply(self.normalize_phone)\n        df['email'] = df['email'].str.lower()\n\n        # 3. 数据映射\n        df['partner_type'] = df['customer_vendor_flag'].map({\n            'K': 'Customer',\n            'L': 'Vendor'\n        })\n\n        # 4. 数据验证\n        df = df[df['email'].str.contains('@')]  # 邮箱格式验证\n\n        return df\n\n    def load_to_new_system(self, df: pd.DataFrame):\n        \"\"\"加载到新系统\"\"\"\n        # 批量 API 调用\n        for chunk in self.chunk_dataframe(df, chunk_size=1000):\n            self.call_batch_api(chunk)\n\n    def reconcile(self, df: pd.DataFrame):\n        \"\"\"数据对账\"\"\"\n        # 四维度对账：数量、完整性、准确性、一致性\n        pass\n```\n\n### 11.3 数据校验四维度\n\n#### 11.3.1 数量对账\n- 旧系统记录数 == 新系统记录数\n- 按维度统计：按公司代码、按物料类型、按客户分组等\n\n#### 11.3.2 完整性对账\n- 必填字段非空率 > 95%\n- 关键字段覆盖率 100%（如业务伙伴编号、物料编号）\n\n#### 11.3.3 准确性对账\n- 抽样对账：随机抽取 1000 条记录逐字段比对\n- 金额对账：科目余额、应收应付、库存金额精确匹配（容差 < 0.01）\n\n#### 11.3.4 一致性对账\n- 跨表一致性：凭证借贷平衡、销售订单金额 == 发票金额\n- 引用完整性：外键完整性检查（如销售订单 → 客户主数据）\n\n### 11.4 双轨与切换策略\n\n#### 11.4.1 双轨阶段（1-2 个月）\n```\nDay 1-30: 双写阶段\n- 新业务同时写入旧系统和新系统\n- 新系统只读模式（不对外暴露）\n- 每日对账（新系统 vs. 旧系统）\n\nDay 31-45: 灰度阶段\n- 10% 流量切到新系统（只读查询）\n- 监控新系统稳定性\n- 每日对账\n\nDay 46-60: 全量只读阶段\n- 100% 读流量切到新系统\n- 写流量仍在旧系统\n- 双向对账\n\nDay 61: 切换日\n- 关闭旧系统写入\n- 新系统开放写入\n- 24 小时值班监控\n```\n\n#### 11.4.2 回滚预案\n**触发条件**：\n- 新系统错误率 > 1%\n- 新系统 P99 延迟 > 1000ms 持续 10 分钟\n- 数据一致性对账失败（差异 > 0.1%）\n- 用户反馈严重 Bug（P0 级别）\n\n**回滚流程**：\n1. 停止新系统写入（Feature Flag Off）\n2. 恢复旧系统写入\n3. 数据回滚：丢弃新系统切换后产生的数据（如有）\n4. 配置回滚：恢复旧系统 API 路由\n5. 通知用户：系统已恢复正常\n6. 事后分析：根因分析与修复计划\n\n### 11.5 冻结窗口策略\n\n#### 11.5.1 主数据冻结\n- 冻结时间：切换前 24 小时\n- 冻结范围：业务伙伴、物料、科目、组织架构\n- 解冻时间：切换后验证通过（约 4 小时）\n\n#### 11.5.2 关键交易冻结\n- 冻结时间：切换日 00:00-06:00（6 小时窗口）\n- 冻结范围：凭证过账、订单创建、库存事务、薪资核算\n- 解冻策略：分批解冻（先凭证，再订单，最后库存）\n\n#### 11.5.3 冲突解决流程\n- 冲突检测：双写期间检测同一记录被修改\n- 冲突解决策略：\n  - 时间戳优先：最后写入胜出\n  - 旧系统优先：双轨期旧系统为主\n  - 人工仲裁：关键冲突由业务专家决定\n\n### 11.6 合规与安全\n\n#### 11.6.1 数据脱敏\n- PII 字段脱敏：姓名、电话、邮箱、身份证号\n- 脱敏算法：SHA256 Hash + Salt（不可逆）\n- 财务数据脱敏：金额 ± 10% 随机偏移\n\n#### 11.6.2 传输加密\n- TLS 1.3 加密传输\n- 数据库连接加密（PostgreSQL SSL）\n- 文件传输加密（SFTP）\n\n#### 11.6.3 访问审计\n- 迁移操作全程审计\n- 审计字段：操作人、操作时间、操作类型、IP 地址\n- 审计日志留存 7 年\n\n#### 11.6.4 留存与销毁\n- 迁移脚本留存：3 年\n- 迁移日志留存：7 年\n- 临时数据销毁：迁移完成后 30 天内销毁\n\n---\n\n## 十二、总结与后续计划\n\n### 12.1 本增强版计划的主要补充内容\n\n1. **新增阶段 0**：平台与主数据治理（MDG/GRC/IAM）\n2. **新增 TR/FSCM**：资金管理与财务供应链\n3. **新增 SCM/IBP**：高级供应链计划\n4. **新增 PS**：项目系统\n5. **增强 BI/BW**：企业数据仓库与完整 BI 平台\n6. **通用交付检查清单**：15 个维度的验收标准\n7. **事件载荷标准模板**：统一的事件结构\n8. **性能与容量基准**：详细的性能指标\n9. **跨模块事件与接口基线**：6 大业务流程事件链\n10. **数据迁移与切换策略**：完整的迁移方案\n\n### 12.2 与原计划的关系\n\n- **Month 1-2**：在原基础设施建设基础上，增加阶段 0（主数据治理与 IAM）\n- **Month 3-5**：在原 Financial Service 基础上，增加 TR/FSCM 模块\n- **Month 6-8**：保持原供应链模块计划\n- **Month 9-10**：在原 HR/Quality/Maintenance 基础上，增加 WM/TM 和 SCM/IBP、PS\n- **Month 11**：增强 Analytics Service 为完整的 BI/BW 平台\n- **Month 12**：保持原上线准备计划\n\n### 12.3 关键成功因素\n\n1. **严格验收**：每个阶段结束必须通过通用交付检查清单验收\n2. **事件驱动**：所有服务间集成优先使用事件驱动，减少同步调用\n3. **数据质量**：主数据治理从第一天开始，数据质量 KPI 纳入绩效考核\n4. **性能监控**：每个 Sprint 结束都要进行性能基准测试\n5. **文档先行**：ADR、接口文档、Runbook 与代码同步更新\n6. **灰度发布**：所有新功能必须通过 Feature Flag 灰度发布\n7. **数据迁移**：提前 2 个月开始迁移准备，多轮演练\n\n### 12.4 后续 12-24 个月计划（可选）\n\n- **Month 13-15**：移动端应用（React Native/Flutter）\n- **Month 16-18**：高级分析（机器学习预测、智能推荐）\n- **Month 19-21**：国际化（多语言、多币种、多时区）\n- **Month 22-24**：行业特化（制造业 MES、零售业 POS、服务业 FSM）\n\n---\n\n**文档维护**：\n- 本文档应与 Rust-Abc.md 和 Rust-BOM.md 保持同步\n- 每个 Sprint 结束后更新进度和验收状态\n- 每个 Stage Review 后更新风险和改进措施\n\n**联系方式**：team@rust-erp.example.com\n", "md/Rust-Abc.md": "# Rust ERP 系统 - 5人团队12个月开发计划\n\n**项目名称**: Rust ERP 微服务系统\n**团队规模**: 5人\n**开发周期**: 12个月（52周 / 260工作日）\n**架构模式**: DDD + CQRS + Event Sourcing + Microservices\n**文档版本**: v1.0\n**创建日期**: 2025-12-21\n\n---\n\n## 一、团队角色与职责分配\n\n### 1.1 团队成员\n\n| 成员 | 角色 | 主要职责 | 技术专长 |\n|-----|------|---------|---------|\n| **开发者A** | 架构师 & 后端负责人 | 系统架构设计、共享库开发、技术攻关 | Rust、DDD、微服务架构 |\n| **开发者B** | 财务模块负责人 | Financial Service、Controlling Service开发 | Rust、PostgreSQL、会计业务 |\n| **开发者C** | 供应链模块负责人 | Materials Service、Sales Service、Production Service开发 | Rust、分布式系统、供应链业务 |\n| **开发者D** | 基础设施负责人 | DevOps、Kafka、Redis、Kubernetes部署 | Rust、Kafka、K8s、监控 |\n| **开发者E** | 全栈开发者 | HR Service、Quality Service、API Gateway、前端集成 | Rust、gRPC、前端集成 |\n\n### 1.2 工作模式\n\n- **敏捷开发**: 2周1个Sprint，每月2个Sprint\n- **代码评审**: 所有代码必须经过至少1人评审\n- **测试覆盖率**: 核心业务逻辑 > 80%\n- **每日站会**: 15分钟同步进度和问题\n- **每月回顾**: Sprint Review + Retrospective\n\n---\n\n## 二、开发阶段划分（12个月）\n\n```\n月份 1-2   | 阶段1: 基础设施建设与共享库开发\n月份 3-5   | 阶段2: 核心财务模块开发（FI/CO）\n月份 6-8   | 阶段3: 供应链模块开发（MM/SD/PP）\n月份 9-10  | 阶段4: 人力资源与质量模块（HR/QM/PM）\n月份 11-12 | 阶段5: 集成测试、性能优化、上线准备\n```\n\n---\n\n## 三、详细开发计划（按月分解）\n\n---\n\n## 第1个月（Week 1-4）：基础设施建设\n\n### 目标\n- 搭建开发环境\n- 完成共享库开发\n- 建立 CI/CD 流程\n- 部署基础设施（PostgreSQL、Redis、Kafka、Kubernetes）\n\n### Week 1（Day 1-5）：开发环境搭建\n\n#### Day 1-2: 项目初始化（全员）\n- **开发者A**:\n  - 创建 GitHub 仓库，设置 Cargo Workspace 结构\n  - 编写 README、CONTRIBUTING、开发规范文档\n  - 配置 GitHub Actions CI 模板\n- **开发者B**:\n  - 搭建本地 PostgreSQL 数据库（Docker Compose）\n  - 配置数据库连接池和迁移工具（SQLx）\n- **开发者C**:\n  - 搭建本地 Redis 集群（Docker Compose）\n  - 编写 Redis 连接测试代码\n- **开发者D**:\n  - 搭建本地 Kafka 集群（Zookeeper + Broker）\n  - 创建 Kafka 主题命名规范文档\n  - 配置 Kubernetes 本地开发环境（k3d/minikube）\n- **开发者E**:\n  - 配置 Rust 开发环境（rustfmt、clippy、cargo-watch）\n  - 安装 Protobuf 编译器，测试 gRPC 编译\n\n#### Day 3-5: 共享库开发 - domain-primitives\n- **开发者A**（领导）:\n  - `shared/domain-primitives/src/lib.rs`: 公共类型定义\n  - `shared/domain-primitives/src/aggregate.rs`: AggregateRoot trait\n  - `shared/domain-primitives/src/entity.rs`: Entity trait\n  - `shared/domain-primitives/src/value_object.rs`: ValueObject trait\n  - `shared/domain-primitives/src/errors.rs`: DomainError 定义\n- **开发者B**（协助）:\n  - `shared/domain-primitives/src/money.rs`: Money 值对象（金额+币种）\n  - `shared/domain-primitives/src/uuid_wrapper.rs`: 强类型 UUID 封装\n  - 单元测试：Money 算术运算、币种验证\n- **开发者C**（协助）:\n  - `shared/domain-primitives/src/email.rs`: Email 值对象\n  - `shared/domain-primitives/src/phone.rs`: PhoneNumber 值对象\n  - 单元测试：Email/Phone 格式验证\n\n### Week 2（Day 6-10）：共享库开发 - event-sourcing\n\n#### Day 6-8: Event Sourcing 框架\n- **开发者A**（领导）:\n  - `shared/event-sourcing/src/event.rs`: DomainEvent trait 定义\n  - `shared/event-sourcing/src/event_store.rs`: EventStore trait 和 PostgreSQL 实现\n  - `shared/event-sourcing/src/aggregate_repository.rs`: 基于事件重建聚合的仓储\n  - `shared/event-sourcing/src/event_bus.rs`: EventBus trait 定义\n- **开发者D**（协助）:\n  - `shared/event-sourcing/src/kafka_event_bus.rs`: Kafka EventBus 实现\n  - 集成测试：事件发布到 Kafka，从 Kafka 消费\n- **开发者B**（协助）:\n  - 编写 Event Store 数据库表迁移脚本\n  - 编写事件序列化/反序列化测试\n\n#### Day 9-10: CQRS 框架\n- **开发者A**:\n  - `shared/cqrs/src/command.rs`: Command trait 和 CommandHandler trait\n  - `shared/cqrs/src/query.rs`: Query trait 和 QueryHandler trait\n  - `shared/cqrs/src/command_bus.rs`: 命令总线实现\n  - `shared/cqrs/src/query_bus.rs`: 查询总线实现\n- **开发者E**:\n  - 编写 CQRS 使用示例和文档\n  - 单元测试：命令/查询处理流程\n\n### Week 3（Day 11-15）：共享库开发 - observability\n\n#### Day 11-13: 可观测性工具\n- **开发者D**（领导）:\n  - `shared/observability/src/tracing.rs`: 集成 OpenTelemetry + Jaeger\n  - `shared/observability/src/metrics.rs`: Prometheus 指标收集器\n  - `shared/observability/src/logging.rs`: 结构化日志配置（tracing-subscriber）\n- **开发者A**（协助）:\n  - 编写可观测性中间件（HTTP/gRPC 拦截器）\n  - 配置 Jaeger 和 Prometheus 测试环境\n- **开发者E**（协助）:\n  - 编写 Grafana Dashboard 模板\n  - 配置 Loki 日志聚合\n\n#### Day 14-15: API Gateway 框架搭建\n- **开发者E**（领导）:\n  - 创建 `api-gateway` 服务目录结构\n  - 配置 Kong Gateway Docker Compose\n  - 编写 JWT 认证中间件（Axum）\n  - 配置限流、CORS 中间件\n- **开发者A**（协助）:\n  - 设计 API Gateway 路由规则\n  - 编写服务发现配置（Consul/Kubernetes DNS）\n\n### Week 4（Day 16-20）：CI/CD 与 Kubernetes 部署\n\n#### Day 16-18: CI/CD 流程\n- **开发者D**（领导）:\n  - 编写 `.github/workflows/ci.yml`（Lint、Test、Build）\n  - 配置 GitHub Actions 缓存策略\n  - 编写 Docker 镜像构建流程（Multi-stage Dockerfile）\n  - 配置 GitHub Container Registry\n- **开发者A**（协助）:\n  - 编写代码覆盖率检查（cargo-tarpaulin）\n  - 配置安全审计（cargo-audit）\n\n#### Day 19-20: Kubernetes 部署模板\n- **开发者D**:\n  - 编写 Kubernetes Deployment 模板（YAML）\n  - 配置 HPA（HorizontalPodAutoscaler）\n  - 编写 Helm Chart 模板\n  - 配置 Istio Service Mesh（mTLS、流量管理）\n- **全员**:\n  - Sprint 1 Review：演示共享库和基础设施\n  - Sprint 1 Retrospective：总结问题和改进点\n\n---\n\n## 第2个月（Week 5-8）：核心财务模块启动\n\n### 目标\n- 完成 Financial Service 核心功能（总账、应收应付）\n- 实现 DDD 四层架构示例\n- 建立开发模板和最佳实践\n\n### Week 5（Day 21-25）：Financial Service - 领域层开发\n\n#### Day 21-23: 领域模型设计（开发者B领导，开发者A协助）\n- **开发者B**:\n  - `domain/aggregates/account.rs`: Account 聚合根（会计科目）\n    - `create()`: 创建科目\n    - `update_balance()`: 更新余额\n    - `close_period()`: 关闭期间\n  - `domain/value_objects/account_number.rs`: 科目编号值对象\n  - `domain/value_objects/fiscal_period.rs`: 会计期间值对象\n  - `domain/value_objects/amount.rs`: 金额值对象\n- **开发者A**:\n  - `domain/aggregates/transaction.rs`: Transaction 聚合根（财务交易）\n    - `create()`: 创建交易\n    - `post()`: 过账\n    - `reverse()`: 冲销\n  - `domain/entities/journal_entry.rs`: 分录实体\n  - `domain/events/account_events.rs`: AccountCreated、BalanceUpdated 事件\n  - `domain/events/transaction_events.rs`: TransactionPosted、TransactionReversed 事件\n\n#### Day 24-25: 领域服务和仓储接口\n- **开发者B**:\n  - `domain/services/balance_calculator.rs`: 余额计算服务\n  - `domain/services/exchange_rate_service.rs`: 汇率转换服务\n  - `domain/repositories/account_repository.rs`: AccountRepository trait\n  - `domain/repositories/transaction_repository.rs`: TransactionRepository trait\n- **单元测试**（全覆盖）:\n  - 科目创建业务规则测试\n  - 交易过账借贷平衡测试\n  - 金额货币转换测试\n\n### Week 6（Day 26-30）：Financial Service - 基础设施层\n\n#### Day 26-28: PostgreSQL 仓储实现\n- **开发者B**:\n  - `infrastructure/persistence/postgres/account_repo_impl.rs`: Account 仓储实现\n  - `infrastructure/persistence/postgres/transaction_repo_impl.rs`: Transaction 仓储实现\n  - `infrastructure/persistence/postgres/models.rs`: ORM 模型定义\n  - 迁移脚本：`migrations/001_create_accounts_table.sql`\n  - 迁移脚本：`migrations/002_create_transactions_table.sql`\n  - 迁移脚本：`migrations/003_create_journal_entries_table.sql`\n- **开发者A**:\n  - `infrastructure/messaging/kafka_producer.rs`: 事件发布实现\n  - `infrastructure/messaging/kafka_consumer.rs`: 事件订阅实现\n  - 集成测试：数据库 CRUD 操作\n\n#### Day 29-30: Redis 缓存实现\n- **开发者B**:\n  - `infrastructure/persistence/redis/account_cache.rs`: 科目余额缓存\n  - `infrastructure/persistence/redis/transaction_cache.rs`: 交易查询缓存\n  - 缓存失效策略实现（Write-Through）\n\n### Week 7（Day 31-35）：Financial Service - 应用层与API层\n\n#### Day 31-33: CQRS 命令/查询处理器\n- **开发者B**:\n  - **命令处理器**:\n    - `application/commands/create_account.rs`: 创建科目命令\n    - `application/commands/post_transaction.rs`: 过账交易命令\n    - `application/commands/close_period.rs`: 结账命令\n  - **查询处理器**:\n    - `application/queries/get_account.rs`: 查询科目详情\n    - `application/queries/get_account_balance.rs`: 查询余额\n    - `application/queries/list_transactions.rs`: 查询交易列表\n- **开发者A**:\n  - `application/services/account_service.rs`: 科目管理服务\n  - `application/services/transaction_service.rs`: 交易处理服务\n\n#### Day 34-35: REST API 和 gRPC 实现\n- **开发者B**:\n  - `api/http/handlers/account_handler.rs`: 科目 HTTP 接口\n  - `api/http/handlers/transaction_handler.rs`: 交易 HTTP 接口\n  - `api/http/routes.rs`: 路由配置\n  - `api/dto/requests.rs` 和 `api/dto/responses.rs`: DTO 定义\n- **开发者A**:\n  - `proto/financial.proto`: gRPC 接口定义\n  - `api/grpc/services/financial_service.rs`: gRPC 服务实现\n  - 集成测试：API 端到端测试\n\n### Week 8（Day 36-40）：Financial Service - 集成与部署\n\n#### Day 36-38: 集成测试和文档\n- **开发者B**:\n  - 编写端到端集成测试（创建科目 → 过账交易 → 查询余额）\n  - 编写 API 文档（OpenAPI/Swagger）\n  - 性能测试：使用 wrk/k6 压测 API\n- **开发者A**:\n  - 配置 Prometheus 指标暴露\n  - 配置 Jaeger 链路追踪\n  - 编写运维手册\n\n#### Day 39-40: 部署到 Kubernetes\n- **开发者D**:\n  - 编写 financial-service Kubernetes Deployment\n  - 配置 ConfigMap 和 Secret\n  - 部署到测试环境并验证\n- **全员**:\n  - Sprint 2 Review：演示 Financial Service 功能\n  - Sprint 2 Retrospective\n\n---\n\n## 第3个月（Week 9-12）：财务模块完善 + Controlling Service\n\n### 目标\n- 完善 Financial Service（应收应付、资产管理）\n- 开发 Controlling Service（成本中心、利润中心）\n\n### Week 9（Day 41-45）：Financial Service - FI-AR/AP 模块\n\n#### Day 41-43: 应收账款（AR）开发\n- **开发者B**:\n  - `domain/aggregates/receivable.rs`: 应收账款聚合根\n  - `domain/services/dunning_service.rs`: 催款服务\n  - `application/commands/create_invoice.rs`: 创建客户发票\n  - `application/commands/record_payment.rs`: 记录收款\n  - `application/queries/aging_report.rs`: 账龄分析查询\n\n#### Day 44-45: 应付账款（AP）开发\n- **开发者B**:\n  - `domain/aggregates/payable.rs`: 应付账款聚合根\n  - `application/commands/create_vendor_invoice.rs`: 创建供应商发票\n  - `application/commands/process_payment.rs`: 处理付款\n  - `application/queries/payment_schedule.rs`: 付款计划查询\n\n### Week 10（Day 46-50）：Financial Service - FI-AA 固定资产\n\n#### Day 46-48: 固定资产管理\n- **开发者B**:\n  - `domain/aggregates/asset.rs`: 资产聚合根\n  - `domain/services/depreciation_calculator.rs`: 折旧计算服务\n  - `application/commands/acquire_asset.rs`: 资产购置\n  - `application/commands/calculate_depreciation.rs`: 计算折旧\n  - `application/commands/dispose_asset.rs`: 资产处置\n\n#### Day 49-50: 银行管理（FI-BL）\n- **开发者B**:\n  - `domain/aggregates/bank_account.rs`: 银行账户聚合根\n  - `application/commands/bank_reconciliation.rs`: 银行对账\n  - `application/queries/cash_flow_report.rs`: 现金流量报表\n\n### Week 11（Day 51-55）：Controlling Service - CO 基础\n\n#### Day 51-53: Controlling Service 领域层\n- **开发者B**:\n  - 创建 `controlling-service` 项目结构\n  - `domain/aggregates/cost_center.rs`: 成本中心聚合根\n  - `domain/aggregates/cost_element.rs`: 成本要素聚合根\n  - `domain/aggregates/internal_order.rs`: 内部订单聚合根\n  - `domain/events/cost_center_events.rs`: 成本中心事件\n  - `domain/services/cost_allocation_service.rs`: 成本分配服务\n\n#### Day 54-55: Controlling Service 应用层\n- **开发者B**:\n  - `application/commands/create_cost_center.rs`: 创建成本中心\n  - `application/commands/allocate_costs.rs`: 成本分配\n  - `application/queries/cost_center_report.rs`: 成本中心报表\n  - `application/queries/variance_analysis.rs`: 差异分析\n\n### Week 12（Day 56-60）：Controlling Service 完善\n\n#### Day 56-58: 利润中心会计（EC-PCA）\n- **开发者B**:\n  - `domain/aggregates/profit_center.rs`: 利润中心聚合根\n  - `application/commands/assign_profit_center.rs`: 分配利润中心\n  - `application/queries/profitability_report.rs`: 盈利能力报表\n\n#### Day 59-60: 集成 Financial + Controlling\n- **开发者A + B**:\n  - 配置跨服务事件订阅（Financial 事件 → Controlling 消费）\n  - 集成测试：过账交易自动更新成本中心\n- **全员**: Sprint 3 Review\n\n---\n\n## 第4个月（Week 13-16）：Materials Service 启动\n\n### 目标\n- 完成 Materials Management 核心功能（采购、库存）\n- 实现库存事务处理和 FIFO/LIFO 成本核算\n\n### Week 13（Day 61-65）：Materials Service - 领域层\n\n#### Day 61-63: 物料主数据和采购\n- **开发者C**（领导）:\n  - `domain/aggregates/material.rs`: 物料聚合根\n  - `domain/aggregates/purchase_order.rs`: 采购订单聚合根\n  - `domain/value_objects/sku.rs`: SKU 值对象\n  - `domain/value_objects/quantity.rs`: 数量值对象（含单位）\n  - `domain/events/material_events.rs`: MaterialCreated、PriceUpdated 事件\n  - `domain/events/purchase_events.rs`: PurchaseOrderCreated、GoodsReceived 事件\n\n#### Day 64-65: 供应商管理\n- **开发者C**:\n  - `domain/aggregates/vendor.rs`: 供应商聚合根\n  - `domain/services/vendor_evaluation_service.rs`: 供应商评估服务\n  - `application/commands/create_vendor.rs`: 创建供应商\n  - `application/queries/vendor_performance.rs`: 供应商绩效查询\n\n### Week 14（Day 66-70）：Materials Service - 库存管理\n\n#### Day 66-68: 库存事务处理\n- **开发者C**:\n  - `domain/aggregates/inventory.rs`: 库存聚合根\n  - `domain/services/stock_valuation_service.rs`: 库存估价服务（FIFO/LIFO）\n  - `application/commands/goods_receipt.rs`: 收货命令\n  - `application/commands/goods_issue.rs`: 发货命令\n  - `application/commands/stock_transfer.rs`: 库存转移命令\n  - `application/queries/stock_level.rs`: 库存水平查询\n\n#### Day 69-70: 库存盘点\n- **开发者C**:\n  - `domain/aggregates/physical_inventory.rs`: 盘点单聚合根\n  - `application/commands/create_inventory_document.rs`: 创建盘点单\n  - `application/commands/post_inventory_difference.rs`: 过账盘点差异\n\n### Week 15（Day 71-75）：Materials Service - 基础设施层\n\n#### Day 71-73: PostgreSQL 仓储实现\n- **开发者C**:\n  - `infrastructure/persistence/postgres/material_repo_impl.rs`\n  - `infrastructure/persistence/postgres/purchase_order_repo_impl.rs`\n  - `infrastructure/persistence/postgres/inventory_repo_impl.rs`\n  - 迁移脚本：物料表、采购订单表、库存事务表\n- **开发者D**（协助）:\n  - 配置 Redis 缓存：库存快照、物料主数据缓存\n\n#### Day 74-75: API 实现\n- **开发者C**:\n  - `api/http/handlers/material_handler.rs`\n  - `api/http/handlers/purchase_handler.rs`\n  - `api/http/handlers/inventory_handler.rs`\n  - `proto/materials.proto`: gRPC 接口定义\n\n### Week 16（Day 76-80）：Materials Service - 集成测试\n\n#### Day 76-78: 集成测试\n- **开发者C**:\n  - 端到端测试：创建采购订单 → 收货 → 更新库存\n  - 库存估价测试：FIFO/LIFO 成本计算正确性\n  - 与 Financial Service 集成测试（收货自动生成库存凭证）\n\n#### Day 79-80: 部署和文档\n- **开发者D**: 部署 Materials Service 到 Kubernetes\n- **开发者C**: 编写 API 文档和运维手册\n- **全员**: Sprint 4 Review\n\n---\n\n## 第5个月（Week 17-20）：Sales Service 开发\n\n### 目标\n- 完成 Sales & Distribution 核心功能\n- 实现销售订单、定价、发货、开票流程\n\n### Week 17（Day 81-85）：Sales Service - 领域层\n\n#### Day 81-83: 销售订单管理\n- **开发者C**:\n  - `domain/aggregates/sales_order.rs`: 销售订单聚合根\n  - `domain/aggregates/customer.rs`: 客户聚合根\n  - `domain/value_objects/delivery_address.rs`: 交货地址值对象\n  - `domain/events/sales_events.rs`: SalesOrderCreated、OrderConfirmed 事件\n  - `domain/services/pricing_service.rs`: 定价服务（折扣、促销）\n\n#### Day 84-85: 交付和开票\n- **开发者C**:\n  - `domain/aggregates/delivery.rs`: 交付单聚合根\n  - `domain/aggregates/billing_document.rs`: 开票单聚合根\n  - `application/commands/create_sales_order.rs`\n  - `application/commands/create_delivery.rs`\n  - `application/commands/create_invoice.rs`\n\n### Week 18（Day 86-90）：Sales Service - 定价和信用管理\n\n#### Day 86-88: 定价引擎\n- **开发者C**:\n  - `domain/services/pricing_engine.rs`: 复杂定价逻辑（条件定价）\n  - `domain/aggregates/pricing_condition.rs`: 定价条件聚合根\n  - 支持：基础价格、数量折扣、客户折扣、促销价格\n\n#### Day 89-90: 信用管理\n- **开发者C**:\n  - `domain/services/credit_check_service.rs`: 信用检查服务\n  - `application/commands/check_credit_limit.rs`: 检查信用额度\n  - 与 Financial Service 集成：查询客户欠款\n\n### Week 19（Day 91-95）：Sales Service - 基础设施与API\n\n#### Day 91-93: 基础设施层\n- **开发者C**:\n  - PostgreSQL 仓储实现（销售订单、客户、交付、开票）\n  - Redis 缓存：客户主数据、定价条件\n  - Kafka 事件发布：SalesOrderCreated、InvoiceCreated\n\n#### Day 94-95: API 实现\n- **开发者C**:\n  - REST API: 创建销售订单、查询订单、创建交付、创建发票\n  - gRPC API: 信用检查、定价查询\n  - 集成测试：完整销售流程（订单 → 发货 → 开票）\n\n### Week 20（Day 96-100）：Sales Service - 集成和优化\n\n#### Day 96-98: 跨服务集成\n- **开发者C + B**:\n  - 销售订单创建 → 自动预留库存（调用 Materials Service）\n  - 开票 → 自动生成应收账款（调用 Financial Service）\n  - 事件驱动集成测试\n\n#### Day 99-100: 性能优化\n- **开发者C**:\n  - 定价计算性能优化（缓存定价条件）\n  - 查询优化：添加数据库索引\n- **开发者D**: 部署 Sales Service\n- **全员**: Sprint 5 Review\n\n---\n\n## 第6个月（Week 21-24）：Production Service 开发\n\n### 目标\n- 完成 Production Planning 核心功能\n- 实现 BOM、工艺路线、生产订单、MRP\n\n### Week 21（Day 101-105）：Production Service - 领域层\n\n#### Day 101-103: BOM 和工艺路线\n- **开发者C**:\n  - `domain/aggregates/bom.rs`: 物料清单聚合根（Bill of Materials）\n  - `domain/aggregates/routing.rs`: 工艺路线聚合根\n  - `domain/aggregates/work_center.rs`: 工作中心聚合根\n  - `domain/value_objects/component.rs`: 组件值对象（物料+数量）\n  - `domain/services/explosion_service.rs`: BOM 展开服务\n\n#### Day 104-105: 生产订单\n- **开发者C**:\n  - `domain/aggregates/production_order.rs`: 生产订单聚合根\n  - `domain/events/production_events.rs`: ProductionOrderCreated、GoodsManufactured 事件\n  - `application/commands/create_production_order.rs`\n  - `application/commands/confirm_production.rs`: 生产确认\n\n### Week 22（Day 106-110）：Production Service - MRP 和排程\n\n#### Day 106-108: MRP（物料需求计划）\n- **开发者C**:\n  - `domain/services/mrp_service.rs`: MRP 计算服务\n  - `application/commands/run_mrp.rs`: 运行 MRP\n  - `application/queries/planned_orders.rs`: 查询计划订单\n  - MRP 逻辑：根据销售订单、安全库存计算物料需求\n\n#### Day 109-110: 产能需求计划（CRP）\n- **开发者C**:\n  - `domain/services/capacity_planning_service.rs`: 产能计划服务\n  - `application/queries/capacity_load.rs`: 工作中心负荷查询\n  - 简化版排程算法（FIFO 排程）\n\n### Week 23（Day 111-115）：Production Service - 基础设施与API\n\n#### Day 111-113: 基础设施层\n- **开发者C**:\n  - PostgreSQL 仓储：BOM、工艺路线、生产订单\n  - Redis 缓存：BOM 结构、工作中心主数据\n  - Kafka 事件：ProductionOrderCreated、GoodsManufactured\n\n#### Day 114-115: API 实现\n- **开发者C**:\n  - REST API: 创建 BOM、创建生产订单、运行 MRP、查询产能负荷\n  - gRPC API: BOM 展开、产能检查\n  - 集成测试：MRP 运行 → 生成计划订单 → 转换为生产订单\n\n### Week 24（Day 116-120）：Production Service - 集成\n\n#### Day 116-118: 跨服务集成\n- **开发者C**:\n  - 生产订单创建 → 自动预留物料（调用 Materials Service）\n  - 生产确认 → 自动收货成品、发出原材料（调用 Materials Service）\n  - 生产确认 → 生成生产成本凭证（调用 Financial Service）\n\n#### Day 119-120: 测试和部署\n- **开发者C**: 端到端测试（完整生产流程）\n- **开发者D**: 部署 Production Service\n- **全员**: Sprint 6 Review\n\n---\n\n## 第7个月（Week 25-28）：HR Service 开发\n\n### 目标\n- 完成 Human Resources 核心功能\n- 实现员工管理、组织架构、考勤、薪资核算\n\n### Week 25（Day 121-125）：HR Service - 领域层\n\n#### Day 121-123: 员工和组织管理\n- **开发者E**（领导）:\n  - `domain/aggregates/employee.rs`: 员工聚合根\n  - `domain/aggregates/organization_unit.rs`: 组织单元聚合根\n  - `domain/aggregates/position.rs`: 职位聚合根\n  - `domain/value_objects/employee_id.rs`: 员工编号值对象\n  - `domain/events/employee_events.rs`: EmployeeHired、EmployeeTerminated 事件\n\n#### Day 124-125: 考勤管理\n- **开发者E**:\n  - `domain/aggregates/attendance.rs`: 考勤记录聚合根\n  - `domain/aggregates/leave_request.rs`: 请假单聚合根\n  - `domain/services/attendance_calculation_service.rs`: 考勤计算服务\n  - `application/commands/clock_in.rs`: 打卡\n  - `application/commands/request_leave.rs`: 请假\n\n### Week 26（Day 126-130）：HR Service - 薪资核算\n\n#### Day 126-128: 薪资计算\n- **开发者E**:\n  - `domain/aggregates/payroll.rs`: 工资单聚合根\n  - `domain/services/payroll_calculator.rs`: 薪资计算服务\n  - `application/commands/run_payroll.rs`: 运行薪资核算\n  - 支持：基本工资、加班费、津贴、扣款、社保、个税\n\n#### Day 129-130: 招聘管理\n- **开发者E**:\n  - `domain/aggregates/job_posting.rs`: 职位发布聚合根\n  - `domain/aggregates/applicant.rs`: 应聘者聚合根\n  - `application/commands/create_job_posting.rs`\n  - `application/commands/submit_application.rs`\n\n### Week 27（Day 131-135）：HR Service - 基础设施与API\n\n#### Day 131-133: 基础设施层\n- **开发者E**:\n  - PostgreSQL 仓储：员工、组织、考勤、薪资\n  - Redis 缓存：员工主数据、组织架构\n  - Kafka 事件：EmployeeHired、PayrollProcessed\n\n#### Day 134-135: API 实现\n- **开发者E**:\n  - REST API: 员工管理、考勤打卡、请假申请、薪资查询\n  - gRPC API: 查询员工信息、组织架构查询\n  - 集成测试：完整薪资核算流程\n\n### Week 28（Day 136-140）：HR Service - 集成和部署\n\n#### Day 136-138: 跨服务集成\n- **开发者E + B**:\n  - 薪资核算 → 生成薪资凭证（调用 Financial Service）\n  - 员工入职 → 创建成本中心分配（调用 Controlling Service）\n\n#### Day 139-140: 测试和部署\n- **开发者E**: 端到端测试\n- **开发者D**: 部署 HR Service\n- **全员**: Sprint 7 Review\n\n---\n\n## 第8个月（Week 29-32）：Quality & Maintenance Service 开发\n\n### 目标\n- 完成 Quality Management 和 Plant Maintenance\n- 实现质检流程和设备维护管理\n\n### Week 29（Day 141-145）：Quality Service\n\n#### Day 141-143: 质量管理领域层\n- **开发者E**:\n  - `domain/aggregates/inspection_lot.rs`: 检验批次聚合根\n  - `domain/aggregates/quality_notification.rs`: 质量通知聚合根\n  - `domain/aggregates/inspection_plan.rs`: 检验计划聚合根\n  - `domain/events/quality_events.rs`: InspectionCompleted、DefectReported 事件\n\n#### Day 144-145: 质量检验流程\n- **开发者E**:\n  - `application/commands/create_inspection_lot.rs`: 创建检验批次\n  - `application/commands/record_inspection_result.rs`: 记录检验结果\n  - `application/commands/create_quality_notification.rs`: 创建质量通知\n  - `application/queries/defect_statistics.rs`: 缺陷统计\n\n### Week 30（Day 146-150）：Maintenance Service\n\n#### Day 146-148: 设备维护领域层\n- **开发者E**:\n  - `domain/aggregates/equipment.rs`: 设备聚合根\n  - `domain/aggregates/maintenance_order.rs`: 维护工单聚合根\n  - `domain/aggregates/maintenance_plan.rs`: 维护计划聚合根\n  - `domain/events/maintenance_events.rs`: MaintenanceOrderCreated、MaintenanceCompleted 事件\n\n#### Day 149-150: 维护计划\n- **开发者E**:\n  - `domain/services/maintenance_scheduling_service.rs`: 维护排程服务\n  - `application/commands/create_maintenance_order.rs`\n  - `application/commands/complete_maintenance.rs`\n  - `application/queries/equipment_downtime.rs`: 设备停机时间查询\n\n### Week 31（Day 151-155）：基础设施与API\n\n#### Day 151-153: 基础设施层\n- **开发者E**:\n  - PostgreSQL 仓储：质检批次、质量通知、设备、维护工单\n  - Kafka 事件发布\n\n#### Day 154-155: API 实现\n- **开发者E**:\n  - REST API: 质检管理、维护管理\n  - 集成测试：收货检验流程、预防性维护流程\n\n### Week 32（Day 156-160）：集成和部署\n\n#### Day 156-158: 跨服务集成\n- **开发者E + C**:\n  - 收货 → 自动创建检验批次（Quality Service 订阅 Materials Service 事件）\n  - 维护完成 → 生成维护成本凭证（调用 Financial Service）\n\n#### Day 159-160: 部署\n- **开发者D**: 部署 Quality Service 和 Maintenance Service\n- **全员**: Sprint 8 Review\n\n---\n\n## 第9个月（Week 33-36）：Warehouse & Transport Service\n\n### 目标\n- 完成扩展仓库管理（EWM）和运输管理（TM）\n\n### Week 33-34（Day 161-170）：Warehouse Service\n\n#### Day 161-165: 仓库管理（开发者C领导）\n- `domain/aggregates/warehouse.rs`: 仓库聚合根\n- `domain/aggregates/storage_bin.rs`: 库位聚合根\n- `domain/aggregates/warehouse_task.rs`: 仓库任务聚合根\n- `domain/services/slotting_service.rs`: 库位优化服务\n- `application/commands/create_inbound_delivery.rs`: 创建入库单\n- `application/commands/create_outbound_delivery.rs`: 创建出库单\n- `application/commands/execute_picking.rs`: 执行拣货\n\n#### Day 166-170: 基础设施、API、测试\n- PostgreSQL 仓储、Redis 缓存、API 实现\n- 集成测试：入库上架、出库拣货、盘点流程\n- 与 Materials Service 集成（库存同步）\n\n### Week 35-36（Day 171-180）：Transport Service\n\n#### Day 171-175: 运输管理（开发者C领导）\n- `domain/aggregates/shipment.rs`: 运输单聚合根\n- `domain/aggregates/carrier.rs`: 承运商聚合根\n- `domain/services/route_optimization_service.rs`: 路径优化服务\n- `domain/services/freight_calculator.rs`: 运费计算服务\n- `application/commands/create_shipment.rs`\n- `application/commands/assign_carrier.rs`\n- `application/queries/shipment_tracking.rs`: 运输跟踪\n\n#### Day 176-180: 基础设施、API、集成、部署\n- PostgreSQL 仓储、API 实现\n- 与 Sales Service 集成（发货单 → 创建运输单）\n- 部署 Warehouse Service 和 Transport Service\n- **全员**: Sprint 9 Review\n\n---\n\n## 第10个月（Week 37-40）：CRM & Analytics Service\n\n### 目标\n- 完成客户关系管理和商业智能分析\n\n### Week 37-38（Day 181-190）：CRM Service\n\n#### Day 181-185: CRM 领域层（开发者E领导）\n- `domain/aggregates/customer.rs`: 客户聚合根（扩展）\n- `domain/aggregates/campaign.rs`: 营销活动聚合根\n- `domain/aggregates/service_ticket.rs`: 服务工单聚合根\n- `domain/aggregates/opportunity.rs`: 销售机会聚合根\n- `application/commands/create_campaign.rs`\n- `application/commands/create_service_ticket.rs`\n- `application/queries/customer_360_view.rs`: 客户360度视图\n\n#### Day 186-190: 基础设施、API、集成\n- PostgreSQL 仓储、API 实现\n- 与 Sales Service 集成（客户主数据同步）\n- 部署 CRM Service\n\n### Week 39-40（Day 191-200）：Analytics Service\n\n#### Day 191-195: 数据仓库设计（开发者A + D领导）\n- 设计星型模型（事实表 + 维度表）\n- ETL 流程：从各服务同步数据到分析库\n- `domain/aggregates/report.rs`: 报表聚合根\n- `application/queries/financial_dashboard.rs`: 财务仪表盘\n- `application/queries/sales_dashboard.rs`: 销售仪表盘\n- `application/queries/inventory_dashboard.rs`: 库存仪表盘\n\n#### Day 196-200: BI 工具集成\n- 配置 Metabase / Superset\n- 创建预定义报表和仪表盘\n- 集成测试：实时数据更新到分析库\n- 部署 Analytics Service\n- **全员**: Sprint 10 Review\n\n---\n\n## 第11个月（Week 41-44）：系统集成测试与性能优化\n\n### 目标\n- 完整端到端业务流程测试\n- 性能优化和压力测试\n- 安全加固\n\n### Week 41（Day 201-205）：端到端集成测试\n\n#### Day 201-205: 完整业务流程测试（全员）\n- **采购到付款流程（P2P）**:\n  - 创建采购申请 → 生成采购订单 → 收货 → 发票校验 → 付款 → 财务凭证\n  - 测试数据一致性、事件传播、分布式事务\n- **订单到现金流程（O2C）**:\n  - 创建销售订单 → 信用检查 → 库存预留 → 发货 → 开票 → 收款 → 财务凭证\n  - 测试定价、库存扣减、应收账款\n- **生产计划流程**:\n  - MRP 运行 → 生产订单 → 领料 → 生产确认 → 成品入库 → 成本核算\n  - 测试 BOM 展开、库存消耗、成本结转\n\n### Week 42（Day 206-210）：性能优化\n\n#### Day 206-208: 数据库优化（开发者A + D）\n- 慢查询分析（pg_stat_statements）\n- 添加缺失索引\n- 分区表优化（按日期分区历史数据）\n- 数据库连接池调优（PgBouncer）\n\n#### Day 209-210: 缓存优化（开发者D）\n- 识别热点数据，添加 Redis 缓存\n- 缓存预热策略\n- 缓存一致性保证（Write-Through vs. Cache-Aside）\n\n### Week 43（Day 211-215）：压力测试\n\n#### Day 211-213: 性能基准测试（开发者D + 全员）\n- 使用 k6/wrk 进行压测\n  - 目标：1000 TPS（Transactions Per Second）\n  - P99 延迟 < 200ms\n- 识别性能瓶颈（CPU、内存、I/O、网络）\n- Kubernetes HPA 调优（自动扩缩容）\n\n#### Day 214-215: 分布式追踪分析（开发者D）\n- Jaeger 追踪分析：识别慢服务调用\n- 优化服务间调用（减少同步调用，改为异步）\n- 数据库批量操作优化\n\n### Week 44（Day 216-220）：安全加固\n\n#### Day 216-218: 安全审计（开发者A + E）\n- 依赖漏洞扫描（cargo-audit）\n- 容器镜像扫描（Trivy）\n- API 安全测试（SQL 注入、XSS、CSRF）\n- 实施 OWASP Top 10 检查\n\n#### Day 219-220: 访问控制加固（开发者E）\n- 配置 RBAC（基于角色的访问控制）\n- 实施字段级权限控制\n- API 限流策略调优\n- **全员**: Sprint 11 Review\n\n---\n\n## 第12个月（Week 45-48）：生产准备与上线\n\n### 目标\n- 生产环境部署\n- 监控告警配置\n- 文档完善\n- 用户培训\n\n### Week 45（Day 221-225）：生产环境准备\n\n#### Day 221-223: 生产环境部署（开发者D领导）\n- 配置生产 Kubernetes 集群（多可用区）\n- 部署所有微服务（使用 Helm）\n- 配置 Istio Service Mesh（mTLS、流量管理）\n- 数据库主从复制配置\n- Redis 集群部署（主从 + 哨兵）\n- Kafka 集群部署（3副本）\n\n#### Day 224-225: 备份和灾难恢复（开发者D）\n- 配置自动备份（PostgreSQL WAL 归档）\n- 编写灾难恢复手册\n- 演练数据恢复流程（RTO < 5分钟，RPO < 1分钟）\n\n### Week 46（Day 226-230）：监控告警配置\n\n#### Day 226-228: 监控仪表盘（开发者D + A）\n- 配置 Grafana Dashboard\n  - 系统监控：CPU、内存、磁盘、网络\n  - 业务监控：交易量、错误率、响应时间\n  - 数据库监控：连接数、慢查询、死锁\n- 配置 Prometheus 告警规则\n  - CPU > 80% 持续 5分钟\n  - 错误率 > 1% 持续 3分钟\n  - P99 延迟 > 500ms\n\n#### Day 229-230: 日志聚合（开发者D）\n- 配置 Loki + Vector 日志收集\n- 配置日志告警（ERROR 级别日志）\n- 创建日志查询模板\n\n### Week 47（Day 231-235）：文档和培训\n\n#### Day 231-233: 文档编写（全员）\n- **开发者A**: 系统架构文档、技术选型说明\n- **开发者B**: 财务模块用户手册、API 文档\n- **开发者C**: 供应链模块用户手册、业务流程文档\n- **开发者D**: 运维手册、部署指南、故障排查手册\n- **开发者E**: HR/质量模块用户手册、管理员指南\n\n#### Day 234-235: 用户培训（全员）\n- 编写培训材料（PPT、视频教程）\n- 组织内部培训（分模块）\n- 收集用户反馈\n\n### Week 48（Day 236-240）：最终验收和上线\n\n#### Day 236-238: 最终验收测试（全员）\n- UAT（User Acceptance Testing）用户验收测试\n- 业务流程完整性测试\n- 数据迁移测试（从旧系统迁移）\n- 回归测试（确保所有功能正常）\n\n#### Day 239: 上线准备\n- 生产环境最终检查\n- 数据库初始化（基础数据导入）\n- 配置监控告警\n- 准备回滚方案\n\n#### Day 240: 正式上线\n- 蓝绿部署策略（先 10% 流量，逐步增加到 100%）\n- 实时监控系统指标\n- 待命支持（24小时值班）\n- **项目总结会议**\n\n---\n\n## 四、关键里程碑和交付物\n\n| 月份 | 阶段 | 关键交付物 | 成功标准 |\n|-----|------|----------|---------|\n| 月1-2 | 基础设施 | 共享库、CI/CD、Kubernetes 集群、API Gateway | 所有服务可部署、事件发布/订阅正常 |\n| 月3-5 | 财务模块 | Financial Service、Controlling Service | 完整会计流程、成本核算功能 |\n| 月6-8 | 供应链模块 | Materials、Sales、Production Service | 采购、销售、生产流程端到端可用 |\n| 月9-10 | 人力与质量 | HR、Quality、Maintenance Service | 薪资核算、质检、维护流程可用 |\n| 月11 | 集成优化 | 端到端测试通过、性能达标 | TPS > 1000、P99 < 200ms |\n| 月12 | 生产上线 | 生产环境部署、监控告警、用户培训 | 系统稳定运行、用户可操作 |\n\n---\n\n## 五、风险管理\n\n### 5.1 技术风险\n\n| 风险 | 影响 | 应对措施 |\n|-----|------|---------|\n| Rust 生态不成熟 | 高 | 提前调研关键库（SQLx、Axum、Tonic），准备 Plan B |\n| 分布式事务复杂度 | 高 | 使用 Saga 模式，详细设计补偿流程 |\n| 性能不达标 | 中 | 提前进行性能测试，预留优化时间 |\n| Kafka 消息丢失 | 高 | 配置 acks=all、幂等生产者、消费者偏移量管理 |\n\n### 5.2 业务风险\n\n| 风险 | 影响 | 应对措施 |\n|-----|------|---------|\n| 业务需求理解偏差 | 高 | 定期与业务团队评审，快速迭代 |\n| KILLER 功能覆盖不全 | 中 | 聚焦核心流程，边缘功能后续迭代 |\n| 数据迁移失败 | 高 | 提前准备数据迁移脚本，多次演练 |\n\n### 5.3 团队风险\n\n| 风险 | 影响 | 应对措施 |\n|-----|------|---------|\n| 人员离职 | 高 | 代码充分文档化、知识共享会议 |\n| 技能不足 | 中 | 内部培训、技术分享、结对编程 |\n| 沟通不畅 | 中 | 每日站会、定期回顾、代码评审 |\n\n---\n\n## 六、质量保证策略\n\n### 6.1 测试策略\n\n```\n测试金字塔：\n             /\\\n            /E2E\\          10% - 端到端测试\n           /------\\\n          /集成测试\\        30% - 集成测试（跨服务）\n         /----------\\\n        /  单元测试  \\      60% - 单元测试（领域层100%覆盖）\n       /--------------\\\n```\n\n### 6.2 代码质量\n\n- **代码评审**: 所有 PR 必须经过至少 1 人评审\n- **静态分析**: Clippy（无警告）、rustfmt（统一格式）\n- **安全审计**: 每周运行 cargo-audit\n- **文档覆盖**: 所有公开 API 必须有文档注释\n\n### 6.3 持续集成\n\n```yaml\nCI 流程（每次提交）：\n1. 编译检查（cargo build）\n2. 代码格式检查（cargo fmt --check）\n3. Lint 检查（cargo clippy）\n4. 单元测试（cargo test）\n5. 集成测试（cargo test --test integration）\n6. 安全审计（cargo audit）\n7. 代码覆盖率检查（cargo tarpaulin）\n8. Docker 镜像构建\n```\n\n---\n\n## 七、成功指标（KPI）\n\n### 7.1 开发指标\n\n- **代码覆盖率**: 核心业务逻辑 > 80%\n- **代码审查通过率**: > 95%\n- **CI 构建成功率**: > 90%\n- **平均 PR 合并时间**: < 2天\n\n### 7.2 性能指标\n\n- **API 响应时间**: P99 < 200ms\n- **吞吐量**: > 1000 TPS\n- **系统可用性**: > 99.9% (SLA)\n- **错误率**: < 0.1%\n\n### 7.3 业务指标\n\n- **功能覆盖率**: 覆盖 KILLER 核心模块 80% 功能\n- **用户满意度**: > 85%\n- **数据准确性**: 财务数据 100% 准确\n\n---\n\n## 八、工具和技术栈总结\n\n### 8.1 开发工具\n\n| 类别 | 工具 | 用途 |\n|-----|------|-----|\n| 编程语言 | Rust 2021 Edition | 核心开发语言 |\n| IDE | VS Code + rust-analyzer | 开发环境 |\n| 版本控制 | Git + GitHub | 代码管理 |\n| 包管理 | Cargo | 依赖管理 |\n\n### 8.2 运行时组件\n\n| 组件 | 技术 | 版本 |\n|-----|------|-----|\n| Web 框架 | Axum | 0.7 |\n| 异步运行时 | Tokio | 1.35 |\n| 数据库 | PostgreSQL | 16 |\n| 缓存 | Redis | 7 |\n| 消息队列 | Kafka | 3.6 |\n| RPC 框架 | Tonic (gRPC) | 0.11 |\n\n### 8.3 基础设施\n\n| 组件 | 技术 | 用途 |\n|-----|------|-----|\n| 容器化 | Docker | 应用打包 |\n| 编排 | Kubernetes | 容器编排 |\n| 服务网格 | Istio | mTLS、流量管理 |\n| 监控 | Prometheus + Grafana | 指标收集和可视化 |\n| 日志 | Loki + Vector | 日志聚合 |\n| 追踪 | Jaeger | 分布式追踪 |\n\n---\n\n## 九、附录：每日任务示例\n\n### 示例：第 1 天任务详细拆解\n\n#### 开发者A（架构师）\n```\n上午（9:00-12:00）:\n- 09:00-10:00: 创建 GitHub 仓库，初始化 Cargo Workspace\n- 10:00-11:00: 编写 README.md、CONTRIBUTING.md\n- 11:00-12:00: 配置 GitHub Actions CI 模板（cargo fmt、clippy、test）\n\n下午（13:30-18:00）:\n- 13:30-15:00: 设计项目目录结构，创建所有服务的骨架项目\n- 15:00-16:30: 编写开发规范文档（命名规范、错误处理、测试要求）\n- 16:30-18:00: 代码评审流程文档，配置 GitHub Branch Protection\n```\n\n#### 开发者B（财务模块负责人）\n```\n上午（9:00-12:00）:\n- 09:00-10:30: 安装 Docker，配置 PostgreSQL 容器\n- 10:30-12:00: 编写 docker-compose.yml（PostgreSQL + pgAdmin）\n\n下午（13:30-18:00）:\n- 13:30-15:00: 测试数据库连接，安装 SQLx CLI\n- 15:00-16:30: 创建第一个迁移脚本（测试表）\n- 16:30-18:00: 配置数据库连接池（sqlx::PgPool），编写连接测试代码\n```\n\n#### 开发者C（供应链模块负责人）\n```\n上午（9:00-12:00）:\n- 09:00-10:30: 安装 Docker，配置 Redis 容器\n- 10:30-12:00: 编写 Redis 连接测试代码（redis-rs crate）\n\n下午（13:30-18:00）:\n- 13:30-15:00: 测试 Redis 基本操作（SET/GET/DEL）\n- 15:00-16:30: 研究 Redis 连接池配置（ConnectionManager）\n- 16:30-18:00: 编写 Redis 缓存 trait 定义\n```\n\n#### 开发者D（基础设施负责人）\n```\n上午（9:00-12:00）:\n- 09:00-10:30: 安装 Docker，配置 Kafka 集群（Zookeeper + Broker）\n- 10:30-12:00: 测试 Kafka 生产者/消费者（rdkafka crate）\n\n下午（13:30-18:00）:\n- 13:30-15:00: 创建 Kafka 主题命名规范文档\n- 15:00-16:30: 安装 k3d/minikube，配置本地 Kubernetes\n- 16:30-18:00: 部署 Kafka 到 Kubernetes，测试连接\n```\n\n#### 开发者E（全栈开发者）\n```\n上午（9:00-12:00）:\n- 09:00-10:00: 配置 Rust 开发环境（rustup、VS Code + rust-analyzer）\n- 10:00-11:00: 安装 Protobuf 编译器，测试 tonic-build\n- 11:00-12:00: 创建第一个 gRPC 服务示例（Hello World）\n\n下午（13:30-18:00）:\n- 13:30-15:00: 测试 gRPC 客户端/服务端通信\n- 15:00-16:30: 研究 Axum 框架，创建第一个 HTTP 服务\n- 16:30-18:00: 集成 gRPC 和 HTTP（同一端口暴露两种协议）\n```\n\n---\n\n## 十、总结\n\n### 10.1 项目亮点\n\n1. **现代化技术栈**: Rust + DDD + CQRS + Event Sourcing，充分利用 Rust 的性能和安全优势\n2. **微服务架构**: 每个服务独立部署、独立数据库，支持水平扩展\n3. **事件驱动**: 通过 Kafka 实现服务解耦和最终一致性\n4. **完整可观测性**: Prometheus、Grafana、Jaeger、Loki 四件套\n5. **高可用设计**: Kubernetes 多副本、HPA 自动扩缩容、数据库主从复制\n\n### 10.2 交付成果\n\n- **15 个微服务**: Financial、Controlling、Materials、Sales、Production、HR、Quality、Maintenance、Warehouse、Transport、CRM、Analytics、API Gateway\n- **3 个共享库**: domain-primitives、event-sourcing、cqrs、observability\n- **完整文档**: 架构设计、API 文档、用户手册、运维手册\n- **CI/CD 流程**: GitHub Actions 自动化构建、测试、部署\n- **生产环境**: Kubernetes 集群、监控告警、备份恢复\n\n### 10.3 后续迭代计划\n\n- **第 13-15 个月**: 移动端应用开发（React Native）\n- **第 16-18 个月**: 高级分析功能（机器学习预测、智能推荐）\n- **第 19-21 个月**: 国际化支持（多语言、多币种、多时区）\n- **第 22-24 个月**: 行业特化（制造业、零售业、服务业定制化功能）\n\n---\n\n## 十一、阶段日常任务与验收建议\n每个阶段分别设定“每日任务清单”+“每日验收测试”，便于站会同步与 Sprint 回顾时填入记录。\n\n### 阶段1（Month 1-2 基础设施与共享库）\n- **每日任务清单**：检查环境/仓库、推进共享库 PR、审查 CI 变更、执行 Kafka/Redis/K8s 健康检查、更新开发规范文档。\n- **验收/测试**：CI 全绿（`cargo fmt`/`clippy`/`test`）、共享库单元覆盖率 ≥90%、基础设施 smoke 验证（PostgreSQL/Kafka/Redis/K8s）、文档演示完成。\n\n### 阶段2（Month 3-5 财务 & Controlling）\n- **每日任务清单**：推进领域模型/命令/查询、同步 Kafka 事件契约、落地数据库迁移、更新 API/Proto 文档、记录风险点。\n- **验收/测试**：契约测试（`create_journal_entry`、`post_transaction`）、双账一致性对账脚本、API/gRPC contract test、支付批/现金池压测、ClickHouse 财务 view 对账。\n\n### 阶段3（Month 6-8 供应链模块）\n- **每日任务清单**：排查采购/销售/生产/库存链路、更新事件/CDC 依赖、执行 ATP/MRP/RF 场景、同步库存/成本指标、跨服务 Saga 追踪。\n- **验收/测试**：P2P/O2C/MRP 全链路自动化、ATP CPI/响应监控、MRP 批运行（<2h）、三单匹配回归、ClickHouse 采购/库存 KPI 对账。\n\n### 阶段4（Month 9-10 HCM/质量/运维）\n- **每日任务清单**：同步人力/薪资/招聘流程、验证质量/维护工单、审查合规/RBAC 策略、确认事件/报表订阅。\n- **验收/测试**：薪资批次/考勤链路自动化、质量通知与 CAPA 回归、PM 工单生命周期测试、权限穿透测试、灰度/切换演练记录。\n\n### 阶段5（Month 11-12 集成/性能/上线）\n- **每日任务清单**：回放端到端流程、监控性能/容量、整理事故/告警、文档/培训更新、核对 Go-Live 检查清单。\n- **验收/测试**：所有核心流程回归（P2P/O2C/生产/薪资/CRM）、k6 压测（1000 TPS、P99 < 200ms）、安全审计（`cargo-audit`、Trivy、OWASP）、UAT 记录、蓝绿/金丝雀部署验证。\n\n每日完成后记录测试结果与异常告警状态，未过则触发复盘与任务重排。\n\n## 十二、协作与治理机制\n保持五人团队高效推进需要明确的协作节奏与异常处理机制。\n\n- **Sprint cadence**: 固定两周 Sprint，周一计划、周五 Review & Retro，每阶段末安排 Stage Review。\n- **看板与指标**: 使用 Scrum board（Backlog / Ready / In Progress / Review / QA / Done），每日站会汇报 blockers 与依赖。\n- **质量门**: 进入下阶段前必须：所有测试（单元/集成/端到端）通过、事件契约文档更新、ClickHouse KPI/报表刷新、Runbook/部署文档评审。\n- **异常处理**: 若 blocker 持续 >1 天，立即召开风险缓解/复盘会议（架构师 + 模块负责人 + QA）。\n- **依赖映射**: 阶段1结束后维护依赖矩阵（服务→依赖→负责人），每周更新并贴在看板上。\n\n## 十三、文档与传承\n确保知识传递与交接顺畅，所有模块需维护统一文档与分享节奏。\n\n- **模板**: 每个服务需提供 `docs/{service}/README.md` 与 `runbook.md`，涵盖架构、API/event contract、部署/恢复、容量和异常策略。\n- **知识库**: 使用 GitHub Wiki/Gitbook 汇总“FAQ”、“培训素材”、“版本说明”；每个 Sprint 末由某成员更新至少一项。\n- **培训与分享**: 每月一次技术分享（30 分钟），每季度一次业务流程/验收 walkthrough，并归档 PPT/视频。\n- **接手指南**: 若成员需交接，提前两周提交：当前 Sprint 状态、未解风险与缓解、下一步计划、关键契约/事件、CI/CD/Runbook 链接。\n\n---\n\n**文档版本**: v1.0\n**最后更新**: 2025-12-21\n**维护者**: Rust ERP 开发团队\n**联系方式**: team@rust-erp.example.com\n\n---\n\n**注**: 本计划为指导性文档，实际开发中可能根据进度和反馈进行调整。关键原则是保持敏捷、快速迭代、持续交付。\n", "md/Rust-Api.md": "# Rust ERP 系统 API 设计文档\n\n## 1. API 设计原则\n\n### 1.1 设计规范\n\n- **RESTful 风格**：资源导向，使用标准 HTTP 方法\n- **版本控制**：URL 路径包含版本号 `/api/v1/...`\n- **统一响应格式**：成功和错误响应保持一致的结构\n- **幂等性**：PUT/DELETE 操作保证幂等，POST 使用幂等键\n- **分页**：列表接口统一使用 `page`、`page_size`、`total` 参数\n- **过滤排序**：支持 `filter`、`sort`、`order` 查询参数\n- **国际化**：支持多语言错误消息（Accept-Language header）\n\n### 1.2 HTTP 状态码规范\n\n| 状态码 | 含义 | 使用场景 |\n|-------|------|---------|\n| 200 OK | 成功 | GET、PUT、PATCH 成功 |\n| 201 Created | 已创建 | POST 创建资源成功 |\n| 202 Accepted | 已接受 | 异步任务已提交 |\n| 204 No Content | 无内容 | DELETE 成功 |\n| 400 Bad Request | 请求错误 | 参数验证失败 |\n| 401 Unauthorized | 未认证 | JWT token 无效或过期 |\n| 403 Forbidden | 禁止访问 | 权限不足 |\n| 404 Not Found | 未找到 | 资源不存在 |\n| 409 Conflict | 冲突 | 资源已存在或状态冲突 |\n| 422 Unprocessable Entity | 无法处理 | 业务规则验证失败 |\n| 429 Too Many Requests | 请求过多 | 触发限流 |\n| 500 Internal Server Error | 服务器错误 | 系统内部错误 |\n| 503 Service Unavailable | 服务不可用 | 服务降级或维护中 |\n\n### 1.3 统一响应格式\n\n```json\n// 成功响应\n{\n  \"success\": true,\n  \"data\": {\n    // 实际数据\n  },\n  \"metadata\": {\n    \"timestamp\": \"2025-12-21T10:00:00Z\",\n    \"request_id\": \"req-123456\"\n  }\n}\n\n// 错误响应\n{\n  \"success\": false,\n  \"error\": {\n    \"code\": \"ACCOUNT_NOT_FOUND\",\n    \"message\": \"Account 1000 not found\",\n    \"details\": [\n      {\n        \"field\": \"account_number\",\n        \"issue\": \"Account does not exist in the system\"\n      }\n    ]\n  },\n  \"metadata\": {\n    \"timestamp\": \"2025-12-21T10:00:00Z\",\n    \"request_id\": \"req-123456\"\n  }\n}\n\n// 分页响应\n{\n  \"success\": true,\n  \"data\": {\n    \"items\": [...],\n    \"pagination\": {\n      \"page\": 1,\n      \"page_size\": 20,\n      \"total_items\": 150,\n      \"total_pages\": 8\n    }\n  },\n  \"metadata\": {\n    \"timestamp\": \"2025-12-21T10:00:00Z\",\n    \"request_id\": \"req-123456\"\n  }\n}\n```\n\n---\n\n## 2. 财务服务 API (Financial Service)\n\n**Base URL**: `https://api.erp.example.com/financial/v1`\n\n### 2.1 会计科目管理 (Accounts)\n\n#### 2.1.1 创建会计科目\n\n**接口**: `POST /accounts`\n\n**描述**: 创建新的会计科目（总账科目）\n\n**请求头**:\n```http\nAuthorization: Bearer <JWT_TOKEN>\nContent-Type: application/json\nIdempotency-Key: uuid-12345  # 幂等键，防止重复创建\n```\n\n**请求体**:\n```json\n{\n  \"account_number\": \"1001\",\n  \"account_name\": \"现金\",\n  \"account_type\": \"ASSET\",  // ASSET, LIABILITY, EQUITY, REVENUE, EXPENSE\n  \"currency\": \"CNY\",\n  \"parent_account\": null,  // 上级科目（可选）\n  \"is_leaf\": true,  // 是否末级科目\n  \"balance_type\": \"DEBIT\",  // DEBIT（借方）, CREDIT（贷方）\n  \"cost_center_required\": false,  // 是否强制成本中心\n  \"profit_center_required\": false,\n  \"description\": \"库存现金账户\"\n}\n```\n\n**响应** (201 Created):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"account_id\": \"acc-550e8400-e29b-41d4-a716-446655440000\",\n    \"account_number\": \"1001\",\n    \"account_name\": \"现金\",\n    \"account_type\": \"ASSET\",\n    \"currency\": \"CNY\",\n    \"current_balance\": 0.00,\n    \"is_active\": true,\n    \"created_at\": \"2025-12-21T10:00:00Z\",\n    \"created_by\": \"user-123\"\n  },\n  \"metadata\": {\n    \"timestamp\": \"2025-12-21T10:00:00Z\",\n    \"request_id\": \"req-123456\"\n  }\n}\n```\n\n**错误响应** (409 Conflict):\n```json\n{\n  \"success\": false,\n  \"error\": {\n    \"code\": \"ACCOUNT_ALREADY_EXISTS\",\n    \"message\": \"Account 1001 already exists\",\n    \"details\": []\n  }\n}\n```\n\n---\n\n#### 2.1.2 获取科目详情\n\n**接口**: `GET /accounts/{account_number}`\n\n**描述**: 根据科目编号查询科目详细信息\n\n**请求参数**:\n- `account_number` (路径参数): 科目编号\n\n**响应** (200 OK):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"account_id\": \"acc-550e8400-e29b-41d4-a716-446655440000\",\n    \"account_number\": \"1001\",\n    \"account_name\": \"现金\",\n    \"account_type\": \"ASSET\",\n    \"currency\": \"CNY\",\n    \"current_balance\": 150000.00,\n    \"debit_total\": 200000.00,\n    \"credit_total\": 50000.00,\n    \"is_active\": true,\n    \"parent_account\": null,\n    \"children_accounts\": [\"1001.01\", \"1001.02\"],\n    \"created_at\": \"2025-12-21T10:00:00Z\",\n    \"updated_at\": \"2025-12-21T15:30:00Z\"\n  }\n}\n```\n\n---\n\n#### 2.1.3 查询科目列表\n\n**接口**: `GET /accounts`\n\n**描述**: 分页查询科目列表，支持过滤和排序\n\n**查询参数**:\n- `page` (int, 默认 1): 页码\n- `page_size` (int, 默认 20, 最大 100): 每页数量\n- `account_type` (string, 可选): 科目类型过滤\n- `currency` (string, 可选): 币种过滤\n- `is_active` (boolean, 可选): 是否激活\n- `search` (string, 可选): 科目编号或名称模糊搜索\n- `sort` (string, 默认 \"account_number\"): 排序字段\n- `order` (string, 默认 \"asc\"): 排序方向 (asc/desc)\n\n**示例**: `GET /accounts?account_type=ASSET&currency=CNY&page=1&page_size=20`\n\n**响应** (200 OK):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"items\": [\n      {\n        \"account_id\": \"acc-123\",\n        \"account_number\": \"1001\",\n        \"account_name\": \"现金\",\n        \"account_type\": \"ASSET\",\n        \"currency\": \"CNY\",\n        \"current_balance\": 150000.00,\n        \"is_active\": true\n      },\n      {\n        \"account_id\": \"acc-124\",\n        \"account_number\": \"1002\",\n        \"account_name\": \"银行存款\",\n        \"account_type\": \"ASSET\",\n        \"currency\": \"CNY\",\n        \"current_balance\": 5000000.00,\n        \"is_active\": true\n      }\n    ],\n    \"pagination\": {\n      \"page\": 1,\n      \"page_size\": 20,\n      \"total_items\": 150,\n      \"total_pages\": 8\n    }\n  }\n}\n```\n\n---\n\n#### 2.1.4 更新科目信息\n\n**接口**: `PATCH /accounts/{account_number}`\n\n**描述**: 部分更新科目信息（不允许修改科目编号和类型）\n\n**请求体**:\n```json\n{\n  \"account_name\": \"库存现金\",\n  \"description\": \"更新后的描述\",\n  \"is_active\": true\n}\n```\n\n**响应** (200 OK):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"account_id\": \"acc-123\",\n    \"account_number\": \"1001\",\n    \"account_name\": \"库存现金\",\n    \"updated_at\": \"2025-12-21T16:00:00Z\"\n  }\n}\n```\n\n---\n\n#### 2.1.5 停用科目\n\n**接口**: `DELETE /accounts/{account_number}`\n\n**描述**: 停用科目（软删除，不允许物理删除）\n\n**响应** (200 OK):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"account_number\": \"1001\",\n    \"is_active\": false,\n    \"deactivated_at\": \"2025-12-21T16:00:00Z\"\n  }\n}\n```\n\n**错误响应** (422 Unprocessable Entity):\n```json\n{\n  \"success\": false,\n  \"error\": {\n    \"code\": \"ACCOUNT_HAS_BALANCE\",\n    \"message\": \"Cannot deactivate account with non-zero balance\",\n    \"details\": [\n      {\n        \"field\": \"current_balance\",\n        \"value\": 150000.00,\n        \"issue\": \"Account balance must be zero before deactivation\"\n      }\n    ]\n  }\n}\n```\n\n---\n\n### 2.2 财务交易管理 (Transactions)\n\n#### 2.2.1 创建财务凭证\n\n**接口**: `POST /transactions`\n\n**描述**: 创建财务凭证（记账凭证），包含多个分录\n\n**请求体**:\n```json\n{\n  \"document_date\": \"2025-12-21\",\n  \"posting_date\": \"2025-12-21\",\n  \"document_type\": \"JE\",  // JE=日记账分录, IV=发票, PY=付款\n  \"reference_number\": \"JV-2025-001\",\n  \"description\": \"采购办公用品\",\n  \"fiscal_year\": 2025,\n  \"fiscal_period\": 12,\n  \"currency\": \"CNY\",\n  \"exchange_rate\": 1.0,\n  \"entries\": [\n    {\n      \"line_number\": 1,\n      \"account_number\": \"6601\",  // 办公费用\n      \"debit_amount\": 5000.00,\n      \"credit_amount\": 0.00,\n      \"cost_center\": \"CC-001\",\n      \"profit_center\": null,\n      \"description\": \"购买打印纸\"\n    },\n    {\n      \"line_number\": 2,\n      \"account_number\": \"1002\",  // 银行存款\n      \"debit_amount\": 0.00,\n      \"credit_amount\": 5000.00,\n      \"cost_center\": null,\n      \"profit_center\": null,\n      \"description\": \"银行转账支付\"\n    }\n  ]\n}\n```\n\n**业务规则校验**:\n- 借贷必须平衡：`SUM(debit_amount) = SUM(credit_amount)`\n- 至少包含 2 个分录\n- 科目必须存在且激活\n- 会计期间必须未关闭\n- 如果科目要求成本中心/利润中心，分录必须提供\n\n**响应** (201 Created):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"transaction_id\": \"tx-550e8400-e29b-41d4-a716-446655440000\",\n    \"document_number\": \"FI-2025-000123\",  // 系统自动生成\n    \"document_date\": \"2025-12-21\",\n    \"posting_date\": \"2025-12-21\",\n    \"status\": \"POSTED\",  // DRAFT（草稿）, POSTED（已过账）, REVERSED（已冲销）\n    \"total_amount\": 5000.00,\n    \"currency\": \"CNY\",\n    \"entries_count\": 2,\n    \"created_at\": \"2025-12-21T10:00:00Z\",\n    \"created_by\": \"user-123\",\n    \"posted_at\": \"2025-12-21T10:00:00Z\",\n    \"posted_by\": \"user-123\"\n  }\n}\n```\n\n**错误响应** (422 Unprocessable Entity):\n```json\n{\n  \"success\": false,\n  \"error\": {\n    \"code\": \"UNBALANCED_TRANSACTION\",\n    \"message\": \"Transaction is not balanced\",\n    \"details\": [\n      {\n        \"field\": \"entries\",\n        \"issue\": \"Debit total (5000.00) does not equal credit total (4500.00)\"\n      }\n    ]\n  }\n}\n```\n\n---\n\n#### 2.2.2 查询交易详情\n\n**接口**: `GET /transactions/{transaction_id}`\n\n**描述**: 获取财务凭证的完整信息，包括所有分录\n\n**响应** (200 OK):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"transaction_id\": \"tx-550e8400-e29b-41d4-a716-446655440000\",\n    \"document_number\": \"FI-2025-000123\",\n    \"document_date\": \"2025-12-21\",\n    \"posting_date\": \"2025-12-21\",\n    \"document_type\": \"JE\",\n    \"status\": \"POSTED\",\n    \"total_amount\": 5000.00,\n    \"currency\": \"CNY\",\n    \"description\": \"采购办公用品\",\n    \"entries\": [\n      {\n        \"entry_id\": \"entry-001\",\n        \"line_number\": 1,\n        \"account_number\": \"6601\",\n        \"account_name\": \"办公费用\",\n        \"debit_amount\": 5000.00,\n        \"credit_amount\": 0.00,\n        \"cost_center\": \"CC-001\",\n        \"cost_center_name\": \"行政部\",\n        \"description\": \"购买打印纸\"\n      },\n      {\n        \"entry_id\": \"entry-002\",\n        \"line_number\": 2,\n        \"account_number\": \"1002\",\n        \"account_name\": \"银行存款\",\n        \"debit_amount\": 0.00,\n        \"credit_amount\": 5000.00,\n        \"description\": \"银行转账支付\"\n      }\n    ],\n    \"created_at\": \"2025-12-21T10:00:00Z\",\n    \"created_by\": \"user-123\",\n    \"created_by_name\": \"张三\",\n    \"posted_at\": \"2025-12-21T10:00:00Z\"\n  }\n}\n```\n\n---\n\n#### 2.2.3 查询交易列表\n\n**接口**: `GET /transactions`\n\n**查询参数**:\n- `page`, `page_size`: 分页参数\n- `account_number` (可选): 按科目过滤\n- `document_type` (可选): 凭证类型\n- `status` (可选): 状态过滤\n- `posting_date_from` (可选): 过账日期起始\n- `posting_date_to` (可选): 过账日期结束\n- `fiscal_year` (可选): 会计年度\n- `fiscal_period` (可选): 会计期间\n- `cost_center` (可选): 成本中心\n- `created_by` (可选): 创建人\n\n**示例**: `GET /transactions?account_number=1001&posting_date_from=2025-01-01&posting_date_to=2025-12-31&page=1`\n\n**响应** (200 OK):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"items\": [\n      {\n        \"transaction_id\": \"tx-123\",\n        \"document_number\": \"FI-2025-000123\",\n        \"posting_date\": \"2025-12-21\",\n        \"document_type\": \"JE\",\n        \"status\": \"POSTED\",\n        \"total_amount\": 5000.00,\n        \"currency\": \"CNY\",\n        \"description\": \"采购办公用品\",\n        \"created_by_name\": \"张三\",\n        \"created_at\": \"2025-12-21T10:00:00Z\"\n      }\n    ],\n    \"pagination\": {\n      \"page\": 1,\n      \"page_size\": 20,\n      \"total_items\": 500,\n      \"total_pages\": 25\n    }\n  }\n}\n```\n\n---\n\n#### 2.2.4 冲销交易\n\n**接口**: `POST /transactions/{transaction_id}/reverse`\n\n**描述**: 生成反向凭证冲销原交易\n\n**请求体**:\n```json\n{\n  \"reversal_date\": \"2025-12-22\",\n  \"reason\": \"原凭证录入错误，需要冲销重做\"\n}\n```\n\n**响应** (201 Created):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"original_transaction_id\": \"tx-123\",\n    \"reversal_transaction_id\": \"tx-456\",\n    \"reversal_document_number\": \"FI-2025-000456\",\n    \"original_status\": \"REVERSED\",\n    \"reversal_status\": \"POSTED\",\n    \"reversed_at\": \"2025-12-22T10:00:00Z\"\n  }\n}\n```\n\n---\n\n### 2.3 账户余额查询 (Balances)\n\n#### 2.3.1 查询科目余额\n\n**接口**: `GET /accounts/{account_number}/balance`\n\n**查询参数**:\n- `as_of_date` (可选): 截止日期，默认当前日期\n- `currency` (可选): 币种，默认科目主币种\n- `cost_center` (可选): 成本中心维度\n- `profit_center` (可选): 利润中心维度\n\n**示例**: `GET /accounts/1001/balance?as_of_date=2025-12-21`\n\n**响应** (200 OK):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"account_number\": \"1001\",\n    \"account_name\": \"现金\",\n    \"currency\": \"CNY\",\n    \"as_of_date\": \"2025-12-21\",\n    \"opening_balance\": 100000.00,  // 期初余额\n    \"debit_total\": 200000.00,      // 借方发生额\n    \"credit_total\": 50000.00,      // 贷方发生额\n    \"closing_balance\": 250000.00,  // 期末余额\n    \"balance_type\": \"DEBIT\",       // 余额方向\n    \"last_updated\": \"2025-12-21T15:30:00Z\"\n  }\n}\n```\n\n---\n\n#### 2.3.2 批量查询余额\n\n**接口**: `POST /balances/batch`\n\n**描述**: 批量查询多个科目的余额\n\n**请求体**:\n```json\n{\n  \"account_numbers\": [\"1001\", \"1002\", \"2001\", \"2002\"],\n  \"as_of_date\": \"2025-12-21\",\n  \"currency\": \"CNY\"\n}\n```\n\n**响应** (200 OK):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"as_of_date\": \"2025-12-21\",\n    \"currency\": \"CNY\",\n    \"balances\": [\n      {\n        \"account_number\": \"1001\",\n        \"account_name\": \"现金\",\n        \"closing_balance\": 250000.00,\n        \"balance_type\": \"DEBIT\"\n      },\n      {\n        \"account_number\": \"1002\",\n        \"account_name\": \"银行存款\",\n        \"closing_balance\": 5000000.00,\n        \"balance_type\": \"DEBIT\"\n      }\n    ]\n  }\n}\n```\n\n---\n\n### 2.4 财务报表 (Reports)\n\n#### 2.4.1 生成资产负债表\n\n**接口**: `POST /reports/balance-sheet`\n\n**描述**: 生成资产负债表（异步任务）\n\n**请求体**:\n```json\n{\n  \"as_of_date\": \"2025-12-31\",\n  \"currency\": \"CNY\",\n  \"consolidation_level\": \"COMPANY\",  // COMPANY, DIVISION, COST_CENTER\n  \"format\": \"PDF\",  // PDF, EXCEL, JSON\n  \"language\": \"zh-CN\"\n}\n```\n\n**响应** (202 Accepted):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"task_id\": \"report-task-123\",\n    \"status\": \"PROCESSING\",\n    \"created_at\": \"2025-12-21T10:00:00Z\",\n    \"estimated_completion\": \"2025-12-21T10:05:00Z\",\n    \"status_url\": \"/tasks/report-task-123\"\n  }\n}\n```\n\n**查询任务状态**: `GET /tasks/{task_id}`\n\n**响应** (200 OK):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"task_id\": \"report-task-123\",\n    \"status\": \"COMPLETED\",  // PROCESSING, COMPLETED, FAILED\n    \"progress\": 100,\n    \"result\": {\n      \"report_url\": \"https://storage.example.com/reports/balance-sheet-2025-12-31.pdf\",\n      \"expires_at\": \"2025-12-28T10:00:00Z\"\n    },\n    \"created_at\": \"2025-12-21T10:00:00Z\",\n    \"completed_at\": \"2025-12-21T10:03:00Z\"\n  }\n}\n```\n\n---\n\n#### 2.4.2 生成利润表\n\n**接口**: `POST /reports/income-statement`\n\n**请求体**:\n```json\n{\n  \"period_from\": \"2025-01-01\",\n  \"period_to\": \"2025-12-31\",\n  \"currency\": \"CNY\",\n  \"comparison_period\": \"PREVIOUS_YEAR\",  // NONE, PREVIOUS_YEAR, BUDGET\n  \"format\": \"EXCEL\"\n}\n```\n\n**响应**: 同资产负债表（异步任务）\n\n---\n\n#### 2.4.3 生成现金流量表\n\n**接口**: `POST /reports/cash-flow-statement`\n\n**请求体**:\n```json\n{\n  \"period_from\": \"2025-01-01\",\n  \"period_to\": \"2025-12-31\",\n  \"method\": \"INDIRECT\",  // DIRECT（直接法）, INDIRECT（间接法）\n  \"currency\": \"CNY\",\n  \"format\": \"PDF\"\n}\n```\n\n**响应**: 异步任务响应\n\n---\n\n### 2.5 会计期间管理 (Fiscal Periods)\n\n#### 2.5.1 查询会计期间状态\n\n**接口**: `GET /fiscal-periods/{year}/{period}`\n\n**示例**: `GET /fiscal-periods/2025/12`\n\n**响应** (200 OK):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"fiscal_year\": 2025,\n    \"fiscal_period\": 12,\n    \"period_name\": \"2025年12月\",\n    \"start_date\": \"2025-12-01\",\n    \"end_date\": \"2025-12-31\",\n    \"status\": \"OPEN\",  // OPEN（开放）, CLOSED（关闭）, LOCKED（锁定）\n    \"is_current\": true,\n    \"closed_at\": null,\n    \"closed_by\": null\n  }\n}\n```\n\n---\n\n#### 2.5.2 关闭会计期间\n\n**接口**: `POST /fiscal-periods/{year}/{period}/close`\n\n**描述**: 关闭会计期间（不可逆操作）\n\n**请求体**:\n```json\n{\n  \"closing_notes\": \"12月期间关账，所有凭证已审核\"\n}\n```\n\n**响应** (200 OK):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"fiscal_year\": 2025,\n    \"fiscal_period\": 12,\n    \"status\": \"CLOSED\",\n    \"closed_at\": \"2025-12-21T18:00:00Z\",\n    \"closed_by\": \"user-123\",\n    \"closing_notes\": \"12月期间关账，所有凭证已审核\"\n  }\n}\n```\n\n---\n\n## 3. 销售服务 API (Sales Service)\n\n**Base URL**: `https://api.erp.example.com/sales/v1`\n\n### 3.1 销售订单管理 (Sales Orders)\n\n#### 3.1.1 创建销售订单\n\n**接口**: `POST /orders`\n\n**请求体**:\n```json\n{\n  \"customer_id\": \"cust-12345\",\n  \"order_date\": \"2025-12-21\",\n  \"requested_delivery_date\": \"2025-12-28\",\n  \"sales_organization\": \"SO-001\",\n  \"distribution_channel\": \"DC-01\",\n  \"division\": \"DIV-01\",\n  \"payment_terms\": \"NET30\",  // 付款条款：30天内付款\n  \"incoterms\": \"FOB\",         // 国际贸易术语\n  \"currency\": \"CNY\",\n  \"items\": [\n    {\n      \"line_number\": 10,\n      \"material_number\": \"MAT-001\",\n      \"quantity\": 100,\n      \"unit\": \"PC\",  // 件\n      \"unit_price\": 500.00,\n      \"discount_percent\": 5.0,\n      \"tax_code\": \"VAT13\",  // 增值税13%\n      \"delivery_date\": \"2025-12-28\",\n      \"plant\": \"PLANT-01\",  // 工厂\n      \"storage_location\": \"SL-01\"\n    },\n    {\n      \"line_number\": 20,\n      \"material_number\": \"MAT-002\",\n      \"quantity\": 50,\n      \"unit\": \"PC\",\n      \"unit_price\": 1000.00,\n      \"discount_percent\": 0,\n      \"tax_code\": \"VAT13\",\n      \"delivery_date\": \"2025-12-28\",\n      \"plant\": \"PLANT-01\",\n      \"storage_location\": \"SL-01\"\n    }\n  ],\n  \"shipping_address\": {\n    \"street\": \"张江高科技园区\",\n    \"city\": \"上海\",\n    \"postal_code\": \"201203\",\n    \"country\": \"CN\"\n  }\n}\n```\n\n**响应** (201 Created):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"order_id\": \"so-550e8400-e29b-41d4-a716-446655440000\",\n    \"order_number\": \"SO-2025-001234\",\n    \"customer_id\": \"cust-12345\",\n    \"customer_name\": \"上海某某科技有限公司\",\n    \"order_date\": \"2025-12-21\",\n    \"status\": \"CREATED\",  // CREATED, CONFIRMED, PARTIALLY_DELIVERED, DELIVERED, CANCELLED\n    \"total_net_value\": 97500.00,  // (100*500*0.95 + 50*1000)\n    \"total_tax\": 12675.00,        // 13% VAT\n    \"total_gross_value\": 110175.00,\n    \"currency\": \"CNY\",\n    \"items_count\": 2,\n    \"created_at\": \"2025-12-21T10:00:00Z\",\n    \"created_by\": \"user-123\"\n  }\n}\n```\n\n---\n\n#### 3.1.2 查询订单详情\n\n**接口**: `GET /orders/{order_number}`\n\n**响应** (200 OK):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"order_id\": \"so-123\",\n    \"order_number\": \"SO-2025-001234\",\n    \"customer\": {\n      \"customer_id\": \"cust-12345\",\n      \"customer_number\": \"C-10001\",\n      \"customer_name\": \"上海某某科技有限公司\",\n      \"credit_limit\": 1000000.00,\n      \"credit_exposure\": 500000.00\n    },\n    \"order_date\": \"2025-12-21\",\n    \"status\": \"CONFIRMED\",\n    \"total_net_value\": 97500.00,\n    \"total_tax\": 12675.00,\n    \"total_gross_value\": 110175.00,\n    \"currency\": \"CNY\",\n    \"payment_terms\": \"NET30\",\n    \"items\": [\n      {\n        \"line_number\": 10,\n        \"material_number\": \"MAT-001\",\n        \"material_description\": \"产品A\",\n        \"quantity\": 100,\n        \"unit\": \"PC\",\n        \"unit_price\": 500.00,\n        \"discount_percent\": 5.0,\n        \"net_value\": 47500.00,\n        \"tax_amount\": 6175.00,\n        \"gross_value\": 53675.00,\n        \"delivery_status\": \"NOT_DELIVERED\",\n        \"delivered_quantity\": 0,\n        \"open_quantity\": 100\n      },\n      {\n        \"line_number\": 20,\n        \"material_number\": \"MAT-002\",\n        \"material_description\": \"产品B\",\n        \"quantity\": 50,\n        \"unit\": \"PC\",\n        \"unit_price\": 1000.00,\n        \"discount_percent\": 0,\n        \"net_value\": 50000.00,\n        \"tax_amount\": 6500.00,\n        \"gross_value\": 56500.00,\n        \"delivery_status\": \"NOT_DELIVERED\",\n        \"delivered_quantity\": 0,\n        \"open_quantity\": 50\n      }\n    ],\n    \"delivery_schedule\": [\n      {\n        \"item_number\": 10,\n        \"schedule_line\": 1,\n        \"quantity\": 100,\n        \"requested_date\": \"2025-12-28\",\n        \"confirmed_date\": \"2025-12-28\"\n      }\n    ],\n    \"created_at\": \"2025-12-21T10:00:00Z\",\n    \"confirmed_at\": \"2025-12-21T11:00:00Z\"\n  }\n}\n```\n\n---\n\n#### 3.1.3 查询订单列表\n\n**接口**: `GET /orders`\n\n**查询参数**:\n- `customer_id`: 客户ID过滤\n- `status`: 订单状态\n- `order_date_from`, `order_date_to`: 日期范围\n- `search`: 订单号或客户名称搜索\n- `page`, `page_size`: 分页\n\n**响应**: 分页列表格式\n\n---\n\n#### 3.1.4 确认订单\n\n**接口**: `POST /orders/{order_number}/confirm`\n\n**描述**: 确认订单（检查库存、信用额度）\n\n**响应** (200 OK):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"order_number\": \"SO-2025-001234\",\n    \"status\": \"CONFIRMED\",\n    \"confirmed_at\": \"2025-12-21T11:00:00Z\",\n    \"confirmed_by\": \"user-123\",\n    \"availability_check\": {\n      \"passed\": true,\n      \"items\": [\n        {\n          \"line_number\": 10,\n          \"available_quantity\": 150,\n          \"requested_quantity\": 100,\n          \"status\": \"AVAILABLE\"\n        }\n      ]\n    },\n    \"credit_check\": {\n      \"passed\": true,\n      \"credit_limit\": 1000000.00,\n      \"current_exposure\": 500000.00,\n      \"order_value\": 110175.00,\n      \"new_exposure\": 610175.00\n    }\n  }\n}\n```\n\n---\n\n#### 3.1.5 取消订单\n\n**接口**: `POST /orders/{order_number}/cancel`\n\n**请求体**:\n```json\n{\n  \"cancellation_reason\": \"客户取消订单\",\n  \"notify_customer\": true\n}\n```\n\n**响应** (200 OK):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"order_number\": \"SO-2025-001234\",\n    \"status\": \"CANCELLED\",\n    \"cancelled_at\": \"2025-12-21T14:00:00Z\",\n    \"cancellation_reason\": \"客户取消订单\"\n  }\n}\n```\n\n---\n\n### 3.2 发货管理 (Deliveries)\n\n#### 3.2.1 创建发货单\n\n**接口**: `POST /deliveries`\n\n**请求体**:\n```json\n{\n  \"order_number\": \"SO-2025-001234\",\n  \"delivery_date\": \"2025-12-28\",\n  \"items\": [\n    {\n      \"order_item_number\": 10,\n      \"quantity\": 100,\n      \"picking_location\": \"SL-01\"\n    }\n  ],\n  \"carrier\": \"顺丰速运\",\n  \"tracking_number\": \"SF123456789\"\n}\n```\n\n**响应** (201 Created):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"delivery_id\": \"del-123\",\n    \"delivery_number\": \"DN-2025-005678\",\n    \"order_number\": \"SO-2025-001234\",\n    \"delivery_date\": \"2025-12-28\",\n    \"status\": \"CREATED\",  // CREATED, PICKED, PACKED, SHIPPED, DELIVERED\n    \"items_count\": 1,\n    \"total_quantity\": 100,\n    \"created_at\": \"2025-12-28T08:00:00Z\"\n  }\n}\n```\n\n---\n\n#### 3.2.2 过账发货（库存扣减）\n\n**接口**: `POST /deliveries/{delivery_number}/post-goods-issue`\n\n**描述**: 执行库存扣减，财务过账\n\n**响应** (200 OK):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"delivery_number\": \"DN-2025-005678\",\n    \"status\": \"SHIPPED\",\n    \"goods_issue_posted\": true,\n    \"goods_issue_date\": \"2025-12-28\",\n    \"material_document\": \"MD-2025-789\",  // 物料凭证号\n    \"accounting_document\": \"FI-2025-456\", // 财务凭证号\n    \"posted_at\": \"2025-12-28T10:00:00Z\"\n  }\n}\n```\n\n---\n\n### 3.3 开票管理 (Billing)\n\n#### 3.3.1 创建发票\n\n**接口**: `POST /invoices`\n\n**请求体**:\n```json\n{\n  \"order_number\": \"SO-2025-001234\",\n  \"delivery_number\": \"DN-2025-005678\",\n  \"invoice_date\": \"2025-12-28\",\n  \"billing_type\": \"STANDARD\",  // STANDARD, CREDIT_MEMO, DEBIT_MEMO\n  \"payment_terms\": \"NET30\",\n  \"items\": [\n    {\n      \"order_item_number\": 10,\n      \"quantity\": 100,\n      \"unit_price\": 500.00\n    }\n  ]\n}\n```\n\n**响应** (201 Created):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"invoice_id\": \"inv-123\",\n    \"invoice_number\": \"INV-2025-009876\",\n    \"order_number\": \"SO-2025-001234\",\n    \"customer_id\": \"cust-12345\",\n    \"invoice_date\": \"2025-12-28\",\n    \"due_date\": \"2026-01-27\",  // NET30\n    \"total_net_value\": 47500.00,\n    \"total_tax\": 6175.00,\n    \"total_gross_value\": 53675.00,\n    \"currency\": \"CNY\",\n    \"status\": \"POSTED\",\n    \"accounting_document\": \"FI-2025-457\",\n    \"pdf_url\": \"https://storage.example.com/invoices/INV-2025-009876.pdf\",\n    \"created_at\": \"2025-12-28T11:00:00Z\"\n  }\n}\n```\n\n---\n\n## 4. 物料服务 API (Materials Service)\n\n**Base URL**: `https://api.erp.example.com/materials/v1`\n\n### 4.1 物料主数据 (Materials)\n\n#### 4.1.1 创建物料\n\n**接口**: `POST /materials`\n\n**请求体**:\n```json\n{\n  \"material_number\": \"MAT-001\",  // 可选，系统自动生成\n  \"material_type\": \"FERT\",  // ROH=原料, HALB=半成品, FERT=成品\n  \"industry_sector\": \"M\",   // M=机械, C=化工, P=制药\n  \"basic_data\": {\n    \"description\": \"产品A\",\n    \"base_unit_of_measure\": \"PC\",  // 基本单位\n    \"material_group\": \"MG-001\",\n    \"division\": \"DIV-01\",\n    \"gross_weight\": 2.5,\n    \"net_weight\": 2.0,\n    \"weight_unit\": \"KG\",\n    \"volume\": 0.01,\n    \"volume_unit\": \"M3\"\n  },\n  \"sales_data\": {\n    \"sales_organization\": \"SO-001\",\n    \"distribution_channel\": \"DC-01\",\n    \"item_category_group\": \"NORM\",\n    \"delivering_plant\": \"PLANT-01\",\n    \"tax_classification\": \"VAT13\"\n  },\n  \"purchasing_data\": {\n    \"purchasing_group\": \"PG-01\",\n    \"material_group\": \"MG-001\",\n    \"order_unit\": \"PC\"\n  },\n  \"mrp_data\": {\n    \"mrp_type\": \"PD\",  // PD=MRP, VB=消耗性\n    \"lot_size\": \"EX\",  // EX=精确订单量\n    \"procurement_type\": \"E\",  // E=自制, F=外购\n    \"planning_time_fence\": 30,\n    \"safety_stock\": 100,\n    \"reorder_point\": 200,\n    \"maximum_stock_level\": 1000\n  },\n  \"accounting_data\": {\n    \"valuation_class\": \"3000\",\n    \"price_control\": \"S\",  // S=标准价格, V=移动平均价\n    \"standard_price\": 450.00,\n    \"currency\": \"CNY\"\n  }\n}\n```\n\n**响应** (201 Created):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"material_id\": \"mat-550e8400-e29b-41d4-a716-446655440000\",\n    \"material_number\": \"MAT-001\",\n    \"description\": \"产品A\",\n    \"material_type\": \"FERT\",\n    \"base_unit\": \"PC\",\n    \"created_at\": \"2025-12-21T10:00:00Z\",\n    \"created_by\": \"user-123\"\n  }\n}\n```\n\n---\n\n#### 4.1.2 查询物料详情\n\n**接口**: `GET /materials/{material_number}`\n\n**响应**: 包含完整的物料主数据\n\n---\n\n### 4.2 库存管理 (Inventory)\n\n#### 4.2.1 查询库存\n\n**接口**: `GET /inventory`\n\n**查询参数**:\n- `material_number`: 物料编号\n- `plant`: 工厂\n- `storage_location`: 库位\n- `batch`: 批次号（可选）\n- `special_stock`: 特殊库存类型（可选）\n\n**示例**: `GET /inventory?material_number=MAT-001&plant=PLANT-01`\n\n**响应** (200 OK):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"material_number\": \"MAT-001\",\n    \"material_description\": \"产品A\",\n    \"plant\": \"PLANT-01\",\n    \"storage_locations\": [\n      {\n        \"storage_location\": \"SL-01\",\n        \"unrestricted_stock\": 500,  // 非限制使用库存\n        \"quality_inspection_stock\": 50,  // 质检库存\n        \"blocked_stock\": 10,  // 冻结库存\n        \"total_stock\": 560,\n        \"unit\": \"PC\",\n        \"value\": 252000.00,  // 库存价值（560 * 450）\n        \"currency\": \"CNY\",\n        \"last_updated\": \"2025-12-21T10:00:00Z\"\n      }\n    ],\n    \"total_plant_stock\": 560\n  }\n}\n```\n\n---\n\n#### 4.2.2 创建收货单\n\n**接口**: `POST /goods-receipts`\n\n**描述**: 采购订单收货\n\n**请求体**:\n```json\n{\n  \"purchase_order\": \"PO-2025-001\",\n  \"receipt_date\": \"2025-12-21\",\n  \"movement_type\": \"101\",  // 101=采购订单收货\n  \"items\": [\n    {\n      \"po_item_number\": 10,\n      \"material_number\": \"MAT-001\",\n      \"quantity\": 200,\n      \"unit\": \"PC\",\n      \"plant\": \"PLANT-01\",\n      \"storage_location\": \"SL-01\",\n      \"batch\": \"BATCH-20251221\",  // 可选\n      \"stock_type\": \"UNRESTRICTED\"  // UNRESTRICTED, QUALITY, BLOCKED\n    }\n  ],\n  \"vendor_number\": \"V-10001\",\n  \"delivery_note\": \"DN-VENDOR-123\"\n}\n```\n\n**响应** (201 Created):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"material_document\": \"MD-2025-001234\",\n    \"document_date\": \"2025-12-21\",\n    \"posting_date\": \"2025-12-21\",\n    \"movement_type\": \"101\",\n    \"items_count\": 1,\n    \"accounting_document\": \"FI-2025-789\",  // 自动生成财务凭证\n    \"posted_at\": \"2025-12-21T10:00:00Z\"\n  }\n}\n```\n\n---\n\n#### 4.2.3 创建发货单（出库）\n\n**接口**: `POST /goods-issues`\n\n**请求体**:\n```json\n{\n  \"issue_date\": \"2025-12-21\",\n  \"movement_type\": \"601\",  // 601=销售订单发货\n  \"items\": [\n    {\n      \"material_number\": \"MAT-001\",\n      \"quantity\": 100,\n      \"unit\": \"PC\",\n      \"plant\": \"PLANT-01\",\n      \"storage_location\": \"SL-01\",\n      \"sales_order\": \"SO-2025-001234\",\n      \"sales_order_item\": 10\n    }\n  ]\n}\n```\n\n**响应** (201 Created):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"material_document\": \"MD-2025-005678\",\n    \"movement_type\": \"601\",\n    \"posted_at\": \"2025-12-21T10:00:00Z\"\n  }\n}\n```\n\n---\n\n### 4.3 采购订单 (Purchase Orders)\n\n#### 4.3.1 创建采购订单\n\n**接口**: `POST /purchase-orders`\n\n**请求体**:\n```json\n{\n  \"vendor_id\": \"V-10001\",\n  \"purchasing_organization\": \"PO-01\",\n  \"purchasing_group\": \"PG-01\",\n  \"document_date\": \"2025-12-21\",\n  \"payment_terms\": \"NET30\",\n  \"incoterms\": \"FOB\",\n  \"currency\": \"CNY\",\n  \"items\": [\n    {\n      \"item_number\": 10,\n      \"material_number\": \"MAT-RAW-001\",\n      \"short_text\": \"原材料A\",\n      \"quantity\": 1000,\n      \"unit\": \"KG\",\n      \"net_price\": 50.00,\n      \"plant\": \"PLANT-01\",\n      \"storage_location\": \"SL-01\",\n      \"delivery_date\": \"2025-12-28\",\n      \"tax_code\": \"VAT13\",\n      \"account_assignment_category\": \"K\",  // K=成本中心\n      \"cost_center\": \"CC-001\"\n    }\n  ]\n}\n```\n\n**响应** (201 Created):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"po_id\": \"po-123\",\n    \"po_number\": \"PO-2025-004567\",\n    \"vendor_id\": \"V-10001\",\n    \"vendor_name\": \"供应商A\",\n    \"document_date\": \"2025-12-21\",\n    \"total_value\": 50000.00,\n    \"currency\": \"CNY\",\n    \"status\": \"CREATED\",\n    \"items_count\": 1,\n    \"created_at\": \"2025-12-21T10:00:00Z\"\n  }\n}\n```\n\n---\n\n## 5. gRPC 接口定义\n\n### 5.1 财务服务 gRPC\n\n```protobuf\nsyntax = \"proto3\";\n\npackage erp.financial.v1;\n\n// 财务服务\nservice FinancialService {\n  // 查询账户余额（同步调用）\n  rpc GetAccountBalance(GetAccountBalanceRequest)\n      returns (GetAccountBalanceResponse);\n\n  // 批量查询余额\n  rpc GetAccountBalances(GetAccountBalancesRequest)\n      returns (GetAccountBalancesResponse);\n\n  // 验证交易合法性\n  rpc ValidateTransaction(ValidateTransactionRequest)\n      returns (ValidateTransactionResponse);\n\n  // 创建财务凭证\n  rpc PostTransaction(PostTransactionRequest)\n      returns (PostTransactionResponse);\n\n  // 查询会计期间状态\n  rpc GetFiscalPeriodStatus(GetFiscalPeriodStatusRequest)\n      returns (GetFiscalPeriodStatusResponse);\n}\n\n// 查询余额请求\nmessage GetAccountBalanceRequest {\n  string account_number = 1;\n  string currency = 2;\n  string as_of_date = 3;  // ISO 8601: \"2025-12-21\"\n  optional string cost_center = 4;\n  optional string profit_center = 5;\n}\n\n// 余额响应\nmessage GetAccountBalanceResponse {\n  string account_number = 1;\n  string account_name = 2;\n  string currency = 3;\n  double opening_balance = 4;\n  double debit_total = 5;\n  double credit_total = 6;\n  double closing_balance = 7;\n  string balance_type = 8;  // \"DEBIT\" or \"CREDIT\"\n  int64 last_updated_timestamp = 9;\n}\n\n// 批量查询请求\nmessage GetAccountBalancesRequest {\n  repeated string account_numbers = 1;\n  string currency = 2;\n  string as_of_date = 3;\n}\n\nmessage GetAccountBalancesResponse {\n  repeated GetAccountBalanceResponse balances = 1;\n}\n\n// 验证交易请求\nmessage ValidateTransactionRequest {\n  TransactionData transaction = 1;\n}\n\nmessage TransactionData {\n  string posting_date = 1;\n  int32 fiscal_year = 2;\n  int32 fiscal_period = 3;\n  string currency = 4;\n  repeated JournalEntry entries = 5;\n}\n\nmessage JournalEntry {\n  int32 line_number = 1;\n  string account_number = 2;\n  double debit_amount = 3;\n  double credit_amount = 4;\n  optional string cost_center = 5;\n}\n\n// 验证响应\nmessage ValidateTransactionResponse {\n  bool is_valid = 1;\n  repeated ValidationError errors = 2;\n}\n\nmessage ValidationError {\n  string error_code = 1;\n  string error_message = 2;\n  optional string field = 3;\n}\n```\n\n---\n\n## 6. WebSocket 实时通知 API\n\n### 6.1 连接 WebSocket\n\n**URL**: `wss://api.erp.example.com/ws/v1/notifications`\n\n**认证**: 通过查询参数传递 JWT token\n```\nwss://api.erp.example.com/ws/v1/notifications?token=<JWT_TOKEN>\n```\n\n### 6.2 订阅主题\n\n**客户端发送**:\n```json\n{\n  \"action\": \"subscribe\",\n  \"topics\": [\n    \"financial.transactions.posted\",\n    \"sales.orders.confirmed\",\n    \"inventory.low_stock_alert\"\n  ]\n}\n```\n\n**服务端确认**:\n```json\n{\n  \"type\": \"subscription_confirmed\",\n  \"topics\": [\n    \"financial.transactions.posted\",\n    \"sales.orders.confirmed\",\n    \"inventory.low_stock_alert\"\n  ],\n  \"timestamp\": \"2025-12-21T10:00:00Z\"\n}\n```\n\n### 6.3 接收事件通知\n\n**服务端推送**:\n```json\n{\n  \"type\": \"event\",\n  \"topic\": \"sales.orders.confirmed\",\n  \"data\": {\n    \"order_number\": \"SO-2025-001234\",\n    \"customer_name\": \"上海某某科技有限公司\",\n    \"total_value\": 110175.00,\n    \"currency\": \"CNY\",\n    \"confirmed_at\": \"2025-12-21T11:00:00Z\"\n  },\n  \"timestamp\": \"2025-12-21T11:00:01Z\",\n  \"event_id\": \"evt-123456\"\n}\n```\n\n---\n\n## 7. 错误码表\n\n### 7.1 通用错误码\n\n| 错误码 | HTTP状态 | 说明 |\n|-------|---------|------|\n| INVALID_REQUEST | 400 | 请求参数格式错误 |\n| UNAUTHORIZED | 401 | JWT token 无效或过期 |\n| FORBIDDEN | 403 | 权限不足 |\n| NOT_FOUND | 404 | 资源不存在 |\n| ALREADY_EXISTS | 409 | 资源已存在（重复创建） |\n| VALIDATION_FAILED | 422 | 业务规则验证失败 |\n| RATE_LIMIT_EXCEEDED | 429 | 超过速率限制 |\n| INTERNAL_ERROR | 500 | 系统内部错误 |\n| SERVICE_UNAVAILABLE | 503 | 服务不可用 |\n\n### 7.2 财务服务错误码\n\n| 错误码 | 说明 |\n|-------|------|\n| ACCOUNT_NOT_FOUND | 会计科目不存在 |\n| ACCOUNT_ALREADY_EXISTS | 科目编号已存在 |\n| ACCOUNT_HAS_BALANCE | 科目有余额，不能删除 |\n| UNBALANCED_TRANSACTION | 交易借贷不平衡 |\n| PERIOD_CLOSED | 会计期间已关闭 |\n| INVALID_POSTING_DATE | 过账日期无效 |\n| COST_CENTER_REQUIRED | 该科目需要成本中心 |\n| INSUFFICIENT_BALANCE | 余额不足 |\n\n### 7.3 销售服务错误码\n\n| 错误码 | 说明 |\n|-------|------|\n| CUSTOMER_NOT_FOUND | 客户不存在 |\n| CREDIT_LIMIT_EXCEEDED | 超过信用额度 |\n| MATERIAL_NOT_AVAILABLE | 物料不可用 |\n| ORDER_ALREADY_DELIVERED | 订单已发货，不能修改 |\n| INVALID_QUANTITY | 数量无效 |\n\n---\n\n## 8. API 版本演进策略\n\n### 8.1 版本控制\n\n- **URL 版本**：`/api/v1/`, `/api/v2/`\n- **向后兼容原则**：\n  - 新增字段不算破坏性变更\n  - 删除字段或修改字段类型需要新版本\n  - 新版本至少保留 12 个月兼容期\n\n### 8.2 废弃通知\n\n**响应头**:\n```http\nDeprecation: true\nSunset: Sat, 21 Dec 2026 10:00:00 GMT\nLink: </api/v2/accounts>; rel=\"alternate\"\n```\n\n**响应体包含警告**:\n```json\n{\n  \"success\": true,\n  \"data\": {...},\n  \"warnings\": [\n    {\n      \"code\": \"DEPRECATED_API\",\n      \"message\": \"This endpoint will be removed on 2026-12-21. Please migrate to /api/v2/accounts\"\n    }\n  ]\n}\n```\n\n---\n\n## 9. 性能与限流\n\n### 9.1 速率限制\n\n```http\n# 响应头\nX-RateLimit-Limit: 1000         # 每小时限制\nX-RateLimit-Remaining: 950      # 剩余次数\nX-RateLimit-Reset: 1703145600   # 重置时间（Unix timestamp）\n```\n\n**限制策略**:\n- 默认：1000 次/小时/用户\n- 批量接口：100 次/小时\n- 报表生成：10 次/小时\n\n### 9.2 性能目标\n\n| 接口类型 | P95 延迟 | P99 延迟 |\n|---------|---------|---------|\n| 查询单条记录 | < 50ms | < 100ms |\n| 查询列表（20条） | < 100ms | < 200ms |\n| 创建/更新操作 | < 200ms | < 500ms |\n| 复杂计算（余额） | < 500ms | < 1s |\n| 报表生成（异步） | < 5min | < 10min |\n\n---\n\n## 10. 安全最佳实践\n\n### 10.1 API 密钥管理\n\n- 使用 JWT Bearer Token\n- Token 有效期：1 小时（访问令牌）\n- Refresh Token 有效期：7 天\n\n### 10.2 敏感数据脱敏\n\n**响应示例**:\n```json\n{\n  \"bank_account\": \"6217 **** **** 1234\",  // 银行卡号脱敏\n  \"id_card\": \"310***********0012\",        // 身份证号脱敏\n  \"phone\": \"138****5678\"                  // 手机号脱敏\n}\n```\n\n### 10.3 审计日志\n\n所有写操作自动记录：\n- 操作人（user_id）\n- 操作时间（timestamp）\n- 操作类型（CREATE/UPDATE/DELETE）\n- 请求ID（request_id）\n- IP 地址\n- 变更前后数据（diff）\n\n---\n\n## 11. 人力资本服务 API (HCM)\n\n**Base URL**: `https://api.erp.example.com/hcm/v1`\n\n### 11.1 员工档案 (PA/OM)\n\n#### 11.1.1 创建员工\n\n**接口**: `POST /employees`\n\n**请求体**:\n```json\n{\n  \"employee_number\": \"E000123\",  // 可选，系统可自动生成\n  \"first_name\": \"三\",\n  \"last_name\": \"张\",\n  \"display_name\": \"张三\",\n  \"hire_date\": \"2025-12-21\",\n  \"employment_type\": \"FULL_TIME\",  // FULL_TIME, PART_TIME, CONTRACTOR, INTERN\n  \"job_code\": \"DEV-SENIOR\",\n  \"position_id\": \"POS-001\",\n  \"org_unit\": \"IT-DEV\",\n  \"manager_id\": \"E000001\",\n  \"location\": \"Beijing-HQ\",\n  \"email\": \"zhang.san@example.com\",\n  \"phone\": \"+86-13800000000\",\n  \"cost_center\": \"CC-IT-01\",\n  \"payroll_area\": \"CN-M\",\n  \"work_schedule_rule\": \"WS-STD-40H\"\n}\n```\n\n**响应** (201 Created):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"employee_id\": \"emp-550e8400-e29b-41d4-a716-446655440000\",\n    \"employee_number\": \"E000123\",\n    \"display_name\": \"张三\",\n    \"status\": \"ACTIVE\",\n    \"hire_date\": \"2025-12-21\",\n    \"job_code\": \"DEV-SENIOR\",\n    \"org_unit\": \"IT-DEV\",\n    \"manager_id\": \"E000001\",\n    \"created_at\": \"2025-12-21T10:00:00Z\"\n  }\n}\n```\n\n---\n\n#### 11.1.2 查询员工详情\n\n**接口**: `GET /employees/{employee_id}`\n\n**响应** (200 OK):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"employee_id\": \"emp-550e8400-e29b-41d4-a716-446655440000\",\n    \"employee_number\": \"E000123\",\n    \"display_name\": \"张三\",\n    \"employment_type\": \"FULL_TIME\",\n    \"job_code\": \"DEV-SENIOR\",\n    \"position_id\": \"POS-001\",\n    \"org_unit\": \"IT-DEV\",\n    \"manager_id\": \"E000001\",\n    \"hire_date\": \"2025-12-21\",\n    \"status\": \"ACTIVE\",\n    \"cost_center\": \"CC-IT-01\",\n    \"payroll_area\": \"CN-M\",\n    \"location\": \"Beijing-HQ\",\n    \"contact\": {\n      \"email\": \"zhang.san@example.com\",\n      \"phone\": \"+86-13800000000\"\n    },\n    \"created_at\": \"2025-12-21T10:00:00Z\",\n    \"updated_at\": \"2025-12-21T15:00:00Z\"\n  }\n}\n```\n\n---\n\n### 11.2 工时与考勤 (Time Management)\n\n#### 11.2.1 录入工时\n\n**接口**: `POST /time-entries`\n\n**请求体**:\n```json\n{\n  \"employee_id\": \"emp-550e8400-e29b-41d4-a716-446655440000\",\n  \"work_date\": \"2025-12-21\",\n  \"start_time\": \"09:00\",\n  \"end_time\": \"18:00\",\n  \"attendance_type\": \"WORK\",  // WORK, OVERTIME, TRAVEL, REMOTE\n  \"project_code\": \"PRJ-ERP-01\",\n  \"cost_center\": \"CC-IT-01\",\n  \"remarks\": \"上线支持\"\n}\n```\n\n**业务规则校验**:\n- `start_time` < `end_time`\n- 同一员工一天内不可重复时间段\n- OVERTIME 需要经理审批\n\n**响应** (201 Created):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"time_entry_id\": \"te-123\",\n    \"employee_id\": \"emp-550e8400-e29b-41d4-a716-446655440000\",\n    \"duration_hours\": 9.0,\n    \"overtime_hours\": 1.0,\n    \"status\": \"APPROVAL_PENDING\"\n  }\n}\n```\n\n---\n\n### 11.3 请假申请 (Absence)\n\n#### 11.3.1 创建请假单\n\n**接口**: `POST /leave-requests`\n\n**请求体**:\n```json\n{\n  \"employee_id\": \"emp-550e8400-e29b-41d4-a716-446655440000\",\n  \"leave_type\": \"ANNUAL\",  // ANNUAL, SICK, UNPAID, MARRIAGE\n  \"start_date\": \"2025-12-28\",\n  \"end_date\": \"2026-01-02\",\n  \"reason\": \"家庭出行\",\n  \"attachment_urls\": []\n}\n```\n\n**响应** (201 Created):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"leave_request_id\": \"lv-123\",\n    \"status\": \"PENDING\",\n    \"approver_id\": \"emp-0002\",\n    \"submitted_at\": \"2025-12-21T12:00:00Z\",\n    \"expected_decision_at\": \"2025-12-21T18:00:00Z\"\n  }\n}\n```\n\n---\n\n### 11.4 薪资模拟 (Payroll Simulation)\n\n#### 11.4.1 计算单次工资\n\n**接口**: `POST /payroll/simulations`\n\n**请求体**:\n```json\n{\n  \"employee_id\": \"emp-550e8400-e29b-41d4-a716-446655440000\",\n  \"period_start\": \"2025-12-01\",\n  \"period_end\": \"2025-12-31\",\n  \"currency\": \"CNY\"\n}\n```\n\n**响应** (200 OK):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"employee_id\": \"emp-550e8400-e29b-41d4-a716-446655440000\",\n    \"gross_pay\": 30000.00,\n    \"tax\": 3500.00,\n    \"social_security\": 2500.00,\n    \"net_pay\": 24000.00,\n    \"pay_date\": \"2025-12-28\",\n    \"currency\": \"CNY\",\n    \"calculation_notes\": \"含2小时加班费\"\n  }\n}\n```\n\n---\n\n## 12. 客户服务与 CRM API (Service/CRM)\n\n**Base URL**: `https://api.erp.example.com/crm/v1`\n\n### 12.1 服务工单 (Service Tickets)\n\n#### 12.1.1 创建服务工单\n\n**接口**: `POST /service-tickets`\n\n**请求体**:\n```json\n{\n  \"ticket_type\": \"INCIDENT\",  // INCIDENT, RETURN, INSTALLATION\n  \"priority\": \"HIGH\",         // LOW, MEDIUM, HIGH, URGENT\n  \"channel\": \"PHONE\",         // PHONE, EMAIL, PORTAL, ONSITE\n  \"customer_id\": \"cust-12345\",\n  \"contact_person\": \"王经理\",\n  \"product_number\": \"MAT-001\",\n  \"serial_number\": \"SN-2025-0001\",\n  \"contract_number\": \"CTR-2025-01\",\n  \"description\": \"设备噪音过大\",\n  \"sla_hours\": 8,\n  \"attachments\": []\n}\n```\n\n**响应** (201 Created):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"ticket_id\": \"svc-123\",\n    \"ticket_number\": \"SVC-2025-000123\",\n    \"status\": \"OPEN\",\n    \"priority\": \"HIGH\",\n    \"assigned_group\": \"FIELD-SVC-BJ\",\n    \"sla_due_at\": \"2025-12-21T18:00:00Z\"\n  }\n}\n```\n\n---\n\n#### 12.1.2 分派工单\n\n**接口**: `POST /service-tickets/{ticket_number}/assign`\n\n**请求体**:\n```json\n{\n  \"assignee_id\": \"emp-0009\",\n  \"skill_group\": \"ELECTRICAL\",\n  \"expected_response_at\": \"2025-12-21T14:00:00Z\"\n}\n```\n\n**响应** (200 OK):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"ticket_number\": \"SVC-2025-000123\",\n    \"status\": \"IN_PROGRESS\",\n    \"assignee_id\": \"emp-0009\",\n    \"assigned_at\": \"2025-12-21T12:10:00Z\"\n  }\n}\n```\n\n---\n\n#### 12.1.3 结案与回访\n\n**接口**: `POST /service-tickets/{ticket_number}/close`\n\n**请求体**:\n```json\n{\n  \"resolution_code\": \"REPAIRED\",  // REPAIRED, REPLACED, NO_FAULT_FOUND\n  \"resolution_notes\": \"更换轴承后噪音恢复正常\",\n  \"used_parts\": [\n    {\n      \"material_number\": \"MAT-BEARING-6310-2RS\",\n      \"quantity\": 2,\n      \"unit\": \"EA\"\n    }\n  ],\n  \"labor_hours\": 3.5,\n  \"customer_signature\": true\n}\n```\n\n**响应** (200 OK):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"ticket_number\": \"SVC-2025-000123\",\n    \"status\": \"CLOSED\",\n    \"closed_at\": \"2025-12-21T16:30:00Z\",\n    \"closed_by\": \"emp-0009\",\n    \"customer_satisfaction_url\": \"https://survey.example.com/svc-2025-000123\"\n  }\n}\n```\n\n---\n\n## 13. 质量管理 API (QM)\n\n**Base URL**: `https://api.erp.example.com/qm/v1`\n\n### 13.1 检验批与使用决定\n\n#### 13.1.1 创建检验批\n\n**接口**: `POST /inspection-lots`\n\n**请求体**:\n```json\n{\n  \"reference_type\": \"PURCHASE\",  // PURCHASE, PRODUCTION, RETURN\n  \"reference_number\": \"PO-2025-004567\",\n  \"material_number\": \"MAT-RAW-001\",\n  \"plant\": \"PLANT-01\",\n  \"storage_location\": \"SL-01\",\n  \"batch\": \"BATCH-20251221\",\n  \"inspection_type\": \"01\",  // 来料检验\n  \"sample_size\": 10\n}\n```\n\n**响应** (201 Created):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"inspection_lot_number\": \"0400001234\",\n    \"status\": \"RELEASED\",\n    \"material_number\": \"MAT-RAW-001\",\n    \"plant\": \"PLANT-01\",\n    \"sample_size\": 10,\n    \"created_at\": \"2025-12-21T10:00:00Z\"\n  }\n}\n```\n\n---\n\n#### 13.1.2 提交检验结果\n\n**接口**: `POST /inspection-lots/{lot_number}/results`\n\n**请求体**:\n```json\n{\n  \"inspector_id\": \"emp-0100\",\n  \"characteristics\": [\n    {\n      \"char_code\": \"DIM-001\",\n      \"result_value\": 10.1,\n      \"unit\": \"MM\",\n      \"status\": \"PASS\"\n    },\n    {\n      \"char_code\": \"VIS-001\",\n      \"status\": \"FAIL\",\n      \"defect_code\": \"SCRATCH\"\n    }\n  ],\n  \"remarks\": \"1件表面划伤\"\n}\n```\n\n**响应** (200 OK):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"inspection_lot_number\": \"0400001234\",\n    \"results_status\": \"RECORDED\",\n    \"nonconforming_units\": 1\n  }\n}\n```\n\n---\n\n#### 13.1.3 质量通知 (QN)\n\n**接口**: `POST /quality-notifications`\n\n**请求体**:\n```json\n{\n  \"notification_type\": \"Q1\",  // Q1=内部缺陷, Q2=客户投诉, Q3=供应商缺陷\n  \"reference_document\": \"PO-2025-004567\",\n  \"material_number\": \"MAT-RAW-001\",\n  \"defect_code\": \"SCRATCH\",\n  \"priority\": \"MEDIUM\",\n  \"description\": \"表面划伤影响外观\",\n  \"reported_by\": \"emp-0100\",\n  \"attachments\": []\n}\n```\n\n**响应** (201 Created):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"notification_number\": \"QN-2025-000789\",\n    \"status\": \"OPEN\",\n    \"assigned_group\": \"QA-PLANT-01\",\n    \"created_at\": \"2025-12-21T10:30:00Z\"\n  }\n}\n```\n\n---\n\n#### 13.1.4 使用决定\n\n**接口**: `POST /inspection-lots/{lot_number}/usage-decision`\n\n**请求体**:\n```json\n{\n  \"decision_code\": \"ACCEPT_WITH_DEDUCTION\",  // ACCEPT, REJECT, ACCEPT_WITH_DEDUCTION\n  \"accepted_quantity\": 9,\n  \"rejected_quantity\": 1,\n  \"follow_up_action\": \"RETURN_TO_VENDOR\",  // SCRAP, REWORK, RETURN_TO_VENDOR\n  \"stock_posting\": \"UNRESTRICTED\"          // UNRESTRICTED, BLOCKED, SCRAP\n}\n```\n\n**响应** (200 OK):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"inspection_lot_number\": \"0400001234\",\n    \"usage_decision\": \"ACCEPT_WITH_DEDUCTION\",\n    \"stock_posted\": true,\n    \"material_document\": \"MD-2025-009001\"\n  }\n}\n```\n\n---\n\n## 14. 设备维护 API (PM)\n\n**Base URL**: `https://api.erp.example.com/pm/v1`\n\n### 14.1 设备主数据 (Equipment)\n\n#### 14.1.1 创建设备\n\n**接口**: `POST /equipments`\n\n**请求体**:\n```json\n{\n  \"equipment_number\": null,  // 可选，系统自动分配\n  \"description\": \"空压机 GA90\",\n  \"category\": \"MACHINE\",\n  \"serial_number\": \"GA90-2020-001234\",\n  \"functional_location\": \"PLANT-BJ-COMP-001\",\n  \"manufacturer\": \"Atlas Copco\",\n  \"model\": \"GA 90\",\n  \"install_date\": \"2020-05-15\",\n  \"cost_center\": \"CC-MFG-01\",\n  \"main_work_center\": \"MECH-BJ-01\"\n}\n```\n\n**响应** (201 Created):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"equipment_id\": \"eq-123\",\n    \"equipment_number\": \"EQ-2025-000789\",\n    \"functional_location\": \"PLANT-BJ-COMP-001\",\n    \"status\": \"INSTALLED\",\n    \"created_at\": \"2025-12-21T10:00:00Z\"\n  }\n}\n```\n\n---\n\n### 14.2 维护通知 (Notifications)\n\n#### 14.2.1 创建维护通知\n\n**接口**: `POST /maintenance-notifications`\n\n**请求体**:\n```json\n{\n  \"equipment_number\": \"EQ-2025-000789\",\n  \"priority\": \"HIGH\",  // LOW, MEDIUM, HIGH, EMERGENCY\n  \"symptom_code\": \"NOISE\",\n  \"description\": \"轴承异常噪音\",\n  \"reported_by\": \"emp-0100\",\n  \"required_start\": \"2025-12-21T18:00:00Z\",\n  \"attachments\": []\n}\n```\n\n**响应** (201 Created):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"notification_number\": \"MN-2025-000456\",\n    \"status\": \"OPEN\",\n    \"equipment_number\": \"EQ-2025-000789\",\n    \"created_at\": \"2025-12-21T12:00:00Z\"\n  }\n}\n```\n\n---\n\n### 14.3 维护工单 (Orders)\n\n#### 14.3.1 创建维护工单\n\n**接口**: `POST /maintenance-orders`\n\n**请求体**:\n```json\n{\n  \"notification_number\": \"MN-2025-000456\",\n  \"equipment_number\": \"EQ-2025-000789\",\n  \"order_type\": \"PM02\",  // PM01=纠正性, PM02=预防性\n  \"planning_plant\": \"PLANT-01\",\n  \"main_work_center\": \"MECH-BJ-01\",\n  \"planned_start\": \"2025-12-21T18:00:00Z\",\n  \"planned_finish\": \"2025-12-21T22:00:00Z\",\n  \"operations\": [\n    {\n      \"operation_number\": 10,\n      \"work_center\": \"MECH-BJ-01\",\n      \"activity_type\": \"MECH\",\n      \"planned_hours\": 4.0\n    }\n  ],\n  \"components\": [\n    {\n      \"material_number\": \"MAT-BEARING-6310-2RS\",\n      \"quantity\": 2,\n      \"unit\": \"EA\",\n      \"storage_location\": \"SL-01\"\n    }\n  ]\n}\n```\n\n**响应** (201 Created):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"maintenance_order_number\": \"MO-2025-000321\",\n    \"status\": \"RELEASED\",\n    \"equipment_number\": \"EQ-2025-000789\",\n    \"notification_number\": \"MN-2025-000456\",\n    \"planned_cost\": 1200.00,\n    \"currency\": \"CNY\"\n  }\n}\n```\n\n---\n\n#### 14.3.2 维护完工确认\n\n**接口**: `POST /maintenance-orders/{order_number}/confirm`\n\n**请求体**:\n```json\n{\n  \"actual_start\": \"2025-12-21T18:00:00Z\",\n  \"actual_finish\": \"2025-12-21T22:00:00Z\",\n  \"labor_hours\": 3.5,\n  \"used_materials\": [\n    {\n      \"material_number\": \"MAT-BEARING-6310-2RS\",\n      \"quantity\": 2,\n      \"unit\": \"EA\"\n    }\n  ],\n  \"technical_completion\": true,\n  \"completion_notes\": \"更换轴承并校准传感器\"\n}\n```\n\n**响应** (200 OK):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"maintenance_order_number\": \"MO-2025-000321\",\n    \"status\": \"TECO\",\n    \"actual_cost\": 1180.00,\n    \"currency\": \"CNY\",\n    \"confirmed_at\": \"2025-12-21T22:10:00Z\"\n  }\n}\n```\n\n---\n\n## 15. 仓储与运输 API (EWM/TM)\n\n**Base URL**: `https://api.erp.example.com/logistics/v1`\n\n### 15.1 仓储作业 (EWM)\n\n#### 15.1.1 创建拣货任务\n\n**接口**: `POST /warehouse-tasks/picking`\n\n**请求体**:\n```json\n{\n  \"delivery_number\": \"DN-2025-005678\",\n  \"wave_number\": \"WAVE-2025-001\",\n  \"picker_id\": \"emp-0200\",\n  \"items\": [\n    {\n      \"delivery_item\": 10,\n      \"material_number\": \"MAT-001\",\n      \"quantity\": 100,\n      \"unit\": \"PC\",\n      \"source_bin\": \"BIN-01-01-A\",\n      \"destination_bin\": \"STAGE-01\"\n    }\n  ]\n}\n```\n\n**响应** (201 Created):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"warehouse_task_id\": \"wt-2025-000111\",\n    \"status\": \"CREATED\",\n    \"delivery_number\": \"DN-2025-005678\",\n    \"assigned_to\": \"emp-0200\"\n  }\n}\n```\n\n---\n\n#### 15.1.2 确认仓储任务\n\n**接口**: `POST /warehouse-tasks/{task_id}/confirm`\n\n**请求体**:\n```json\n{\n  \"confirmed_quantity\": 100,\n  \"exceptions\": [],  // 如缺件可传 EXCEPTION 代码\n  \"confirmed_by\": \"emp-0200\",\n  \"confirmation_time\": \"2025-12-21T10:30:00Z\"\n}\n```\n\n**响应** (200 OK):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"warehouse_task_id\": \"wt-2025-000111\",\n    \"status\": \"CONFIRMED\",\n    \"material_document\": \"MD-2025-009100\"\n  }\n}\n```\n\n---\n\n### 15.2 运输计划与承运商协同 (TM)\n\n#### 15.2.1 创建运输订单\n\n**接口**: `POST /freight-orders`\n\n**请求体**:\n```json\n{\n  \"shipment_type\": \"OUTBOUND\",  // OUTBOUND, INBOUND\n  \"stops\": [\n    {\n      \"type\": \"PICKUP\",\n      \"location\": \"PLANT-01\",\n      \"planned_time\": \"2025-12-22T08:00:00Z\"\n    },\n    {\n      \"type\": \"DROPOFF\",\n      \"location\": \"CUSTOMER-SHANGHAI\",\n      \"planned_time\": \"2025-12-23T14:00:00Z\"\n    }\n  ],\n  \"vehicle_type\": \"TRUCK-10T\",\n  \"carrier_id\": \"CARR-001\",\n  \"related_documents\": [\n    {\n      \"type\": \"DELIVERY\",\n      \"number\": \"DN-2025-005678\"\n    }\n  ],\n  \"freight_charges_currency\": \"CNY\"\n}\n```\n\n**响应** (201 Created):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"freight_order_number\": \"FO-2025-000123\",\n    \"status\": \"PLANNED\",\n    \"carrier_id\": \"CARR-001\",\n    \"tender_status\": \"REQUESTED\"\n  }\n}\n```\n\n---\n\n#### 15.2.2 承运商回应\n\n**接口**: `POST /freight-orders/{freight_order_number}/tender/confirm`\n\n**请求体**:\n```json\n{\n  \"accepted\": true,\n  \"carrier_reference\": \"CARR-001-FO-2025-000123\",\n  \"accepted_by\": \"carrier.user\",\n  \"accepted_at\": \"2025-12-21T13:00:00Z\",\n  \"eta\": \"2025-12-22T08:00:00Z\"\n}\n```\n\n**响应** (200 OK):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"freight_order_number\": \"FO-2025-000123\",\n    \"tender_status\": \"ACCEPTED\",\n    \"eta\": \"2025-12-22T08:00:00Z\"\n  }\n}\n```\n\n---\n\n## 16. 供应商协同与寻源 API (SRM/Ariba)\n\n**Base URL**: `https://api.erp.example.com/procurement/v1`\n\n### 16.1 询价/招标 (RFQ)\n\n#### 16.1.1 创建询价单\n\n**接口**: `POST /rfqs`\n\n**请求体**:\n```json\n{\n  \"title\": \"原材料A 2025Q1采购\",\n  \"category\": \"RAW_MATERIAL\",\n  \"due_date\": \"2025-12-28T12:00:00Z\",\n  \"currency\": \"CNY\",\n  \"incoterms\": \"FOB\",\n  \"payment_terms\": \"NET30\",\n  \"items\": [\n    {\n      \"item_number\": 10,\n      \"material_number\": \"MAT-RAW-001\",\n      \"description\": \"原材料A\",\n      \"quantity\": 1000,\n      \"unit\": \"KG\",\n      \"target_price\": 50.00,\n      \"delivery_date\": \"2026-01-10\"\n    }\n  ],\n  \"invited_suppliers\": [\"V-10001\", \"V-10002\"]\n}\n```\n\n**响应** (201 Created):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"rfq_number\": \"RFQ-2025-000123\",\n    \"status\": \"OPEN\",\n    \"due_date\": \"2025-12-28T12:00:00Z\",\n    \"items_count\": 1,\n    \"invited_suppliers\": 2,\n    \"created_at\": \"2025-12-21T10:00:00Z\"\n  }\n}\n```\n\n---\n\n#### 16.1.2 供应商报价\n\n**接口**: `POST /rfqs/{rfq_number}/bids`\n\n**请求体**:\n```json\n{\n  \"supplier_id\": \"V-10001\",\n  \"valid_until\": \"2026-01-15\",\n  \"currency\": \"CNY\",\n  \"items\": [\n    {\n      \"item_number\": 10,\n      \"quote_price\": 48.50,\n      \"discount_percent\": 2.0,\n      \"delivery_date\": \"2026-01-08\"\n    }\n  ],\n  \"notes\": \"含运费，先到先得\"\n}\n```\n\n**业务规则校验**:\n- 只能在 `due_date` 前提交或修改报价\n- 报价币种需与RFQ一致\n\n**响应** (201 Created):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"bid_id\": \"bid-2025-000999\",\n    \"rfq_number\": \"RFQ-2025-000123\",\n    \"supplier_id\": \"V-10001\",\n    \"status\": \"SUBMITTED\",\n    \"submitted_at\": \"2025-12-21T11:00:00Z\"\n  }\n}\n```\n\n---\n\n#### 16.1.3 评标与授标\n\n**接口**: `POST /rfqs/{rfq_number}/award`\n\n**请求体**:\n```json\n{\n  \"winning_bid_id\": \"bid-2025-000999\",\n  \"justification\": \"最低总价且交期满足\",\n  \"auto_create_po\": true\n}\n```\n\n**响应** (200 OK):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"rfq_number\": \"RFQ-2025-000123\",\n    \"status\": \"AWARDED\",\n    \"winning_bid_id\": \"bid-2025-000999\",\n    \"po_number\": \"PO-2025-009999\",\n    \"awarded_at\": \"2025-12-21T12:00:00Z\"\n  }\n}\n```\n\n---\n\n### 16.2 供应商主数据\n\n#### 16.2.1 供应商准入/注册\n\n**接口**: `POST /suppliers`\n\n**请求体**:\n```json\n{\n  \"supplier_number\": null,  // 可选，系统自动分配\n  \"name\": \"供应商A\",\n  \"tax_id\": \"91310000XXXX\",\n  \"contact\": {\n    \"name\": \"李经理\",\n    \"email\": \"li@supplier.com\",\n    \"phone\": \"+86-13800001111\"\n  },\n  \"bank_account\": {\n    \"bank_name\": \"ICBC\",\n    \"account_number\": \"621700******1234\",\n    \"currency\": \"CNY\"\n  },\n  \"categories\": [\"RAW_MATERIAL\"],\n  \"payment_terms\": \"NET30\",\n  \"incoterms\": \"FOB\",\n  \"risk_score\": 15\n}\n```\n\n**响应** (201 Created):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"supplier_id\": \"sup-550e8400-e29b-41d4-a716-446655440000\",\n    \"supplier_number\": \"V-10003\",\n    \"name\": \"供应商A\",\n    \"status\": \"APPROVED\",\n    \"created_at\": \"2025-12-21T10:00:00Z\"\n  }\n}\n```\n\n---\n\n## 17. 主数据治理 API (MDG)\n\n**Base URL**: `https://api.erp.example.com/mdg/v1`\n\n### 17.1 变更请求 (Change Request)\n\n#### 17.1.1 创建主数据变更请求\n\n**接口**: `POST /change-requests`\n\n**请求体**:\n```json\n{\n  \"entity_type\": \"SUPPLIER\",  // CUSTOMER, SUPPLIER, MATERIAL\n  \"action\": \"CREATE\",         // CREATE, UPDATE, DELETE\n  \"priority\": \"MEDIUM\",       // LOW, MEDIUM, HIGH\n  \"initiator\": \"user-123\",\n  \"reason\": \"新增海外供应商\",\n  \"payload\": {\n    \"supplier_number\": null,\n    \"name\": \"供应商B\",\n    \"country\": \"US\",\n    \"tax_id\": \"99-9999999\",\n    \"currency\": \"USD\",\n    \"payment_terms\": \"NET45\"\n  }\n}\n```\n\n**响应** (201 Created):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"change_request_number\": \"CR-2025-000456\",\n    \"entity_type\": \"SUPPLIER\",\n    \"action\": \"CREATE\",\n    \"status\": \"SUBMITTED\",\n    \"approver_group\": \"MDG-SUP\",\n    \"sla_due_at\": \"2025-12-22T18:00:00Z\",\n    \"created_at\": \"2025-12-21T11:00:00Z\"\n  }\n}\n```\n\n---\n\n#### 17.1.2 审批变更请求\n\n**接口**: `POST /change-requests/{cr_number}/actions`\n\n**请求体**:\n```json\n{\n  \"action\": \"APPROVE\",  // APPROVE, REJECT\n  \"approver\": \"user-approver-01\",\n  \"comments\": \"税号已验证\"\n}\n```\n\n**响应** (200 OK):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"change_request_number\": \"CR-2025-000456\",\n    \"status\": \"APPROVED\",\n    \"approved_at\": \"2025-12-21T12:00:00Z\",\n    \"replicated_to_core\": true\n  }\n}\n```\n\n---\n\n## 18. 供应链计划 API (IBP/PPDS)\n\n**Base URL**: `https://api.erp.example.com/planning/v1`\n\n### 18.1 需求计划 (Demand Planning)\n\n#### 18.1.1 创建需求计划版本\n\n**接口**: `POST /demand-plans`\n\n**请求体**:\n```json\n{\n  \"plan_version\": \"FY2026-BUDGET\",\n  \"currency\": \"CNY\",\n  \"time_bucket\": \"MONTH\",  // DAY, WEEK, MONTH\n  \"lines\": [\n    {\n      \"material_number\": \"MAT-001\",\n      \"plant\": \"PLANT-01\",\n      \"period\": \"2026-01\",\n      \"forecast_quantity\": 1200,\n      \"unit\": \"PC\"\n    },\n    {\n      \"material_number\": \"MAT-001\",\n      \"plant\": \"PLANT-01\",\n      \"period\": \"2026-02\",\n      \"forecast_quantity\": 1500,\n      \"unit\": \"PC\"\n    }\n  ]\n}\n```\n\n**响应** (201 Created):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"plan_version\": \"FY2026-BUDGET\",\n    \"lines_created\": 2,\n    \"status\": \"ACTIVE\",\n    \"created_at\": \"2025-12-21T10:30:00Z\"\n  }\n}\n```\n\n---\n\n### 18.2 MRP/供应计划运行\n\n#### 18.2.1 触发MRP运行\n\n**接口**: `POST /mrp/runs`\n\n**请求体**:\n```json\n{\n  \"plants\": [\"PLANT-01\"],\n  \"materials\": [\"MAT-001\", \"MAT-002\"],\n  \"planning_horizon_days\": 30,\n  \"use_latest_demand_plan\": true,\n  \"lot_size_policy\": \"EX\",  // EX=精确订单量\n  \"include_safety_stock\": true\n}\n```\n\n**响应** (202 Accepted):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"task_id\": \"mrp-task-2025-0001\",\n    \"status\": \"PROCESSING\",\n    \"status_url\": \"/tasks/mrp-task-2025-0001\",\n    \"estimated_completion\": \"2025-12-21T10:45:00Z\"\n  }\n}\n```\n\n**任务结果示例**: `GET /tasks/mrp-task-2025-0001`\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"task_id\": \"mrp-task-2025-0001\",\n    \"status\": \"COMPLETED\",\n    \"generated_planned_orders\": 3,\n    \"generated_purchase_reqs\": 2,\n    \"alerts\": [\n      {\n        \"material_number\": \"MAT-002\",\n        \"type\": \"CAPACITY_CONSTRAINT\",\n        \"message\": \"产能不足，建议分批生产\"\n      }\n    ]\n  }\n}\n```\n\n---\n\n## 19. 差旅与费用报销 API (Travel & Expense / Concur)\n\n**Base URL**: `https://api.erp.example.com/expense/v1`\n\n### 19.1 差旅申请\n\n#### 19.1.1 创建差旅申请\n\n**接口**: `POST /travel-requests`\n\n**请求体**:\n```json\n{\n  \"employee_id\": \"emp-550e8400-e29b-41d4-a716-446655440000\",\n  \"purpose\": \"客户会议与现场勘察\",\n  \"start_date\": \"2026-01-10\",\n  \"end_date\": \"2026-01-14\",\n  \"destinations\": [\"Shanghai\", \"Suzhou\"],\n  \"estimated_cost\": 12000.00,\n  \"currency\": \"CNY\",\n  \"cost_center\": \"CC-SALES-01\",\n  \"project_code\": \"PRJ-CRM-01\",\n  \"requires_booking\": true\n}\n```\n\n**响应** (201 Created):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"travel_request_number\": \"TR-2026-000123\",\n    \"status\": \"PENDING\",\n    \"approver_id\": \"emp-0002\",\n    \"estimated_cost\": 12000.00,\n    \"currency\": \"CNY\",\n    \"created_at\": \"2025-12-22T10:00:00Z\"\n  }\n}\n```\n\n---\n\n#### 19.1.2 审批差旅申请\n\n**接口**: `POST /travel-requests/{request_number}/approve`\n\n**请求体**:\n```json\n{\n  \"approver_id\": \"emp-0002\",\n  \"action\": \"APPROVE\",  // APPROVE, REJECT\n  \"comments\": \"预算充足，同意出差\"\n}\n```\n\n**响应** (200 OK):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"travel_request_number\": \"TR-2026-000123\",\n    \"status\": \"APPROVED\",\n    \"approved_at\": \"2025-12-22T12:00:00Z\",\n    \"approved_by\": \"emp-0002\"\n  }\n}\n```\n\n---\n\n### 19.2 费用报销\n\n#### 19.2.1 创建费用报销单\n\n**接口**: `POST /expense-reports`\n\n**请求体**:\n```json\n{\n  \"employee_id\": \"emp-550e8400-e29b-41d4-a716-446655440000\",\n  \"travel_request_number\": \"TR-2026-000123\",\n  \"report_date\": \"2026-01-15\",\n  \"currency\": \"CNY\",\n  \"lines\": [\n    {\n      \"line_number\": 10,\n      \"expense_type\": \"AIRFARE\",\n      \"amount\": 4500.00,\n      \"currency\": \"CNY\",\n      \"tax_code\": \"VAT13\",\n      \"receipt_url\": \"https://files.example.com/receipts/air-123.pdf\",\n      \"expense_date\": \"2026-01-10\",\n      \"city\": \"Shanghai\"\n    },\n    {\n      \"line_number\": 20,\n      \"expense_type\": \"HOTEL\",\n      \"amount\": 3200.00,\n      \"currency\": \"CNY\",\n      \"tax_code\": \"VAT6\",\n      \"receipt_url\": \"https://files.example.com/receipts/hotel-456.pdf\",\n      \"expense_date\": \"2026-01-11\",\n      \"city\": \"Shanghai\"\n    }\n  ]\n}\n```\n\n**业务规则校验**:\n- 必须关联已批准的差旅申请（如策略要求）\n- 需要发票/凭证的行必须提供 `receipt_url`\n- 金额超过阈值需二级审批\n\n**响应** (201 Created):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"expense_report_number\": \"ER-2026-000555\",\n    \"status\": \"DRAFT\",\n    \"total_amount\": 7700.00,\n    \"currency\": \"CNY\",\n    \"lines_count\": 2,\n    \"created_at\": \"2026-01-15T09:00:00Z\"\n  }\n}\n```\n\n---\n\n#### 19.2.2 提交/审核报销单\n\n**接口**: `POST /expense-reports/{report_number}/submit`\n\n**响应** (200 OK):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"expense_report_number\": \"ER-2026-000555\",\n    \"status\": \"PENDING_APPROVAL\",\n    \"approver_id\": \"emp-0002\",\n    \"submitted_at\": \"2026-01-15T10:00:00Z\"\n  }\n}\n```\n\n**审批接口**: `POST /expense-reports/{report_number}/approve`\n```json\n{\n  \"approver_id\": \"emp-0002\",\n  \"action\": \"APPROVE\",\n  \"comments\": \"发票齐全，金额合理\"\n}\n```\n\n**响应**:\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"expense_report_number\": \"ER-2026-000555\",\n    \"status\": \"APPROVED\",\n    \"approved_at\": \"2026-01-15T12:00:00Z\",\n    \"payment_run_date\": \"2026-01-20\"\n  }\n}\n```\n\n---\n\n## 20. 全球贸易与合规 API (GTS)\n\n**Base URL**: `https://api.erp.example.com/gts/v1`\n\n### 20.1 制裁名单与合规检查\n\n**接口**: `POST /compliance-checks`\n\n**请求体**:\n```json\n{\n  \"partner_type\": \"CUSTOMER\",\n  \"name\": \"ACME Trading LLC\",\n  \"country\": \"IR\",\n  \"address\": \"Tehran, ...\",\n  \"identifier\": \"ID-12345\",\n  \"transaction_value\": 50000,\n  \"currency\": \"USD\"\n}\n```\n\n**响应** (200 OK):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"check_id\": \"gts-ck-0001\",\n    \"result\": \"REJECT\",  // PASS, REVIEW, REJECT\n    \"matched_lists\": [\"OFAC-SDN\"],\n    \"risk_score\": 95,\n    \"created_at\": \"2025-12-22T10:00:00Z\"\n  }\n}\n```\n\n---\n\n### 20.2 商品分类与出口管制\n\n**接口**: `POST /product-classifications`\n\n**请求体**:\n```json\n{\n  \"material_number\": \"MAT-001\",\n  \"country\": \"US\",\n  \"hs_code\": \"841480\",\n  \"eccn\": \"2B999\",\n  \"control_indicators\": [\"NLR\"],\n  \"effective_from\": \"2025-12-22\"\n}\n```\n\n**响应** (201 Created):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"classification_id\": \"cls-2025-0001\",\n    \"material_number\": \"MAT-001\",\n    \"country\": \"US\",\n    \"hs_code\": \"841480\",\n    \"eccn\": \"2B999\",\n    \"created_at\": \"2025-12-22T11:00:00Z\"\n  }\n}\n```\n\n---\n\n### 20.3 报关申报\n\n**接口**: `POST /customs-declarations`\n\n**请求体**:\n```json\n{\n  \"declaration_type\": \"EXPORT\",\n  \"commercial_invoice\": \"INV-2025-009876\",\n  \"country_of_export\": \"CN\",\n  \"country_of_import\": \"US\",\n  \"line_items\": [\n    {\n      \"item_number\": 10,\n      \"material_number\": \"MAT-001\",\n      \"quantity\": 100,\n      \"unit\": \"PC\",\n      \"gross_weight\": 250.0,\n      \"hs_code\": \"841480\",\n      \"customs_value\": 50000.00,\n      \"currency\": \"USD\"\n    }\n  ],\n  \"forwarder\": \"DHL\",\n  \"port_of_loading\": \"Shanghai\",\n  \"port_of_discharge\": \"Los Angeles\"\n}\n```\n\n**响应** (202 Accepted):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"declaration_number\": \"CUS-2025-000888\",\n    \"status\": \"SUBMITTED\",\n    \"status_url\": \"/gts/v1/customs-declarations/CUS-2025-000888/status\",\n    \"created_at\": \"2025-12-22T12:00:00Z\"\n  }\n}\n```\n\n---\n\n## 21. 治理、风险与合规 API (GRC AC/PC)\n\n**Base URL**: `https://api.erp.example.com/grc/v1`\n\n### 21.1 职责分离 (SoD) 风险分析\n\n**接口**: `POST /sod-checks`\n\n**请求体**:\n```json\n{\n  \"user_id\": \"user-123\",\n  \"roles_to_assign\": [\"FIN_AP_CLERK\", \"FIN_PAYMENT_RUN\"],\n  \"system\": \"ERP-PRD\",\n  \"business_process\": \"FI\"\n}\n```\n\n**响应** (200 OK):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"check_id\": \"sod-2025-0001\",\n    \"result\": \"VIOLATION\",\n    \"violations\": [\n      {\n        \"rule_id\": \"SOD-FI-001\",\n        \"description\": \"创建供应商与执行付款不可同岗\",\n        \"conflicting_roles\": [\"FIN_VENDOR_CREATE\", \"FIN_PAYMENT_RUN\"],\n        \"mitigation_control\": \"PAYMENT_REVIEW_BY_CONTROLLER\"\n      }\n    ],\n    \"created_at\": \"2025-12-22T10:30:00Z\"\n  }\n}\n```\n\n---\n\n### 21.2 访问申请与审批\n\n**接口**: `POST /access-requests`\n\n**请求体**:\n```json\n{\n  \"user_id\": \"user-123\",\n  \"requested_roles\": [\"FIN_PAYMENT_RUN\"],\n  \"justification\": \"需要执行月度付款批次\",\n  \"valid_from\": \"2025-12-22\",\n  \"valid_to\": \"2026-01-31\",\n  \"approver_chain\": [\"mgr-001\", \"controller-001\"]\n}\n```\n\n**响应** (201 Created):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"access_request_number\": \"AR-2025-000789\",\n    \"status\": \"PENDING\",\n    \"next_approver\": \"mgr-001\",\n    \"sod_check_id\": \"sod-2025-0001\",\n    \"created_at\": \"2025-12-22T11:00:00Z\"\n  }\n}\n```\n\n---\n\n### 21.3 控制测试记录\n\n**接口**: `POST /controls/{control_id}/tests`\n\n**请求体**:\n```json\n{\n  \"control_id\": \"PAYMENT_REVIEW_BY_CONTROLLER\",\n  \"test_period\": \"2025-Q4\",\n  \"tester\": \"audit-001\",\n  \"evidence_links\": [\"https://files.example.com/audit/payments-q4.zip\"],\n  \"result\": \"EFFECTIVE\",\n  \"comments\": \"抽样10笔均有复核签字\"\n}\n```\n\n**响应** (201 Created):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"control_test_id\": \"ct-2025-0005\",\n    \"control_id\": \"PAYMENT_REVIEW_BY_CONTROLLER\",\n    \"result\": \"EFFECTIVE\",\n    \"tested_at\": \"2025-12-22T12:00:00Z\"\n  }\n}\n```\n\n---\n\n## 22. 扩展错误码与权限矩阵\n\n### 22.1 错误码补充\n\n| 范围 | 错误码 | HTTP | 说明 |\n|------|--------|------|------|\n| 差旅/报销 | TRAVEL_NOT_APPROVED | 422 | 差旅申请未批准，禁止报销关联 |\n| 差旅/报销 | RECEIPT_REQUIRED | 422 | 未上传必须的发票/凭证 |\n| 差旅/报销 | OVER_POLICY_LIMIT | 422 | 金额/天数超出公司差旅政策 |\n| GTS | COMPLIANCE_REJECTED | 403 | 制裁名单命中，交易被拒 |\n| GTS | EXPORT_CONTROL_BLOCK | 403 | 出口管制受限，需合规放行 |\n| GTS | CLASSIFICATION_MISSING | 422 | 缺失HS/ECCN分类，无法申报 |\n| GRC | SOD_VIOLATION | 409 | 职责分离冲突，需缓释或拒绝 |\n| GRC | APPROVER_NOT_AUTHORIZED | 403 | 审批人不具备对应控制权限 |\n\n### 22.2 权限矩阵（角色 → 关键接口）\n\n| 角色 | 关键接口 | 说明 |\n|------|---------|------|\n| `EMPLOYEE` | 19.1 创建/查询差旅申请；19.2 创建/提交报销 | 仅可操作本人记录 |\n| `MANAGER` | 19.1 审批差旅；19.2 审批报销 | 需与层级校验 |\n| `FIN_AP_CLERK` | 19.2 报销复核；20.3 报关草稿创建 | 财务应付角色 |\n| `GTS_OFFICER` | 20.1 合规检查；20.2 商品分类；20.3 报关提交 | 具备合规放行权限 |\n| `GRC_ANALYST` | 21.1 SoD 检查；21.2 访问申请审批；21.3 控制测试 | 内控/审计 |\n| `MDG_STEWARD` | 17.1 变更请求审批 | 主数据治理 |\n| `PROCUREMENT` | 16.1 RFQ 创建/授标；16.2 供应商准入 | 采购角色 |\n\n### 22.3 异步任务/回调约定\n\n- 通用任务状态：`PROCESSING`, `COMPLETED`, `FAILED`, `CANCELLED`\n- 回调URL（可选）：在请求体中传 `callback_url`，服务完成后以 `POST` 回传：\n```json\n{\n  \"task_id\": \"mrp-task-2025-0001\",\n  \"status\": \"COMPLETED\",\n  \"result_ref\": \"https://storage.example.com/tasks/mrp-task-2025-0001/result.json\",\n  \"completed_at\": \"2025-12-21T10:45:12Z\"\n}\n```\n- 典型异步接口：报表生成(2.4)、MRP运行(18.2)、报关申报(20.3)、大批量RFQ授标生成PO(16.1)。\n\n### 22.4 枚举与主数据对齐说明\n\n- 币种：ISO 4217 (`CNY`, `USD`...)\n- HS编码：WCO HS 6位或本地扩展；ECCN：符合出口管制目录\n- 港口/地点：UN/LOCODE\n- 税码：与财务模块 2.2/3.1 保持一致 (`VAT13`, `VAT6` 等)\n- 角色/权限：与 IAM/RBAC 目录一致，采用最小权限原则\n\n---\n\n**文档版本**: v1.4\n**最后更新**: 2025-12-22\n**维护者**: ERP 开发团队\n\n## 23. 项目系统 API (PS)\n\n**Base URL**: `https://api.erp.example.com/ps/v1`\n\n### 23.1 项目与WBS\n\n#### 23.1.1 创建项目定义\n\n**接口**: `POST /projects`\n\n**请求体**:\n```json\n{\n  \"project_code\": \"PRJ-2026-001\",  // 可选，系统生成\n  \"description\": \"新工厂产线扩建\",\n  \"start_date\": \"2026-02-01\",\n  \"end_date\": \"2026-08-31\",\n  \"responsible\": \"emp-0100\",\n  \"company_code\": \"1000\",\n  \"currency\": \"CNY\"\n}\n```\n\n**响应** (201 Created):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"project_id\": \"ps-123\",\n    \"project_code\": \"PRJ-2026-001\",\n    \"status\": \"CREATED\",\n    \"created_at\": \"2025-12-22T10:00:00Z\"\n  }\n}\n```\n\n---\n\n#### 23.1.2 创建WBS节点\n\n**接口**: `POST /projects/{project_code}/wbs`\n\n**请求体**:\n```json\n{\n  \"wbs_code\": \"PRJ-2026-001-01\",\n  \"description\": \"土建施工\",\n  \"parent_wbs\": null,\n  \"start_date\": \"2026-02-01\",\n  \"end_date\": \"2026-04-30\",\n  \"responsible\": \"emp-0200\",\n  \"budget\": 3000000,\n  \"currency\": \"CNY\"\n}\n```\n\n**响应** (201 Created):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"wbs_id\": \"wbs-001\",\n    \"wbs_code\": \"PRJ-2026-001-01\",\n    \"status\": \"RELEASED\",\n    \"created_at\": \"2025-12-22T10:10:00Z\"\n  }\n}\n```\n\n---\n\n### 23.2 网络与作业\n\n#### 23.2.1 创建网络及作业\n\n**接口**: `POST /networks`\n\n**请求体**:\n```json\n{\n  \"network_number\": null,\n  \"project_code\": \"PRJ-2026-001\",\n  \"wbs_code\": \"PRJ-2026-001-01\",\n  \"activities\": [\n    {\n      \"activity_number\": 10,\n      \"description\": \"基础施工\",\n      \"work_center\": \"CIVIL-01\",\n      \"planned_hours\": 400,\n      \"planned_cost\": 800000,\n      \"currency\": \"CNY\",\n      \"start_date\": \"2026-02-01\",\n      \"end_date\": \"2026-02-28\"\n    }\n  ]\n}\n```\n\n**响应** (201 Created):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"network_id\": \"ntw-001\",\n    \"network_number\": \"NTW-2026-0001\",\n    \"activities_count\": 1,\n    \"status\": \"RELEASED\"\n  }\n}\n```\n\n---\n\n### 23.3 里程碑与进度\n\n#### 23.3.1 完成里程碑\n\n**接口**: `POST /projects/{project_code}/milestones/{milestone_code}/complete`\n\n**请求体**:\n```json\n{\n  \"completion_date\": \"2026-02-28\",\n  \"confirmed_by\": \"emp-0200\",\n  \"notes\": \"土建基础验收完成\"\n}\n```\n\n**响应** (200 OK):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"milestone_code\": \"MS-FOUNDATION\",\n    \"status\": \"COMPLETED\",\n    \"completed_at\": \"2026-02-28T18:00:00Z\"\n  }\n}\n```\n\n---\n\n### 23.4 成本/收入分配\n\n#### 23.4.1 记录项目成本\n\n**接口**: `POST /projects/{project_code}/costs`\n\n**请求体**:\n```json\n{\n  \"posting_date\": \"2026-02-15\",\n  \"wbs_code\": \"PRJ-2026-001-01\",\n  \"amount\": 500000,\n  \"currency\": \"CNY\",\n  \"cost_element\": \"610000\",\n  \"reference\": \"MIRO-2026-0001\",\n  \"description\": \"土建进度款\"\n}\n```\n\n**响应** (201 Created):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"project_code\": \"PRJ-2026-001\",\n    \"wbs_code\": \"PRJ-2026-001-01\",\n    \"cost_document\": \"PC-2026-0001\",\n    \"amount\": 500000,\n    \"currency\": \"CNY\"\n  }\n}\n```\n\n---\n\n## 24. 产品生命周期管理 API (PLM)\n\n**Base URL**: `https://api.erp.example.com/plm/v1`\n\n### 24.1 工程变更 (ECN)\n\n#### 24.1.1 创建工程变更单\n\n**接口**: `POST /engineering-changes`\n\n**请求体**:\n```json\n{\n  \"change_number\": null,\n  \"title\": \"产品A版本升级\",\n  \"reason\": \"提升散热性能\",\n  \"effective_from\": \"2026-03-01\",\n  \"initiator\": \"eng-001\",\n  \"affected_materials\": [\"MAT-001\"],\n  \"attachments\": []\n}\n```\n\n**响应** (201 Created):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"change_number\": \"ECN-2026-0001\",\n    \"status\": \"DRAFT\",\n    \"created_at\": \"2025-12-22T11:00:00Z\"\n  }\n}\n```\n\n---\n\n### 24.2 BOM 与配方\n\n#### 24.2.1 更新物料清单\n\n**接口**: `POST /boms/{material_number}/revisions`\n\n**请求体**:\n```json\n{\n  \"ecn_number\": \"ECN-2026-0001\",\n  \"revision\": \"B\",\n  \"valid_from\": \"2026-03-01\",\n  \"components\": [\n    {\n      \"item_number\": 10,\n      \"component_material\": \"MAT-PART-100\",\n      \"quantity\": 2,\n      \"unit\": \"EA\"\n    },\n    {\n      \"item_number\": 20,\n      \"component_material\": \"MAT-PART-200\",\n      \"quantity\": 1,\n      \"unit\": \"EA\"\n    }\n  ]\n}\n```\n\n**响应** (201 Created):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"material_number\": \"MAT-001\",\n    \"revision\": \"B\",\n    \"ecn_number\": \"ECN-2026-0001\",\n    \"status\": \"EFFECTIVE\"\n  }\n}\n```\n\n---\n\n### 24.3 文档与合规\n\n#### 24.3.1 上传产品合规文件\n\n**接口**: `POST /materials/{material_number}/compliance-docs`\n\n**请求体**:\n```json\n{\n  \"doc_type\": \"ROHS\",  // ROHS, REACH, MSDS\n  \"effective_from\": \"2026-03-01\",\n  \"file_url\": \"https://files.example.com/compliance/rohsmat001.pdf\"\n}\n```\n\n**响应** (201 Created):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"material_number\": \"MAT-001\",\n    \"doc_type\": \"ROHS\",\n    \"status\": \"ACTIVE\"\n  }\n}\n```\n\n---\n\n## 25. 供应链金融与资金管理 API (FSCM / TRM)\n\n**Base URL**: `https://api.erp.example.com/finance-ext/v1`\n\n### 25.1 信用管理\n\n#### 25.1.1 信用额度检查\n\n**接口**: `POST /credit-checks`\n\n**请求体**:\n```json\n{\n  \"customer_id\": \"cust-12345\",\n  \"order_gross_value\": 110175.00,\n  \"currency\": \"CNY\",\n  \"exposure_before\": 500000.00\n}\n```\n\n**响应** (200 OK):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"passed\": true,\n    \"credit_limit\": 1000000.00,\n    \"exposure_after\": 610175.00,\n    \"decision_code\": \"AUTO_APPROVED\"\n  }\n}\n```\n\n---\n\n### 25.2 催收与争议\n\n#### 25.2.1 发起催收案例\n\n**接口**: `POST /collections`\n\n**请求体**:\n```json\n{\n  \"customer_id\": \"cust-12345\",\n  \"invoice_number\": \"INV-2025-009876\",\n  \"overdue_days\": 15,\n  \"amount_due\": 53675.00,\n  \"currency\": \"CNY\",\n  \"priority\": \"MEDIUM\"\n}\n```\n\n**响应** (201 Created):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"collection_case_id\": \"col-2025-0001\",\n    \"status\": \"OPEN\",\n    \"next_action_due\": \"2025-12-27\"\n  }\n}\n```\n\n---\n\n#### 25.2.2 创建争议案例\n\n**接口**: `POST /disputes`\n\n**请求体**:\n```json\n{\n  \"invoice_number\": \"INV-2025-009876\",\n  \"reason_code\": \"PRICE_DISCREPANCY\",\n  \"disputed_amount\": 1000.00,\n  \"currency\": \"CNY\",\n  \"description\": \"折扣未按约定执行\"\n}\n```\n\n**响应** (201 Created):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"dispute_id\": \"disp-2025-0001\",\n    \"status\": \"OPEN\",\n    \"assigned_to\": \"fin-collector-01\"\n  }\n}\n```\n\n---\n\n### 25.3 资金与现金管理 (TRM)\n\n#### 25.3.1 现金流预测\n\n**接口**: `POST /cash-forecasts`\n\n**请求体**:\n```json\n{\n  \"forecast_horizon_days\": 30,\n  \"company_code\": \"1000\",\n  \"currency\": \"CNY\",\n  \"include_ar\": true,\n  \"include_ap\": true,\n  \"include_payroll\": true\n}\n```\n\n**响应** (200 OK):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"forecast_id\": \"cf-2025-0001\",\n    \"horizon_days\": 30,\n    \"total_inflows\": 12000000.00,\n    \"total_outflows\": 8500000.00,\n    \"net_position\": 3500000.00,\n    \"currency\": \"CNY\",\n    \"generated_at\": \"2025-12-22T12:00:00Z\"\n  }\n}\n```\n\n---\n\n#### 25.3.2 资金交易登记\n\n**接口**: `POST /treasury-deals`\n\n**请求体**:\n```json\n{\n  \"deal_type\": \"FX_SPOT\",  // FX_SPOT, FX_FORWARD, MM_DEPOSIT, MM_LOAN\n  \"counterparty\": \"BANK-ICBC\",\n  \"trade_date\": \"2025-12-22\",\n  \"value_date\": \"2025-12-24\",\n  \"buy_currency\": \"USD\",\n  \"sell_currency\": \"CNY\",\n  \"buy_amount\": 1000000.00,\n  \"fx_rate\": 7.10\n}\n```\n\n**响应** (201 Created):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"deal_id\": \"deal-2025-0001\",\n    \"status\": \"CONFIRMED\",\n    \"settlement_instructions\": \"STD-NOSTRO-ICBC\"\n  }\n}\n```\n\n---\n\n## 26. 外部劳务管理 API (Fieldglass)\n\n**Base URL**: `https://api.erp.example.com/contingent/v1`\n\n### 26.1 外包/临时工工单\n\n#### 26.1.1 创建外包需求\n\n**接口**: `POST /work-orders`\n\n**请求体**:\n```json\n{\n  \"title\": \"DevOps 外包工程师\",\n  \"business_unit\": \"IT\",\n  \"location\": \"Beijing-HQ\",\n  \"start_date\": \"2026-01-05\",\n  \"end_date\": \"2026-06-30\",\n  \"supplier_id\": \"V-EXT-001\",\n  \"rate\": 500.00,\n  \"rate_unit\": \"HOUR\",\n  \"max_hours_per_week\": 40,\n  \"cost_center\": \"CC-IT-OPS\"\n}\n```\n\n**响应** (201 Created):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"work_order_id\": \"wo-2026-0001\",\n    \"status\": \"OPEN\",\n    \"supplier_id\": \"V-EXT-001\",\n    \"created_at\": \"2025-12-22T13:00:00Z\"\n  }\n}\n```\n\n---\n\n### 26.2 外包人员与工时\n\n#### 26.2.1 注册外包人员\n\n**接口**: `POST /contingent-workers`\n\n**请求体**:\n```json\n{\n  \"work_order_id\": \"wo-2026-0001\",\n  \"name\": \"李四\",\n  \"email\": \"li.si@vendor.com\",\n  \"role\": \"DevOps Engineer\",\n  \"badge_id\": \"BADGE-9001\",\n  \"access_start\": \"2026-01-05\",\n  \"access_end\": \"2026-06-30\"\n}\n```\n\n**响应** (201 Created):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"contingent_worker_id\": \"cw-2026-0001\",\n    \"status\": \"ACTIVE\",\n    \"badge_id\": \"BADGE-9001\"\n  }\n}\n```\n\n---\n\n#### 26.2.2 外包工时提交\n\n**接口**: `POST /contingent-time-entries`\n\n**请求体**:\n```json\n{\n  \"contingent_worker_id\": \"cw-2026-0001\",\n  \"work_date\": \"2026-01-10\",\n  \"hours\": 8.0,\n  \"project_code\": \"PRJ-ERP-01\",\n  \"approver_id\": \"emp-0100\"\n}\n```\n\n**响应** (201 Created):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"time_entry_id\": \"ct-2026-0001\",\n    \"status\": \"PENDING_APPROVAL\"\n  }\n}\n```\n\n---\n\n## 27. SuccessFactors 云场景 API (绩效/入职/薪酬)\n\n**Base URL**: `https://api.erp.example.com/sf/v1`\n\n### 27.1 绩效与目标 (Performance & Goals)\n\n#### 27.1.1 创建绩效目标\n\n**接口**: `POST /performance/goals`\n\n**请求体**:\n```json\n{\n  \"employee_id\": \"emp-550e8400-e29b-41d4-a716-446655440000\",\n  \"goal_cycle\": \"2026-H1\",\n  \"title\": \"提升客户满意度\",\n  \"description\": \"NPS 提升 5 分\",\n  \"weight\": 0.3,\n  \"due_date\": \"2026-06-30\"\n}\n```\n\n**响应** (201 Created):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"goal_id\": \"goal-2026-0001\",\n    \"status\": \"ACTIVE\",\n    \"created_at\": \"2025-12-22T14:00:00Z\"\n  }\n}\n```\n\n---\n\n### 27.2 入职 (Onboarding)\n\n#### 27.2.1 触发入职流程\n\n**接口**: `POST /onboarding/flows`\n\n**请求体**:\n```json\n{\n  \"employee_id\": \"emp-550e8400-e29b-41d4-a716-446655440000\",\n  \"start_date\": \"2026-01-05\",\n  \"location\": \"Beijing-HQ\",\n  \"tasks\": [\"UPLOAD_ID\", \"IT_ASSET_SETUP\", \"BANK_INFO\"]\n}\n```\n\n**响应** (201 Created):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"onboarding_flow_id\": \"onb-2026-0001\",\n    \"status\": \"IN_PROGRESS\",\n    \"tasks_total\": 3\n  }\n}\n```\n\n---\n\n### 27.3 薪酬 (Compensation)\n\n#### 27.3.1 创建薪酬调整方案\n\n**接口**: `POST /compensation/adjustments`\n\n**请求体**:\n```json\n{\n  \"employee_id\": \"emp-550e8400-e29b-41d4-a716-446655440000\",\n  \"plan_year\": 2026,\n  \"currency\": \"CNY\",\n  \"base_increase_percent\": 5.0,\n  \"lump_sum\": 10000.00,\n  \"reason\": \"年度绩效A档\"\n}\n```\n\n**响应** (200 OK):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"comp_adjustment_id\": \"comp-2026-0001\",\n    \"status\": \"APPROVAL_PENDING\",\n    \"proposed_new_base\": 630000.00\n  }\n}\n```\n\n---\n\n## 28. 房地产管理 API (RE-FX)\n\n**Base URL**: `https://api.erp.example.com/realestate/v1`\n\n### 28.1 合同管理\n\n#### 28.1.1 创建租赁合同\n\n**接口**: `POST /lease-contracts`\n\n**请求体**:\n```json\n{\n  \"contract_number\": null,\n  \"property_id\": \"PROP-001\",\n  \"tenant\": \"ACME Co.\",\n  \"start_date\": \"2026-01-01\",\n  \"end_date\": \"2026-12-31\",\n  \"currency\": \"CNY\",\n  \"base_rent\": 50000.00,\n  \"billing_cycle\": \"MONTHLY\",\n  \"payment_terms\": \"NET30\"\n}\n```\n\n**响应** (201 Created):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"contract_id\": \"lc-2026-0001\",\n    \"contract_number\": \"LC-2026-0001\",\n    \"status\": \"ACTIVE\"\n  }\n}\n```\n\n---\n\n### 28.2 租金结算\n\n**接口**: `POST /lease-contracts/{contract_number}/billing`\n\n**请求体**:\n```json\n{\n  \"period\": \"2026-02\",\n  \"service_charges\": 3000.00,\n  \"tax_code\": \"VAT6\"\n}\n```\n\n**响应** (201 Created):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"invoice_number\": \"RE-INV-2026-0001\",\n    \"gross_amount\": 56000.00,\n    \"currency\": \"CNY\",\n    \"due_date\": \"2026-03-02\"\n  }\n}\n```\n\n---\n\n## 29. 车队管理 API (FM)\n\n**Base URL**: `https://api.erp.example.com/fleet/v1`\n\n### 29.1 车辆主数据\n\n**接口**: `POST /vehicles`\n\n**请求体**:\n```json\n{\n  \"vin\": \"LJ1234567890\",\n  \"plate_number\": \"京A12345\",\n  \"vehicle_type\": \"TRUCK\",\n  \"purchase_date\": \"2024-05-01\",\n  \"fuel_type\": \"DIESEL\",\n  \"cost_center\": \"CC-LOG-01\"\n}\n```\n\n**响应** (201 Created):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"vehicle_id\": \"veh-2025-0001\",\n    \"status\": \"ACTIVE\"\n  }\n}\n```\n\n---\n\n### 29.2 维修与保养\n\n**接口**: `POST /vehicles/{vehicle_id}/maintenance`\n\n**请求体**:\n```json\n{\n  \"service_date\": \"2025-12-25\",\n  \"service_type\": \"PREVENTIVE\",  // PREVENTIVE, CORRECTIVE\n  \"odometer\": 80000,\n  \"workshop\": \"WS-BJ-01\",\n  \"cost\": 2500.00,\n  \"currency\": \"CNY\"\n}\n```\n\n**响应** (201 Created):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"maintenance_id\": \"vehm-2025-0001\",\n    \"vehicle_id\": \"veh-2025-0001\",\n    \"next_service_due_km\": 90000\n  }\n}\n```\n\n---\n\n### 29.3 油耗记录\n\n**接口**: `POST /vehicles/{vehicle_id}/fuel-consumptions`\n\n**请求体**:\n```json\n{\n  \"fill_date\": \"2025-12-20\",\n  \"volume\": 80,\n  \"unit\": \"L\",\n  \"cost\": 720.00,\n  \"currency\": \"CNY\",\n  \"odometer\": 79500\n}\n```\n\n**响应** (201 Created):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"fuel_id\": \"fu-2025-0001\",\n    \"avg_consumption_l_per_100km\": 10.5\n  }\n}\n```\n\n---\n\n## 30. 技术平台与集成附录\n\n- **API Gateway/Fiori Launchpad**：统一网关前置认证、路由和流控；UI5/Fiori 前端通过 OData/REST 调用业务服务。\n- **BI/BW 报表输出**：通过异步任务导出到对象存储，返回 `report_url` 与有效期；对接外部 BI 时提供预签名 URL。\n- **事件/回调安全**：回调请求携带 `X-Signature` (HMAC-SHA256) 与 `timestamp`，服务端需验证防重放。\n\n---\n\n## 31. 新增模块错误码与权限补充\n\n### 31.1 错误码补充\n\n| 范围 | 错误码 | HTTP | 说明 |\n|------|--------|------|------|\n| PS | WBS_NOT_FOUND | 404 | WBS 不存在或未发布 |\n| PS | BUDGET_EXCEEDED | 422 | 成本过账超预算 |\n| PS | MILESTONE_NOT_FOUND | 404 | 里程碑不存在 |\n| PLM | ECN_ALREADY_ACTIVE | 409 | 工程变更已生效或重复提交 |\n| PLM | BOM_REVISION_CONFLICT | 409 | 同一版本号已存在 |\n| PLM | COMPLIANCE_DOC_MISSING | 422 | 合规文件缺失 |\n| FSCM | CREDIT_CHECK_FAILED | 403 | 信用检查失败 |\n| FSCM | COLLECTION_CLOSED | 409 | 催收案例已关闭 |\n| TRM | FX_RATE_MISSING | 422 | 缺少汇率或曲线 |\n| TRM | DEAL_INCONSISTENT | 422 | 交易参数不一致（买卖币种/金额） |\n| Fieldglass | WORK_ORDER_CLOSED | 409 | 工单已关闭，禁止新增人员/工时 |\n| Fieldglass | HOURS_EXCEED_LIMIT | 422 | 工时超过上限或重复提交 |\n| RE-FX | LEASE_OVERLAP | 422 | 合同期间与现有合同重叠 |\n| RE-FX | PROPERTY_NOT_FOUND | 404 | 物业不存在 |\n| FM | VEHICLE_NOT_FOUND | 404 | 车辆不存在 |\n| FM | ODOMETER_ROLLBACK | 422 | 里程表回退，需人工校验 |\n| SuccessFactors | GOAL_CYCLE_CLOSED | 409 | 目标周期已关闭 |\n| SuccessFactors | COMP_APPROVAL_REQUIRED | 403 | 薪酬需审批后才能生效 |\n| SuccessFactors | ONBOARDING_TASK_INVALID | 422 | 入职任务标识无效 |\n\n### 31.2 权限矩阵增补\n\n| 角色 | 关键接口 | 说明 |\n|------|---------|------|\n| `PROJECT_MANAGER` | 23.x 项目/WBS/里程碑 | 项目创建、WBS维护 |\n| `PROJECT_CONTROLLER` | 23.4 成本过账 | 预算/成本控制 |\n| `ENGINEERING` | 24.x ECN/BOM/文档 | 工程变更与BOM修订 |\n| `PLM_CONTROLLER` | 24.x 审批 | 合规与版本发布 |\n| `CREDIT_MANAGER` | 25.1 信用检查 | 额度审批 |\n| `COLLECTION_AGENT` | 25.2 催收/争议 | 应收催收 |\n| `TREASURY_USER` | 25.3 资金交易/预测 | 资金前台/中台 |\n| `FIELDGLASS_MANAGER` | 26.x 工单/人员/工时 | 外包管理 |\n| `REAL_ESTATE_MANAGER` | 28.x 合同/结算 | 房地产合同与结算 |\n| `FLEET_MANAGER` | 29.x 车辆/维保/油耗 | 车队管理 |\n| `HR_COMPENSATION` | 27.3 薪酬调整 | 薪酬方案审批 |\n\n## 32. 回调签名与重放防护示例\n\n- 请求头：\n  - `X-Signature`: `HMAC-SHA256(secret, timestamp + \"\\n\" + path + \"\\n\" + body_sha256)`\n  - `X-Timestamp`: Unix epoch (seconds)\n  - `X-Request-Id`: 唯一请求ID\n- 验证流程（伪代码）：\n```text\nassert abs(now - X-Timestamp) < 300s\nbody_hash = sha256(request_body)\nexpected = hmac_sha256(secret, f\"{X-Timestamp}\\n{request_path}\\n{body_hash}\")\nassert hmac_compare(expected, X-Signature)\n```\n- 对支持回调的异步任务（报关申报、MRP、报表、RFQ授标、资金交易结算）均可启用；如失败应返回 5xx 让调用方重试。\n\n---\n\n## 33. 业务规划与合并 API (BPC)\n\n**Base URL**: `https://api.erp.example.com/bpc/v1`\n\n### 33.1 计划版本\n\n**接口**: `POST /plan-versions`\n\n**请求体**:\n```json\n{\n  \"plan_id\": \"PLAN-FY2026\",\n  \"description\": \"FY2026 预算版本\",\n  \"currency\": \"CNY\",\n  \"time_bucket\": \"MONTH\",\n  \"copy_from\": \"PLAN-FY2025-ACTUAL\"  // 可选\n}\n```\n\n**响应** (201 Created):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"plan_version\": \"PLAN-FY2026\",\n    \"status\": \"OPEN\",\n    \"created_at\": \"2025-12-22T15:00:00Z\"\n  }\n}\n```\n\n---\n\n### 33.2 提交预算数据\n\n**接口**: `POST /plan-versions/{plan_version}/lines`\n\n**请求体**:\n```json\n{\n  \"cost_center\": \"CC-IT-01\",\n  \"account\": \"610000\",\n  \"period\": \"2026-01\",\n  \"amount\": 200000,\n  \"currency\": \"CNY\",\n  \"comment\": \"研发支出\"\n}\n```\n\n**响应** (200 OK):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"plan_version\": \"PLAN-FY2026\",\n    \"line_id\": \"bpc-line-001\",\n    \"status\": \"SAVED\"\n  }\n}\n```\n\n---\n\n### 33.3 合并运行\n\n**接口**: `POST /consolidations`\n\n**请求体**:\n```json\n{\n  \"consol_id\": \"CONSOL-FY2026-Q1\",\n  \"scope\": [\"COMPANY-1000\", \"COMPANY-2000\"],\n  \"plan_version\": \"PLAN-FY2026\",\n  \"currency\": \"CNY\",\n  \"elimination_rules\": [\"INTERCO-SALES\", \"INTERCO-AR\"],\n  \"callback_url\": \"https://hooks.example.com/bpc\"\n}\n```\n\n**响应** (202 Accepted):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"task_id\": \"bpc-task-0001\",\n    \"status\": \"PROCESSING\",\n    \"status_url\": \"/bpc/v1/tasks/bpc-task-0001\"\n  }\n}\n```\n\n---\n\n## 34. 分析与报表 API (SAC/BW)\n\n**Base URL**: `https://api.erp.example.com/analytics/v1`\n\n### 34.1 数据集导入\n\n**接口**: `POST /datasets`\n\n**请求体**:\n```json\n{\n  \"dataset_name\": \"sales_monthly\",\n  \"description\": \"月度销售汇总\",\n  \"schema\": [\n    {\"name\": \"period\", \"type\": \"STRING\"},\n    {\"name\": \"sales_org\", \"type\": \"STRING\"},\n    {\"name\": \"gross_value\", \"type\": \"NUMBER\"}\n  ],\n  \"source\": \"sales-service\",\n  \"callback_url\": \"https://hooks.example.com/analytics\"\n}\n```\n\n**响应** (202 Accepted):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"dataset_id\": \"ds-2025-0001\",\n    \"upload_url\": \"https://storage.example.com/upload/ds-2025-0001\",\n    \"status\": \"WAITING_UPLOAD\"\n  }\n}\n```\n\n---\n\n### 34.2 报表生成/导出\n\n**接口**: `POST /reports`\n\n**请求体**:\n```json\n{\n  \"report_name\": \"sales-pivot\",\n  \"dataset_id\": \"ds-2025-0001\",\n  \"format\": \"PDF\",\n  \"filters\": {\n    \"period_from\": \"2025-01\",\n    \"period_to\": \"2025-12\"\n  }\n}\n```\n\n**响应** (202 Accepted):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"task_id\": \"anl-task-0001\",\n    \"status\": \"PROCESSING\",\n    \"status_url\": \"/analytics/v1/tasks/anl-task-0001\"\n  }\n}\n```\n\n---\n\n## 35. 集成与中台 API (PI/PO/CPI)\n\n**Base URL**: `https://api.erp.example.com/integration/v1`\n\n### 35.1 注册接口\n\n**接口**: `POST /interfaces`\n\n**请求体**:\n```json\n{\n  \"name\": \"ARIBA-PO-INBOUND\",\n  \"direction\": \"INBOUND\",\n  \"protocol\": \"HTTPS\",\n  \"mapping\": \"XSLT-PO-1.0\",\n  \"target_service\": \"purchase-orders\",\n  \"retry_policy\": \"EXPONENTIAL_BACKOFF\"\n}\n```\n\n**响应** (201 Created):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"interface_id\": \"if-2025-0001\",\n    \"status\": \"ACTIVE\"\n  }\n}\n```\n\n---\n\n### 35.2 发送消息（异步）\n\n**接口**: `POST /messages`\n\n**请求体**:\n```json\n{\n  \"interface_id\": \"if-2025-0001\",\n  \"payload\": \"<PurchaseOrder>...</PurchaseOrder>\",\n  \"content_type\": \"application/xml\"\n}\n```\n\n**响应** (202 Accepted):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"message_id\": \"msg-2025-0001\",\n    \"status\": \"QUEUED\"\n  }\n}\n```\n\n---\n\n### 35.3 映射测试\n\n**接口**: `POST /interfaces/{interface_id}/mappings/test`\n\n**请求体**:\n```json\n{\n  \"payload\": \"<PurchaseOrder>...</PurchaseOrder>\",\n  \"mapping\": \"XSLT-PO-1.0\"\n}\n```\n\n**响应** (200 OK):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"output_sample\": \"<MappedPO>...</MappedPO>\",\n    \"warnings\": []\n  }\n}\n```\n\n---\n\n## 36. IoT 与资产智能 API (IoT/AIN)\n\n**Base URL**: `https://api.erp.example.com/iot/v1`\n\n### 36.1 设备注册\n\n**接口**: `POST /devices`\n\n**请求体**:\n```json\n{\n  \"device_id\": \"COMP-BJ-001\",\n  \"type\": \"IndustrialCompressor\",\n  \"location\": {\n    \"latitude\": 39.9042,\n    \"longitude\": 116.4074\n  },\n  \"thing_model\": \"IndustrialCompressor-v1\"\n}\n```\n\n**响应** (201 Created):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"device_id\": \"COMP-BJ-001\",\n    \"status\": \"ACTIVE\",\n    \"registration_token\": \"iot-token-123\"\n  }\n}\n```\n\n---\n\n### 36.2 遥测上报\n\n**接口**: `POST /devices/{device_id}/telemetry`\n\n**请求体**:\n```json\n{\n  \"timestamp\": \"2025-12-22T14:00:00Z\",\n  \"metrics\": {\n    \"outletTemperature\": 88.0,\n    \"vibrationRms\": 7.8,\n    \"dischargePressure\": 7.9,\n    \"motorCurrent\": 175.0\n  }\n}\n```\n\n**响应** (202 Accepted):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"ingest_id\": \"ing-2025-0001\",\n    \"status\": \"QUEUED\"\n  }\n}\n```\n\n---\n\n### 36.3 告警创建\n\n**接口**: `POST /alerts`\n\n**请求体**:\n```json\n{\n  \"device_id\": \"COMP-BJ-001\",\n  \"severity\": \"WARNING\",\n  \"rule_code\": \"HIGH_TEMP\",\n  \"message\": \"压缩机出口温度过高\",\n  \"recommended_action\": \"检查冷却系统\",\n  \"create_pm_order\": true\n}\n```\n\n**响应** (201 Created):\n```json\n{\n  \"success\": true,\n  \"data\": {\n    \"alert_id\": \"alt-2025-0001\",\n    \"status\": \"OPEN\",\n    \"linked_pm_order\": \"MO-2025-000322\"\n  }\n}\n```\n\n---\n\n## 37. 新增模块错误码与权限补充（BPC/Analytics/Integration/IoT）\n\n### 37.1 错误码补充\n\n| 范围 | 错误码 | HTTP | 说明 |\n|------|--------|------|------|\n| BPC | PLAN_VERSION_LOCKED | 409 | 计划版本已锁定 |\n| BPC | CONSOL_SCOPE_INVALID | 422 | 合并范围无效或缺实体 |\n| Analytics | DATASET_SCHEMA_MISMATCH | 422 | 数据集模式不匹配 |\n| Analytics | REPORT_TEMPLATE_NOT_FOUND | 404 | 报表模板不存在 |\n| Integration | INTERFACE_INACTIVE | 409 | 接口未激活 |\n| Integration | MAPPING_ERROR | 422 | 映射转换错误 |\n| Integration | MESSAGE_RETRY_EXCEEDED | 429 | 消息重试超限 |\n| IoT | DEVICE_NOT_FOUND | 404 | 设备未注册 |\n| IoT | TELEMETRY_SCHEMA_MISMATCH | 422 | 遥测字段/类型不匹配 |\n| IoT | ALERT_RULE_NOT_FOUND | 404 | 告警规则不存在 |\n\n### 37.2 权限矩阵增补\n\n| 角色 | 关键接口 | 说明 |\n|------|---------|------|\n| `BPC_PLANNER` | 33.x 计划/行提交 | 预算/计划录入 |\n| `BPC_CONSOLIDATOR` | 33.3 合并运行 | 触发合并、查看结果 |\n| `ANALYTICS_AUTHOR` | 34.x 数据集/报表 | 数据集创建、报表生成 |\n| `INTEGRATION_ADMIN` | 35.x 接口注册/消息 | 接口生命周期与监控 |\n| `IOT_OPERATOR` | 36.x 设备/遥测/告警 | IoT 运营管理 |\n\n### 37.3 异步任务回调对齐\n\n- BPC 合并、Analytics 报表、Integration 消息发送、IoT 遥测/告警的回调统一使用第 32 章签名规范。\n- 建议对回调启用 5xx 重试与幂等校验（`Idempotency-Key`），防止重复处理。\n\n---\n\n**文档版本**: v1.9\n**最后更新**: 2025-12-22\n**维护者**: ERP 开发团队\n", "md/Rust-BOM.md": "# Rust 替代 KILLER 系统开发清单（非 MVP 版）\n\n> 用 Rust 微服务完整替代 KILLER 的开发波次与模块级交付清单。顺序基于《README-项目文档导航.md》里的文档依赖（先读架构/计划/模块列表），覆盖架构设计文档 2.2 的 15 个服务并补充主数据与平台层。\n\n## 开发波次与顺序\n| 序号 | 模块/服务 | 覆盖的 KILLER 范围 | 主要依赖 | 关键输出 |\n|-----|-----------|-----------------|----------|----------|\n| 0 | 平台与主数据治理（MDG/GRC/IAM） | 主数据、身份、组织、合规 | 基础设施 | API 网关、统一身份、业务伙伴/物料/科目主数据、审计与权限 |\n| 1 | 财务会计 FI | FI-GL/AP/AR/AA/BL/LC/TV | 0 | 会计科目表、凭证处理、月结/年结、税务与多币种 |\n| 2 | 资金与财务供应链 TR/FSCM | TR-CM/TM/MRM、FSCM-CR/CM/DM/BRF | 1 | 现金池与头寸、流动性预测、信用/催收/争议、对冲与定价、付款运行 |\n| 3 | 管理会计 CO | CO-OM/CCA/OPA/ABC、CO-PC/PCP/OBJ/ACT、CO-PA | 1 | 成本中心/要素、内部订单、标准成本/实际成本、获利分析 |\n| 4 | 物料与采购 MM | MM-PUR/RFQ/PO/CON、MM-IM/GR/GI/PI、MM-IV、MM-CBP | 0,1 | 采购到付款流程、库存流水、发票三单匹配、补货策略 |\n| 5 | 销售与分销 SD | SD-BF/MD/SLS/SHP/BIL/CAS | 4,1 | 报价/订单、定价引擎、交付/装运、开票、信用检查 |\n| 6 | 生产计划 PP | PP-BD/SOP/MPS/MRP/CRP/SFC/PI、PP/DS | 4,5,3 | BOM/工艺路线、主生产计划、MRP、产能/排程、车间执行 |\n| 7 | 仓储管理 WM/EWM | WM-IM/LT/RF、EWM Labor/Slotting/Yard/Cross-Docking/VAS/Wave | 4,6 | 库位/波次/库内作业、RF 作业、越库/增值服务、场站管理 |\n| 8 | 运输管理 TM | TM-PLN/FRE/MON | 5,7 | 运输计划、承运商协同、运费结算、在途跟踪 |\n| 9 | 质量管理 QM | QM-PT/QI/CA/QN | 4,6,7 | 检验计划、检验批/结果、质量通知、质量证书、SPC |\n| 10 | 设备维护 PM | PM-EQM/WOC/PRM/IS | 4,6,3 | 设备台账、维护计划、工单流转、备件管理、成本归集 |\n| 11 | 供应链计划 SCM/IBP | IBP S&OP/Demand/Supply/Inventory/Response | 5,6,7 | 需求/供应计划、库存优化、响应与供应、共识计划 |\n| 12 | 项目系统 PS | PS-BD/PLN/EXE/REV | 1,3 | WBS/网络、预算与承诺、进度/成本控制、收入确认 |\n| 13 | 人力资本 HCM | PA/OM/PD/TM/PY/BN、ESS/MSS、SuccessFactors | 0,1 | 组织与职位、考勤、薪资核算、福利、绩效/招聘/培训 |\n| 14 | 客户关系与服务 CRM/CX | CRM、C4C/CX Sales/Service/Marketing/Commerce、FSM | 5,7 | 客户主数据、商机/活动、服务工单/现场服务、全渠道交互 |\n| 15 | 分析与报表 BI/BW | BW/4HANA、SAC、数据仓库/报表 | 1-14 | 主题域数据仓库、语义模型、财务/供应链/HR/CRM 报表与仪表盘 |\n\n## 模块开发清单\n\n### 0. 平台与主数据治理（MDG/GRC/IAM）\n- 领域范围：业务伙伴（客户/供应商）、物料主数据、科目表、组织与成本/利润中心、税码/币种/UoM、角色与职责分离。\n- 业务能力：主数据建模/版本/审批、重复检测与合并、批量导入与变更日志、数据质量规则、跨服务事件分发、参考数据服务（枚举/代码表）。\n- 平台能力：统一身份/SSO、RBAC/ABAC、API 网关、配置中心、审计追踪、加密与密钥管理、日志/指标/追踪基线。\n- 数据集成：初始数据迁移管道、与 FI/MM/SD/HR 的主数据同步、主数据订阅与缓存、主数据变更溯源。\n- 测试与验收：主数据全量/增量对账、权限模型渗透测试、数据质量 KPI（唯一性、完整性、一致性）、高可用/备份恢复演练。\n\n### 1. 财务会计（FI）\n- 领域范围：FI-GL、应收应付、固定资产、银行分类账、差旅、合并。\n- 业务能力：多会计准则与多币种账簿、凭证录入与过账、自动分录模板、期间/年度结账、税务与预提、资产生命周期/折旧、支付运行与催款。\n- 数据与集成：与 MM/SD 对账（GR/IR、开票）、与 TR 共享银行与现金流水、与 HR 工资分录、外部报税接口。\n- 报表：资产负债表、利润表、现金流量表、账龄、税务申报、审计日志/凭证影像。\n- 控制与合规：审批流、权限分离、影像归档、对账差异处理、审计可追溯性、会计政策配置。\n- 测试与迁移：平行账簿双账验证、期初余额导入、关账性能（批量结账）、支付批次演练。\n\n### 2. 资金与财务供应链（TR/FSCM）\n- 领域范围：现金管理、流动性计划、交易管理（外汇/利率/衍生品）、信用管理、催收、争议处理、直接计费。\n- 业务能力：现金池与资金集中、头寸管理、银行对账、付款工厂、信用额度/评分、催收策略、争议案件生命周期、市场数据定价、套期会计。\n- 集成：与 FI 共享银行账户/过账、与 AR/AP 付款/收款、接口银行/Swift/银企直连、风险指标推送至 BI。\n- 报表与监控：流动性预测、现金流滚动、信用暴露、对冲效果评估、DSO/DPO。\n- 合规：限额与审批、职责分离、交易日志留存、KYC/AML 钩子。\n\n### 3. 管理会计（CO）\n- 领域范围：成本中心/要素、内部订单、作业成本法、产品成本控制（计划/实际）、盈利能力分析（CO-PA）。\n- 业务能力：标准成本/实际成本核算、分摊/分配/分摊循环、成本对象控制、WIP/差异结转、利润中心分析。\n- 集成：与 FI 过账、与 PP/SD/PM 取成本、与 PS/HR 的成本归集、成本与利润维度对齐。\n- 报表：成本中心/内部订单报表、成本差异分析、盈利能力分段（客户/产品/渠道）。\n- 控制：版本与预算控制、成本锁定策略、结算规则配置、结算批处理监控。\n\n### 4. 物料与采购（MM）\n- 领域范围：寻源/RFQ、采购申请/订单/合同、供应商管理、库存管理（GR/GI/转储/盘点）、发票校验、消耗型补货。\n- 业务能力：采购到付款全链路、价格与条件合同、三单匹配、批次/序列号、质量阻断库存、寄售/委外、自动补货策略。\n- 集成：与 FI/CO 过账、与 QM 质检、与 WM/EWM 库内作业、与 SRM/Ariba 的目录/PO/发票接口。\n- 报表：采购周期/准时率、供应商评分、库存周转/安全库存、价格变动分析。\n- 控制：审批流、分段权限、供应商资质与黑名单、采购限制（金额/品类）、盘点差异处理。\n\n### 5. 销售与分销（SD）\n- 领域范围：主数据（客户/物料/定价）、询价/报价/销售订单、交付/装运、计费/开票、信用检查、销售支持。\n- 业务能力：多层定价/折扣/促销、可承诺量/可供日期（ATP）、分销渠道与合作伙伴模型、退货/换货、部分发货与部分开票、对账单与收款对照。\n- 集成：与 MM 库存与出库、与 FI/CO 开票与收入确认、与 TM/WM 配送、与 CRM 营销/服务。\n- 报表：销售漏斗、订单履约率、毛利/净利、信用暴露、退货率。\n- 控制：审批、信用限额、价格保护、税务与合规校验、电子发票接口。\n\n### 6. 生产计划（PP）\n- 领域范围：BOM/工艺路线、S&OP、主生产计划、MRP、产能计划、车间执行、流程工业（批次/配方）、高级排程（PP/DS）。\n- 业务能力：需求驱动/库存驱动计划、MRP 运算与例外、生产订单/工单、派工与反馈、批次管理与追溯、替代料/并行/交叉工序、排程约束（产能/物料/工具）。\n- 集成：与 MM/SD 需求、与 CO 成本核算、与 QM/PM 检验与维护、与 WM/EWM 领料/回库。\n- 报表：计划达成率、生产周期、在制品、工序效率、物料齐套率。\n- 控制：版本化 BOM/工艺、变更管理、锁定规则、生产审批/签字、异常处置流程。\n\n### 7. 仓储管理（WM/EWM）\n- 领域范围：库存地点/库位、上架/拣货/移库、波次/任务管理、RF/条码、越库、增值服务、库位优化/Slotting、劳动力管理、场站管理。\n- 业务能力：入库（PO/生产/退货）、出库（销售/生产领料/调拨）、波次/批次策略、托盘/包装、RF 作业指引、装卸/门禁、越库与直通流程。\n- 集成：与 MM/SD/PP/PM 的库存交易、与 TM 装运、与 QM 检验点、与设备/自动化接口（可选）。\n- 报表：库龄、拣货效率、盘点差异、场站吞吐、劳动力利用率。\n- 控制：作业分配策略、权限到仓/库位、异常库存隔离、安全/合规检查。\n\n### 8. 运输管理（TM）\n- 领域范围：运输计划、承运商协同、运价与合同、运费结算、在途监控。\n- 业务能力：路线/装载优化、多段多式联运、承运商招投标与分配、运价计算、提/派车、签收与 POD、异常与索赔、碳排放核算。\n- 集成：与 SD/WM 交付、与 FI 结算、与外部 TMS/承运商 API、地图/轨迹服务。\n- 报表：运输成本、准时率、装载率、异常率、碳排放。\n- 控制：运价版本、审批、黑名单承运商、GPS/事件签名校验。\n\n### 9. 质量管理（QM）\n- 领域范围：质检计划、检验批与结果、质量通知、质量证书、统计过程控制。\n- 业务能力：来料/过程/出货/库存转移检验，取样方案与判定规则，缺陷记录与处置，质量阻断与放行，证书生成与回溯。\n- 集成：与 MM/WM 入库检验、与 PP 在制检验、与 SD 出货检验、与 PM 质量反馈、与供应商/客户门户共享质量数据。\n- 报表：合格率、缺陷趋势、供应商质量、成本（COPQ）、SPC 控制图。\n- 控制：检验版本、审批与签字、批次追溯、CAPA 闭环。\n\n### 10. 设备维护（PM）\n- 领域范围：设备与功能位置、维护计划/策略、通知与工单、预防性/预测性维护、备件与工时。\n- 业务能力：故障/预防/改造工单流程，维护包与计划排程，备件需求与领用，计量点与抄表，成本归集与结算。\n- 集成：与 MM/WM 备件、与 CO/FI 成本、与 QM 质量反馈、与 IoT/传感器（可选）、与 HR 工时。\n- 报表：MTBF/MTTR、计划 vs 实际、备件消耗、停机损失。\n- 控制：审批/锁定、安全许可、技术对象版本与历史、工单审计。\n\n### 11. 供应链计划（SCM/IBP）\n- 领域范围：S&OP、需求计划、供应计划、库存优化、响应与供应。\n- 业务能力：统计/因果/AI 预测、需求协同、分层计划、约束型供应计划、部署与再平衡、库存定位/安全库存、情景与假设分析、供应响应与重计划。\n- 集成：与 SD 需求、与 PP/WM/ TM 执行反馈、与 FI/CO 成本、数据仓库共享计划版本。\n- 报表：预测准确度、履约率、库存周转/缺货率、计划偏差。\n- 控制：计划版本管理、审批、警戒线/例外管理、主数据一致性校验。\n\n### 12. 项目系统（PS）\n- 领域范围：WBS/网络计划、里程碑、预算/承诺、成本/收入、物料/工时。\n- 业务能力：项目模板、预算控制/冻结、采购/生产/工时集成、进度与挣值、收入确认（完工百分比/完工合同）、变更与索赔。\n- 集成：与 FI/CO 成本与结算、与 MM/SD/PP 的需求、与 HR 工时、与 CRM 商机→项目交接。\n- 报表：进度偏差、成本偏差、现金流、里程碑达成、合同毛利。\n- 控制：版本与基线、审批门、授权到 WBS 层、风险登记册。\n\n### 13. 人力资本管理（HCM）\n- 领域范围：组织/职位、员工主数据、时间/考勤、薪资、福利、绩效、招聘/入职、培训、员工/经理自助。\n- 业务能力：合同/异动、排班与加班、薪资核算与分摊、社保/税务、绩效与目标、继任与发展、培训计划、移动/自助入口。\n- 集成：与 FI/CO 薪资分录、与 PS/PM 工时、与门禁/考勤设备、可选对接 SuccessFactors。\n- 报表：员工成本、离职率、出勤率、薪酬结构、培训/绩效指标。\n- 控制：隐私与合规（GDPR 等）、角色隔离、薪资保密、审计与留痕。\n\n### 14. 客户关系与服务（CRM/CX）\n- 领域范围：客户主数据与 360 视图、商机/线索、营销活动、合同、服务请求/工单、现场服务、全渠道（Web/电话/邮件/社交）、电商（可选）。\n- 业务能力：潜客评分、活动编排、报价与合同、SLA 与排班、工单派发与现场服务、知识库、自助门户、退换/保内保外、客户同意与偏好管理。\n- 集成：与 SD 订单/配送、与 FI/CO 账单与应收、与 TM/WM 物流状态、与 HR 排班、与外部渠道/联络中心。\n- 报表：销售漏斗、活动 ROI、客户满意度/CSAT/NPS、服务水平达成、续约/流失。\n- 控制：隐私/同意、通话/聊天记录留存、SLA 配置、多渠道身份统一。\n\n### 15. 分析与报表（BI/BW）\n- 领域范围：企业数据仓库、语义模型、指标与报表、仪表盘、自助分析、数据质量与血缘。\n- 业务能力：主题域数据模型（财务/供应链/生产/HR/CRM）、批/流式 ETL、主数据对齐、历史快照、预算 vs 实际、预构建 KPI 库、权限到指标/列。\n- 集成：从 0-14 模块采集事件与批量数据、与 Kafka/CDC、与外部 BI（SAC/PowerBI）、数据服务 API。\n- 运营：数据质量规则、作业调度与重试、成本与性能优化、容量规划、备份/灾备。\n- 报表交付：法定报表、管理报表、实时运营看板、移动/订阅、异常告警。\n\n---\n- 用法：每个模块在进入开发前，结合《Rust-DDD-微服务架构最佳实践.md》《Rust-ERP系统架构设计文档.md》《Rust-ERP系统API设计文档.md》细化到用例/接口/事件；完成功能、集成、报表、合规与性能验证后再进入下一波次。确保非 MVP 覆盖：业务闭环、合规可用、可观测与运维就绪、数据质量与迁移完成。\n\n## 通用模块交付检查清单（适用于 0-15）\n- 领域与流程：限界上下文、核心用例、状态机/生命周期、异常场景、审批流。\n- 数据模型与元数据：主/交易/参考数据建模，版本与变更，历史快照，数据血缘。\n- API/gRPC 与事件：REST/gRPC 契约、错误码、鉴权/鉴别；领域事件、集成事件、重试/幂等、事件溯源。\n- 规则与工作流：定价/税务/信控/合规模型，规则引擎配置与灰度发布。\n- 集成：跨服务调用矩阵，外部系统接口（银行/税务/物流/设备），批处理与实时链路。\n- 主数据与迁移：对齐 MDG 模式，初始/增量迁移，校验与回滚，双写/只读切换策略。\n- 报表与数据产品：运营报表、法定报表、管理看板，自助分析语义层，数据可见性权限。\n- 权限与合规：RBAC/ABAC、职责分离、审计日志、留存周期、隐私与同意管理。\n- 可观测性与 SRE：指标/日志/追踪基线，SLI/SLO，告警路由，灰度/熔断/限流。\n- 性能与容量：基准与压测场景、容量模型、缓存/分片策略、批处理窗口。\n- 测试策略：单元/契约/集成/端到端/回归，金丝雀数据集，测试数据脱敏。\n- 数据质量：完整性/唯一性/一致性/及时性规则，DQ 告警与补救流程。\n- 运维与自动化：CI/CD、数据库迁移脚本、回滚/热修、作业调度与重试、运行手册。\n- 文档与培训：ADR、接口与事件清单、运维 Runbook、用户手册、培训材料。\n- Cutover 与 Rollout：黑暗发布/灰度/全量切换步骤、回滚方案、业务验收/双轨期支持。\n\n## 首三波次详细任务包\n### 波次 0：平台与主数据治理（MDG/GRC/IAM）\n- 身份与访问：OIDC/OAuth2、单点登录、RBAC/ABAC、职责分离校验、中台级权限缓存。\n- 主数据域：业务伙伴/物料/科目/组织/成本利润中心/币种与税码/UoM；重号检测、合并、版本与审批。\n- 平台基线：API 网关（限流/签名/审计）、配置中心、密钥管理、日志/指标/追踪三件套。\n- 事件与同步：主数据变更事件规范、下游订阅（FI/MM/SD/HR）、幂等与重放、缓存一致性策略。\n- 迁移与质量：初始导入工具、数据质量规则与评分、对账与抽样验收、备份恢复演练。\n\n### 波次 1：财务会计（FI）\n- 账簿与科目表：多会计准则/多币种账簿、科目主数据管理、维度与分段控制。\n- 凭证与过账：凭证模板、分录引擎、税务计算、影像与附件、冲销与调账、期末/年度结账。\n- 子账：AR/AP 账龄、付款条件、催款策略；资产卡片、折旧键、资产转移/报废/减值。\n- 资金接口：与银行/银企直连付款批次、对账单导入；与 TR 的现金池共享。\n- 报表与合规：财务三大表、账龄/税表、审计跟踪、留存策略、合规参数配置。\n- 测试与性能：批量凭证过账性能、关账批处理窗口、付款运行回归、期初余额导入与双账验证。\n\n### 波次 2：资金与财务供应链（TR/FSCM）\n- 现金与流动性：现金池、头寸、预测模型、限额控制、付款工厂配置。\n- 信用与催收：额度模型与评分、授信审批、放行检查、催收策略与工作队列、争议案件闭环。\n- 交易管理：外汇/利率/衍生品交易生命周期、定价与市值、会计处理与套期会计。\n- 集成：与 FI/AP/AR 的付款/收款过账、银行接口（对账/指令/回执）、市场数据源接入。\n- 报表：流动性滚动预测、现金流差异、信用暴露、DSO/DPO、对冲效果。\n- 风控与合规：KYC/AML 钩子、审批与双人复核、日志与留存。\n\n### 波次 3：管理会计（CO）\n- 成本建模：成本中心/要素主数据、内部订单模板、活动类型与作业率、版本与期间控制。\n- 标准成本：成本估算、BOM/工艺取数、标准价发布、成本组件拆分、替代料与成本核算变式。\n- 实际成本与结算：作业分配/分摊/分配循环、成本对象控制、在制品与差异、结算规则（FI/CO/PS/资产）。\n- 盈利能力分析：CO-PA 维度模型（客户/产品/区域/渠道）、盈利性分段、报告配置、与 FI/SD 对齐。\n- 集成：与 PP/SD/PM 的成本取数，与 FI 凭证一致性校验，与 PS/HR 工时分摊。\n- 绩效与测试：月结批处理性能、差异计算正确性、利润中心与 CO-PA 对账、版本锁与回滚。\n\n### 波次 4：物料与采购（MM）\n- 寻源与采购：供应商主数据/资格、RFQ/报价、采购申请→订单→合同，价格条件与有效期，招投标可选。\n- 库存与仓储接口：GR/GI/转储、批次/序列号、质量阻断、盘点/差异、寄售/委外流程。\n- 发票与三单匹配：PO/收货/发票自动匹配，容差规则，未清项处理，借贷调整。\n- 补货策略：消耗型补货、再订货点、VMI/寄售、计划交期与供应商绩效。\n- 集成：与 FI/CO 过账，与 QM 检验触发，与 WM/EWM/PP 的库存与领退料，与 Ariba/SRM 接口可选。\n- 报表：采购周期/准时率、价格变动、供应商评分、库存周转与安全库存、发票差异。\n\n### 波次 5：销售与分销（SD）\n- 主数据与定价：客户/物料/合作伙伴角色、定价条件/折扣/促销、税务与信用检查前置。\n- 订单全链路：询价/报价/销售订单、可承诺量/可供日期（ATP）、部分发货/部分开票、退换/拒收。\n- 交付与装运：拣配/包装/装运单、发运与签收、对接 TM/WM/EWM，运费计费与分摊。\n- 计费与对账：开票类型（发票/贷项/借项/预收）、对账单、收款对照，收入确认入口。\n- 集成：与 FI/CO 开票与收入确认、与 TM 运费、与 CRM/CX 商机→订单、与库存与生产的可用性。\n- 报表与控制：履约率、毛利/净利、信用暴露、退货率，审批与价格保护、税务与电子发票接口。\n\n### 波次 6：生产计划（PP）\n- 主数据：BOM/工艺路线/工作中心/能力类别，替代料、并行/交叉工序，版本与变更控制。\n- 计划与排程：S&OP 对接、主生产计划、MRP 运算与异常、能力需求计划、PP/DS 高级排程。\n- 执行：生产订单/工单、派工/报工、报废与返工、产出与副产品、批次追溯、看板/拉动（可选）。\n- 物料与成本：领料/退料、回库、替代料；与 CO 成本对象、标准/实际成本链接。\n- 质量与维护接口：在制检验触发 QM，设备与工装可用性对接 PM，异常与停机反馈。\n- 报表：计划达成率、在制品、工序效率、齐套率、产能利用；控制：锁单/审批、版本化、异常处置。\n\n### 波次 7：仓储管理（WM/EWM）\n- 库位与主数据：仓库/库位/HU/包装规格、波次模板、作业类型与策略、Slotting 规则。\n- 作业与任务：收货上架、拣货/集货/包装、移库、盘点，RF/条码作业指引，波次与任务分配。\n- 进出流程：越库、交叉转运、增值服务（VAS）、场站/门禁/排队、装卸与发运交接。\n- 集成：与 MM/SD/PP/PM/QM 的业务事件，与 TM 运输计划/装运，对接自动化设备接口（可选）。\n- 绩效与可观测：库龄/拣货效率/波次完成率/盘点差异，任务 SLA 告警；安全/权限到仓/库位。\n\n### 波次 8：运输管理（TM）\n- 计划与优化：路线/装载优化，多段/多式联运，订单整合与拆分，约束（时间窗/容量/成本）。\n- 承运商协同：招投标/分配、运价与合同、绩效与黑名单、电子回单与 POD。\n- 执行与结算：派车/调度、在途跟踪、异常/索赔、运费计算与分摊、对接 FI 结算。\n- 集成：与 SD/WM 装运单、与地图/轨迹服务、与外部 TMS/承运商 API。\n- 报表：运输成本/准时率/装载率/异常率/碳排放；控制：运价版本、审批、事件签名校验。\n\n### 波次 9：质量管理（QM）\n- 计划与采样：检验计划、特性与限度、采样方案、检验点与触发。\n- 执行与结果：检验批、缺陷记录、判定与处置、阻断与放行、质量证书生成。\n- 通知与CAPA：质量通知、根因分析、纠正预防措施闭环，与供应商/客户反馈接口。\n- 集成：与 MM/WM 入库检验、PP 在制检验、SD 出货检验、PM 质量反馈。\n- 报表：合格率、缺陷趋势、供应商质量、SPC 控制图、COPQ；控制：签字与审批、批次追溯。\n\n### 波次 10：设备维护（PM）\n- 技术对象：设备/功能位置/装置结构，计量点与抄表，版本与历史。\n- 维护策略：预防性计划、计划包与生成规则、预测性维护（可与 IoT 接入）、安全许可与票据。\n- 通知与工单：故障/改造/预防工单，计划/排程、工时与备件、验收与关闭。\n- 集成：与 MM/WM 备件、与 CO/FI 成本结算、与 QM 质量反馈、与 HR 工时。\n- 报表：MTBF/MTTR、计划 vs 实际、备件消耗、停机损失；控制：审批、锁定、审计与安全。\n\n### 波次 11：供应链计划（SCM/IBP）\n- 需求：统计/因果/ML 预测、协同、分层与细分、异常与促销处理。\n- 供应与库存：约束型供应计划、分配与承诺、部署与再平衡、安全库存与库存优化。\n- 响应与重计划：事件驱动重计划、供应响应、情景模拟与版本管理、共识计划。\n- 集成：与 SD 需求、PP/WM/TM 执行反馈、FI/CO 成本，数据仓库同步计划版本。\n- 报表：预测准确度、履约率、库存周转/缺货率、计划偏差；控制：版本审批、主数据一致性。\n\n### 波次 12：项目系统（PS）\n- 结构与基线：WBS/网络/里程碑，模板与版本，基线与变更管理。\n- 预算与承诺：预算冻结/解锁、承诺控制、预警与审批。\n- 执行与成本：采购/生产/工时/费用集成，挣值分析，收入确认（完工百分比/完工合同）。\n- 集成：与 FI/CO 成本结算、与 MM/SD/PP 需求执行、与 HR 工时、与 CRM 商机交接。\n- 报表：进度/成本偏差、现金流、里程碑达成、合同毛利；控制：授权到 WBS 层、风险登记。\n\n### 波次 13：人力资本管理（HCM）\n- 主数据与组织：组织/职位、员工主数据、合同与异动、排班与加班。\n- 时间与薪资：考勤与请假、工时、薪资核算与分摊、社保/税务接口、薪资密钥与保密。\n- 人才与绩效：招聘与入职、培训与学习、绩效与目标、继任与发展、员工/经理自助。\n- 集成：与 FI/CO 薪资分录、与 PS/PM 工时、与门禁/考勤设备、对接 SuccessFactors 可选。\n- 合规与隐私：同意与隐私、数据留存与删除、角色隔离、审计与追踪。\n\n### 波次 14：客户关系与服务（CRM/CX）\n- 销售与营销：线索/商机/活动、评分与分配、报价与合同、全渠道触达与偏好管理。\n- 服务与现场：服务请求/工单、SLA/排班、派工与现场服务、知识库与自助门户、保内/保外/索赔。\n- 全渠道与电商：电话/邮件/社交/IM/小程序，电商订单（可选），统一客户视图与身份。\n- 集成：与 SD 订单与配送、与 FI/CO 账单与应收、与 TM/WM 物流状态、与 HR 排班。\n- 报表：漏斗、活动 ROI、客户满意度/CSAT/NPS、SLA 达成、续约/流失；控制：隐私/同意、记录留存。\n\n### 波次 15：分析与报表（BI/BW）\n- 数据获取：CDC/事件总线、批量 ETL、准实时链路、数据质量校验与重试。\n- 模型与语义：主题域数据模型（财务/供应链/生产/HR/CRM）、历史快照、主数据对齐、语义层与权限。\n- 报表与数据产品：法定报表、管理报表、运营看板、自助分析、移动/订阅、异常告警。\n- 运营与治理：DQ 规则、血缘与影响分析、作业编排、成本/性能优化、备份与灾备。\n- 接口：数据服务 API、对接 SAC/PowerBI/第三方 BI。\n\n## 后续波次重点交付提示\n- 波次 3（CO）：标准/实际成本、作业分配、内部订单、利润分析，成本结算批次与差异处理性能。\n- 波次 4-6（MM/SD/PP）：P2P/O2C/MTS-MTO 全链路，MRP/排程/ATP，价格与定价引擎，三单匹配与库存齐套、工单与车间执行。\n- 波次 7-8（WM/EWM/TM）：库内作业/波次/RF/场站，运输计划与运费结算、在途跟踪，与 SD/PP/FI 深度耦合的库存与物流事件一致性。\n- 波次 9-10（QM/PM）：检验计划与批次、CAPA 闭环、质量阻断；维护计划/工单、备件与停机损失、IoT 预测性维护可选。\n- 波次 11（SCM/IBP）：预测/供应/库存优化、情景规划、计划版本治理，与执行层的反馈闭环。\n- 波次 12（PS）：WBS/预算/承诺、挣值、收入确认、合同变更与索赔、跨模块成本/物料/工时集成。\n- 波次 13-14（HCM/CRM/CX）：薪资/考勤/绩效/招聘与隐私合规；商机/营销/服务/全渠道与现场服务。\n- 波次 15（BI/BW）：主题域数仓、CDC/事件采集、语义层与权限、法定与管理报表、成本/性能/数据质量运营。\n\n## 跨模块关键事件与接口基线\n- P2P（采购到付款）：PR/RFQ/PO 创建→发布→变更事件；收货（GR）、发票（MIRO/三单匹配）、付款批次与回执；供应商主数据同步；价格/合同变更事件。\n- O2C（订单到收款）：询价/报价/销售订单→交付/装运→开票→收款→退换；信用检查与放行事件；ATP/可用量查询接口；运费计费/分摊事件；电子发票/税控接口。\n- MTS/MTO/生产：MRP 需求与异常、生产订单/工单状态、领退料、报工、报废/返工、批次与追溯事件；在制检验触发；成本结算事件。\n- 仓储/运输：波次/任务生成、上架/拣货/移库/盘点、场站/门禁、运输计划/派车/在途/签收、POD 事件；与 TM 运价/承运商接口；RF 扫描校验。\n- 财务/成本：凭证过账、资产变动、关账状态、成本分摊/结算、CO-PA 分段；TR 付款/对账、市场数据；税务/报税接口。\n- 主数据：业务伙伴/物料/科目/组织/税码/UoM 变更事件，版本/生效日期，去重与合并；缓存失效策略。\n- 分析与数仓：事件总线与 CDC 采集规范、重放与幂等键、Schema 演进与版本化、血缘元数据推送。\n\n## 数据迁移与切换策略要点\n- 范围与优先级：主数据先行（BP/物料/科目/组织），再迁交易/历史（按模块波次分批）；识别只读/只写/双写阶段。\n- 工具与校验：抽取-清洗-映射脚本、样本对账、全量对账四维度（数量/完整性/准确性/一致性），抽样凭证/订单/库存/薪资/资产核对。\n- 双轨与回滚：灰度切换（暗发布→灰度→全量），双账/双轨对比，回滚预案（数据回滚/流量回切/配置回滚）。\n- 冻结窗口：切换前冻结主数据与关键交易（短窗口），切换后解冻策略，冲突解决流程。\n- 合规与安全：数据脱敏、传输加密、访问审计、留存与销毁计划。\n\n## 性能与容量基准建议（起步指标，可按业务调优）\n- API/事件：核心写接口 p99 < 200-300ms，读接口 p99 < 150-200ms；Kafka 事件处理滞留 < 1 分钟；幂等键覆盖 ≥ 99%。\n- 批处理：关账/成本结算/三单匹配/运费结算批次在可接受窗口内（示例：关账夜间 2-4h；MRP/IBP 夜间批 < 2h），失败可重试与断点续跑。\n- 容量：按峰值 QPS/并发与日订单/凭证量预估，预留 30-50% 余量；缓存命中率目标 > 85%；数据库读写分离与分片策略准备。\n- 可用性：核心链路（身份、主数据、FI、订单、库存）目标 99.9%+；关键队列堆积告警、回压与限流策略到位。\n- 可观测：三类黄金指标（RED/USE）、业务 SLI（履约率、三单匹配成功率、MRP/ATP 准确度、薪资计算成功率、信用放行 SLA 等）纳入监控。\n\n## 波次验收模板（进入下一波次前必须满足）\n- 功能闭环：主/辅账务、主数据、核心用例、异常与审批、撤销/冲销/回滚流程完成；跨模块依赖用例打通。\n- 数据一致性：领域事件/CDC 覆盖，幂等与重放验证，关键对账（主数据、库存、财务、信用、薪资）通过。\n- 性能与容量：上述基准达标（接口 p99、批处理窗口、队列滞留、缓存命中、QPS 余量）。\n- 安全与合规：RBAC/ABAC、生效/过期策略、隐私/同意（含审计留存）、分离职责检查、渗透/安全扫描。\n- 可观测与运维：指标/日志/追踪上线，SLO/告警路由生效，Runbook/回滚预案验证；CI/CD、迁移脚本、种子数据完备。\n- 报表与数据：运营/法定报表上线，自助查询/语义层可用；数据质量规则与告警上线；数仓/事件采集对齐。\n- 培训与文档：ADR、接口/事件清单、配置指南、运维手册、用户培训材料完成；上线前演练完成。\n\n## 首波次（0-2）验收样例\n- 波次 0（平台/MDG/GRC/IAM）\n  - SSO/OIDC、RBAC/ABAC、职责分离策略及审计通过；API 网关限流/签名/审计生效。\n  - 主数据域（BP/物料/科目/组织/成本中心/税码/UoM）建模完成，变更事件与缓存一致性验证；数据质量评分机制上线。\n  - 备份/恢复演练通过，可观测性基线（日志/指标/追踪）部署完成。\n- 波次 1（FI）\n  - 多账簿/多币种凭证过账、税务计算、期间/年度结账、支付运行、资产折旧、AR/AP 账龄/催款闭环通过。\n  - 与 MM/SD 对账（GR/IR、开票）、期初余额导入双账验证通过；关账批次窗口可接受。\n  - 财务三大表/账龄/税表/审计日志可用，审批与影像归档生效。\n- 波次 2（TR/FSCM）\n  - 现金池/头寸/流动性预测、付款工厂运行；信用额度/评分/放行、催收与争议闭环。\n  - 外汇/利率/衍生品交易生命周期与会计处理、对冲与套期会计；银行接口（指令/回执/对账）稳定。\n  - DSO/DPO、信用暴露、流动性滚动报表可用；KYC/AML 钩子与双人复核生效。\n\n## API/事件命名与版本化简约规范\n- REST：`/api/{domain}/{resource}`，使用语义版本 `/v1`；写接口幂等键用 `Idempotency-Key`；错误码对齐 API 设计文档。\n- gRPC：包名 `{domain}.{service}.v1`，方法名动词化；拦截器统一鉴权/审计/幂等。\n- 事件：主题命名 `erp.{domain}.{event}`，事件版本字段 `event_version`，幂等键 `event_id`；事件 Schema 版本化与向后兼容；重试/死信/重放策略清晰。\n\n## 工具与产物建议\n- 配置/密钥：ConfigMap/Secret 管理与分环境覆盖，密钥轮换策略。\n- 数据：Migration/Seed 脚本、对账脚本、数据脱敏脚本；批处理编排（如 Argo/Airflow）模板。\n- 测试：契约测试（HTTP/gRPC/事件），模拟数据与金丝雀数据集；性能/压测脚本。\n- 部署：Helm/Manifest 与 Kustomize 模板、灰度与回滚脚本、混沌演练脚本（可选）。\n- 报表：法定/管理报表模板，语义层/指标定义文件，数据血缘/质量仪表盘。\n\n## 波次关键用例/接口/报表参考（精简版）\n- 波次 3（CO）\n  - 用例：成本中心/内部订单创建与审批；标准成本估算与发布；作业分配/分摊；WIP 与差异结算；CO-PA 分段报表。\n  - 接口/事件：`/co/cost-centers`，`/co/internal-orders`，`/co/allocations/run`，事件 `erp.co.allocation.completed`。\n  - 报表：成本中心/内部订单成本报表，差异分析，盈利能力分段。\n- 波次 4（MM）\n  - 用例：供应商资格/黑名单；RFQ→PO→合同；收货/退货；盘点；三单匹配与差异处理；寄售/委外。\n  - 接口/事件：`/mm/vendors`，`/mm/rfq`，`/mm/purchase-orders`，`/mm/gr`，`/mm/invoices`；事件 `erp.mm.gr.posted`，`erp.mm.invoice.matched`。\n  - 报表：采购周期/准时率、供应商评分、库存周转/安全库存。\n- 波次 5（SD）\n  - 用例：报价/订单/变更；ATP 承诺；部分发货/开票；退换/拒收；信用检查。\n  - 接口/事件：`/sd/quotes`，`/sd/orders`，`/sd/atp`，`/sd/deliveries`，`/sd/invoices`；事件 `erp.sd.order.created`，`erp.sd.delivery.shipped`，`erp.sd.invoice.issued`。\n  - 报表：履约率、毛利/净利、信用暴露、退货率。\n- 波次 6（PP）\n  - 用例：BOM/工艺版本；MRP 与例外；生产订单/工单派工与报工；批次追溯；替代料与并行/交叉工序。\n  - 接口/事件：`/pp/boms`，`/pp/routings`，`/pp/mrp/run`，`/pp/orders`，`/pp/operations/confirm`；事件 `erp.pp.mrp.completed`，`erp.pp.order.completed`。\n  - 报表：计划达成率、在制品、工序效率、齐套率。\n- 波次 7（WM/EWM）\n  - 用例：上架/拣货/移库/盘点；波次与任务分配；越库、VAS；场站/门禁/排队；RF 扫码。\n  - 接口/事件：`/wm/warehouses`，`/wm/tasks`，`/wm/waves`，`/wm/yard/appointments`；事件 `erp.wm.task.completed`，`erp.wm.wave.released`。\n  - 报表：库龄、拣货效率、盘点差异、场站吞吐。\n- 波次 8（TM）\n  - 用例：路线/装载优化；承运商招投标/分配；运价与合同；派车/在途/签收；运费结算。\n  - 接口/事件：`/tm/shipments`，`/tm/carriers`，`/tm/rates`，`/tm/pod`；事件 `erp.tm.shipment.dispatched`，`erp.tm.pod.received`。\n  - 报表：运输成本、准时率、装载率、异常率、碳排放。\n- 波次 9（QM）\n  - 用例：检验计划与采样；检验批/判定/处置；质量通知与 CAPA；质量证书。\n  - 接口/事件：`/qm/inspection-plans`，`/qm/lots`，`/qm/defects`，`/qm/notifications`；事件 `erp.qm.lot.released`，`erp.qm.notification.closed`。\n  - 报表：合格率、缺陷趋势、SPC 控制图、COPQ。\n- 波次 10（PM）\n  - 用例：设备/功能位置台账；预防/预测性维护计划；工单流转与备件；计量点抄表。\n  - 接口/事件：`/pm/equipment`，`/pm/maintenance-plans`，`/pm/orders`，`/pm/measurements`；事件 `erp.pm.order.completed`，`erp.pm.plan.generated`。\n  - 报表：MTBF/MTTR、备件消耗、停机损失、计划 vs 实际。\n- 波次 11（SCM/IBP）\n  - 用例：需求预测与协同；约束型供应计划；库存优化；响应与重计划；计划版本管理。\n  - 接口/事件：`/ibp/forecasts`，`/ibp/supply-plans`，`/ibp/inventory-policies`，`/ibp/scenarios`；事件 `erp.ibp.plan.published`。\n  - 报表：预测准确度、履约率、库存周转/缺货率、计划偏差。\n- 波次 12（PS）\n  - 用例：WBS/网络/里程碑；预算与承诺控制；挣值与进度；收入确认；变更与索赔。\n  - 接口/事件：`/ps/projects`，`/ps/wbs`，`/ps/budgets`，`/ps/progress`，`/ps/revenue-recognition`；事件 `erp.ps.progress.updated`。\n  - 报表：进度/成本偏差、现金流、里程碑达成、合同毛利。\n- 波次 13（HCM）\n  - 用例：组织/职位/员工主数据；考勤/请假/排班；薪资核算与分摊；绩效与招聘/培训；员工/经理自助。\n  - 接口/事件：`/hcm/employees`，`/hcm/time`，`/hcm/payroll`，`/hcm/performance`，`/hcm/recruiting`；事件 `erp.hcm.payroll.posted`，`erp.hcm.time.approved`。\n  - 报表：员工成本、出勤率、离职率、薪酬结构、培训与绩效指标。\n- 波次 14（CRM/CX）\n  - 用例：线索/商机/活动；报价与合同；服务请求/工单/现场服务；全渠道交互；电商（可选）。\n  - 接口/事件：`/crm/leads`，`/crm/opportunities`，`/crm/campaigns`，`/crm/tickets`，`/crm/field-service`；事件 `erp.crm.lead.converted`，`erp.crm.ticket.closed`。\n  - 报表：漏斗、活动 ROI、CSAT/NPS、SLA 达成、续约/流失。\n- 波次 15（BI/BW）\n  - 用例：CDC/事件/批采集；主题域模型与语义层；法定/管理/运营报表；自助分析。\n  - 接口/事件：数据服务 API（按域暴露），元数据/血缘推送；事件 `erp.dw.pipeline.failed`（告警），`erp.dw.dataset.published`。\n  - 报表：财务三表、P2P/O2C/库存/生产/HR/CRM 主题仪表盘与法定报表。\n\n## 用例/接口/事件落地步骤（适用于各波次）\n1) 需求分解：梳理用例→时序图/状态机→输入输出/前置后置条件→异常与补偿。\n2) 契约设计：REST/gRPC/事件 Schema，幂等键与重试策略，错误码/业务码对齐，版本策略。\n3) 权限与合规：鉴权/鉴别、字段脱敏、审计字段、职责分离检查点。\n4) 集成矩阵：上游/下游接口清单、事件订阅发布、批处理/实时链路、超时/降级策略。\n5) 数据与迁移：表结构/索引、CDC/事件映射、迁移脚本、回滚方案、对账脚本。\n6) 验收用例：正向/异常/性能/安全/回滚场景，契约测试与端到端测试集。\n7) 可观测性：指标/日志/追踪埋点、SLO 与告警规则、Dashboards。\n\n## 事件载荷最小字段模板（建议）\n- 元信息：`event_id`（幂等）、`event_version`、`occurred_at`（UTC）、`producer`、`correlation_id`、`trace_id`。\n- 业务主体：`aggregate_type`、`aggregate_id`、`payload`（业务数据，含版本或 schema_ref）。\n- 上下文：`actor`（用户/系统）、`tenant`（如多租户）、`source_system`、`ip/device`（可选）。\n- 合规：`sensitivity`（PII/财务/机密）、`signature`（可选）、`retention`（留存策略标识）。\n\n## 报表与语义层开发步骤（参考 BI/BW 波次）\n1) 主题域建模：维度/事实定义、粒度与主键、历史快照策略（SCD）、与主数据对齐。\n2) 数据采集：事件/CDC/批量，校验与重试，缺口补偿与重放，血缘登记。\n3) 语义层：业务指标口径定义、权限（行/列/指标）、计算字段与时间智能。\n4) 报表/看板：法定/管理/运营/实时，过滤与下钻，订阅与告警。\n5) 数据质量：规则与阈值、DQ 告警、异常处理与回补；性能与成本优化。\n6) 验收：对账（来源系统 vs 数仓 vs 报表）、性能 SLA、权限穿透测试、移动端可用性。\n\n## 关键接口/事件字段示例（选取两条主链路）\n- P2P：GR 事件 `erp.mm.gr.posted`\n  - 必填：`event_id`，`event_version`，`occurred_at`，`producer`，`aggregate_type=goods_receipt`，`aggregate_id`（GR 编号），`po_id`，`po_item_id`，`material_id`，`batch`（可选），`plant`，`storage_location`，`qty`，`uom`，`valuation_price`，`currency`，`company_code`，`fiscal_year`，`gr_type`（101/102/122…），`status`（posted/blocked），`actor`。\n  - 校验：幂等键=GR 编号+行；金额/数量容差；版本向后兼容。\n- O2C：发票事件 `erp.sd.invoice.issued`\n  - 必填：`event_id`，`aggregate_type=invoice`，`aggregate_id`（发票号），`order_id`，`customer_id`，`billing_date`，`net_amount`，`tax_amount`，`gross_amount`，`currency`，`company_code`，`fiscal_year`，`tax_code`，`payment_term`，`items`（material/qty/price/tax），`status`（issued/canceled），`actor`。\n  - 校验：金额=Σ行；税额与税码匹配；重复发票防重；电子发票接口回执处理。\n\n## 压测与容量演练模板（按模块抽样）\n- P2P：GR/Invoice/Post 10-20k/小时；三单匹配批处理 1-2 小时内完成；峰值并发 200-300 tps。\n- O2C：订单创建/变更 5-10k/小时；ATP 查询 p99 < 200ms；开票批次 10k+ 行内 60-90 分钟；信用检查链路压测。\n- 生产/MRP：MRP 夜间批，典型 1-2h；报工/领料并发 200 tps；在制量一致性抽检。\n- 仓储：波次/任务生成与完成并发 200-400 tps；RF 操作低延迟；盘点/场站高峰持续 1-2h。\n- 资金：付款批次（成百上千笔）与银行回执；市场数据高频拉取；流动性预测窗口。\n- HCM/薪资：薪资批次（全员）在窗口内完成；考勤入库/计算并发；隐私字段脱敏验证。\n- BI：批/流同步延迟（流 < 1 分钟，批 < 30-60 分钟），报表 p95 < 2s，峰值并发查询容量。\n\n## 对账与数据质量检查点（示例）\n- 财务：总账借贷平衡；FI 与 CO/CO-PA 对齐；GR/IR 对账；TR 银行对账。\n- 供应链：库存账实一致（按物料/批次/库位）；P2P 三单匹配率；O2C 订单-交付-开票-收款一致性。\n- 生产：WIP/报工与领料一致；BOM 耗用差异；MRP 需求与执行反馈差异。\n- 人力：薪资核算与账务分录一致；考勤与排班/请假一致；隐私字段访问审计。\n- 数据仓库：源系统 vs 数仓 vs 报表的数量/金额/粒度对账；DQ 规则覆盖率。\n\n## 后续波次验收样例（3-15）\n- 3 CO：标准/实际成本计算完成；分摊/分配/结算批次在窗口内；WIP 与差异结转正确；CO-PA 报表与 FI/SD 金额对齐。\n- 4 MM：P2P 闭环（RFQ→PO→GR→IV→支付），三单匹配成功率达标，差异/容差处理落地；批次/序列号库存一致；补货策略生效；供应商评分报表可用。\n- 5 SD：询价/报价/订单→发货→开票→收款→退换闭环；ATP 准确度与响应时间达标；信用检查/冻结/解冻有效；毛利/退货报表正确。\n- 6 PP：MRP 运行与例外清单；生产订单派工/报工/报废/替代料；批次追溯；WIP 对账；CO 成本对象结算对齐。\n- 7 WM/EWM：波次/任务生成与 RF 执行；越库/VAS/场站流程跑通；库存账实抽检通过；任务/波次延迟在阈值内。\n- 8 TM：路线/装载优化结果可复现；承运商分配与回执；在途跟踪与 POD；运费计算/分摊/结算完成；异常与索赔闭环。\n- 9 QM：检验计划与采样规则生效；检验批结果录入与判定；质量通知→CAPA 闭环；质量证书生成；SPC/合格率报表可用。\n- 10 PM：设备/功能位置台账完成；维护计划生成与工单流转；备件领用与成本归集；停机/MTBF/MTTR 指标可用；安全许可与审批有效。\n- 11 SCM/IBP：预测准确度达阈值；供应/库存优化方案发布；情景/版本管理与共识计划；执行反馈闭环（计划→执行→反馈）。\n- 12 PS：WBS/网络/里程碑建立；预算/承诺控制生效；挣值与进度报表；收入确认（完工百分比/完工合同）正确；变更/索赔流程。\n- 13 HCM：组织/员工/职位主数据；考勤/请假审批；薪资批次与分录正确；绩效/招聘/培训流程；隐私与访问审计通过。\n- 14 CRM/CX：线索→商机→合同闭环；活动/营销执行与 ROI；服务工单/SLA/现场服务；全渠道交互记录；同意与隐私偏好管理。\n- 15 BI/BW：CDC/事件/批链路延迟达标；主题域语义层与权限；核心仪表盘（财务/P2P/O2C/库存/生产/HR/CRM）上线；DQ 规则与告警生效。\n\n## 测试与验证包模板（各波次复用）\n- 用例覆盖：核心正向、异常/补偿、审批/撤销/冲销、边界值、批量/并发。\n- 契约测试：REST/gRPC/事件契约，Schema 兼容性测试，幂等与重放。\n- 端到端：主链路（P2P/O2C/MRP/ATP/发运/付款/收款/薪资等）全程回放；跨模块数据一致性校验。\n- 性能压测：接口延迟/吞吐、批处理窗口、队列堆积/回压，缓存命中。\n- 数据质量：主/交易数据抽样、断言与规则，库存/账务/订单对账脚本自动化。\n- 安全：鉴权/授权、越权/穿透、敏感字段脱敏、审计留痕、渗透扫描。\n- 可用性与韧性：降级/熔断/重试、混沌演练（可选）、灾备切换/备份恢复。\n- 验收记录：测试报告、缺陷清单、修复验证、Go/No-Go 结论。\n\n## Cutover 简版剧本（适用于大波次上线）\n1) 冻结与公告：定义冻结范围/窗口，业务公告，开关名单。\n2) 备份与快照：DB 备份、配置快照、Feature Flag 状态记录。\n3) 数据迁移：执行迁移/校验脚本，抽样对账，异常处理与重试策略。\n4) 应用切换：灰度/流量切换（5%→25%→100%）、健康检查、回滚预案就绪。\n5) 验证：烟雾（接口/事件/批处理）、关键报表、对账（库存/账务/订单/薪资等）。\n6) 观察期：加强监控与值守，告警响应分级，缺陷快速通道。\n7) 关闭与归档：确认上线、解冻、文档归档、经验复盘。\n\n## 风险与兜底（高频通用项）\n- 主数据不一致：主数据双轨校验、缓存失效策略、强制回源开关。\n- 对账差异：对账脚本每日跑批，差异告警与人工处理 SOP。\n- 批处理超时：批次分片/并行、断点续跑、容量预留与回退计划。\n- 事件积压：消费速率监控、回压/限流、死信与重放流程。\n- 权限与合规：职责分离规则未生效→强制阻断；审计与留存策略检查。\n- 性能瓶颈：热点拆分、缓存/索引/分片、降级策略（只读/限流）。\n- 切换失败：流量回切、配置回滚、数据回滚脚本预演。\n", "md/Rust-Build.md": "# Rust ERP 系统部署运维手册\n\n## 1. 部署架构概览\n\n### 1.1 环境划分\n\n| 环境 | 用途 | 访问控制 | 数据备份 |\n|-----|------|---------|---------|\n| **开发环境** (dev) | 日常开发、功能调试 | 开发团队 | 不备份 |\n| **测试环境** (test) | 集成测试、QA 测试 | 开发+QA团队 | 不备份 |\n| **预发布环境** (staging) | 上线前验证、压力测试 | 开发+运维团队 | 每日备份 |\n| **生产环境** (production) | 正式对外服务 | 仅运维团队 | 实时备份 |\n\n### 1.2 生产环境拓扑\n\n```\n┌─────────────────────────────────────────────────────────────────┐\n│                         CDN / CloudFlare                         │\n│                    静态资源、全球加速                              │\n└─────────────────────────────────────────────────────────────────┘\n                              ↓ HTTPS\n┌─────────────────────────────────────────────────────────────────┐\n│                      负载均衡器 (Load Balancer)                   │\n│              AWS ALB / Nginx + Keepalived                        │\n│              IP: 10.0.1.10 (VIP)                                 │\n└─────────────────────────────────────────────────────────────────┘\n                    ↓                        ↓\n    ┌───────────────────────┐    ┌───────────────────────┐\n    │  Kubernetes Cluster   │    │  Kubernetes Cluster   │\n    │  Zone: us-east-1a     │    │  Zone: us-east-1b     │\n    │  ┌─────────────────┐  │    │  ┌─────────────────┐  │\n    │  │  财务服务 Pod×3  │  │    │  │  财务服务 Pod×3  │  │\n    │  │  销售服务 Pod×3  │  │    │  │  销售服务 Pod×3  │  │\n    │  │  物料服务 Pod×3  │  │    │  │  物料服务 Pod×3  │  │\n    │  └─────────────────┘  │    │  └─────────────────┘  │\n    └───────────────────────┘    └───────────────────────┘\n                    ↓                        ↓\n┌─────────────────────────────────────────────────────────────────┐\n│                      数据层（高可用集群）                          │\n│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐          │\n│  │ PostgreSQL   │  │    Redis     │  │    Kafka     │          │\n│  │ Master-Slave │  │   Cluster    │  │   Cluster    │          │\n│  │  + Patroni   │  │ Sentinel×3   │  │  Broker×3    │          │\n│  └──────────────┘  └──────────────┘  └──────────────┘          │\n└─────────────────────────────────────────────────────────────────┘\n                    ↓                        ↓\n┌─────────────────────────────────────────────────────────────────┐\n│                      监控与日志系统                               │\n│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐          │\n│  │ Prometheus   │  │   Grafana    │  │   Loki +     │          │\n│  │   + Alert    │  │ Dashboards   │  │  Jaeger      │          │\n│  └──────────────┘  └──────────────┘  └──────────────┘          │\n└─────────────────────────────────────────────────────────────────┘\n```\n\n---\n\n## 2. Kubernetes 部署配置\n\n### 2.1 命名空间创建\n\n```yaml\n# namespaces/production.yaml\napiVersion: v1\nkind: Namespace\nmetadata:\n  name: erp-prod\n  labels:\n    environment: production\n    team: erp-platform\n\n---\napiVersion: v1\nkind: Namespace\nmetadata:\n  name: erp-infra\n  labels:\n    environment: production\n    team: infrastructure\n```\n\n**应用命名空间**：\n\n```bash\nkubectl apply -f namespaces/production.yaml\n```\n\n---\n\n### 2.2 ConfigMap 配置\n\n```yaml\n# config/financial-service-config.yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: financial-service-config\n  namespace: erp-prod\ndata:\n  APP_NAME: \"financial-service\"\n  APP_ENV: \"production\"\n  LOG_LEVEL: \"info\"\n\n  # 数据库配置（非敏感）\n  DATABASE_MAX_CONNECTIONS: \"20\"\n  DATABASE_MIN_CONNECTIONS: \"5\"\n\n  # Redis 配置\n  REDIS_MAX_CONNECTIONS: \"50\"\n\n  # Kafka 配置\n  KAFKA_BROKERS: \"kafka-0.kafka-headless.erp-infra.svc.cluster.local:9092,kafka-1.kafka-headless.erp-infra.svc.cluster.local:9092,kafka-2.kafka-headless.erp-infra.svc.cluster.local:9092\"\n  KAFKA_GROUP_ID: \"financial-service-prod-group\"\n  KAFKA_TOPIC_TRANSACTION_POSTED: \"financial.transaction.posted\"\n\n  # OpenTelemetry\n  OTEL_EXPORTER_JAEGER_ENDPOINT: \"http://jaeger-collector.erp-infra.svc.cluster.local:14268/api/traces\"\n  OTEL_SERVICE_NAME: \"financial-service\"\n\n  # Prometheus\n  PROMETHEUS_METRICS_PORT: \"9091\"\n```\n\n---\n\n### 2.3 Secret 管理\n\n```yaml\n# secrets/financial-service-secrets.yaml\napiVersion: v1\nkind: Secret\nmetadata:\n  name: financial-service-secrets\n  namespace: erp-prod\ntype: Opaque\nstringData:\n  DATABASE_URL: \"postgres://financial_user:PROD_PASSWORD_HERE@postgres-primary.erp-infra.svc.cluster.local:5432/financial_db?sslmode=require\"\n  REDIS_URL: \"redis://:REDIS_PROD_PASSWORD@redis-master.erp-infra.svc.cluster.local:6379/0\"\n  JWT_SECRET: \"CHANGE-THIS-TO-STRONG-SECRET-IN-PRODUCTION-MIN-32-CHARS\"\n\n  # 加密密钥（用于敏感数据加密）\n  ENCRYPTION_KEY: \"BASE64_ENCODED_AES_256_KEY_HERE\"\n```\n\n**创建 Secret**（推荐使用加密工具）：\n\n```bash\n# 方案1：使用 kubectl 直接创建（不推荐，会留下历史记录）\nkubectl apply -f secrets/financial-service-secrets.yaml\n\n# 方案2：使用 Sealed Secrets（推荐）\nkubeseal --format=yaml < secrets/financial-service-secrets.yaml > secrets/financial-service-sealed-secrets.yaml\nkubectl apply -f secrets/financial-service-sealed-secrets.yaml\n\n# 方案3：使用 Vault（企业推荐）\n# 集成 HashiCorp Vault，动态获取密钥\n```\n\n---\n\n### 2.4 Deployment 部署配置\n\n```yaml\n# deployments/financial-service.yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: financial-service\n  namespace: erp-prod\n  labels:\n    app: financial-service\n    version: v1.0.0\nspec:\n  replicas: 3  # 生产环境至少3副本\n  strategy:\n    type: RollingUpdate\n    rollingUpdate:\n      maxSurge: 1         # 最多额外创建1个Pod\n      maxUnavailable: 0   # 滚动更新期间保持所有Pod可用\n  selector:\n    matchLabels:\n      app: financial-service\n  template:\n    metadata:\n      labels:\n        app: financial-service\n        version: v1.0.0\n      annotations:\n        prometheus.io/scrape: \"true\"\n        prometheus.io/port: \"9091\"\n        prometheus.io/path: \"/metrics\"\n    spec:\n      # 亲和性配置（Pod 分散到不同节点）\n      affinity:\n        podAntiAffinity:\n          preferredDuringSchedulingIgnoredDuringExecution:\n            - weight: 100\n              podAffinityTerm:\n                labelSelector:\n                  matchExpressions:\n                    - key: app\n                      operator: In\n                      values:\n                        - financial-service\n                topologyKey: kubernetes.io/hostname\n\n      # 容器配置\n      containers:\n        - name: financial-service\n          image: registry.example.com/erp/financial-service:1.0.0\n          imagePullPolicy: IfNotPresent\n\n          # 端口\n          ports:\n            - name: http\n              containerPort: 8000\n              protocol: TCP\n            - name: grpc\n              containerPort: 50051\n              protocol: TCP\n            - name: metrics\n              containerPort: 9091\n              protocol: TCP\n\n          # 环境变量\n          env:\n            - name: APP_HOST\n              value: \"0.0.0.0\"\n            - name: APP_PORT\n              value: \"8000\"\n\n          # 从 ConfigMap 加载环境变量\n          envFrom:\n            - configMapRef:\n                name: financial-service-config\n            - secretRef:\n                name: financial-service-secrets\n\n          # 资源限制\n          resources:\n            requests:\n              cpu: \"500m\"        # 0.5核\n              memory: \"512Mi\"\n            limits:\n              cpu: \"2000m\"       # 2核\n              memory: \"2Gi\"\n\n          # 健康检查\n          livenessProbe:\n            httpGet:\n              path: /health\n              port: 8000\n            initialDelaySeconds: 30\n            periodSeconds: 10\n            timeoutSeconds: 5\n            failureThreshold: 3\n\n          readinessProbe:\n            httpGet:\n              path: /health\n              port: 8000\n            initialDelaySeconds: 10\n            periodSeconds: 5\n            timeoutSeconds: 3\n            successThreshold: 1\n            failureThreshold: 3\n\n          # 启动探针（避免慢启动被 kill）\n          startupProbe:\n            httpGet:\n              path: /health\n              port: 8000\n            initialDelaySeconds: 0\n            periodSeconds: 5\n            timeoutSeconds: 3\n            failureThreshold: 30  # 允许最多150秒启动时间\n\n          # 安全上下文\n          securityContext:\n            runAsNonRoot: true\n            runAsUser: 1000\n            allowPrivilegeEscalation: false\n            readOnlyRootFilesystem: true\n            capabilities:\n              drop:\n                - ALL\n\n          # 挂载卷\n          volumeMounts:\n            - name: tmp\n              mountPath: /tmp\n            - name: config\n              mountPath: /app/config\n              readOnly: true\n\n      # 卷定义\n      volumes:\n        - name: tmp\n          emptyDir: {}\n        - name: config\n          configMap:\n            name: financial-service-config\n\n      # 镜像拉取凭证\n      imagePullSecrets:\n        - name: registry-credentials\n\n      # 优雅关闭时间\n      terminationGracePeriodSeconds: 60\n```\n\n**部署应用**：\n\n```bash\nkubectl apply -f deployments/financial-service.yaml\n\n# 查看部署状态\nkubectl rollout status deployment/financial-service -n erp-prod\n\n# 查看 Pod 状态\nkubectl get pods -n erp-prod -l app=financial-service\n\n# 查看 Pod 日志\nkubectl logs -f deployment/financial-service -n erp-prod\n```\n\n---\n\n### 2.5 Service 配置\n\n```yaml\n# services/financial-service.yaml\napiVersion: v1\nkind: Service\nmetadata:\n  name: financial-service\n  namespace: erp-prod\n  labels:\n    app: financial-service\n  annotations:\n    service.beta.kubernetes.io/aws-load-balancer-type: \"nlb\"  # AWS NLB\nspec:\n  type: ClusterIP  # 内部服务使用 ClusterIP\n  selector:\n    app: financial-service\n  ports:\n    - name: http\n      port: 80\n      targetPort: 8000\n      protocol: TCP\n    - name: grpc\n      port: 50051\n      targetPort: 50051\n      protocol: TCP\n    - name: metrics\n      port: 9091\n      targetPort: 9091\n      protocol: TCP\n  sessionAffinity: None\n```\n\n---\n\n### 2.6 Ingress 配置（外部访问）\n\n```yaml\n# ingress/financial-service-ingress.yaml\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: financial-service-ingress\n  namespace: erp-prod\n  annotations:\n    # Nginx Ingress 配置\n    kubernetes.io/ingress.class: \"nginx\"\n    nginx.ingress.kubernetes.io/ssl-redirect: \"true\"\n    nginx.ingress.kubernetes.io/force-ssl-redirect: \"true\"\n\n    # 限流配置\n    nginx.ingress.kubernetes.io/limit-rps: \"100\"\n    nginx.ingress.kubernetes.io/limit-connections: \"50\"\n\n    # CORS 配置\n    nginx.ingress.kubernetes.io/enable-cors: \"true\"\n    nginx.ingress.kubernetes.io/cors-allow-origin: \"https://erp.example.com\"\n\n    # 超时配置\n    nginx.ingress.kubernetes.io/proxy-connect-timeout: \"60\"\n    nginx.ingress.kubernetes.io/proxy-send-timeout: \"60\"\n    nginx.ingress.kubernetes.io/proxy-read-timeout: \"60\"\n\n    # TLS 证书（cert-manager 自动管理）\n    cert-manager.io/cluster-issuer: \"letsencrypt-prod\"\nspec:\n  tls:\n    - hosts:\n        - api.erp.example.com\n      secretName: api-erp-tls\n  rules:\n    - host: api.erp.example.com\n      http:\n        paths:\n          - path: /financial\n            pathType: Prefix\n            backend:\n              service:\n                name: financial-service\n                port:\n                  number: 80\n          - path: /sales\n            pathType: Prefix\n            backend:\n              service:\n                name: sales-service\n                port:\n                  number: 80\n```\n\n---\n\n### 2.7 HorizontalPodAutoscaler（自动扩缩容）\n\n```yaml\n# hpa/financial-service-hpa.yaml\napiVersion: autoscaling/v2\nkind: HorizontalPodAutoscaler\nmetadata:\n  name: financial-service-hpa\n  namespace: erp-prod\nspec:\n  scaleTargetRef:\n    apiVersion: apps/v1\n    kind: Deployment\n    name: financial-service\n  minReplicas: 3\n  maxReplicas: 20\n  metrics:\n    # CPU 利用率\n    - type: Resource\n      resource:\n        name: cpu\n        target:\n          type: Utilization\n          averageUtilization: 70  # CPU 超过70%触发扩容\n\n    # 内存利用率\n    - type: Resource\n      resource:\n        name: memory\n        target:\n          type: Utilization\n          averageUtilization: 80\n\n    # 自定义指标：HTTP 请求速率（需要 Prometheus Adapter）\n    - type: Pods\n      pods:\n        metric:\n          name: http_requests_per_second\n        target:\n          type: AverageValue\n          averageValue: \"1000\"  # 每秒超过1000请求时扩容\n\n  behavior:\n    scaleDown:\n      stabilizationWindowSeconds: 300  # 缩容稳定窗口5分钟\n      policies:\n        - type: Percent\n          value: 50              # 每次最多缩容50%\n          periodSeconds: 60\n    scaleUp:\n      stabilizationWindowSeconds: 0\n      policies:\n        - type: Percent\n          value: 100             # 每次最多扩容100%（翻倍）\n          periodSeconds: 15\n        - type: Pods\n          value: 4               # 每次最多增加4个Pod\n          periodSeconds: 15\n      selectPolicy: Max          # 选择最大扩容策略\n```\n\n---\n\n## 3. 数据库部署\n\n### 3.1 PostgreSQL 高可用部署（Patroni + etcd）\n\n使用 Bitnami PostgreSQL HA Helm Chart：\n\n```bash\n# 添加 Bitnami Helm 仓库\nhelm repo add bitnami https://charts.bitnami.com/bitnami\nhelm repo update\n\n# 创建 values.yaml 配置文件\ncat > postgres-ha-values.yaml << 'EOF'\npostgresql:\n  replicaCount: 3  # 1个主节点 + 2个从节点\n\n  image:\n    tag: \"16.1.0\"\n\n  auth:\n    enablePostgresUser: true\n    postgresPassword: \"CHANGE_ME_POSTGRES_PASSWORD\"\n    username: \"erp_user\"\n    password: \"CHANGE_ME_ERP_PASSWORD\"\n    database: \"erp_prod\"\n\n  resources:\n    requests:\n      cpu: \"1000m\"\n      memory: \"2Gi\"\n    limits:\n      cpu: \"4000m\"\n      memory: \"8Gi\"\n\n  persistence:\n    enabled: true\n    storageClass: \"gp3\"  # AWS EBS gp3\n    size: \"100Gi\"\n\n  metrics:\n    enabled: true\n    serviceMonitor:\n      enabled: true\n\npgpool:\n  replicaCount: 2\n\n  adminUsername: \"admin\"\n  adminPassword: \"CHANGE_ME_ADMIN_PASSWORD\"\n\n  resources:\n    requests:\n      cpu: \"250m\"\n      memory: \"256Mi\"\n    limits:\n      cpu: \"1000m\"\n      memory: \"1Gi\"\n\netcd:\n  replicaCount: 3\n\n  persistence:\n    enabled: true\n    storageClass: \"gp3\"\n    size: \"10Gi\"\nEOF\n\n# 部署 PostgreSQL HA 集群\nhelm install postgres-ha bitnami/postgresql-ha \\\n  --namespace erp-infra \\\n  --create-namespace \\\n  --values postgres-ha-values.yaml\n\n# 查看部署状态\nkubectl get pods -n erp-infra -l app.kubernetes.io/name=postgresql-ha\n\n# 获取连接信息\nexport POSTGRES_PASSWORD=$(kubectl get secret --namespace erp-infra postgres-ha-postgresql-ha-postgresql -o jsonpath=\"{.data.password}\" | base64 -d)\necho \"PostgreSQL Password: $POSTGRES_PASSWORD\"\n\n# 连接到主节点\nkubectl run postgres-client --rm --tty -i --restart='Never' --namespace erp-infra \\\n  --image docker.io/bitnami/postgresql:16 \\\n  --env=\"PGPASSWORD=$POSTGRES_PASSWORD\" \\\n  --command -- psql --host postgres-ha-postgresql-ha-pgpool -U erp_user -d erp_prod -p 5432\n```\n\n---\n\n### 3.2 Redis 高可用部署（Sentinel）\n\n```bash\n# 创建 Redis values.yaml\ncat > redis-ha-values.yaml << 'EOF'\narchitecture: replication\n\nauth:\n  enabled: true\n  password: \"CHANGE_ME_REDIS_PASSWORD\"\n\nmaster:\n  replicaCount: 1\n  persistence:\n    enabled: true\n    storageClass: \"gp3\"\n    size: \"10Gi\"\n  resources:\n    requests:\n      cpu: \"250m\"\n      memory: \"512Mi\"\n    limits:\n      cpu: \"1000m\"\n      memory: \"2Gi\"\n\nreplica:\n  replicaCount: 2\n  persistence:\n    enabled: true\n    storageClass: \"gp3\"\n    size: \"10Gi\"\n  resources:\n    requests:\n      cpu: \"250m\"\n      memory: \"512Mi\"\n    limits:\n      cpu: \"1000m\"\n      memory: \"2Gi\"\n\nsentinel:\n  enabled: true\n  quorum: 2\n  downAfterMilliseconds: 5000\n  failoverTimeout: 10000\nEOF\n\n# 部署 Redis 集群\nhelm install redis-ha bitnami/redis \\\n  --namespace erp-infra \\\n  --values redis-ha-values.yaml\n\n# 获取 Redis 密码\nexport REDIS_PASSWORD=$(kubectl get secret --namespace erp-infra redis-ha -o jsonpath=\"{.data.redis-password}\" | base64 -d)\n\n# 连接到 Redis\nkubectl run redis-client --rm --tty -i --restart='Never' --namespace erp-infra \\\n  --image docker.io/bitnami/redis:7.2 \\\n  --env REDIS_PASSWORD=$REDIS_PASSWORD \\\n  --command -- redis-cli -h redis-ha-master -a $REDIS_PASSWORD\n```\n\n---\n\n### 3.3 Kafka 集群部署\n\n```bash\n# 创建 Kafka values.yaml\ncat > kafka-values.yaml << 'EOF'\nreplicaCount: 3\n\nzookeeper:\n  enabled: true\n  replicaCount: 3\n  persistence:\n    enabled: true\n    storageClass: \"gp3\"\n    size: \"10Gi\"\n\npersistence:\n  enabled: true\n  storageClass: \"gp3\"\n  size: \"50Gi\"\n\nresources:\n  requests:\n    cpu: \"500m\"\n    memory: \"1Gi\"\n  limits:\n    cpu: \"2000m\"\n    memory: \"4Gi\"\n\nmetrics:\n  kafka:\n    enabled: true\n  jmx:\n    enabled: true\n\nlisteners:\n  client:\n    protocol: PLAINTEXT\n  controller:\n    protocol: PLAINTEXT\n  interbroker:\n    protocol: PLAINTEXT\n  external:\n    protocol: PLAINTEXT\n\nexternalAccess:\n  enabled: false\nEOF\n\n# 部署 Kafka 集群\nhelm install kafka bitnami/kafka \\\n  --namespace erp-infra \\\n  --values kafka-values.yaml\n\n# 创建 Kafka 主题\nkubectl run kafka-client --rm --tty -i --restart='Never' --namespace erp-infra \\\n  --image docker.io/bitnami/kafka:3.6 \\\n  --command -- kafka-topics.sh \\\n    --bootstrap-server kafka-0.kafka-headless.erp-infra.svc.cluster.local:9092 \\\n    --create \\\n    --topic financial.transaction.posted \\\n    --partitions 6 \\\n    --replication-factor 3\n```\n\n---\n\n## 4. CI/CD 流水线\n\n### 4.1 GitHub Actions 配置\n\n创建 `.github/workflows/deploy-production.yml`：\n\n```yaml\nname: Deploy to Production\n\non:\n  push:\n    tags:\n      - 'v*.*.*'  # 触发条件：推送版本标签（如 v1.0.0）\n\nenv:\n  REGISTRY: registry.example.com\n  IMAGE_NAME: erp/financial-service\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4\n\n      - name: Set up Rust\n        uses: actions-rs/toolchain@v1\n        with:\n          toolchain: stable\n          profile: minimal\n          override: true\n\n      - name: Cache Cargo dependencies\n        uses: actions/cache@v3\n        with:\n          path: |\n            ~/.cargo/bin/\n            ~/.cargo/registry/index/\n            ~/.cargo/registry/cache/\n            ~/.cargo/git/db/\n            target/\n          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}\n\n      - name: Run tests\n        run: |\n          cargo test --all --release\n\n      - name: Build release binary\n        run: |\n          cargo build --release --package financial-service\n\n      - name: Extract version\n        id: extract_version\n        run: |\n          echo \"VERSION=${GITHUB_REF#refs/tags/v}\" >> $GITHUB_OUTPUT\n\n      - name: Login to Docker Registry\n        uses: docker/login-action@v3\n        with:\n          registry: ${{ env.REGISTRY }}\n          username: ${{ secrets.REGISTRY_USERNAME }}\n          password: ${{ secrets.REGISTRY_PASSWORD }}\n\n      - name: Build and push Docker image\n        uses: docker/build-push-action@v5\n        with:\n          context: ./services/financial-service\n          push: true\n          tags: |\n            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.extract_version.outputs.VERSION }}\n            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest\n          cache-from: type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest\n          cache-to: type=inline\n\n  deploy:\n    needs: build\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4\n\n      - name: Extract version\n        id: extract_version\n        run: |\n          echo \"VERSION=${GITHUB_REF#refs/tags/v}\" >> $GITHUB_OUTPUT\n\n      - name: Configure kubectl\n        uses: azure/k8s-set-context@v3\n        with:\n          method: kubeconfig\n          kubeconfig: ${{ secrets.KUBE_CONFIG }}\n\n      - name: Update Deployment image\n        run: |\n          kubectl set image deployment/financial-service \\\n            financial-service=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.extract_version.outputs.VERSION }} \\\n            -n erp-prod\n\n      - name: Wait for rollout\n        run: |\n          kubectl rollout status deployment/financial-service -n erp-prod --timeout=5m\n\n      - name: Verify deployment\n        run: |\n          kubectl get pods -n erp-prod -l app=financial-service\n\n      - name: Notify Slack\n        if: always()\n        uses: 8398a7/action-slack@v3\n        with:\n          status: ${{ job.status }}\n          text: |\n            Deployment ${{ job.status }}\n            Version: ${{ steps.extract_version.outputs.VERSION }}\n            Service: financial-service\n          webhook_url: ${{ secrets.SLACK_WEBHOOK }}\n```\n\n---\n\n### 4.2 Dockerfile 优化（多阶段构建）\n\n创建 `services/financial-service/Dockerfile`：\n\n```dockerfile\n# ===== 构建阶段 =====\nFROM rust:1.75-slim-bookworm AS builder\n\n# 安装依赖\nRUN apt-get update && apt-get install -y \\\n    pkg-config \\\n    libssl-dev \\\n    cmake \\\n    && rm -rf /var/lib/apt/lists/*\n\n# 创建工作目录\nWORKDIR /app\n\n# 复制 Cargo 文件并构建依赖（缓存层）\nCOPY Cargo.toml Cargo.lock ./\nCOPY shared/ ./shared/\nCOPY services/financial-service/Cargo.toml ./services/financial-service/\n\nRUN mkdir -p services/financial-service/src && \\\n    echo \"fn main() {}\" > services/financial-service/src/main.rs && \\\n    cargo build --release --package financial-service && \\\n    rm -rf services/financial-service/src\n\n# 复制源代码并构建\nCOPY services/financial-service/src ./services/financial-service/src\nRUN touch services/financial-service/src/main.rs && \\\n    cargo build --release --package financial-service\n\n# ===== 运行阶段 =====\nFROM debian:bookworm-slim\n\n# 安装运行时依赖\nRUN apt-get update && apt-get install -y \\\n    ca-certificates \\\n    libssl3 \\\n    && rm -rf /var/lib/apt/lists/*\n\n# 创建非 root 用户\nRUN useradd -m -u 1000 -s /bin/bash appuser\n\n# 工作目录\nWORKDIR /app\n\n# 从构建阶段复制二进制文件\nCOPY --from=builder /app/target/release/financial-service /app/financial-service\n\n# 切换到非 root 用户\nUSER appuser\n\n# 暴露端口\nEXPOSE 8000 50051 9091\n\n# 健康检查\nHEALTHCHECK --interval=30s --timeout=5s --start-period=10s --retries=3 \\\n  CMD curl -f http://localhost:8000/health || exit 1\n\n# 启动命令\nENTRYPOINT [\"/app/financial-service\"]\n```\n\n---\n\n## 5. 监控告警配置\n\n### 5.1 Prometheus 配置\n\n创建 `config/prometheus.yml`：\n\n```yaml\nglobal:\n  scrape_interval: 15s\n  evaluation_interval: 15s\n  external_labels:\n    cluster: 'erp-production'\n\n# 告警规则文件\nrule_files:\n  - '/etc/prometheus/rules/*.yml'\n\n# Alertmanager 配置\nalerting:\n  alertmanagers:\n    - static_configs:\n        - targets:\n            - 'alertmanager:9093'\n\n# 抓取配置\nscrape_configs:\n  # Kubernetes API Server\n  - job_name: 'kubernetes-apiservers'\n    kubernetes_sd_configs:\n      - role: endpoints\n    scheme: https\n    tls_config:\n      ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt\n    bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token\n    relabel_configs:\n      - source_labels: [__meta_kubernetes_namespace, __meta_kubernetes_service_name, __meta_kubernetes_endpoint_port_name]\n        action: keep\n        regex: default;kubernetes;https\n\n  # Kubernetes Nodes\n  - job_name: 'kubernetes-nodes'\n    kubernetes_sd_configs:\n      - role: node\n    scheme: https\n    tls_config:\n      ca_file: /var/run/secrets/kubernetes.io/serviceaccount/ca.crt\n    bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token\n    relabel_configs:\n      - action: labelmap\n        regex: __meta_kubernetes_node_label_(.+)\n\n  # Kubernetes Pods（通过注解自动发现）\n  - job_name: 'kubernetes-pods'\n    kubernetes_sd_configs:\n      - role: pod\n    relabel_configs:\n      - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_scrape]\n        action: keep\n        regex: true\n      - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_path]\n        action: replace\n        target_label: __metrics_path__\n        regex: (.+)\n      - source_labels: [__address__, __meta_kubernetes_pod_annotation_prometheus_io_port]\n        action: replace\n        regex: ([^:]+)(?::\\d+)?;(\\d+)\n        replacement: $1:$2\n        target_label: __address__\n      - action: labelmap\n        regex: __meta_kubernetes_pod_label_(.+)\n      - source_labels: [__meta_kubernetes_namespace]\n        action: replace\n        target_label: kubernetes_namespace\n      - source_labels: [__meta_kubernetes_pod_name]\n        action: replace\n        target_label: kubernetes_pod_name\n\n  # PostgreSQL Exporter\n  - job_name: 'postgres'\n    static_configs:\n      - targets:\n          - 'postgres-ha-postgresql-ha-metrics.erp-infra.svc.cluster.local:9187'\n\n  # Redis Exporter\n  - job_name: 'redis'\n    static_configs:\n      - targets:\n          - 'redis-ha-metrics.erp-infra.svc.cluster.local:9121'\n\n  # Kafka Exporter\n  - job_name: 'kafka'\n    static_configs:\n      - targets:\n          - 'kafka-0.kafka-headless.erp-infra.svc.cluster.local:5556'\n          - 'kafka-1.kafka-headless.erp-infra.svc.cluster.local:5556'\n          - 'kafka-2.kafka-headless.erp-infra.svc.cluster.local:5556'\n```\n\n---\n\n### 5.2 告警规则\n\n创建 `config/prometheus-rules/erp-alerts.yml`：\n\n```yaml\ngroups:\n  - name: erp_service_alerts\n    interval: 30s\n    rules:\n      # 服务宕机告警\n      - alert: ServiceDown\n        expr: up{job=~\"kubernetes-pods\",app=~\".*-service\"} == 0\n        for: 2m\n        labels:\n          severity: critical\n        annotations:\n          summary: \"Service {{ $labels.app }} is down\"\n          description: \"{{ $labels.app }} in namespace {{ $labels.kubernetes_namespace }} has been down for more than 2 minutes.\"\n\n      # 高错误率告警\n      - alert: HighErrorRate\n        expr: |\n          (\n            rate(http_requests_total{status=~\"5..\"}[5m])\n            /\n            rate(http_requests_total[5m])\n          ) > 0.05\n        for: 5m\n        labels:\n          severity: warning\n        annotations:\n          summary: \"High error rate on {{ $labels.app }}\"\n          description: \"Error rate is {{ $value | humanizePercentage }} on {{ $labels.app }}\"\n\n      # 高延迟告警\n      - alert: HighLatency\n        expr: |\n          histogram_quantile(0.95,\n            rate(http_request_duration_seconds_bucket[5m])\n          ) > 1\n        for: 5m\n        labels:\n          severity: warning\n        annotations:\n          summary: \"High latency on {{ $labels.app }}\"\n          description: \"P95 latency is {{ $value }}s on {{ $labels.app }}\"\n\n      # CPU 使用率过高\n      - alert: HighCPUUsage\n        expr: |\n          (\n            sum(rate(container_cpu_usage_seconds_total{namespace=\"erp-prod\"}[5m])) by (pod)\n            /\n            sum(container_spec_cpu_quota{namespace=\"erp-prod\"} / container_spec_cpu_period{namespace=\"erp-prod\"}) by (pod)\n          ) > 0.9\n        for: 10m\n        labels:\n          severity: warning\n        annotations:\n          summary: \"High CPU usage on pod {{ $labels.pod }}\"\n          description: \"CPU usage is {{ $value | humanizePercentage }}\"\n\n      # 内存使用率过高\n      - alert: HighMemoryUsage\n        expr: |\n          (\n            container_memory_working_set_bytes{namespace=\"erp-prod\"}\n            /\n            container_spec_memory_limit_bytes{namespace=\"erp-prod\"}\n          ) > 0.9\n        for: 10m\n        labels:\n          severity: warning\n        annotations:\n          summary: \"High memory usage on pod {{ $labels.pod }}\"\n          description: \"Memory usage is {{ $value | humanizePercentage }}\"\n\n  - name: database_alerts\n    interval: 30s\n    rules:\n      # 数据库连接数过高\n      - alert: HighDatabaseConnections\n        expr: |\n          pg_stat_database_numbackends{datname!~\"template.*|postgres\"}\n          /\n          pg_settings_max_connections > 0.8\n        for: 5m\n        labels:\n          severity: warning\n        annotations:\n          summary: \"High database connections on {{ $labels.datname }}\"\n          description: \"Database connections usage is {{ $value | humanizePercentage }}\"\n\n      # 数据库死锁\n      - alert: DatabaseDeadlocks\n        expr: rate(pg_stat_database_deadlocks[5m]) > 0\n        for: 1m\n        labels:\n          severity: warning\n        annotations:\n          summary: \"Database deadlocks detected on {{ $labels.datname }}\"\n          description: \"{{ $value }} deadlocks per second\"\n\n      # 慢查询过多\n      - alert: HighSlowQueries\n        expr: rate(pg_stat_database_tup_returned[5m]) / rate(pg_stat_database_tup_fetched[5m]) < 0.5\n        for: 10m\n        labels:\n          severity: warning\n        annotations:\n          summary: \"High slow query ratio on {{ $labels.datname }}\"\n```\n\n---\n\n### 5.3 Grafana Dashboard\n\n导入预配置的 Dashboard JSON（示例）：\n\n```bash\n# 使用 ConfigMap 挂载 Dashboard JSON\nkubectl create configmap grafana-dashboards \\\n  --from-file=config/grafana/dashboards/ \\\n  -n erp-infra\n\n# 在 Grafana Deployment 中挂载\n# volumes:\n#   - name: dashboards\n#     configMap:\n#       name: grafana-dashboards\n# volumeMounts:\n#   - name: dashboards\n#     mountPath: /var/lib/grafana/dashboards\n```\n\n---\n\n## 6. 备份与恢复\n\n### 6.1 PostgreSQL 自动备份\n\n创建 CronJob 定时备份：\n\n```yaml\n# cronjobs/postgres-backup.yaml\napiVersion: batch/v1\nkind: CronJob\nmetadata:\n  name: postgres-backup\n  namespace: erp-infra\nspec:\n  schedule: \"0 2 * * *\"  # 每天凌晨2点执行\n  successfulJobsHistoryLimit: 7\n  failedJobsHistoryLimit: 3\n  jobTemplate:\n    spec:\n      template:\n        spec:\n          restartPolicy: OnFailure\n          containers:\n            - name: postgres-backup\n              image: postgres:16-alpine\n              env:\n                - name: PGHOST\n                  value: \"postgres-ha-postgresql-ha-pgpool.erp-infra.svc.cluster.local\"\n                - name: PGUSER\n                  value: \"erp_user\"\n                - name: PGPASSWORD\n                  valueFrom:\n                    secretKeyRef:\n                      name: postgres-ha-postgresql-ha-postgresql\n                      key: password\n                - name: AWS_ACCESS_KEY_ID\n                  valueFrom:\n                    secretKeyRef:\n                      name: aws-credentials\n                      key: access-key-id\n                - name: AWS_SECRET_ACCESS_KEY\n                  valueFrom:\n                    secretKeyRef:\n                      name: aws-credentials\n                      key: secret-access-key\n              command:\n                - /bin/sh\n                - -c\n                - |\n                  set -e\n                  TIMESTAMP=$(date +%Y%m%d_%H%M%S)\n                  BACKUP_FILE=\"financial_db_${TIMESTAMP}.sql.gz\"\n\n                  # 执行备份\n                  pg_dump -h $PGHOST -U $PGUSER -d financial_db | gzip > /tmp/${BACKUP_FILE}\n\n                  # 上传到 S3\n                  apk add --no-cache aws-cli\n                  aws s3 cp /tmp/${BACKUP_FILE} s3://erp-backups/postgres/${BACKUP_FILE}\n\n                  # 清理本地文件\n                  rm /tmp/${BACKUP_FILE}\n\n                  # 删除30天前的备份\n                  aws s3 ls s3://erp-backups/postgres/ | awk '{print $4}' | while read file; do\n                    FILE_DATE=$(echo $file | grep -oP '\\d{8}')\n                    DAYS_OLD=$(( ($(date +%s) - $(date -d $FILE_DATE +%s)) / 86400 ))\n                    if [ $DAYS_OLD -gt 30 ]; then\n                      aws s3 rm s3://erp-backups/postgres/$file\n                    fi\n                  done\n\n                  echo \"Backup completed: ${BACKUP_FILE}\"\n              volumeMounts:\n                - name: backup-tmp\n                  mountPath: /tmp\n          volumes:\n            - name: backup-tmp\n              emptyDir: {}\n```\n\n---\n\n### 6.2 恢复流程\n\n```bash\n# 1. 下载备份文件\naws s3 cp s3://erp-backups/postgres/financial_db_20251221_020000.sql.gz /tmp/\n\n# 2. 解压\ngunzip /tmp/financial_db_20251221_020000.sql.gz\n\n# 3. 恢复到数据库\nkubectl run postgres-restore --rm -i --restart='Never' --namespace erp-infra \\\n  --image postgres:16-alpine \\\n  --env=\"PGPASSWORD=$POSTGRES_PASSWORD\" \\\n  -- psql -h postgres-ha-postgresql-ha-pgpool -U erp_user -d financial_db < /tmp/financial_db_20251221_020000.sql\n```\n\n---\n\n## 7. 日常运维操作\n\n### 7.1 滚动更新\n\n```bash\n# 更新镜像版本\nkubectl set image deployment/financial-service \\\n  financial-service=registry.example.com/erp/financial-service:1.1.0 \\\n  -n erp-prod\n\n# 查看滚动更新状态\nkubectl rollout status deployment/financial-service -n erp-prod\n\n# 查看更新历史\nkubectl rollout history deployment/financial-service -n erp-prod\n\n# 回滚到上一个版本\nkubectl rollout undo deployment/financial-service -n erp-prod\n\n# 回滚到指定版本\nkubectl rollout undo deployment/financial-service --to-revision=3 -n erp-prod\n```\n\n---\n\n### 7.2 扩缩容\n\n```bash\n# 手动扩容\nkubectl scale deployment/financial-service --replicas=5 -n erp-prod\n\n# 查看 HPA 状态\nkubectl get hpa -n erp-prod\n\n# 编辑 HPA 配置\nkubectl edit hpa financial-service-hpa -n erp-prod\n```\n\n---\n\n### 7.3 日志查看\n\n```bash\n# 查看 Pod 日志\nkubectl logs -f deployment/financial-service -n erp-prod\n\n# 查看多个 Pod 日志（使用 stern）\nstern financial-service -n erp-prod\n\n# 查看最近100行日志\nkubectl logs --tail=100 deployment/financial-service -n erp-prod\n\n# 查看之前的 Pod 日志（崩溃后）\nkubectl logs --previous deployment/financial-service -n erp-prod\n```\n\n---\n\n### 7.4 进入容器调试\n\n```bash\n# 进入 Pod shell\nkubectl exec -it deployment/financial-service -n erp-prod -- /bin/bash\n\n# 运行临时调试容器（ephemeral container）\nkubectl debug -it financial-service-xxx -n erp-prod --image=busybox --target=financial-service\n\n# 查看容器资源使用情况\nkubectl top pods -n erp-prod\nkubectl top nodes\n```\n\n---\n\n## 8. 故障排查手册\n\n### 8.1 Pod 无法启动\n\n**症状**: Pod 状态为 `CrashLoopBackOff` 或 `Error`\n\n**排查步骤**:\n\n```bash\n# 1. 查看 Pod 事件\nkubectl describe pod <pod-name> -n erp-prod\n\n# 2. 查看容器日志\nkubectl logs <pod-name> -n erp-prod --previous\n\n# 3. 检查资源限制\nkubectl get pod <pod-name> -n erp-prod -o yaml | grep -A 10 resources\n\n# 4. 检查配置是否正确\nkubectl get configmap financial-service-config -n erp-prod -o yaml\nkubectl get secret financial-service-secrets -n erp-prod -o yaml\n\n# 5. 检查镜像是否存在\nkubectl describe pod <pod-name> -n erp-prod | grep Image\n```\n\n---\n\n### 8.2 数据库连接失败\n\n**排查步骤**:\n\n```bash\n# 1. 检查数据库服务是否正常\nkubectl get pods -n erp-infra | grep postgres\n\n# 2. 测试数据库连接\nkubectl run pg-test --rm -it --restart='Never' --namespace erp-infra \\\n  --image postgres:16-alpine \\\n  --env=\"PGPASSWORD=$POSTGRES_PASSWORD\" \\\n  -- psql -h postgres-ha-postgresql-ha-pgpool -U erp_user -d financial_db -c \"SELECT 1;\"\n\n# 3. 检查数据库连接数\nkubectl exec -it postgres-ha-postgresql-ha-postgresql-0 -n erp-infra -- \\\n  psql -U erp_user -d financial_db -c \"SELECT count(*) FROM pg_stat_activity;\"\n\n# 4. 查看慢查询\nkubectl exec -it postgres-ha-postgresql-ha-postgresql-0 -n erp-infra -- \\\n  psql -U erp_user -d financial_db -c \"SELECT pid, now() - pg_stat_activity.query_start AS duration, query FROM pg_stat_activity WHERE (now() - pg_stat_activity.query_start) > interval '5 minutes';\"\n```\n\n---\n\n### 8.3 性能问题\n\n**排查步骤**:\n\n```bash\n# 1. 查看 CPU 和内存使用率\nkubectl top pods -n erp-prod\n\n# 2. 查看 Prometheus 指标\n# 访问 Grafana Dashboard: http://grafana.example.com\n\n# 3. 查看请求延迟分布\n# 使用 Jaeger 追踪: http://jaeger.example.com\n\n# 4. 分析数据库查询性能\nkubectl exec -it postgres-ha-postgresql-ha-postgresql-0 -n erp-infra -- \\\n  psql -U erp_user -d financial_db -c \"SELECT query, calls, total_time, mean_time FROM pg_stat_statements ORDER BY mean_time DESC LIMIT 10;\"\n```\n\n---\n\n## 9. 安全加固\n\n### 9.1 网络策略\n\n```yaml\n# network-policies/financial-service-netpol.yaml\napiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: financial-service-netpol\n  namespace: erp-prod\nspec:\n  podSelector:\n    matchLabels:\n      app: financial-service\n  policyTypes:\n    - Ingress\n    - Egress\n  ingress:\n    # 允许来自 Ingress Controller 的流量\n    - from:\n        - namespaceSelector:\n            matchLabels:\n              name: ingress-nginx\n      ports:\n        - protocol: TCP\n          port: 8000\n    # 允许来自其他微服务的 gRPC 流量\n    - from:\n        - podSelector:\n            matchLabels:\n              app: sales-service\n      ports:\n        - protocol: TCP\n          port: 50051\n    # 允许 Prometheus 抓取指标\n    - from:\n        - namespaceSelector:\n            matchLabels:\n              name: erp-infra\n        - podSelector:\n            matchLabels:\n              app: prometheus\n      ports:\n        - protocol: TCP\n          port: 9091\n  egress:\n    # 允许访问数据库\n    - to:\n        - namespaceSelector:\n            matchLabels:\n              name: erp-infra\n        - podSelector:\n            matchLabels:\n              app.kubernetes.io/name: postgresql-ha\n      ports:\n        - protocol: TCP\n          port: 5432\n    # 允许访问 Redis\n    - to:\n        - namespaceSelector:\n            matchLabels:\n              name: erp-infra\n        - podSelector:\n            matchLabels:\n              app.kubernetes.io/name: redis\n      ports:\n        - protocol: TCP\n          port: 6379\n    # 允许访问 Kafka\n    - to:\n        - namespaceSelector:\n            matchLabels:\n              name: erp-infra\n        - podSelector:\n            matchLabels:\n              app.kubernetes.io/name: kafka\n      ports:\n        - protocol: TCP\n          port: 9092\n    # 允许 DNS 查询\n    - to:\n        - namespaceSelector:\n            matchLabels:\n              name: kube-system\n        - podSelector:\n            matchLabels:\n              k8s-app: kube-dns\n      ports:\n        - protocol: UDP\n          port: 53\n```\n\n---\n\n## 10. 成本优化\n\n### 10.1 资源请求优化\n\n```bash\n# 分析实际资源使用情况\nkubectl top pods -n erp-prod --containers\n\n# 使用 VPA (Vertical Pod Autoscaler) 自动调整资源请求\nkubectl apply -f https://github.com/kubernetes/autoscaler/releases/download/vertical-pod-autoscaler-0.13.0/vpa-v0.13.0.yaml\n\n# 创建 VPA 配置\ncat > vpa-financial-service.yaml << 'EOF'\napiVersion: autoscaling.k8s.io/v1\nkind: VerticalPodAutoscaler\nmetadata:\n  name: financial-service-vpa\n  namespace: erp-prod\nspec:\n  targetRef:\n    apiVersion: apps/v1\n    kind: Deployment\n    name: financial-service\n  updatePolicy:\n    updateMode: \"Auto\"  # 自动应用建议\n  resourcePolicy:\n    containerPolicies:\n      - containerName: financial-service\n        minAllowed:\n          cpu: \"250m\"\n          memory: \"256Mi\"\n        maxAllowed:\n          cpu: \"4000m\"\n          memory: \"4Gi\"\nEOF\n\nkubectl apply -f vpa-financial-service.yaml\n```\n\n---\n\n**文档版本**: v1.0\n**最后更新**: 2025-12-21\n**维护者**: ERP 运维团队\n", "md/Rust-Data.md": "# Rust ERP 系统架构设计文档\n\n## 1. 系统概述\n\n### 1.1 项目背景\n本项目旨在使用 Rust 语言和微服务架构，从零开发一套完整的 ERP 系统，用于替代传统的 KILLER 系统。系统采用领域驱动设计（DDD）、CQRS 模式和事件溯源（Event Sourcing）等现代架构模式。\n\n### 1.2 设计目标\n- **高性能**：利用 Rust 的零成本抽象和内存安全特性，实现高性能低延迟\n- **可扩展性**：微服务架构支持水平扩展和独立部署\n- **业务完整性**：覆盖 KILLER 全部核心模块功能\n- **可维护性**：DDD 分层架构确保代码清晰、职责分离\n- **数据一致性**：事件溯源保证数据完整性和可追溯性\n\n### 1.3 技术栈选型\n\n| 技术领域 | 选型 | 版本 | 选型理由 |\n|---------|------|------|---------|\n| 编程语言 | Rust | 2021 Edition | 内存安全、高性能、并发友好 |\n| Web 框架 | Axum | 0.7 | 基于 Tokio、类型安全、生态完善 |\n| 数据库 | PostgreSQL | 16 | ACID、JSON支持、成熟稳定 |\n| 缓存 | Redis | 7 | 高性能、支持多种数据结构 |\n| 消息队列 | Apache Kafka | 3.x | 高吞吐、持久化、事件溯源基础 |\n| RPC 框架 | gRPC (Tonic) | 0.11 | 高性能、类型安全、双向流 |\n| ORM | SQLx | 0.7 | 编译时 SQL 检查、异步支持 |\n| 容器编排 | Kubernetes | 1.28+ | 服务发现、自动扩缩容、健康检查 |\n| 监控 | Prometheus + Grafana | - | 指标采集、可视化、告警 |\n| 日志 | Loki + Vector | - | 日志聚合、查询分析 |\n| 链路追踪 | Jaeger | - | 分布式追踪、性能分析 |\n\n---\n\n## 2. 整体架构设计\n\n### 2.1 架构风格\n\n```\n┌─────────────────────────────────────────────────────────────────┐\n│                         客户端层 (Clients)                        │\n│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐        │\n│  │  Web UI  │  │ Mobile   │  │  Desktop │  │ 3rd API  │        │\n│  └──────────┘  └──────────┘  └──────────┘  └──────────┘        │\n└─────────────────────────────────────────────────────────────────┘\n                              ↓ HTTPS/HTTP2\n┌─────────────────────────────────────────────────────────────────┐\n│                      API 网关层 (API Gateway)                     │\n│  ┌──────────────────────────────────────────────────────────┐   │\n│  │  Kong / Nginx + 认证 + 限流 + 路由 + 负载均衡              │   │\n│  └──────────────────────────────────────────────────────────┘   │\n└─────────────────────────────────────────────────────────────────┘\n                              ↓ gRPC/REST\n┌─────────────────────────────────────────────────────────────────┐\n│                      微服务层 (Microservices)                     │\n│  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐           │\n│  │   财务   │ │   销售   │ │   采购   │ │   生产   │  ...      │\n│  │ Financial│ │  Sales   │ │Materials │ │Production│           │\n│  └──────────┘ └──────────┘ └──────────┘ └──────────┘           │\n│       ↓              ↓              ↓              ↓             │\n│  ┌────────────────────────────────────────────────────────┐     │\n│  │              共享服务 (Shared Services)                 │     │\n│  │  认证服务 │ 事件总线 │ 配置中心 │ 服务发现              │     │\n│  └────────────────────────────────────────────────────────┘     │\n└─────────────────────────────────────────────────────────────────┘\n                              ↓\n┌─────────────────────────────────────────────────────────────────┐\n│                      数据层 (Data Layer)                         │\n│  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────┐           │\n│  │PostgreSQL│ │  Redis   │ │  Kafka   │ │  S3/OSS  │           │\n│  │  主数据  │ │   缓存   │ │ 事件存储 │ │ 文件存储 │           │\n│  └──────────┘ └──────────┘ └──────────┘ └──────────┘           │\n└─────────────────────────────────────────────────────────────────┘\n                              ↓\n┌─────────────────────────────────────────────────────────────────┐\n│                   基础设施层 (Infrastructure)                     │\n│  ┌──────────────────────────────────────────────────────────┐   │\n│  │  Kubernetes + Docker + Prometheus + Grafana + Jaeger     │   │\n│  └──────────────────────────────────────────────────────────┘   │\n└─────────────────────────────────────────────────────────────────┘\n```\n\n### 2.2 微服务划分（对应 KILLER 模块）\n\n| 微服务名称 | KILLER 模块 | 核心职责 | 数据库 |\n|-----------|---------|---------|-------|\n| financial-service | FI (财务会计) | 总账、应收应付、资产管理、银行管理 | financial_db |\n| controlling-service | CO (管理会计) | 成本中心、成本要素、内部订单、获利分析 | controlling_db |\n| materials-service | MM (物料管理) | 采购、库存、供应商管理、物料主数据 | materials_db |\n| sales-service | SD (销售与分销) | 销售订单、定价、发货、开票 | sales_db |\n| production-service | PP (生产计划) | 生产订单、MRP、工艺路线、BOM | production_db |\n| hr-service | HR (人力资源) | 组织管理、薪资、考勤、招聘培训 | hr_db |\n| quality-service | QM (质量管理) | 质检计划、检验批次、质量通知 | quality_db |\n| maintenance-service | PM (设备维护) | 设备主数据、维护计划、工单管理 | maintenance_db |\n| crm-service | CRM (客户关系) | 客户主数据、营销活动、服务管理 | crm_db |\n| project-service | PS (项目管理) | 项目结构、WBS、预算控制 | project_db |\n| scm-service | SCM (供应链) | 需求计划、高级计划、供应商协同 | scm_db |\n| treasury-service | TR (财务管理) | 现金管理、资金预测、风险管理 | treasury_db |\n| warehouse-service | WM/EWM (仓储) | 库位管理、入出库、移库、盘点 | warehouse_db |\n| transport-service | TM (运输管理) | 运输计划、承运商管理、运费计算 | transport_db |\n| analytics-service | BW/BI (商业智能) | 数据仓库、报表、分析、Dashboard | analytics_db |\n\n---\n\n## 3. DDD 分层架构设计\n\n### 3.1 四层架构说明\n\n每个微服务严格遵循 DDD 四层架构，从外到内依次为：\n\n```\n┌──────────────────────────────────────────────────────────┐\n│                     API 层 (API Layer)                    │\n│  职责：HTTP/gRPC 接口暴露、请求验证、响应序列化           │\n│  依赖：Application 层                                     │\n│  技术：Axum Router、Tonic gRPC、Validator                │\n└──────────────────────────────────────────────────────────┘\n                          ↓ 调用\n┌──────────────────────────────────────────────────────────┐\n│                 应用层 (Application Layer)                │\n│  职责：用例编排、CQRS 命令/查询处理、事务管理             │\n│  依赖：Domain 层                                          │\n│  技术：Command/Query Handler、DTO、应用服务               │\n└──────────────────────────────────────────────────────────┘\n                          ↓ 调用\n┌──────────────────────────────────────────────────────────┐\n│                  领域层 (Domain Layer)                    │\n│  职责：业务逻辑、聚合根、实体、值对象、领域事件            │\n│  依赖：无（纯业务逻辑）                                   │\n│  技术：Aggregate、Entity、ValueObject、DomainEvent        │\n└──────────────────────────────────────────────────────────┘\n                          ↑ 依赖倒置\n┌──────────────────────────────────────────────────────────┐\n│              基础设施层 (Infrastructure Layer)             │\n│  职责：数据持久化、外部服务集成、事件发布                 │\n│  依赖：Domain 层接口                                      │\n│  技术：PostgreSQL、Redis、Kafka、gRPC Client              │\n└──────────────────────────────────────────────────────────┘\n```\n\n### 3.2 各层详细设计\n\n#### 3.2.1 API 层 (api/)\n\n```rust\n// 结构说明\napi/\n├── http/              // HTTP REST API 端点\n│   ├── routes.rs      // 路由定义和分组\n│   ├── handlers/      // HTTP 请求处理器\n│   │   ├── account.rs       // 会计科目相关接口\n│   │   ├── transaction.rs   // 交易相关接口\n│   │   └── report.rs        // 报表相关接口\n│   ├── middleware/    // 中间件\n│   │   ├── auth.rs          // JWT 认证中间件\n│   │   ├── logging.rs       // 请求日志中间件\n│   │   └── cors.rs          // CORS 跨域处理\n│   └── validators/    // 请求参数验证器\n│       └── account_validator.rs\n├── grpc/              // gRPC 服务端点\n│   ├── proto/         // Protobuf 定义文件\n│   │   └── financial.proto\n│   ├── services/      // gRPC 服务实现\n│   │   └── financial_service.rs\n│   └── interceptors/ // gRPC 拦截器\n│       └── auth.rs\n└── dto/              // 数据传输对象\n    ├── requests/     // 请求 DTO\n    │   ├── create_account_request.rs\n    │   └── post_transaction_request.rs\n    └── responses/    // 响应 DTO\n        ├── account_response.rs\n        └── transaction_response.rs\n```\n\n**关键职责**：\n- 接收外部请求（HTTP/gRPC）\n- 参数验证（格式、业务规则前置检查）\n- 调用 Application 层处理业务逻辑\n- 序列化响应数据返回给客户端\n- 不包含业务逻辑，仅做数据转换和路由\n\n#### 3.2.2 应用层 (application/)\n\n```rust\n// 结构说明\napplication/\n├── commands/          // 写操作命令（CQRS-C）\n│   ├── create_account.rs      // 创建科目命令及处理器\n│   ├── post_transaction.rs    // 过账交易命令及处理器\n│   └── close_period.rs        // 结账命令及处理器\n├── queries/           // 读操作查询（CQRS-Q）\n│   ├── get_account.rs         // 查询科目详情\n│   ├── list_transactions.rs   // 查询交易列表\n│   └── generate_report.rs     // 生成财务报表\n├── services/          // 应用服务（用例编排）\n│   ├── account_service.rs     // 科目管理服务\n│   ├── transaction_service.rs // 交易处理服务\n│   └── reporting_service.rs   // 报表服务\n└── dto/              // 应用层数据传输对象\n    ├── account_dto.rs\n    └── transaction_dto.rs\n```\n\n**关键职责**：\n- 实现具体业务用例（Use Case）\n- CQRS 模式：分离命令（Command）和查询（Query）\n- 调用 Domain 层的聚合根执行业务逻辑\n- 事务管理和异常处理\n- 发布领域事件到消息队列\n\n**CQRS 模式说明**：\n- **Command（命令）**：修改数据的操作，返回成功/失败，触发领域事件\n- **Query（查询）**：只读操作，可以直接查询数据库视图，不经过领域模型\n- **优势**：读写分离、性能优化、独立扩展\n\n#### 3.2.3 领域层 (domain/)\n\n```rust\n// 结构说明\ndomain/\n├── aggregates/        // 聚合根（Aggregate Root）\n│   ├── account/       // 会计科目聚合\n│   │   ├── account.rs         // 科目聚合根\n│   │   ├── account_type.rs    // 科目类型实体\n│   │   └── balance.rs         // 余额值对象\n│   └── transaction/   // 交易聚合\n│       ├── transaction.rs     // 交易聚合根\n│       ├── journal_entry.rs   // 分录实体\n│       └── posting.rs         // 过账记录实体\n├── entities/          // 实体（Entity）\n│   ├── cost_center.rs         // 成本中心实体\n│   └── profit_center.rs       // 利润中心实体\n├── value_objects/     // 值对象（Value Object）\n│   ├── amount.rs              // 金额值对象（带币种）\n│   ├── account_number.rs      // 科目编号值对象\n│   └── fiscal_period.rs       // 会计期间值对象\n├── events/            // 领域事件（Domain Event）\n│   ├── account_created.rs     // 科目创建事件\n│   ├── transaction_posted.rs  // 交易过账事件\n│   └── period_closed.rs       // 期间关闭事件\n├── services/          // 领域服务（Domain Service）\n│   ├── balance_calculator.rs  // 余额计算服务\n│   └── exchange_rate.rs       // 汇率转换服务\n└── repositories/      // 仓储接口（trait）\n    ├── account_repository.rs      // 科目仓储接口\n    └── transaction_repository.rs  // 交易仓储接口\n```\n\n**关键职责**：\n- **聚合根（Aggregate Root）**：\n  - 业务逻辑的核心，保证数据一致性边界\n  - 对外提供业务方法（如 `post_transaction()`）\n  - 产生领域事件（如 `TransactionPosted`）\n  - 示例：`Account`、`Transaction`\n\n- **实体（Entity）**：\n  - 有唯一标识的领域对象\n  - 生命周期内状态可变\n  - 示例：`JournalEntry`（分录）\n\n- **值对象（Value Object）**：\n  - 无唯一标识，由属性值定义\n  - 不可变（immutable）\n  - 示例：`Amount`（金额+币种）、`AccountNumber`\n\n- **领域事件（Domain Event）**：\n  - 业务操作产生的事实记录\n  - 不可变，带时间戳\n  - 用于事件溯源和跨服务通信\n  - 示例：`AccountCreated`、`TransactionPosted`\n\n- **领域服务（Domain Service）**：\n  - 不属于单个实体的业务逻辑\n  - 示例：复杂的余额计算、汇率转换\n\n- **仓储接口（Repository Trait）**：\n  - 定义数据持久化抽象接口\n  - 实现在 Infrastructure 层（依赖倒置原则）\n\n#### 3.2.4 基础设施层 (infrastructure/)\n\n```rust\n// 结构说明\ninfrastructure/\n├── persistence/       // 数据持久化\n│   ├── postgres/      // PostgreSQL 实现\n│   │   ├── account_repo_impl.rs   // 科目仓储实现\n│   │   ├── transaction_repo_impl.rs\n│   │   ├── models.rs              // 数据库模型（ORM）\n│   │   └── migrations/            // SQL 迁移脚本\n│   │       └── 001_init.sql\n│   └── redis/         // Redis 缓存实现\n│       └── cache.rs\n├── messaging/         // 消息中间件\n│   ├── kafka/         // Kafka 实现\n│   │   ├── producer.rs            // 事件发布\n│   │   └── consumer.rs            // 事件订阅\n│   └── event_store.rs             // 事件存储实现\n├── external/          // 外部服务集成\n│   ├── sales_client.rs            // 销售服务 gRPC 客户端\n│   ├── materials_client.rs        // 物料服务 gRPC 客户端\n│   └── auth_client.rs             // 认证服务客户端\n└── config/            // 配置管理\n    ├── database.rs                // 数据库配置\n    └── kafka.rs                   // Kafka 配置\n```\n\n**关键职责**：\n- 实现 Domain 层定义的仓储接口（Repository Trait）\n- 数据库访问（PostgreSQL/Redis）\n- 消息队列集成（Kafka 生产者/消费者）\n- 外部服务调用（gRPC Client）\n- 配置管理和环境变量加载\n\n---\n\n## 4. CQRS 与事件溯源架构\n\n### 4.1 CQRS 架构图\n\n```\n┌─────────────────────────────────────────────────────────────┐\n│                        客户端请求                            │\n└─────────────────────────────────────────────────────────────┘\n                    ↓                    ↓\n        ┌───────────────────┐   ┌──────────────────┐\n        │   命令端 (Write)   │   │  查询端 (Read)    │\n        │  Command Side     │   │  Query Side      │\n        └───────────────────┘   └──────────────────┘\n                    ↓                    ↓\n        ┌───────────────────┐   ┌──────────────────┐\n        │  Command Handler  │   │  Query Handler   │\n        │  调用聚合根        │   │  直接查询视图     │\n        └───────────────────┘   └──────────────────┘\n                    ↓                    ↓\n        ┌───────────────────┐   ┌──────────────────┐\n        │  领域模型 (DDD)    │   │  读模型 (DTO)     │\n        │  Aggregate Root   │   │  Materialized    │\n        └───────────────────┘   │  View / Cache    │\n                    ↓            └──────────────────┘\n        ┌───────────────────┐            ↑\n        │  事件存储 (Kafka)  │────────────┘\n        │  Event Store      │   事件投影 (Projection)\n        └───────────────────┘\n                    ↓\n        ┌───────────────────┐\n        │  写数据库 (PG)     │\n        │  Write DB         │\n        └───────────────────┘\n```\n\n### 4.2 事件溯源流程\n\n```rust\n// 事件溯源示例流程\n\n// 1. 客户端发起命令\nPOST /api/accounts/{id}/post-transaction\n{\n  \"debit_account\": \"1000\",\n  \"credit_account\": \"2000\",\n  \"amount\": 10000,\n  \"currency\": \"CNY\"\n}\n\n// 2. Command Handler 处理\nlet command = PostTransactionCommand { ... };\nlet aggregate = transaction_repo.get(id).await?;  // 加载聚合根\naggregate.post(command)?;                         // 执行业务逻辑\ntransaction_repo.save(aggregate).await?;          // 保存\n\n// 3. 聚合根产生领域事件\nTransactionPosted {\n  transaction_id: \"TX-001\",\n  debit_account: \"1000\",\n  credit_account: \"2000\",\n  amount: 10000,\n  currency: \"CNY\",\n  posted_at: \"2025-12-21T10:00:00Z\"\n}\n\n// 4. 事件持久化到 Kafka\nkafka_producer.send(\"financial.transaction.posted\", event).await?;\n\n// 5. 事件存储到数据库\nINSERT INTO events (aggregate_id, event_type, payload, version)\nVALUES ('TX-001', 'TransactionPosted', '{\"amount\":10000,...}', 1);\n\n// 6. 投影到读模型（异步）\n// Kafka Consumer 监听事件，更新 Redis 缓存和查询表\nZADD account:1000:transactions TX-001  // Redis 有序集合\nINSERT INTO transaction_view ...       // PostgreSQL 查询视图\n\n// 7. 查询端直接读取视图\nGET /api/accounts/1000/transactions\n→ 从 Redis 或 transaction_view 表读取，无需重建聚合\n```\n\n### 4.3 事件版本控制\n\n```rust\n// 事件版本化示例\n#[derive(Serialize, Deserialize)]\n#[serde(tag = \"version\")]\npub enum TransactionPostedEvent {\n    #[serde(rename = \"v1\")]\n    V1(TransactionPostedV1),\n\n    #[serde(rename = \"v2\")]\n    V2(TransactionPostedV2),  // 新增字段：cost_center\n}\n\n// 事件升级器（Upcaster）\nimpl From<TransactionPostedV1> for TransactionPostedV2 {\n    fn from(v1: TransactionPostedV1) -> Self {\n        TransactionPostedV2 {\n            cost_center: None,  // 兼容旧版本\n            ..v1\n        }\n    }\n}\n```\n\n---\n\n## 5. 服务间通信设计\n\n### 5.1 同步通信：gRPC\n\n```protobuf\n// financial.proto\nsyntax = \"proto3\";\n\nservice FinancialService {\n  // 查询账户余额（同步调用）\n  rpc GetAccountBalance(GetAccountBalanceRequest)\n      returns (GetAccountBalanceResponse);\n\n  // 验证交易合法性（同步调用）\n  rpc ValidateTransaction(ValidateTransactionRequest)\n      returns (ValidateTransactionResponse);\n}\n\nmessage GetAccountBalanceRequest {\n  string account_number = 1;\n  string currency = 2;\n  string as_of_date = 3;  // 可选，查询历史余额\n}\n\nmessage GetAccountBalanceResponse {\n  string account_number = 1;\n  double balance = 2;\n  string currency = 3;\n  int64 timestamp = 4;\n}\n```\n\n**使用场景**：\n- 需要即时响应的操作（如验证库存是否充足）\n- 跨服务查询（如销售服务查询财务科目余额）\n- 服务健康检查\n\n### 5.2 异步通信：Kafka 事件\n\n```rust\n// Kafka 主题命名规范：<domain>.<aggregate>.<event>\n// 示例主题：\n- financial.account.created\n- financial.transaction.posted\n- sales.order.created\n- materials.goods_received.completed\n\n// 事件消息格式（CloudEvents 规范）\n{\n  \"specversion\": \"1.0\",\n  \"type\": \"com.erp.financial.transaction.posted\",\n  \"source\": \"/financial-service\",\n  \"id\": \"TX-001-20250621\",\n  \"time\": \"2025-12-21T10:00:00Z\",\n  \"datacontenttype\": \"application/json\",\n  \"data\": {\n    \"transaction_id\": \"TX-001\",\n    \"amount\": 10000,\n    \"currency\": \"CNY\",\n    ...\n  }\n}\n```\n\n**使用场景**：\n- 领域事件发布/订阅（如交易过账后通知成本中心）\n- 跨服务数据同步（如客户主数据变更同步到销售/财务）\n- 审计日志和事件溯源\n\n### 5.3 服务依赖图\n\n```\n财务服务 (Financial)\n  ↓ gRPC 调用（查询科目）\n销售服务 (Sales) ──→ 发布事件：OrderCreated\n  ↓ 订阅\n财务服务 (Financial) ──→ 自动创建应收账款凭证\n\n物料服务 (Materials) ──→ 发布事件：GoodsReceivedCompleted\n  ↓ 订阅\n财务服务 (Financial) ──→ 自动创建库存凭证\n```\n\n---\n\n## 6. 数据库设计原则\n\n### 6.1 每服务独立数据库\n\n```\nfinancial-service    → financial_db (PostgreSQL)\nsales-service        → sales_db (PostgreSQL)\nmaterials-service    → materials_db (PostgreSQL)\n...\n\n原则：\n- 每个微服务拥有独立的数据库实例或 Schema\n- 禁止跨服务直接访问数据库\n- 数据共享通过 API 或事件实现\n```\n\n### 6.2 事件存储表设计\n\n```sql\n-- 事件存储表（每个服务都有）\nCREATE TABLE events (\n    event_id         UUID PRIMARY KEY,\n    aggregate_type   VARCHAR(100) NOT NULL,  -- 聚合类型：Account/Transaction\n    aggregate_id     VARCHAR(100) NOT NULL,  -- 聚合ID\n    event_type       VARCHAR(200) NOT NULL,  -- 事件类型\n    event_version    INT NOT NULL,           -- 事件版本号\n    payload          JSONB NOT NULL,         -- 事件数据\n    metadata         JSONB,                  -- 元数据（用户、IP等）\n    created_at       TIMESTAMP NOT NULL,\n    sequence_number  BIGSERIAL                -- 全局顺序号\n);\n\nCREATE INDEX idx_events_aggregate ON events(aggregate_type, aggregate_id);\nCREATE INDEX idx_events_created_at ON events(created_at);\nCREATE INDEX idx_events_sequence ON events(sequence_number);\n```\n\n### 6.3 CQRS 读写分离\n\n```sql\n-- 写模型（标准化）\nCREATE TABLE accounts (\n    account_id       UUID PRIMARY KEY,\n    account_number   VARCHAR(20) UNIQUE NOT NULL,\n    account_type     VARCHAR(50) NOT NULL,\n    currency         VARCHAR(3) NOT NULL,\n    created_at       TIMESTAMP NOT NULL\n);\n\nCREATE TABLE transactions (\n    transaction_id   UUID PRIMARY KEY,\n    posting_date     DATE NOT NULL,\n    document_number  VARCHAR(50),\n    created_at       TIMESTAMP NOT NULL\n);\n\nCREATE TABLE journal_entries (\n    entry_id         UUID PRIMARY KEY,\n    transaction_id   UUID REFERENCES transactions(transaction_id),\n    account_id       UUID REFERENCES accounts(account_id),\n    debit_amount     DECIMAL(19,2),\n    credit_amount    DECIMAL(19,2)\n);\n\n-- 读模型（反规范化，查询优化）\nCREATE MATERIALIZED VIEW account_balance_view AS\nSELECT\n    a.account_id,\n    a.account_number,\n    a.account_type,\n    COALESCE(SUM(je.debit_amount), 0) - COALESCE(SUM(je.credit_amount), 0) AS balance,\n    MAX(t.posting_date) AS last_posting_date\nFROM accounts a\nLEFT JOIN journal_entries je ON a.account_id = je.account_id\nLEFT JOIN transactions t ON je.transaction_id = t.transaction_id\nGROUP BY a.account_id, a.account_number, a.account_type;\n\n-- 定时刷新物化视图\nCREATE INDEX idx_account_balance_account_number ON account_balance_view(account_number);\n```\n\n---\n\n## 7. 可观测性设计\n\n### 7.1 监控指标（Prometheus）\n\n```rust\n// Prometheus 指标定义\nuse prometheus::{Counter, Histogram, Gauge};\n\n// 业务指标\n- financial_transactions_total (Counter)           // 交易总数\n- financial_transaction_amount_total (Counter)     // 交易总金额\n- financial_account_balance (Gauge)                // 账户余额\n\n// 技术指标\n- http_requests_total (Counter)                    // HTTP 请求总数\n- http_request_duration_seconds (Histogram)        // 请求延迟\n- grpc_requests_total (Counter)                    // gRPC 请求总数\n- db_query_duration_seconds (Histogram)            // 数据库查询延迟\n- kafka_messages_published_total (Counter)         // Kafka 消息发布数\n- kafka_messages_consumed_total (Counter)          // Kafka 消息消费数\n```\n\n### 7.2 日志规范（结构化日志）\n\n```rust\n// 使用 tracing 库\nuse tracing::{info, warn, error, debug};\n\n// 日志字段规范\ninfo!(\n    transaction_id = %tx_id,\n    account_number = %account_no,\n    amount = %amount,\n    user_id = %user_id,\n    trace_id = %trace_id,  // 链路追踪ID\n    \"Transaction posted successfully\"\n);\n\n// 日志级别：\n// ERROR: 系统错误、业务异常\n// WARN:  潜在问题、降级操作\n// INFO:  关键业务操作（交易过账、订单创建）\n// DEBUG: 调试信息（开发环境）\n```\n\n### 7.3 分布式追踪（Jaeger）\n\n```rust\n// OpenTelemetry 集成\nuse opentelemetry::trace::{Tracer, Span};\n\n// Trace 传播：\nHTTP Header: traceparent: 00-{trace-id}-{span-id}-01\ngRPC Metadata: grpc-trace-bin\n\n// Span 命名规范：\n- HTTP: \"POST /api/transactions\"\n- gRPC: \"FinancialService/PostTransaction\"\n- DB:   \"SELECT accounts WHERE account_number = ?\"\n- Kafka: \"Publish financial.transaction.posted\"\n```\n\n---\n\n## 8. 安全设计\n\n### 8.1 认证与授权\n\n```\n┌──────────────────────────────────────────────────────────┐\n│  认证流程：JWT (JSON Web Token)                           │\n└──────────────────────────────────────────────────────────┘\n\n1. 客户端 → Auth Service: POST /auth/login (username, password)\n2. Auth Service 验证 → 返回 JWT Token\n3. 客户端携带 Token → API Gateway: Authorization: Bearer <JWT>\n4. API Gateway 验证签名 → 转发到微服务\n5. 微服务验证 Token → 提取用户信息（user_id, roles）\n\nJWT Payload 示例：\n{\n  \"sub\": \"user-123\",                    // 用户ID\n  \"username\": \"john.doe\",\n  \"roles\": [\"财务主管\", \"会计\"],        // 角色\n  \"permissions\": [\"account:read\", \"transaction:write\"],  // 权限\n  \"exp\": 1703145600                     // 过期时间\n}\n```\n\n### 8.2 权限控制（RBAC）\n\n```rust\n// 基于角色的访问控制（Role-Based Access Control）\n\n// 角色定义\nenum Role {\n    FinanceManager,       // 财务主管\n    Accountant,           // 会计\n    SalesManager,         // 销售主管\n    WarehouseKeeper,      // 仓库管理员\n    SystemAdmin,          // 系统管理员\n}\n\n// 权限检查中间件\n#[derive(Debug)]\nstruct RequirePermission(&'static str);\n\n// 使用示例\nasync fn post_transaction(\n    Extension(user): Extension<User>,\n    _: RequirePermission(\"transaction:write\"),  // 权限检查\n    Json(payload): Json<PostTransactionRequest>\n) -> Result<Json<TransactionResponse>, Error> {\n    // 业务逻辑\n}\n```\n\n### 8.3 数据加密\n\n```rust\n// 敏感数据加密存储\n- 密码：bcrypt hash（不可逆）\n- 银行账号：AES-256-GCM 加密\n- 个人信息：字段级加密（column-level encryption）\n\n// 传输加密\n- HTTPS/TLS 1.3（外部通信）\n- mTLS（服务间 gRPC 通信）\n\n// 密钥管理\n- 使用 Vault 或 AWS KMS 管理密钥\n- 密钥轮换策略（每90天）\n```\n\n---\n\n## 9. 部署架构\n\n### 9.1 Kubernetes 部署拓扑\n\n```yaml\n# 命名空间划分\nnamespaces:\n  - erp-prod           # 生产环境\n  - erp-staging        # 预发布环境\n  - erp-dev            # 开发环境\n  - erp-infra          # 基础设施（Kafka, PostgreSQL）\n\n# 每个微服务的 Kubernetes 资源\nfinancial-service/\n├── deployment.yaml        # Deployment（3副本）\n├── service.yaml           # Service（ClusterIP）\n├── ingress.yaml           # Ingress（外部访问）\n├── hpa.yaml               # HorizontalPodAutoscaler（自动扩缩容）\n├── configmap.yaml         # 配置（非敏感）\n└── secret.yaml            # 密钥（数据库密码、JWT密钥）\n\n# HPA 配置示例\nspec:\n  minReplicas: 3\n  maxReplicas: 20\n  metrics:\n    - type: Resource\n      resource:\n        name: cpu\n        target:\n          type: Utilization\n          averageUtilization: 70    # CPU 70% 触发扩容\n    - type: Pods\n      pods:\n        metric:\n          name: http_requests_per_second\n        target:\n          type: AverageValue\n          averageValue: \"1000\"      # 每秒1000请求触发扩容\n```\n\n### 9.2 服务网格（Istio）\n\n```yaml\n# 使用 Istio 实现：\n- 服务发现\n- 负载均衡（Round Robin / Least Conn）\n- 熔断器（Circuit Breaker）\n- 重试和超时\n- mTLS 加密\n- 流量管理（金丝雀发布、蓝绿部署）\n\n# VirtualService 示例（金丝雀发布）\napiVersion: networking.istio.io/v1beta1\nkind: VirtualService\nmetadata:\n  name: financial-service\nspec:\n  hosts:\n    - financial-service\n  http:\n    - match:\n        - headers:\n            x-canary:\n              exact: \"true\"\n      route:\n        - destination:\n            host: financial-service\n            subset: v2\n          weight: 100\n    - route:\n        - destination:\n            host: financial-service\n            subset: v1\n          weight: 90        # 90% 流量到 v1\n        - destination:\n            host: financial-service\n            subset: v2\n          weight: 10        # 10% 流量到 v2（新版本）\n```\n\n### 9.3 CI/CD 流程\n\n```yaml\n# GitHub Actions 工作流\nname: Build and Deploy Financial Service\n\non:\n  push:\n    branches: [main]\n    paths:\n      - 'services/financial-service/**'\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions-rs/toolchain@v1\n        with:\n          toolchain: stable\n      - run: cargo test --workspace\n      - run: cargo clippy -- -D warnings\n      - run: cargo fmt -- --check\n\n  build:\n    needs: test\n    runs-on: ubuntu-latest\n    steps:\n      - uses: docker/build-push-action@v4\n        with:\n          context: ./services/financial-service\n          push: true\n          tags: |\n            registry.example.com/financial-service:${{ github.sha }}\n            registry.example.com/financial-service:latest\n\n  deploy:\n    needs: build\n    runs-on: ubuntu-latest\n    steps:\n      - run: kubectl set image deployment/financial-service \\\n              financial-service=registry.example.com/financial-service:${{ github.sha }}\n      - run: kubectl rollout status deployment/financial-service\n```\n\n---\n\n## 10. 性能优化策略\n\n### 10.1 缓存策略\n\n```rust\n// 三级缓存架构\n1. 应用内缓存（Process Cache）\n   - 使用 moka 或 cached crate\n   - 缓存不变数据：科目表、汇率表\n   - TTL: 5-15分钟\n\n2. 分布式缓存（Redis）\n   - 缓存热数据：用户Session、常用查询结果\n   - 使用 Redis Cluster（主从复制 + 哨兵）\n   - TTL: 1-24小时\n   - 缓存失效策略：Write-Through / Cache-Aside\n\n3. CDN 缓存\n   - 缓存静态资源（前端、文档）\n   - TTL: 7-30天\n\n// Redis 缓存示例\ncache_key: \"account:balance:{account_number}:{currency}:{date}\"\ncache_value: { \"balance\": 100000.00, \"updated_at\": \"2025-12-21T10:00:00Z\" }\nTTL: 3600 seconds (1小时)\n```\n\n### 10.2 数据库优化\n\n```sql\n-- 索引策略\nCREATE INDEX CONCURRENTLY idx_transactions_posting_date\n    ON transactions(posting_date DESC);  -- 按日期查询优化\n\nCREATE INDEX CONCURRENTLY idx_journal_entries_account_id_posting_date\n    ON journal_entries(account_id, posting_date DESC);  -- 复合索引\n\n-- 分区表（按月分区）\nCREATE TABLE transactions (\n    transaction_id UUID,\n    posting_date DATE NOT NULL,\n    ...\n) PARTITION BY RANGE (posting_date);\n\nCREATE TABLE transactions_2025_01 PARTITION OF transactions\n    FOR VALUES FROM ('2025-01-01') TO ('2025-02-01');\n\nCREATE TABLE transactions_2025_02 PARTITION OF transactions\n    FOR VALUES FROM ('2025-02-01') TO ('2025-03-01');\n\n-- 读写分离\n- 主库（Master）：处理写操作（INSERT/UPDATE/DELETE）\n- 从库（Slave）：处理读操作（SELECT）\n- 使用 PgBouncer 连接池\n```\n\n### 10.3 异步处理\n\n```rust\n// 使用消息队列异步处理耗时任务\n\n// 同步流程（慢）\nPOST /api/reports/generate-balance-sheet\n→ 计算所有科目余额（5分钟）\n→ 生成 PDF（2分钟）\n→ 返回下载链接\n\n// 异步流程（快）\nPOST /api/reports/generate-balance-sheet\n→ 创建任务记录（Task ID: RPT-001）\n→ 发送 Kafka 消息到 report.generation.requested\n→ 立即返回 202 Accepted { task_id: \"RPT-001\" }\n\n后台 Worker 监听 Kafka：\n→ 生成报表\n→ 上传到 S3\n→ 发送通知到用户\n\n用户轮询或 WebSocket 接收完成通知：\nGET /api/tasks/RPT-001\n→ { status: \"completed\", download_url: \"...\" }\n```\n\n---\n\n## 11. 灾难恢复与高可用\n\n### 11.1 备份策略\n\n```bash\n# PostgreSQL 备份\n- 每日全量备份（pg_dump）\n- 每小时增量备份（WAL归档）\n- 保留30天历史备份\n- 跨区域复制（异地容灾）\n\n# 备份脚本示例\n0 2 * * * pg_dump financial_db | gzip > /backup/financial_db_$(date +\\%Y\\%m\\%d).sql.gz\n```\n\n### 11.2 高可用架构\n\n```\n┌────────────────────────────────────────────────┐\n│         负载均衡器 (Load Balancer)              │\n│              Nginx / HAProxy                   │\n└────────────────────────────────────────────────┘\n                    ↓ 健康检查\n    ┌───────────────┬───────────────┬──────────────┐\n    │  Pod 1        │  Pod 2        │  Pod 3       │\n    │  (Zone A)     │  (Zone B)     │  (Zone C)    │  多可用区部署\n    └───────────────┴───────────────┴──────────────┘\n                    ↓\n    ┌───────────────────────────────────────────┐\n    │  PostgreSQL 主从复制 (Patroni + etcd)      │\n    │  Master (Zone A) → Slave (Zone B, C)      │\n    └───────────────────────────────────────────┘\n\n- RTO（恢复时间目标）：< 5分钟\n- RPO（恢复点目标）：< 1分钟（数据丢失容忍度）\n```\n\n---\n\n## 12. 开发规范\n\n### 12.1 代码规范\n\n```rust\n// 1. 命名规范\n- 文件名：snake_case（account_service.rs）\n- 结构体/枚举：PascalCase（AccountAggregate）\n- 函数/变量：snake_case（create_account）\n- 常量：SCREAMING_SNAKE_CASE（MAX_RETRY_COUNT）\n\n// 2. 错误处理\n- 使用 thiserror 定义领域错误\n- 使用 anyhow 处理基础设施错误\n- 禁止 unwrap()/expect()（除测试代码）\n\n#[derive(Debug, thiserror::Error)]\npub enum AccountError {\n    #[error(\"Account {0} not found\")]\n    NotFound(String),\n\n    #[error(\"Insufficient balance: required {required}, available {available}\")]\n    InsufficientBalance { required: Decimal, available: Decimal },\n}\n\n// 3. 测试覆盖率\n- 单元测试：70%+（领域层必须100%）\n- 集成测试：核心业务流程全覆盖\n- 使用 cargo-tarpaulin 检查覆盖率\n\n// 4. 文档注释\n/// 过账交易到总账\n///\n/// # 参数\n/// - `transaction`: 待过账的交易\n///\n/// # 返回\n/// - `Ok(JournalEntry)`: 成功生成的分录\n/// - `Err(AccountError)`: 业务校验失败\n///\n/// # 示例\n/// ```rust\n/// let entry = post_transaction(tx).await?;\n/// ```\npub async fn post_transaction(transaction: Transaction) -> Result<JournalEntry, AccountError>\n```\n\n### 12.2 Git 工作流\n\n```bash\n# 分支策略（GitFlow）\nmain              # 生产分支（受保护）\n├── develop       # 开发主分支\n│   ├── feature/add-account-api      # 功能分支\n│   ├── feature/impl-cqrs            # 功能分支\n│   └── bugfix/fix-balance-calc      # 缺陷修复分支\n└── release/v1.0.0                   # 发布分支\n\n# Commit 规范（Conventional Commits）\nfeat: 添加会计科目创建API\nfix: 修复余额计算精度问题\ndocs: 更新架构设计文档\nrefactor: 重构事件发布逻辑\ntest: 添加交易过账集成测试\nchore: 升级 Axum 到 0.7.5\n```\n\n---\n\n## 13. 附录：术语表\n\n| 术语 | 英文 | 说明 |\n|-----|------|-----|\n| 聚合根 | Aggregate Root | DDD 中的核心概念，保证一致性边界 |\n| 值对象 | Value Object | 无唯一标识，由属性值定义的不可变对象 |\n| 领域事件 | Domain Event | 业务操作产生的事实记录 |\n| 仓储 | Repository | 领域对象持久化抽象接口 |\n| CQRS | Command Query Responsibility Segregation | 命令查询职责分离模式 |\n| 事件溯源 | Event Sourcing | 通过事件序列重建状态的模式 |\n| 幂等性 | Idempotency | 多次执行相同操作结果一致 |\n| 最终一致性 | Eventual Consistency | 分布式系统中数据最终达成一致 |\n| 限界上下文 | Bounded Context | DDD 中明确的模型边界 |\n| 熔断器 | Circuit Breaker | 防止级联故障的保护机制 |\n\n---\n\n\n**文档版本**: v1.0\n**最后更新**: 2025-12-21\n**维护者**: ERP 开发团队\n", "md/Rust-Dir.md": "# Rust ERP 系统项目目录结构（附中文注释）\n\n```\n/                                    # 项目根目录\n├── Cargo.toml                                 # Workspace工作空间配置文件\n├── Cargo.lock                                 # 依赖锁定文件\n├── .github/                                   # GitHub相关配置\n│   └── workflows/                             # GitHub Actions工作流\n│       ├── ci.yml                             # 持续集成流程\n│       ├── deploy-staging.yml                 # 部署到预发环境\n│       ├── deploy-production.yml              # 部署到生产环境\n│       └── security-audit.yml                 # 安全审计流程\n├── .gitignore                                 # Git忽略文件配置\n├── README.md                                  # 项目说明文档\n├── docker/                                    # Docker相关配置\n│   ├── Dockerfile.service                     # 微服务通用Dockerfile\n│   ├── docker-compose.yml                     # 完整系统编排文件\n│   ├── docker-compose.dev.yml                 # 开发环境编排文件\n│   └── docker-compose.prod.yml                # 生产环境编排文件\n├── k8s/                                       # Kubernetes部署配置\n│   ├── base/                                  # Kustomize基础配置\n│   │   ├── namespace.yaml                     # 命名空间定义\n│   │   ├── api-gateway/                       # API网关部署配置\n│   │   ├── financial-service/                 # 财务服务部署配置\n│   │   ├── controlling-service/               # 管理会计服务部署配置\n│   │   ├── materials-service/                 # 物料服务部署配置\n│   │   ├── sales-service/                     # 销售服务部署配置\n│   │   ├── production-service/                # 生产服务部署配置\n│   │   ├── hr-service/                        # 人力资源服务部署配置\n│   │   ├── quality-service/                   # 质量管理服务部署配置\n│   │   ├── maintenance-service/               # 设备维护服务部署配置\n│   │   ├── crm-service/                       # 客户关系服务部署配置\n│   │   ├── project-service/                   # 项目管理服务部署配置\n│   │   ├── scm-service/                       # 供应链服务部署配置\n│   │   ├── treasury-service/                  # 资金管理服务部署配置\n│   │   ├── warehouse-service/                 # 仓库服务部署配置\n│   │   ├── shipping-service/                  # 运输服务部署配置\n│   │   └── analytics-service/                 # 分析服务部署配置\n│   ├── overlays/                              # Kustomize环境覆盖配置\n│   │   ├── dev/                               # 开发环境配置\n│   │   ├── staging/                           # 预发环境配置\n│   │   └── production/                        # 生产环境配置\n│   └── helm/                                  # Helm Charts\n│       └── erp-system/                        # ERP系统Helm Chart\n│           ├── Chart.yaml                     # Chart元数据\n│           ├── values.yaml                    # 默认配置值\n│           ├── values-dev.yaml                # 开发环境配置值\n│           ├── values-staging.yaml            # 预发环境配置值\n│           ├── values-production.yaml         # 生产环境配置值\n│           └── templates/                     # Kubernetes模板文件\n├── proto/                                     # gRPC协议定义文件\n│   ├── common/                                # 通用协议\n│   │   └── v1/                                # v1版本\n│   │       ├── error.proto                    # 错误定义\n│   │       ├── pagination.proto               # 分页定义\n│   │       └── metadata.proto                 # 元数据定义\n│   ├── financial/                             # 财务服务协议\n│   │   └── v1/\n│   │       ├── financial_service.proto        # 财务服务主接口\n│   │       ├── general_ledger.proto           # 总账协议\n│   │       ├── accounts_payable.proto         # 应付账款协议\n│   │       ├── accounts_receivable.proto      # 应收账款协议\n│   │       └── asset_accounting.proto         # 资产会计协议\n│   ├── controlling/                           # 管理会计服务协议\n│   │   └── v1/\n│   │       ├── controlling_service.proto      # 管理会计服务主接口\n│   │       ├── cost_center.proto              # 成本中心协议\n│   │       └── profitability.proto            # 盈利能力分析协议\n│   ├── materials/                             # 物料服务协议\n│   │   └── v1/\n│   │       ├── materials_service.proto        # 物料服务主接口\n│   │       ├── purchasing.proto               # 采购协议\n│   │       ├── inventory.proto                # 库存协议\n│   │       └── invoice_verification.proto     # 发票校验协议\n│   ├── sales/                                 # 销售服务协议\n│   │   └── v1/\n│   │       ├── sales_service.proto            # 销售服务主接口\n│   │       ├── order.proto                    # 订单协议\n│   │       ├── shipping.proto                 # 发货协议\n│   │       └── billing.proto                  # 计费协议\n│   ├── production/                            # 生产服务协议\n│   │   └── v1/\n│   │       ├── production_service.proto       # 生产服务主接口\n│   │       ├── planning.proto                 # 生产计划协议\n│   │       └── shop_floor.proto               # 车间控制协议\n│   ├── hr/                                    # 人力资源服务协议\n│   │   └── v1/\n│   │       ├── hr_service.proto               # 人力资源服务主接口\n│   │       ├── personnel.proto                # 人事协议\n│   │       ├── payroll.proto                  # 工资协议\n│   │       └── time_management.proto          # 时间管理协议\n│   ├── quality/                               # 质量管理服务协议\n│   │   └── v1/\n│   │       └── quality_service.proto          # 质量服务主接口\n│   ├── maintenance/                           # 设备维护服务协议\n│   │   └── v1/\n│   │       └── maintenance_service.proto      # 维护服务主接口\n│   ├── crm/                                   # 客户关系服务协议\n│   │   └── v1/\n│   │       └── crm_service.proto              # CRM服务主接口\n│   ├── project/                               # 项目管理服务协议\n│   │   └── v1/\n│   │       └── project_service.proto          # 项目服务主接口\n│   ├── scm/                                   # 供应链服务协议\n│   │   └── v1/\n│   │       └── scm_service.proto              # 供应链服务主接口\n│   ├── treasury/                              # 资金管理服务协议\n│   │   └── v1/\n│   │       └── treasury_service.proto         # 资金服务主接口\n│   ├── warehouse/                             # 仓库服务协议\n│   │   └── v1/\n│   │       └── warehouse_service.proto        # 仓库服务主接口\n│   ├── shipping/                              # 运输服务协议\n│   │   └── v1/\n│   │       └── shipping_service.proto         # 运输服务主接口\n│   └── analytics/                             # 分析服务协议\n│       └── v1/\n│           └── analytics_service.proto        # 分析服务主接口\n├── shared/                                    # 共享库目录\n│   ├── domain-primitives/                     # 领域原语库\n│   │   ├── Cargo.toml                         # 包配置\n│   │   └── src/\n│   │       ├── lib.rs                         # 库入口\n│   │       ├── money.rs                       # 货币值对象\n│   │       ├── currency.rs                    # 货币类型\n│   │       ├── email.rs                       # 邮箱值对象\n│   │       ├── phone_number.rs                # 电话号码值对象\n│   │       ├── address.rs                     # 地址值对象\n│   │       ├── uuid_wrapper.rs                # UUID包装器\n│   │       ├── quantity.rs                    # 数量值对象\n│   │       ├── percentage.rs                  # 百分比值对象\n│   │       ├── date_range.rs                  # 日期范围值对象\n│   │       └── entity_id.rs                   # 实体ID值对象\n│   ├── event-sourcing/                        # 事件溯源框架库\n│   │   ├── Cargo.toml\n│   │   └── src/\n│   │       ├── lib.rs                         # 库入口\n│   │       ├── event.rs                       # 事件trait定义\n│   │       ├── event_store.rs                 # 事件存储接口\n│   │       ├── aggregate.rs                   # 聚合根trait\n│   │       ├── snapshot.rs                    # 快照功能\n│   │       └── projection.rs                  # 事件投影\n│   ├── cqrs/                                  # CQRS框架库\n│   │   ├── Cargo.toml\n│   │   └── src/\n│   │       ├── lib.rs                         # 库入口\n│   │       ├── command.rs                     # 命令trait定义\n│   │       ├── command_handler.rs             # 命令处理器\n│   │       ├── query.rs                       # 查询trait定义\n│   │       ├── query_handler.rs               # 查询处理器\n│   │       └── bus.rs                         # 消息总线\n│   ├── observability/                         # 可观测性库\n│   │   ├── Cargo.toml\n│   │   └── src/\n│   │       ├── lib.rs                         # 库入口\n│   │       ├── tracing.rs                     # 分布式追踪\n│   │       ├── metrics.rs                     # 指标采集\n│   │       ├── logging.rs                     # 日志记录\n│   │       └── correlation_id.rs              # 关联ID生成\n│   ├── messaging/                             # 消息传递库\n│   │   ├── Cargo.toml\n│   │   └── src/\n│   │       ├── lib.rs                         # 库入口\n│   │       ├── kafka/                         # Kafka集成\n│   │       │   ├── mod.rs\n│   │       │   ├── producer.rs                # 生产者封装\n│   │       │   └── consumer.rs                # 消费者封装\n│   │       └── event_bus.rs                   # 事件总线抽象\n│   ├── auth/                                  # 认证授权库\n│   │   ├── Cargo.toml\n│   │   └── src/\n│   │       ├── lib.rs                         # 库入口\n│   │       ├── jwt.rs                         # JWT认证\n│   │       ├── oauth.rs                       # OAuth2.0\n│   │       ├── rbac.rs                        # 基于角色的访问控制\n│   │       └── permissions.rs                 # 权限管理\n│   └── api-contracts/                         # API契约库\n│       ├── Cargo.toml\n│       └── src/\n│           ├── lib.rs                         # 库入口\n│           ├── request.rs                     # 请求基类\n│           ├── response.rs                    # 响应基类\n│           ├── error.rs                       # 错误定义\n│           └── pagination.rs                  # 分页定义\n├── services/                                  # 微服务目录\n│   ├── financial-service/                     # 财务服务（对应KILLER FI模块）\n│   │   ├── Cargo.toml                         # 服务依赖配置\n│   │   ├── src/\n│   │   │   ├── main.rs                        # 服务入口\n│   │   │   ├── config.rs                      # 配置加载\n│   │   │   ├── api/                           # API接口层\n│   │   │   │   ├── mod.rs\n│   │   │   │   ├── rest/                      # REST API\n│   │   │   │   │   ├── mod.rs\n│   │   │   │   │   ├── routes.rs              # 路由定义\n│   │   │   │   │   ├── handlers/              # HTTP处理器\n│   │   │   │   │   │   ├── mod.rs\n│   │   │   │   │   │   ├── general_ledger_handler.rs      # 总账处理器\n│   │   │   │   │   │   ├── accounts_payable_handler.rs    # 应付账款处理器\n│   │   │   │   │   │   ├── accounts_receivable_handler.rs # 应收账款处理器\n│   │   │   │   │   │   └── asset_accounting_handler.rs    # 资产会计处理器\n│   │   │   │   │   └── dto/                   # 数据传输对象\n│   │   │   │   │       ├── mod.rs\n│   │   │   │   │       ├── gl_dto.rs          # 总账DTO\n│   │   │   │   │       ├── ap_dto.rs          # 应付账款DTO\n│   │   │   │   │       ├── ar_dto.rs          # 应收账款DTO\n│   │   │   │   │       └── aa_dto.rs          # 资产会计DTO\n│   │   │   │   └── grpc/                      # gRPC接口\n│   │   │   │       ├── mod.rs\n│   │   │   │       └── financial_service_impl.rs # gRPC服务实现\n│   │   │   ├── application/                   # 应用层（CQRS）\n│   │   │   │   ├── mod.rs\n│   │   │   │   ├── commands/                  # 命令（写操作）\n│   │   │   │   │   ├── mod.rs\n│   │   │   │   │   ├── gl/                    # 总账命令\n│   │   │   │   │   │   ├── mod.rs\n│   │   │   │   │   │   ├── create_journal_entry.rs   # 创建凭证\n│   │   │   │   │   │   ├── post_journal_entry.rs     # 过账凭证\n│   │   │   │   │   │   └── reverse_entry.rs          # 冲销凭证\n│   │   │   │   │   ├── ap/                    # 应付账款命令\n│   │   │   │   │   │   ├── mod.rs\n│   │   │   │   │   │   ├── create_invoice.rs         # 创建发票\n│   │   │   │   │   │   ├── process_payment.rs        # 处理付款\n│   │   │   │   │   │   └── create_credit_memo.rs     # 创建贷项凭证\n│   │   │   │   │   ├── ar/                    # 应收账款命令\n│   │   │   │   │   │   ├── mod.rs\n│   │   │   │   │   │   ├── create_customer_invoice.rs # 创建客户发票\n│   │   │   │   │   │   ├── record_payment.rs          # 记录收款\n│   │   │   │   │   │   └── dunning.rs                 # 催款处理\n│   │   │   │   │   └── aa/                    # 资产会计命令\n│   │   │   │   │       ├── mod.rs\n│   │   │   │   │       ├── acquire_asset.rs           # 资产购置\n│   │   │   │   │       ├── depreciate_asset.rs        # 资产折旧\n│   │   │   │   │       └── retire_asset.rs            # 资产报废\n│   │   │   │   ├── queries/                   # 查询（读操作）\n│   │   │   │   │   ├── mod.rs\n│   │   │   │   │   ├── gl/                    # 总账查询\n│   │   │   │   │   │   ├── mod.rs\n│   │   │   │   │   │   ├── get_trial_balance.rs      # 获取试算表\n│   │   │   │   │   │   ├── get_account_balance.rs    # 获取科目余额\n│   │   │   │   │   │   └── get_journal_entries.rs    # 获取凭证列表\n│   │   │   │   │   ├── ap/                    # 应付账款查询\n│   │   │   │   │   │   ├── mod.rs\n│   │   │   │   │   │   ├── get_open_items.rs         # 获取未清项\n│   │   │   │   │   │   └── get_vendor_ledger.rs      # 获取供应商分类账\n│   │   │   │   │   ├── ar/                    # 应收账款查询\n│   │   │   │   │   │   ├── mod.rs\n│   │   │   │   │   │   ├── get_aging_report.rs       # 获取账龄分析\n│   │   │   │   │   │   └── get_customer_ledger.rs    # 获取客户分类账\n│   │   │   │   │   └── aa/                    # 资产会计查询\n│   │   │   │   │       ├── mod.rs\n│   │   │   │   │       └── get_asset_register.rs     # 获取资产登记簿\n│   │   │   │   └── services/                  # 应用服务\n│   │   │   │       ├── mod.rs\n│   │   │   │       └── financial_application_service.rs # 财务应用服务\n│   │   │   ├── domain/                        # 领域层（DDD核心）\n│   │   │   │   ├── mod.rs\n│   │   │   │   ├── aggregates/                # 聚合根\n│   │   │   │   │   ├── mod.rs\n│   │   │   │   │   ├── gl/                    # 总账聚合\n│   │   │   │   │   │   ├── mod.rs\n│   │   │   │   │   │   ├── journal_entry.rs          # 凭证聚合根\n│   │   │   │   │   │   ├── account.rs                # 会计科目\n│   │   │   │   │   │   └── fiscal_period.rs          # 会计期间\n│   │   │   │   │   ├── ap/                    # 应付账款聚合\n│   │   │   │   │   │   ├── mod.rs\n│   │   │   │   │   │   ├── vendor_invoice.rs         # 供应商发票聚合根\n│   │   │   │   │   │   ├── payment.rs                # 付款\n│   │   │   │   │   │   └── vendor.rs                 # 供应商\n│   │   │   │   │   ├── ar/                    # 应收账款聚合\n│   │   │   │   │   │   ├── mod.rs\n│   │   │   │   │   │   ├── customer_invoice.rs       # 客户发票聚合根\n│   │   │   │   │   │   ├── customer_payment.rs       # 客户付款\n│   │   │   │   │   │   └── customer.rs               # 客户\n│   │   │   │   │   └── aa/                    # 资产会计聚合\n│   │   │   │   │       ├── mod.rs\n│   │   │   │   │       ├── asset.rs                  # 资产聚合根\n│   │   │   │   │       └── depreciation.rs           # 折旧\n│   │   │   │   ├── value_objects/             # 值对象\n│   │   │   │   │   ├── mod.rs\n│   │   │   │   │   ├── money.rs                      # 货币值对象\n│   │   │   │   │   ├── account_number.rs             # 科目编号\n│   │   │   │   │   ├── posting_key.rs                # 过账码\n│   │   │   │   │   ├── document_number.rs            # 凭证号\n│   │   │   │   │   └── tax_code.rs                   # 税码\n│   │   │   │   ├── events/                    # 领域事件\n│   │   │   │   │   ├── mod.rs\n│   │   │   │   │   ├── gl_events.rs                  # 总账事件\n│   │   │   │   │   ├── ap_events.rs                  # 应付账款事件\n│   │   │   │   │   ├── ar_events.rs                  # 应收账款事件\n│   │   │   │   │   └── aa_events.rs                  # 资产会计事件\n│   │   │   │   ├── services/                  # 领域服务\n│   │   │   │   │   ├── mod.rs\n│   │   │   │   │   ├── posting_validator.rs          # 过账验证服务\n│   │   │   │   │   ├── tax_calculator.rs             # 税金计算服务\n│   │   │   │   │   └── exchange_rate_service.rs      # 汇率服务\n│   │   │   │   └── repositories/              # 仓储接口（定义在领域层）\n│   │   │   │       ├── mod.rs\n│   │   │   │       ├── journal_entry_repository.rs   # 凭证仓储接口\n│   │   │   │       ├── invoice_repository.rs         # 发票仓储接口\n│   │   │   │       ├── payment_repository.rs         # 付款仓储接口\n│   │   │   │       └── asset_repository.rs           # 资产仓储接口\n│   │   │   └── infrastructure/                # 基础设施层\n│   │   │       ├── mod.rs\n│   │   │       ├── config.rs                         # 配置实现\n│   │   │       ├── persistence/               # 持久化\n│   │   │       │   ├── mod.rs\n│   │   │       │   ├── postgres/              # PostgreSQL实现\n│   │   │       │   │   ├── mod.rs\n│   │   │       │   │   ├── models.rs                 # 数据库模型\n│   │   │       │   │   ├── journal_entry_repository_impl.rs  # 凭证仓储实现\n│   │   │       │   │   ├── invoice_repository_impl.rs        # 发票仓储实现\n│   │   │       │   │   ├── payment_repository_impl.rs        # 付款仓储实现\n│   │   │       │   │   └── asset_repository_impl.rs          # 资产仓储实现\n│   │   │       │   └── redis/                 # Redis缓存\n│   │   │       │       ├── mod.rs\n│   │   │       │       └── cache.rs                  # 缓存实现\n│   │   │       └── messaging/                 # 消息传递\n│   │   │           ├── mod.rs\n│   │   │           ├── kafka_producer.rs             # Kafka生产者\n│   │   │           └── kafka_consumer.rs             # Kafka消费者\n│   │   ├── migrations/                        # 数据库迁移脚本\n│   │   │   ├── 20250101000000_create_gl_tables.sql           # 创建总账表\n│   │   │   ├── 20250101000001_create_ap_tables.sql           # 创建应付账款表\n│   │   │   ├── 20250101000002_create_ar_tables.sql           # 创建应收账款表\n│   │   │   └── 20250101000003_create_aa_tables.sql           # 创建资产会计表\n│   │   └── tests/                             # 测试目录\n│   │       ├── integration/                   # 集成测试\n│   │       │   ├── mod.rs\n│   │       │   ├── gl_tests.rs                       # 总账集成测试\n│   │       │   ├── ap_tests.rs                       # 应付账款集成测试\n│   │       │   ├── ar_tests.rs                       # 应收账款集成测试\n│   │       │   └── aa_tests.rs                       # 资产会计集成测试\n│   │       └── unit/                          # 单元测试\n│   │           ├── mod.rs\n│   │           └── domain/                    # 领域层单元测试\n│   │               ├── mod.rs\n│   │               └── aggregates/\n│   │\n│   ├── controlling-service/                   # 管理会计服务（对应KILLER CO模块）\n│   │   ├── Cargo.toml\n│   │   ├── src/\n│   │   │   ├── main.rs                        # 服务入口\n│   │   │   ├── config.rs                      # 配置加载\n│   │   │   ├── api/                           # API接口层\n│   │   │   │   ├── mod.rs\n│   │   │   │   ├── rest/                      # REST API\n│   │   │   │   │   ├── mod.rs\n│   │   │   │   │   ├── routes.rs              # 路由定义\n│   │   │   │   │   ├── handlers/              # HTTP处理器\n│   │   │   │   │   │   ├── mod.rs\n│   │   │   │   │   │   ├── cost_center_handler.rs           # 成本中心处理器\n│   │   │   │   │   │   ├── internal_order_handler.rs        # 内部订单处理器\n│   │   │   │   │   │   ├── product_costing_handler.rs       # 产品成本处理器\n│   │   │   │   │   │   └── profitability_handler.rs         # 盈利能力分析处理器\n│   │   │   │   │   └── dto/                   # 数据传输对象\n│   │   │   │   │       ├── mod.rs\n│   │   │   │   │       └── controlling_dto.rs        # 管理会计DTO\n│   │   │   │   └── grpc/                      # gRPC接口\n│   │   │   │       ├── mod.rs\n│   │   │   │       └── controlling_service_impl.rs   # gRPC服务实现\n│   │   │   ├── application/                   # 应用层\n│   │   │   │   ├── mod.rs\n│   │   │   │   ├── commands/                  # 命令\n│   │   │   │   │   ├── mod.rs\n│   │   │   │   │   ├── cost_center/           # 成本中心命令\n│   │   │   │   │   ├── internal_order/        # 内部订单命令\n│   │   │   │   │   ├── product_costing/       # 产品成本命令\n│   │   │   │   │   └── profitability/         # 盈利能力分析命令\n│   │   │   │   ├── queries/                   # 查询\n│   │   │   │   │   ├── mod.rs\n│   │   │   │   │   ├── cost_center/           # 成本中心查询\n│   │   │   │   │   ├── internal_order/        # 内部订单查询\n│   │   │   │   │   ├── product_costing/       # 产品成本查询\n│   │   │   │   │   └── profitability/         # 盈利能力分析查询\n│   │   │   │   └── services/                  # 应用服务\n│   │   │   │       ├── mod.rs\n│   │   │   │       └── controlling_application_service.rs # 管理会计应用服务\n│   │   │   ├── domain/                        # 领域层\n│   │   │   │   ├── mod.rs\n│   │   │   │   ├── aggregates/                # 聚合根\n│   │   │   │   │   ├── mod.rs\n│   │   │   │   │   ├── cost_center.rs                # 成本中心聚合根\n│   │   │   │   │   ├── internal_order.rs             # 内部订单聚合根\n│   │   │   │   │   ├── product_cost.rs               # 产品成本聚合根\n│   │   │   │   │   └── profit_center.rs              # 利润中心聚合根\n│   │   │   │   ├── value_objects/             # 值对象\n│   │   │   │   │   ├── mod.rs\n│   │   │   │   │   ├── cost_element.rs               # 成本要素\n│   │   │   │   │   └── activity_type.rs              # 作业类型\n│   │   │   │   ├── events/                    # 领域事件\n│   │   │   │   │   ├── mod.rs\n│   │   │   │   │   └── controlling_events.rs         # 管理会计事件\n│   │   │   │   ├── services/                  # 领域服务\n│   │   │   │   │   ├── mod.rs\n│   │   │   │   │   ├── cost_allocation_service.rs    # 成本分配服务\n│   │   │   │   │   └── variance_calculator.rs        # 差异计算服务\n│   │   │   │   └── repositories/              # 仓储接口\n│   │   │   │       ├── mod.rs\n│   │   │   │       ├── cost_center_repository.rs     # 成本中心仓储\n│   │   │   │       └── internal_order_repository.rs  # 内部订单仓储\n│   │   │   └── infrastructure/                # 基础设施层\n│   │   │       ├── mod.rs\n│   │   │       ├── config.rs\n│   │   │       ├── persistence/               # 持久化\n│   │   │       │   ├── mod.rs\n│   │   │       │   ├── postgres/              # PostgreSQL实现\n│   │   │       │   │   ├── mod.rs\n│   │   │       │   │   ├── models.rs                 # 数据库模型\n│   │   │       │   │   └── repository_impl.rs        # 仓储实现\n│   │   │       │   └── redis/                 # Redis缓存\n│   │   │       │       ├── mod.rs\n│   │   │       │       └── cache.rs\n│   │   │       └── messaging/                 # 消息传递\n│   │   │           ├── mod.rs\n│   │   │           ├── kafka_producer.rs\n│   │   │           └── kafka_consumer.rs\n│   │   ├── migrations/                        # 数据库迁移\n│   │   │   ├── 20250101000000_create_controlling_tables.sql  # 创建管理会计表\n│   │   │   └── 20250101000001_create_cost_center_tables.sql  # 创建成本中心表\n│   │   └── tests/                             # 测试\n│   │       ├── integration/                   # 集成测试\n│   │       └── unit/                          # 单元测试\n│   │\n│   ├── materials-service/                     # 物料服务（对应KILLER MM模块）\n│   │   ├── Cargo.toml\n│   │   ├── src/\n│   │   │   ├── main.rs\n│   │   │   ├── config.rs\n│   │   │   ├── api/                           # API接口层\n│   │   │   │   ├── mod.rs\n│   │   │   │   ├── rest/\n│   │   │   │   │   ├── mod.rs\n│   │   │   │   │   ├── routes.rs\n│   │   │   │   │   ├── handlers/\n│   │   │   │   │   │   ├── mod.rs\n│   │   │   │   │   │   ├── purchasing_handler.rs            # 采购处理器\n│   │   │   │   │   │   ├── inventory_handler.rs             # 库存处理器\n│   │   │   │   │   │   └── invoice_verification_handler.rs  # 发票校验处理器\n│   │   │   │   │   └── dto/\n│   │   │   │   │       ├── mod.rs\n│   │   │   │   │       └── materials_dto.rs          # 物料DTO\n│   │   │   │   └── grpc/\n│   │   │   │       ├── mod.rs\n│   │   │   │       └── materials_service_impl.rs\n│   │   │   ├── application/                   # 应用层\n│   │   │   │   ├── mod.rs\n│   │   │   │   ├── commands/\n│   │   │   │   │   ├── mod.rs\n│   │   │   │   │   ├── purchasing/            # 采购命令\n│   │   │   │   │   │   ├── mod.rs\n│   │   │   │   │   │   ├── create_purchase_order.rs         # 创建采购订单\n│   │   │   │   │   │   ├── create_rfq.rs                    # 创建询价\n│   │   │   │   │   │   └── create_contract.rs               # 创建合同\n│   │   │   │   │   ├── inventory/             # 库存命令\n│   │   │   │   │   │   ├── mod.rs\n│   │   │   │   │   │   ├── goods_receipt.rs                 # 收货\n│   │   │   │   │   │   ├── goods_issue.rs                   # 发货\n│   │   │   │   │   │   ├── stock_transfer.rs                # 库存转储\n│   │   │   │   │   │   └── physical_inventory.rs            # 实地盘点\n│   │   │   │   │   └── invoice/               # 发票命令\n│   │   │   │   │       ├── mod.rs\n│   │   │   │   │       └── verify_invoice.rs                # 校验发票\n│   │   │   │   ├── queries/                   # 查询\n│   │   │   │   │   ├── mod.rs\n│   │   │   │   │   ├── purchasing/            # 采购查询\n│   │   │   │   │   ├── inventory/             # 库存查询\n│   │   │   │   │   └── invoice/               # 发票查询\n│   │   │   │   └── services/\n│   │   │   │       ├── mod.rs\n│   │   │   │       └── materials_application_service.rs\n│   │   │   ├── domain/                        # 领域层\n│   │   │   │   ├── mod.rs\n│   │   │   │   ├── aggregates/\n│   │   │   │   │   ├── mod.rs\n│   │   │   │   │   ├── purchasing/            # 采购聚合\n│   │   │   │   │   │   ├── mod.rs\n│   │   │   │   │   │   ├── purchase_order.rs                # 采购订单聚合根\n│   │   │   │   │   │   ├── rfq.rs                           # 询价聚合根\n│   │   │   │   │   │   ├── contract.rs                      # 合同聚合根\n│   │   │   │   │   │   └── vendor.rs                        # 供应商\n│   │   │   │   │   ├── inventory/             # 库存聚合\n│   │   │   │   │   │   ├── mod.rs\n│   │   │   │   │   │   ├── material.rs                      # 物料聚合根\n│   │   │   │   │   │   ├── stock.rs                         # 库存\n│   │   │   │   │   │   ├── warehouse.rs                     # 仓库\n│   │   │   │   │   │   └── storage_location.rs              # 存储地点\n│   │   │   │   │   └── invoice/               # 发票聚合\n│   │   │   │   │       ├── mod.rs\n│   │   │   │   │       └── invoice_verification.rs          # 发票校验聚合根\n│   │   │   │   ├── value_objects/             # 值对象\n│   │   │   │   │   ├── mod.rs\n│   │   │   │   │   ├── sku.rs                               # SKU编码\n│   │   │   │   │   ├── quantity.rs                          # 数量\n│   │   │   │   │   ├── unit_of_measure.rs                   # 计量单位\n│   │   │   │   │   └── vendor_code.rs                       # 供应商代码\n│   │   │   │   ├── events/                    # 领域事件\n│   │   │   │   │   ├── mod.rs\n│   │   │   │   │   ├── purchasing_events.rs                 # 采购事件\n│   │   │   │   │   ├── inventory_events.rs                  # 库存事件\n│   │   │   │   │   └── invoice_events.rs                    # 发票事件\n│   │   │   │   ├── services/                  # 领域服务\n│   │   │   │   │   ├── mod.rs\n│   │   │   │   │   ├── stock_allocator.rs                   # 库存分配服务\n│   │   │   │   │   ├── reorder_service.rs                   # 再订货服务\n│   │   │   │   │   └── price_validator.rs                   # 价格验证服务\n│   │   │   │   └── repositories/              # 仓储接口\n│   │   │   │       ├── mod.rs\n│   │   │   │       ├── purchase_order_repository.rs         # 采购订单仓储\n│   │   │   │       ├── material_repository.rs               # 物料仓储\n│   │   │   │       └── stock_repository.rs                  # 库存仓储\n│   │   │   └── infrastructure/                # 基础设施层\n│   │   │       ├── mod.rs\n│   │   │       ├── config.rs\n│   │   │       ├── persistence/\n│   │   │       │   ├── mod.rs\n│   │   │       │   ├── postgres/\n│   │   │       │   │   ├── mod.rs\n│   │   │       │   │   ├── models.rs\n│   │   │       │   │   └── repository_impl.rs\n│   │   │       │   └── redis/\n│   │   │       │       ├── mod.rs\n│   │   │       │       └── cache.rs\n│   │   │       └── messaging/\n│   │   │           ├── mod.rs\n│   │   │           ├── kafka_producer.rs\n│   │   │           └── kafka_consumer.rs\n│   │   ├── migrations/\n│   │   │   ├── 20250101000000_create_materials_tables.sql   # 创建物料表\n│   │   │   ├── 20250101000001_create_purchasing_tables.sql  # 创建采购表\n│   │   │   └── 20250101000002_create_inventory_tables.sql   # 创建库存表\n│   │   └── tests/\n│   │       ├── integration/\n│   │       └── unit/\n│   │\n│   ├── sales-service/                         # 销售服务（对应KILLER SD模块）\n│   │   ├── Cargo.toml\n│   │   ├── src/\n│   │   │   ├── main.rs\n│   │   │   ├── config.rs\n│   │   │   ├── api/\n│   │   │   │   ├── mod.rs\n│   │   │   │   ├── rest/\n│   │   │   │   │   ├── mod.rs\n│   │   │   │   │   ├── routes.rs\n│   │   │   │   │   ├── handlers/\n│   │   │   │   │   │   ├── sales_order_handler.rs\n│   │   │   │   │   │   ├── delivery_handler.rs\n│   │   │   │   │   │   └── billing_handler.rs\n│   │   │   │   │   └── dto/\n│   │   │   │   │       ├── sales_order_dto.rs\n│   │   │   │   │       ├── delivery_dto.rs\n│   │   │   │   │       └── billing_dto.rs\n│   │   │   │   └── grpc/\n│   │   │   │       ├── mod.rs\n│   │   │   │       └── sales_service_impl.rs\n│   │   │   ├── application/\n│   │   │   │   ├── mod.rs\n│   │   │   │   ├── commands/\n│   │   │   │   │   ├── create_sales_order.rs\n│   │   │   │   │   ├── confirm_delivery.rs\n│   │   │   │   │   └── issue_credit_memo.rs\n│   │   │   │   ├── queries/\n│   │   │   │   │   ├── list_open_orders.rs\n│   │   │   │   │   ├── track_delivery.rs\n│   │   │   │   │   └── billing_report.rs\n│   │   │   │   └── services/\n│   │   │   │       ├── mod.rs\n│   │   │   │       └── sales_application_service.rs\n│   │   │   ├── domain/\n│   │   │   │   ├── mod.rs\n│   │   │   │   ├── aggregates/\n│   │   │   │   │   ├── mod.rs\n│   │   │   │   │   ├── sales_order.rs\n│   │   │   │   │   ├── delivery.rs\n│   │   │   │   │   └── billing_record.rs\n│   │   │   │   ├── value_objects/\n│   │   │   │   │   ├── mod.rs\n│   │   │   │   │   ├── pricing.rs\n│   │   │   │   │   └── contract.rs\n│   │   │   │   ├── events/\n│   │   │   │   │   ├── mod.rs\n│   │   │   │   │   └── sales_events.rs\n│   │   │   │   ├── services/\n│   │   │   │   │   ├── mod.rs\n│   │   │   │   │   ├── pricing_service.rs\n│   │   │   │   │   └── route_planning_service.rs\n│   │   │   │   └── repositories/\n│   │   │   │       ├── mod.rs\n│   │   │   │       ├── sales_order_repository.rs\n│   │   │   │       └── delivery_repository.rs\n│   │   │   └── infrastructure/\n│   │   │       ├── mod.rs\n│   │   │       ├── config.rs\n│   │   │       ├── persistence/\n│   │   │       │   ├── mod.rs\n│   │   │       │   ├── postgres/\n│   │   │       │   │   ├── mod.rs\n│   │   │       │   │   ├── models.rs\n│   │   │       │   │   ├── order_repository_impl.rs\n│   │   │       │   │   └── delivery_repository_impl.rs\n│   │   │       │   └── redis/\n│   │   │       │       ├── mod.rs\n│   │   │       │       └── cache.rs\n│   │   │       └── messaging/\n│   │   │           ├── mod.rs\n│   │   │           ├── kafka_producer.rs\n│   │   │           └── kafka_consumer.rs\n│   │   ├── migrations/\n│   │   │   ├── 20250101000000_create_sales_tables.sql\n│   │   └── tests/\n│   │       ├── integration/\n│   │       └── unit/\n│   │\n│   ├── production-service/                    # 生产服务（对应KILLER PP模块）\n│   │   ├── Cargo.toml\n│   │   ├── src/\n│   │   │   ├── main.rs\n│   │   │   ├── config.rs\n│   │   │   ├── api/\n│   │   │   │   ├── mod.rs\n│   │   │   │   ├── rest/\n│   │   │   │   │   ├── mod.rs\n│   │   │   │   │   ├── routes.rs\n│   │   │   │   │   ├── handlers/\n│   │   │   │   │   │   ├── production_plan_handler.rs\n│   │   │   │   │   │   ├── mrp_handler.rs\n│   │   │   │   │   │   └── shop_floor_handler.rs\n│   │   │   │   │   └── dto/\n│   │   │   │   │       ├── production_plan_dto.rs\n│   │   │   │   │       ├── mrp_run_dto.rs\n│   │   │   │   │       └── shop_floor_dto.rs\n│   │   │   │   └── grpc/\n│   │   │   │       ├── mod.rs\n│   │   │   │       └── production_service_impl.rs\n│   │   │   ├── application/\n│   │   │   │   ├── mod.rs\n│   │   │   │   ├── commands/\n│   │   │   │   │   ├── create_production_plan.rs\n│   │   │   │   │   ├── run_mrp_cycle.rs\n│   │   │   │   │   └── release_production_order.rs\n│   │   │   │   ├── queries/\n│   │   │   │   │   ├── get_production_plan.rs\n│   │   │   │   │   ├── get_capacity_status.rs\n│   │   │   │   │   └── get_work_orders.rs\n│   │   │   │   └── services/\n│   │   │   │       ├── mod.rs\n│   │   │   │       └── production_application_service.rs\n│   │   │   ├── domain/\n│   │   │   │   ├── mod.rs\n│   │   │   │   ├── aggregates/\n│   │   │   │   │   ├── mod.rs\n│   │   │   │   │   ├── production_plan.rs\n│   │   │   │   │   ├── work_order.rs\n│   │   │   │   │   └── mrp_run.rs\n│   │   │   │   ├── value_objects/\n│   │   │   │   │   ├── mod.rs\n│   │   │   │   │   ├── resource_requirement.rs\n│   │   │   │   │   └── operation.rs\n│   │   │   │   ├── events/\n│   │   │   │   │   ├── mod.rs\n│   │   │   │   │   └── production_events.rs\n│   │   │   │   ├── services/\n│   │   │   │   │   ├── mod.rs\n│   │   │   │   │   ├── plan_service.rs\n│   │   │   │   │   └── capacity_service.rs\n│   │   │   │   └── repositories/\n│   │   │   │       ├── mod.rs\n│   │   │   │       ├── production_order_repository.rs\n│   │   │   │       └── mrp_repository.rs\n│   │   │   └── infrastructure/\n│   │   │       ├── mod.rs\n│   │   │       ├── config.rs\n│   │   │       ├── persistence/\n│   │   │       │   ├── mod.rs\n│   │   │       │   ├── postgres/\n│   │   │       │   │   ├── mod.rs\n│   │   │       │   │   ├── models.rs\n│   │   │       │   │   ├── production_repository_impl.rs\n│   │   │       │   │   └── mrp_repository_impl.rs\n│   │   │       │   └── redis/\n│   │   │       │       ├── mod.rs\n│   │   │       │       └── cache.rs\n│   │   │       └── messaging/\n│   │   │           ├── mod.rs\n│   │   │           ├── kafka_producer.rs\n│   │   │           └── kafka_consumer.rs\n│   │   ├── migrations/\n│   │   │   ├── 20250101000000_create_production_tables.sql\n│   │   └── tests/\n│   │       ├── integration/\n│   │       └── unit/\n│   │\n│   ├── hr-service/                            # 人力资源服务（对应KILLER HR模块）\n│   │   ├── Cargo.toml\n│   │   ├── src/\n│   │   │   ├── main.rs\n│   │   │   ├── config.rs\n│   │   │   ├── api/\n│   │   │   │   ├── mod.rs\n│   │   │   │   ├── rest/\n│   │   │   │   │   ├── mod.rs\n│   │   │   │   │   ├── routes.rs\n│   │   │   │   │   ├── handlers/\n│   │   │   │   │   │   ├── personnel_handler.rs\n│   │   │   │   │   │   ├── payroll_handler.rs\n│   │   │   │   │   │   └── time_off_handler.rs\n│   │   │   │   │   └── dto/\n│   │   │   │   │       ├── employee_dto.rs\n│   │   │   │   │       ├── payroll_dto.rs\n│   │   │   │   │       └── attendance_dto.rs\n│   │   │   │   └── grpc/\n│   │   │   │       ├── mod.rs\n│   │   │   │       └── hr_service_impl.rs\n│   │   │   ├── application/\n│   │   │   │   ├── mod.rs\n│   │   │   │   ├── commands/\n│   │   │   │   │   ├── hire_employee.rs\n│   │   │   │   │   ├── run_payroll.rs\n│   │   │   │   │   └── approve_time_off.rs\n│   │   │   │   ├── queries/\n│   │   │   │   │   ├── get_employee_profile.rs\n│   │   │   │   │   ├── get_payroll_cycle.rs\n│   │   │   │   │   └── attendance_report.rs\n│   │   │   │   └── services/\n│   │   │   │       ├── mod.rs\n│   │   │   │       └── hr_application_service.rs\n│   │   │   ├── domain/\n│   │   │   │   ├── mod.rs\n│   │   │   │   ├── aggregates/\n│   │   │   │   │   ├── mod.rs\n│   │   │   │   │   ├── employee.rs\n│   │   │   │   │   ├── payroll_cycle.rs\n│   │   │   │   │   └── absence_record.rs\n│   │   │   │   ├── value_objects/\n│   │   │   │   │   ├── mod.rs\n│   │   │   │   │   ├── employment_type.rs\n│   │   │   │   │   └── benefit_package.rs\n│   │   │   │   ├── events/\n│   │   │   │   │   ├── mod.rs\n│   │   │   │   │   └── hr_events.rs\n│   │   │   │   ├── services/\n│   │   │   │   │   ├── mod.rs\n│   │   │   │   │   ├── payroll_service.rs\n│   │   │   │   │   └── time_off_service.rs\n│   │   │   │   └── repositories/\n│   │   │   │       ├── mod.rs\n│   │   │   │       ├── employee_repository.rs\n│   │   │   │       └── payroll_repository.rs\n│   │   │   └── infrastructure/\n│   │   │       ├── mod.rs\n│   │   │       ├── config.rs\n│   │   │       ├── persistence/\n│   │   │       │   ├── mod.rs\n│   │   │       │   ├── postgres/\n│   │   │       │   │   ├── mod.rs\n│   │   │       │   │   ├── models.rs\n│   │   │       │   │   ├── employee_repository_impl.rs\n│   │   │       │   │   └── payroll_repository_impl.rs\n│   │   │       │   └── redis/\n│   │   │       │       ├── mod.rs\n│   │   │       │       └── cache.rs\n│   │   │       └── messaging/\n│   │   │           ├── mod.rs\n│   │   │           ├── kafka_producer.rs\n│   │   │           └── kafka_consumer.rs\n│   │   ├── migrations/\n│   │   │   ├── 20250101000000_create_hr_tables.sql\n│   │   └── tests/\n│   │       ├── integration/\n│   │       └── unit/\n│   │\n│   ├── quality-service/                       # 质量管理服务（对应KILLER QM模块）\n│   │   ├── Cargo.toml\n│   │   ├── src/\n│   │   │   ├── main.rs\n│   │   │   ├── config.rs\n│   │   │   ├── api/\n│   │   │   │   ├── mod.rs\n│   │   │   │   ├── rest/\n│   │   │   │   │   ├── mod.rs\n│   │   │   │   │   ├── routes.rs\n│   │   │   │   │   ├── handlers/\n│   │   │   │   │   │   ├── inspection_handler.rs\n│   │   │   │   │   │   ├── notification_handler.rs\n│   │   │   │   │   │   └── nonconformance_handler.rs\n│   │   │   │   │   └── dto/\n│   │   │   │   │       ├── inspection_dto.rs\n│   │   │   │   │       ├── quality_notification_dto.rs\n│   │   │   │   │       └── ncr_dto.rs\n│   │   │   │   └── grpc/\n│   │   │   │       ├── mod.rs\n│   │   │   │       └── quality_service_impl.rs\n│   │   │   ├── application/\n│   │   │   │   ├── mod.rs\n│   │   │   │   ├── commands/\n│   │   │   │   │   ├── schedule_inspection.rs\n│   │   │   │   │   ├── record_inspection_result.rs\n│   │   │   │   │   └── issue_ncr.rs\n│   │   │   │   ├── queries/\n│   │   │   │   │   ├── get_inspection_plan.rs\n│   │   │   │   │   ├── get_quality_trends.rs\n│   │   │   │   │   └── get_nonconformance.rs\n│   │   │   │   └── services/\n│   │   │   │       ├── mod.rs\n│   │   │   │       └── quality_application_service.rs\n│   │   │   ├── domain/\n│   │   │   │   ├── mod.rs\n│   │   │   │   ├── aggregates/\n│   │   │   │   │   ├── mod.rs\n│   │   │   │   │   ├── inspection_plan.rs\n│   │   │   │   │   ├── inspection_result.rs\n│   │   │   │   │   └── quality_notification.rs\n│   │   │   │   ├── value_objects/\n│   │   │   │   │   ├── mod.rs\n│   │   │   │   │   ├── sampling_plan.rs\n│   │   │   │   │   └── defect_code.rs\n│   │   │   │   ├── events/\n│   │   │   │   │   ├── mod.rs\n│   │   │   │   │   └── quality_events.rs\n│   │   │   │   ├── services/\n│   │   │   │   │   ├── mod.rs\n│   │   │   │   │   ├── sampling_service.rs\n│   │   │   │   │   └── nonconformance_service.rs\n│   │   │   │   └── repositories/\n│   │   │   │       ├── mod.rs\n│   │   │   │       ├── inspection_repository.rs\n│   │   │   │       └── notification_repository.rs\n│   │   │   └── infrastructure/\n│   │   │       ├── mod.rs\n│   │   │       ├── config.rs\n│   │   │       ├── persistence/\n│   │   │       │   ├── mod.rs\n│   │   │       │   ├── postgres/\n│   │   │       │   │   ├── mod.rs\n│   │   │       │   │   ├── models.rs\n│   │   │       │   │   ├── inspection_repository_impl.rs\n│   │   │       │   │   └── notification_repository_impl.rs\n│   │   │       │   └── redis/\n│   │   │       │       ├── mod.rs\n│   │   │       │       └── cache.rs\n│   │   │       └── messaging/\n│   │   │           ├── mod.rs\n│   │   │           ├── kafka_producer.rs\n│   │   │           └── kafka_consumer.rs\n│   │   ├── migrations/\n│   │   │   ├── 20250101000000_create_quality_tables.sql\n│   │   └── tests/\n│   │       ├── integration/\n│   │       └── unit/\n│   │\n│   ├── maintenance-service/                   # 设备维护服务（对应KILLER PM模块）\n│   │   ├── Cargo.toml\n│   │   ├── src/\n│   │   │   ├── main.rs\n│   │   │   ├── config.rs\n│   │   │   ├── api/\n│   │   │   │   ├── mod.rs\n│   │   │   │   ├── rest/\n│   │   │   │   │   ├── mod.rs\n│   │   │   │   │   ├── routes.rs\n│   │   │   │   │   ├── handlers/\n│   │   │   │   │   │   ├── equipment_handler.rs\n│   │   │   │   │   │   ├── work_order_handler.rs\n│   │   │   │   │   │   └── maintenance_schedule_handler.rs\n│   │   │   │   │   └── dto/\n│   │   │   │   │       ├── equipment_dto.rs\n│   │   │   │   │       ├── work_order_dto.rs\n│   │   │   │   │       └── schedule_dto.rs\n│   │   │   │   └── grpc/\n│   │   │   │       ├── mod.rs\n│   │   │   │       └── maintenance_service_impl.rs\n│   │   │   ├── application/\n│   │   │   │   ├── mod.rs\n│   │   │   │   ├── commands/\n│   │   │   │   │   ├── register_equipment.rs\n│   │   │   │   │   ├── create_work_order.rs\n│   │   │   │   │   └── plan_preventive_maintenance.rs\n│   │   │   │   ├── queries/\n│   │   │   │   │   ├── get_equipment_status.rs\n│   │   │   │   │   ├── list_work_orders.rs\n│   │   │   │   │   └── maintenance_schedule.rs\n│   │   │   │   └── services/\n│   │   │   │       ├── mod.rs\n│   │   │   │       └── maintenance_application_service.rs\n│   │   │   ├── domain/\n│   │   │   │   ├── mod.rs\n│   │   │   │   ├── aggregates/\n│   │   │   │   │   ├── mod.rs\n│   │   │   │   │   ├── equipment.rs\n│   │   │   │   │   ├── work_order.rs\n│   │   │   │   │   └── maintenance_schedule.rs\n│   │   │   │   ├── value_objects/\n│   │   │   │   │   ├── mod.rs\n│   │   │   │   │   ├── equipment_type.rs\n│   │   │   │   │   └── maintenance_frequency.rs\n│   │   │   │   ├── events/\n│   │   │   │   │   ├── mod.rs\n│   │   │   │   │   └── maintenance_events.rs\n│   │   │   │   ├── services/\n│   │   │   │   │   ├── mod.rs\n│   │   │   │   │   ├── work_order_service.rs\n│   │   │   │   │   └── preventive_service.rs\n│   │   │   │   └── repositories/\n│   │   │   │       ├── mod.rs\n│   │   │   │       ├── equipment_repository.rs\n│   │   │   │       └── work_order_repository.rs\n│   │   │   └── infrastructure/\n│   │   │       ├── mod.rs\n│   │   │       ├── config.rs\n│   │   │       ├── persistence/\n│   │   │       │   ├── mod.rs\n│   │   │       │   ├── postgres/\n│   │   │       │   │   ├── mod.rs\n│   │   │       │   │   ├── models.rs\n│   │   │       │   │   ├── equipment_repository_impl.rs\n│   │   │       │   │   └── work_order_repository_impl.rs\n│   │   │       │   └── redis/\n│   │   │       │       ├── mod.rs\n│   │   │       │       └── cache.rs\n│   │   │       └── messaging/\n│   │   │           ├── mod.rs\n│   │   │           ├── kafka_producer.rs\n│   │   │           └── kafka_consumer.rs\n│   │   ├── migrations/\n│   │   │   ├── 20250101000000_create_maintenance_tables.sql\n│   │   └── tests/\n│   │       ├── integration/\n│   │       └── unit/\n│   │\n│   ├── crm-service/                           # 客户关系服务（对应KILLER CRM模块）\n│   │   ├── Cargo.toml\n│   │   ├── src/\n│   │   │   ├── main.rs\n│   │   │   ├── config.rs\n│   │   │   ├── api/\n│   │   │   │   ├── mod.rs\n│   │   │   │   ├── rest/\n│   │   │   │   │   ├── mod.rs\n│   │   │   │   │   ├── routes.rs\n│   │   │   │   │   ├── handlers/\n│   │   │   │   │   │   ├── lead_handler.rs\n│   │   │   │   │   │   ├── account_handler.rs\n│   │   │   │   │   │   └── activity_handler.rs\n│   │   │   │   │   └── dto/\n│   │   │   │   │       ├── lead_dto.rs\n│   │   │   │   │       ├── account_dto.rs\n│   │   │   │   │       └── activity_dto.rs\n│   │   │   │   └── grpc/\n│   │   │   │       ├── mod.rs\n│   │   │   │       └── crm_service_impl.rs\n│   │   │   ├── application/\n│   │   │   │   ├── mod.rs\n│   │   │   │   ├── commands/\n│   │   │   │   │   ├── create_lead.rs\n│   │   │   │   │   ├── convert_lead.rs\n│   │   │   │   │   └── log_activity.rs\n│   │   │   │   ├── queries/\n│   │   │   │   │   ├── get_lead_pipeline.rs\n│   │   │   │   │   ├── get_account_summary.rs\n│   │   │   │   │   └── get_activity_trail.rs\n│   │   │   │   └── services/\n│   │   │   │       ├── mod.rs\n│   │   │   │       └── crm_application_service.rs\n│   │   │   ├── domain/\n│   │   │   │   ├── mod.rs\n│   │   │   │   ├── aggregates/\n│   │   │   │   │   ├── mod.rs\n│   │   │   │   │   ├── lead.rs\n│   │   │   │   │   ├── customer_account.rs\n│   │   │   │   │   └── activity.rs\n│   │   │   │   ├── value_objects/\n│   │   │   │   │   ├── mod.rs\n│   │   │   │   │   ├── relationship_strength.rs\n│   │   │   │   │   └── lead_score.rs\n│   │   │   │   ├── events/\n│   │   │   │   │   ├── mod.rs\n│   │   │   │   │   └── crm_events.rs\n│   │   │   │   ├── services/\n│   │   │   │   │   ├── mod.rs\n│   │   │   │   │   ├── lead_scoring_service.rs\n│   │   │   │   │   └── activity_service.rs\n│   │   │   │   └── repositories/\n│   │   │   │       ├── mod.rs\n│   │   │   │       ├── lead_repository.rs\n│   │   │   │       └── account_repository.rs\n│   │   │   └── infrastructure/\n│   │   │       ├── mod.rs\n│   │   │       ├── config.rs\n│   │   │       ├── persistence/\n│   │   │       │   ├── mod.rs\n│   │   │       │   ├── postgres/\n│   │   │       │   │   ├── mod.rs\n│   │   │       │   │   ├── models.rs\n│   │   │       │   │   ├── lead_repository_impl.rs\n│   │   │       │   │   └── account_repository_impl.rs\n│   │   │       │   └── redis/\n│   │   │       │       ├── mod.rs\n│   │   │       │       └── cache.rs\n│   │   │       └── messaging/\n│   │   │           ├── mod.rs\n│   │   │           ├── kafka_producer.rs\n│   │   │           └── kafka_consumer.rs\n│   │   ├── migrations/\n│   │   │   ├── 20250101000000_create_crm_tables.sql\n│   │   └── tests/\n│   │       ├── integration/\n│   │       └── unit/\n│   │\n│   ├── project-service/                       # 项目管理服务（对应KILLER PS模块）\n│   │   ├── Cargo.toml\n│   │   ├── src/\n│   │   │   ├── main.rs\n│   │   │   ├── config.rs\n│   │   │   ├── api/\n│   │   │   │   ├── mod.rs\n│   │   │   │   ├── rest/\n│   │   │   │   │   ├── mod.rs\n│   │   │   │   │   ├── routes.rs\n│   │   │   │   │   ├── handlers/\n│   │   │   │   │   │   ├── project_handler.rs\n│   │   │   │   │   │   ├── wbs_handler.rs\n│   │   │   │   │   │   └── network_handler.rs\n│   │   │   │   │   └── dto/\n│   │   │   │   │       ├── project_dto.rs\n│   │   │   │   │       ├── wbs_dto.rs\n│   │   │   │   │       └── network_dto.rs\n│   │   │   │   └── grpc/\n│   │   │   │       ├── mod.rs\n│   │   │   │       └── project_service_impl.rs\n│   │   │   ├── application/\n│   │   │   │   ├── mod.rs\n│   │   │   │   ├── commands/\n│   │   │   │   │   ├── create_project.rs\n│   │   │   │   │   ├── update_wbs.rs\n│   │   │   │   │   └── schedule_network.rs\n│   │   │   │   ├── queries/\n│   │   │   │   │   ├── get_project_status.rs\n│   │   │   │   │   ├── get_cost_plan.rs\n│   │   │   │   │   └── get_network_view.rs\n│   │   │   │   └── services/\n│   │   │   │       ├── mod.rs\n│   │   │   │       └── project_application_service.rs\n│   │   │   ├── domain/\n│   │   │   │   ├── mod.rs\n│   │   │   │   ├── aggregates/\n│   │   │   │   │   ├── mod.rs\n│   │   │   │   │   ├── project.rs\n│   │   │   │   │   ├── wbs_element.rs\n│   │   │   │   │   └── network_schedule.rs\n│   │   │   │   ├── value_objects/\n│   │   │   │   │   ├── mod.rs\n│   │   │   │   │   ├── milestone.rs\n│   │   │   │   │   └── cost_account.rs\n│   │   │   │   ├── events/\n│   │   │   │   │   ├── mod.rs\n│   │   │   │   │   └── project_events.rs\n│   │   │   │   ├── services/\n│   │   │   │   │   ├── mod.rs\n│   │   │   │   │   └── project_control_service.rs\n│   │   │   │   └── repositories/\n│   │   │   │       ├── mod.rs\n│   │   │   │       ├── project_repository.rs\n│   │   │   │       └── wbs_repository.rs\n│   │   │   └── infrastructure/\n│   │   │       ├── mod.rs\n│   │   │       ├── config.rs\n│   │   │       ├── persistence/\n│   │   │       │   ├── mod.rs\n│   │   │       │   ├── postgres/\n│   │   │       │   │   ├── mod.rs\n│   │   │       │   │   ├── models.rs\n│   │   │       │   │   ├── project_repository_impl.rs\n│   │   │       │   │   └── wbs_repository_impl.rs\n│   │   │       │   └── redis/\n│   │   │       │       ├── mod.rs\n│   │   │       │       └── cache.rs\n│   │   │       └── messaging/\n│   │   │           ├── mod.rs\n│   │   │           ├── kafka_producer.rs\n│   │   │           └── kafka_consumer.rs\n│   │   ├── migrations/\n│   │   │   ├── 20250101000000_create_project_tables.sql\n│   │   └── tests/\n│   │       ├── integration/\n│   │       └── unit/\n│   │\n│   ├── scm-service/                           # 供应链服务（对应KILLER SCM模块）\n│   │   ├── Cargo.toml\n│   │   ├── src/\n│   │   │   ├── main.rs\n│   │   │   ├── config.rs\n│   │   │   ├── api/\n│   │   │   │   ├── mod.rs\n│   │   │   │   ├── rest/\n│   │   │   │   │   ├── mod.rs\n│   │   │   │   │   ├── routes.rs\n│   │   │   │   │   ├── handlers/\n│   │   │   │   │   │   ├── demand_handler.rs\n│   │   │   │   │   │   ├── supply_handler.rs\n│   │   │   │   │   │   └── supplier_handler.rs\n│   │   │   │   │   └── dto/\n│   │   │   │   │       ├── demand_plan_dto.rs\n│   │   │   │   │       ├── supply_plan_dto.rs\n│   │   │   │   │       └── collaboration_dto.rs\n│   │   │   │   └── grpc/\n│   │   │   │       ├── mod.rs\n│   │   │   │       └── scm_service_impl.rs\n│   │   │   ├── application/\n│   │   │   │   ├── mod.rs\n│   │   │   │   ├── commands/\n│   │   │   │   │   ├── create_demand_plan.rs\n│   │   │   │   │   ├── allocate_supply.rs\n│   │   │   │   │   └── start_supplier_collaboration.rs\n│   │   │   │   ├── queries/\n│   │   │   │   │   ├── get_demand_forecast.rs\n│   │   │   │   │   ├── get_supply_status.rs\n│   │   │   │   │   └── get_supplier_performance.rs\n│   │   │   │   └── services/\n│   │   │   │       ├── mod.rs\n│   │   │   │       ├── supply_planning_service.rs\n│   │   │   │       └── collaboration_service.rs\n│   │   │   ├── domain/\n│   │   │   │   ├── mod.rs\n│   │   │   │   ├── aggregates/\n│   │   │   │   │   ├── mod.rs\n│   │   │   │   │   ├── demand_plan.rs\n│   │   │   │   │   ├── supply_plan.rs\n│   │   │   │   │   └── supplier_collaboration.rs\n│   │   │   │   ├── value_objects/\n│   │   │   │   │   ├── mod.rs\n│   │   │   │   │   ├── forecast.rs\n│   │   │   │   │   └── lead_time.rs\n│   │   │   │   ├── events/\n│   │   │   │   │   ├── mod.rs\n│   │   │   │   │   └── scm_events.rs\n│   │   │   │   ├── services/\n│   │   │   │   │   ├── mod.rs\n│   │   │   │   │   ├── demand_planner_service.rs\n│   │   │   │   │   └── collaboration_service.rs\n│   │   │   │   └── repositories/\n│   │   │   │       ├── mod.rs\n│   │   │   │       ├── demand_repository.rs\n│   │   │   │       └── supply_repository.rs\n│   │   │   └── infrastructure/\n│   │   │       ├── mod.rs\n│   │   │       ├── config.rs\n│   │   │       ├── persistence/\n│   │   │       │   ├── mod.rs\n│   │   │       │   ├── postgres/\n│   │   │       │   │   ├── mod.rs\n│   │   │       │   │   ├── models.rs\n│   │   │       │   │   ├── demand_repository_impl.rs\n│   │   │       │   │   └── supply_repository_impl.rs\n│   │   │       │   └── redis/\n│   │   │       │       ├── mod.rs\n│   │   │       │       └── cache.rs\n│   │   │       └── messaging/\n│   │   │           ├── mod.rs\n│   │   │           ├── kafka_producer.rs\n│   │   │           └── kafka_consumer.rs\n│   │   ├── migrations/\n│   │   │   ├── 20250101000000_create_scm_tables.sql\n│   │   └── tests/\n│   │       ├── integration/\n│   │       └── unit/\n│   │\n│   ├── treasury-service/                      # 资金管理服务（对应KILLER TR模块）\n│   │   ├── Cargo.toml\n│   │   ├── src/\n│   │   │   ├── main.rs\n│   │   │   ├── config.rs\n│   │   │   ├── api/\n│   │   │   │   ├── mod.rs\n│   │   │   │   ├── rest/\n│   │   │   │   │   ├── mod.rs\n│   │   │   │   │   ├── routes.rs\n│   │   │   │   │   ├── handlers/\n│   │   │   │   │   │   ├── cash_handler.rs\n│   │   │   │   │   │   ├── payment_handler.rs\n│   │   │   │   │   │   └── risk_handler.rs\n│   │   │   │   │   └── dto/\n│   │   │   │   │       ├── cash_position_dto.rs\n│   │   │   │   │       ├── payment_batch_dto.rs\n│   │   │   │   │       └── risk_dto.rs\n│   │   │   │   └── grpc/\n│   │   │   │       ├── mod.rs\n│   │   │   │       └── treasury_service_impl.rs\n│   │   │   ├── application/\n│   │   │   │   ├── mod.rs\n│   │   │   │   ├── commands/\n│   │   │   │   │   ├── record_cash_position.rs\n│   │   │   │   │   ├── execute_payment.rs\n│   │   │   │   │   └── hedge_risk.rs\n│   │   │   │   ├── queries/\n│   │   │   │   │   ├── cash_overview.rs\n│   │   │   │   │   ├── payment_queue.rs\n│   │   │   │   │   └── risk_dashboard.rs\n│   │   │   │   └── services/\n│   │   │   │       ├── mod.rs\n│   │   │   │       ├── cash_management_service.rs\n│   │   │   │       └── fx_service.rs\n│   │   │   ├── domain/\n│   │   │   │   ├── mod.rs\n│   │   │   │   ├── aggregates/\n│   │   │   │   │   ├── mod.rs\n│   │   │   │   │   ├── cash_position.rs\n│   │   │   │   │   ├── payment_batch.rs\n│   │   │   │   │   └── risk_limit.rs\n│   │   │   │   ├── value_objects/\n│   │   │   │   │   ├── mod.rs\n│   │   │   │   │   ├── fx_rate.rs\n│   │   │   │   │   └── risk_category.rs\n│   │   │   │   ├── events/\n│   │   │   │   │   ├── mod.rs\n│   │   │   │   │   └── treasury_events.rs\n│   │   │   │   ├── services/\n│   │   │   │   │   ├── mod.rs\n│   │   │   │   │   ├── cash_repository.rs\n│   │   │   │   │   └── fx_service.rs\n│   │   │   │   └── repositories/\n│   │   │   │       ├── mod.rs\n│   │   │   │       ├── cash_repository.rs\n│   │   │   │       └── payment_repository.rs\n│   │   │   └── infrastructure/\n│   │   │       ├── mod.rs\n│   │   │       ├── config.rs\n│   │   │       ├── persistence/\n│   │   │       │   ├── mod.rs\n│   │   │       │   ├── postgres/\n│   │   │       │   │   ├── mod.rs\n│   │   │       │   │   ├── models.rs\n│   │   │       │   │   ├── cash_repository_impl.rs\n│   │   │       │   │   └── payment_repository_impl.rs\n│   │   │       │   └── redis/\n│   │   │       │       ├── mod.rs\n│   │   │       │       └── cache.rs\n│   │   │       └── messaging/\n│   │   │           ├── mod.rs\n│   │   │           ├── kafka_producer.rs\n│   │   │           └── kafka_consumer.rs\n│   │   ├── migrations/\n│   │   │   ├── 20250101000000_create_treasury_tables.sql\n│   │   └── tests/\n│   │       ├── integration/\n│   │       └── unit/\n│   │\n│   ├── warehouse-service/                     # 仓库服务（对应KILLER WM/EWM模块）\n│   │   ├── Cargo.toml\n│   │   ├── src/\n│   │   │   ├── main.rs\n│   │   │   ├── config.rs\n│   │   │   ├── api/\n│   │   │   │   ├── mod.rs\n│   │   │   │   ├── rest/\n│   │   │   │   │   ├── mod.rs\n│   │   │   │   │   ├── routes.rs\n│   │   │   │   │   ├── handlers/\n│   │   │   │   │   │   ├── inbound_handler.rs\n│   │   │   │   │   │   ├── outbound_handler.rs\n│   │   │   │   │   │   └── inventory_handler.rs\n│   │   │   │   │   └── dto/\n│   │   │   │   │       ├── inbound_dto.rs\n│   │   │   │   │       ├── outbound_dto.rs\n│   │   │   │   │       └── inventory_dto.rs\n│   │   │   │   └── grpc/\n│   │   │   │       ├── mod.rs\n│   │   │   │       └── warehouse_service_impl.rs\n│   │   │   ├── application/\n│   │   │   │   ├── mod.rs\n│   │   │   │   ├── commands/\n│   │   │   │   │   ├── receive_goods.rs\n│   │   │   │   │   ├── dispatch_goods.rs\n│   │   │   │   │   └── adjust_inventory.rs\n│   │   │   │   ├── queries/\n│   │   │   │   │   ├── inventory_snapshot.rs\n│   │   │   │   │   ├── slotting_recommendations.rs\n│   │   │   │   │   └── storage_occupancy.rs\n│   │   │   │   └── services/\n│   │   │   │       ├── mod.rs\n│   │   │   │       ├── slotting_service.rs\n│   │   │   │       └── material_flow_service.rs\n│   │   │   ├── domain/\n│   │   │   │   ├── mod.rs\n│   │   │   │   ├── aggregates/\n│   │   │   │   │   ├── mod.rs\n│   │   │   │   │   ├── warehouse.rs\n│   │   │   │   │   ├── storage_location.rs\n│   │   │   │   │   └── slotting_plan.rs\n│   │   │   │   ├── value_objects/\n│   │   │   │   │   ├── mod.rs\n│   │   │   │   │   ├── bin.rs\n│   │   │   │   │   └── material_flow.rs\n│   │   │   │   ├── events/\n│   │   │   │   │   ├── mod.rs\n│   │   │   │   │   └── warehouse_events.rs\n│   │   │   │   ├── services/\n│   │   │   │   │   ├── mod.rs\n│   │   │   │   │   ├── slotting_service.rs\n│   │   │   │   │   └── material_flow_service.rs\n│   │   │   │   └── repositories/\n│   │   │   │       ├── mod.rs\n│   │   │   │       ├── warehouse_repository.rs\n│   │   │   │       └── inventory_repository.rs\n│   │   │   └── infrastructure/\n│   │   │       ├── mod.rs\n│   │   │       ├── config.rs\n│   │   │       ├── persistence/\n│   │   │       │   ├── mod.rs\n│   │   │       │   ├── postgres/\n│   │   │       │   │   ├── mod.rs\n│   │   │       │   │   ├── models.rs\n│   │   │       │   │   ├── warehouse_repository_impl.rs\n│   │   │       │   │   └── inventory_repository_impl.rs\n│   │   │       │   └── redis/\n│   │   │       │       ├── mod.rs\n│   │   │       │       └── cache.rs\n│   │   │       └── messaging/\n│   │   │           ├── mod.rs\n│   │   │           ├── kafka_producer.rs\n│   │   │           └── kafka_consumer.rs\n│   │   ├── migrations/\n│   │   │   ├── 20250101000000_create_warehouse_tables.sql\n│   │   └── tests/\n│   │       ├── integration/\n│   │       └── unit/\n│   │\n│   ├── shipping-service/                      # 运输服务（对应KILLER TM模块）\n│   │   ├── Cargo.toml\n│   │   ├── src/\n│   │   │   ├── main.rs\n│   │   │   ├── config.rs\n│   │   │   ├── api/\n│   │   │   │   ├── mod.rs\n│   │   │   │   ├── rest/\n│   │   │   │   │   ├── mod.rs\n│   │   │   │   │   ├── routes.rs\n│   │   │   │   │   ├── handlers/\n│   │   │   │   │   │   ├── shipment_handler.rs\n│   │   │   │   │   │   ├── carrier_handler.rs\n│   │   │   │   │   │   └── tracking_handler.rs\n│   │   │   │   │   └── dto/\n│   │   │   │   │       ├── shipment_dto.rs\n│   │   │   │   │       ├── carrier_dto.rs\n│   │   │   │   │       └── tracking_dto.rs\n│   │   │   │   └── grpc/\n│   │   │   │       ├── mod.rs\n│   │   │   │       └── shipping_service_impl.rs\n│   │   │   ├── application/\n│   │   │   │   ├── mod.rs\n│   │   │   │   ├── commands/\n│   │   │   │   │   ├── create_shipment.rs\n│   │   │   │   │   ├── book_carrier.rs\n│   │   │   │   │   └── update_tracking.rs\n│   │   │   │   ├── queries/\n│   │   │   │   │   ├── shipment_status.rs\n│   │   │   │   │   ├── carrier_performance.rs\n│   │   │   │   │   └── route_adherence.rs\n│   │   │   │   └── services/\n│   │   │   │       ├── mod.rs\n│   │   │   │       └── shipping_application_service.rs\n│   │   │   ├── domain/\n│   │   │   │   ├── mod.rs\n│   │   │   │   ├── aggregates/\n│   │   │   │   │   ├── mod.rs\n│   │   │   │   │   ├── shipment.rs\n│   │   │   │   │   ├── carrier_booking.rs\n│   │   │   │   │   └── route.rs\n│   │   │   │   ├── value_objects/\n│   │   │   │   │   ├── mod.rs\n│   │   │   │   │   ├── route_segment.rs\n│   │   │   │   │   └── shipment_dimension.rs\n│   │   │   │   ├── events/\n│   │   │   │   │   ├── mod.rs\n│   │   │   │   │   └── shipping_events.rs\n│   │   │   │   ├── services/\n│   │   │   │   │   ├── mod.rs\n│   │   │   │   │   └── route_optimizer_service.rs\n│   │   │   │   └── repositories/\n│   │   │   │       ├── mod.rs\n│   │   │   │       ├── shipment_repository.rs\n│   │   │   │       └── carrier_repository.rs\n│   │   │   └── infrastructure/\n│   │   │       ├── mod.rs\n│   │   │       ├── config.rs\n│   │   │       ├── persistence/\n│   │   │       │   ├── mod.rs\n│   │   │       │   ├── postgres/\n│   │   │       │   │   ├── mod.rs\n│   │   │       │   │   ├── models.rs\n│   │   │       │   │   ├── shipment_repository_impl.rs\n│   │   │       │   │   └── carrier_repository_impl.rs\n│   │   │       │   └── redis/\n│   │   │       │       ├── mod.rs\n│   │   │       │       └── cache.rs\n│   │   │       └── messaging/\n│   │   │           ├── mod.rs\n│   │   │           ├── kafka_producer.rs\n│   │   │           └── kafka_consumer.rs\n│   │   ├── migrations/\n│   │   │   ├── 20250101000000_create_shipping_tables.sql\n│   │   └── tests/\n│   │       ├── integration/\n│   │       └── unit/\n│   │\n│   ├── analytics-service/                     # 分析服务（对应KILLER BW/BI模块）\n│   │   ├── Cargo.toml\n│   │   ├── src/\n│   │   │   ├── main.rs\n│   │   │   ├── config.rs\n│   │   │   ├── api/\n│   │   │   │   ├── mod.rs\n│   │   │   │   ├── rest/\n│   │   │   │   │   ├── mod.rs\n│   │   │   │   │   ├── routes.rs\n│   │   │   │   │   ├── handlers/\n│   │   │   │   │   │   ├── report_handler.rs\n│   │   │   │   │   │   ├── dashboard_handler.rs\n│   │   │   │   │   │   └── alert_handler.rs\n│   │   │   │   │   └── dto/\n│   │   │   │   │       ├── report_dto.rs\n│   │   │   │   │       ├── dashboard_dto.rs\n│   │   │   │   │       └── alert_dto.rs\n│   │   │   │   └── grpc/\n│   │   │   │       ├── mod.rs\n│   │   │   │       └── analytics_service_impl.rs\n│   │   │   ├── application/\n│   │   │   │   ├── mod.rs\n│   │   │   │   ├── commands/\n│   │   │   │   │   ├── refresh_dashboard.rs\n│   │   │   │   │   ├── promote_report.rs\n│   │   │   │   │   └── schedule_alert.rs\n│   │   │   │   ├── queries/\n│   │   │   │   │   ├── query_metrics.rs\n│   │   │   │   │   ├── get_dashboard_state.rs\n│   │   │   │   │   └── get_alert_history.rs\n│   │   │   │   └── services/\n│   │   │   │       ├── mod.rs\n│   │   │   │       ├── report_service.rs\n│   │   │   │       └── etl_service.rs\n│   │   │   ├── domain/\n│   │   │   │   ├── mod.rs\n│   │   │   │   ├── aggregates/\n│   │   │   │   │   ├── mod.rs\n│   │   │   │   │   ├── report.rs\n│   │   │   │   │   ├── dashboard.rs\n│   │   │   │   │   └── metric.rs\n│   │   │   │   ├── value_objects/\n│   │   │   │   │   ├── mod.rs\n│   │   │   │   │   ├── kpi.rs\n│   │   │   │   │   └── threshold.rs\n│   │   │   │   ├── events/\n│   │   │   │   │   ├── mod.rs\n│   │   │   │   │   └── analytics_events.rs\n│   │   │   │   ├── services/\n│   │   │   │   │   ├── mod.rs\n│   │   │   │   │   ├── report_service.rs\n│   │   │   │   │   └── etl_service.rs\n│   │   │   │   └── repositories/\n│   │   │   │       ├── mod.rs\n│   │   │   │       ├── clickhouse_repository.rs\n│   │   │   │       └── metrics_repository.rs\n│   │   │   └── infrastructure/\n│   │   │       ├── mod.rs\n│   │   │       ├── config.rs\n│   │   │       ├── persistence/\n│   │   │       │   ├── mod.rs\n│   │   │       │   ├── clickhouse/\n│   │   │       │   │   ├── mod.rs\n│   │   │       │   │   ├── models.rs\n│   │   │       │   │   ├── clickhouse_repository_impl.rs\n│   │   │       │   │   └── ingestion.rs\n│   │   │       │   └── redis/\n│   │   │       │       ├── mod.rs\n│   │   │       │       └── cache.rs\n│   │   │       └── messaging/\n│   │   │           ├── mod.rs\n│   │   │           ├── kafka_producer.rs\n│   │   │           └── kafka_consumer.rs\n│   │   │   ├── etl/\n│   │   │   │   ├── ingestion.rs\n│   │   │   │   └── transformer.rs\n│   │   ├── migrations/\n│   │   │   ├── 20250101000000_create_analytics_tables.sql\n│   │   ├── tests/\n│   │   │   ├── integration/\n│   │   │   └── unit/\n│   │\n│   └── api-gateway/                           # API网关\n│       ├── Cargo.toml\n│       ├── src/\n│       │   ├── main.rs                        # 网关入口\n│       │   ├── config.rs                      # 配置\n│       │   ├── middleware/                    # 中间件\n│       │   │   ├── mod.rs\n│       │   │   ├── auth.rs                    # 认证中间件\n│       │   │   ├── rate_limit.rs              # 限流中间件\n│       │   │   ├── cors.rs                    # CORS中间件\n│       │   │   └── logging.rs                 # 日志中间件\n│       │   ├── routes/                        # 路由\n│       │   │   ├── mod.rs\n│       │   │   └── proxy.rs                   # 反向代理\n│       │   └── health.rs                      # 健康检查\n│       └── tests/\n│           └── integration/                   # 集成测试\n│\n├── infrastructure/                            # 基础设施配置\n│   ├── kafka/                                 # Kafka配置\n│   │   ├── docker-compose.yml                 # Kafka Docker编排\n│   │   └── config/                            # Kafka配置文件\n│   ├── postgres/                              # PostgreSQL配置\n│   │   ├── docker-compose.yml                 # PostgreSQL Docker编排\n│   │   └── init/                              # 初始化脚本\n│   ├── redis/                                 # Redis配置\n│   │   └── docker-compose.yml                 # Redis Docker编排\n│   ├── monitoring/                            # 监控配置\n│   │   ├── prometheus/                        # Prometheus配置\n│   │   │   ├── prometheus.yml                 # Prometheus主配置\n│   │   │   └── alerts/                        # 告警规则\n│   │   ├── grafana/                           # Grafana配置\n│   │   │   ├── dashboards/                    # 仪表盘定义\n│   │   │   └── datasources/                   # 数据源配置\n│   │   ├── loki/                              # Loki日志聚合\n│   │   │   └── config.yml                     # Loki配置\n│   │   └── jaeger/                            # Jaeger追踪\n│   │       └── config.yml                     # Jaeger配置\n│   └── scripts/                               # 运维脚本\n│       ├── setup.sh                           # 环境初始化脚本\n│       ├── deploy.sh                          # 部署脚本\n│       └── backup.sh                          # 备份脚本\n│\n├── docs/                                      # 文档目录\n│   ├── architecture/                          # 架构文档\n│   │   ├── system-design.md                   # 系统设计文档\n│   │   ├── domain-model.md                    # 领域模型文档\n│   │   └── api-design.md                      # API设计文档\n│   ├── deployment/                            # 部署文档\n│   │   ├── local-setup.md                     # 本地环境搭建\n│   │   ├── kubernetes-deployment.md           # K8s部署指南\n│   │   └── production-checklist.md            # 生产检查清单\n│   └── development/                           # 开发文档\n│       ├── coding-standards.md                # 编码规范\n│       ├── testing-guide.md                   # 测试指南\n│       └── contribution-guide.md              # 贡献指南\n│\n└── tools/                                     # 开发工具\n    ├── cli/                                   # 命令行工具\n    │   ├── Cargo.toml\n    │   └── src/\n    │       └── main.rs                        # CLI工具入口\n    ├── migration-tool/                        # 数据库迁移工具\n    │   ├── Cargo.toml\n    │   └── src/\n    │       └── main.rs                        # 迁移工具入口\n    └── load-testing/                          # 负载测试工具\n        ├── Cargo.toml\n        └── scenarios/                         # 测试场景定义\n```\n\n\n**版本**: v1.0\n**创建日期**: 2025-12-21\n**维护者**: ERP开发团队\n", "md/Rust-Domain-Specifications.md": "# Rust ERP 系统 - 领域规格说明书\n## Domain Specifications for KILLER Replacement System\n\n本文档提供每个业务领域的详细技术规格，包括数据模型、API接口、领域事件、业务规则和集成点。\n\n---\n\n## 第一部分：财务会计模块 (FI - Financial Accounting)\n\n### 1.1 数据模型\n\n#### 1.1.1 会计凭证 (Accounting Document)\n\n```rust\n// Domain Entity\npub struct AccountingDocument {\n    // Identity\n    pub document_id: Uuid,\n    pub document_number: String,          // Format: FI-2025-000001\n    pub company_code: CompanyCode,\n    pub fiscal_year: FiscalYear,\n    pub posting_date: NaiveDate,\n    pub document_date: NaiveDate,\n\n    // Classification\n    pub document_type: DocumentType,      // SA-Standard, KR-Credit Memo, KG-Vendor Invoice\n    pub document_category: DocumentCategory, // AR, AP, GL, AA\n    pub reference_document: Option<String>,\n    pub header_text: Option<String>,\n\n    // Financial Data\n    pub currency: Currency,\n    pub exchange_rate: Option<ExchangeRate>,\n    pub local_currency_amount: Money,     // Company code currency\n    pub document_currency_amount: Money,\n\n    // Items\n    pub line_items: Vec<LineItem>,\n\n    // Status & Control\n    pub status: DocumentStatus,           // Draft, Posted, Parked, Reversed\n    pub posting_period: Period,\n    pub reversal_reason: Option<ReversalReason>,\n    pub reversed_document_id: Option<Uuid>,\n\n    // Audit Trail\n    pub created_at: DateTime<Utc>,\n    pub created_by: UserId,\n    pub posted_at: Option<DateTime<Utc>>,\n    pub posted_by: Option<UserId>,\n    pub last_modified_at: DateTime<Utc>,\n    pub last_modified_by: UserId,\n    pub version: i64,                     // Optimistic locking\n}\n\npub struct LineItem {\n    pub line_item_id: Uuid,\n    pub line_number: u16,                 // 001, 002, 003...\n\n    // Account Assignment\n    pub gl_account: GlAccount,\n    pub cost_center: Option<CostCenter>,\n    pub profit_center: Option<ProfitCenter>,\n    pub internal_order: Option<InternalOrder>,\n    pub wbs_element: Option<WbsElement>,\n    pub segment: Option<Segment>,\n\n    // Amounts\n    pub debit_amount: Money,\n    pub credit_amount: Money,\n    pub local_debit_amount: Money,        // Converted to company code currency\n    pub local_credit_amount: Money,\n    pub tax_code: Option<TaxCode>,\n    pub tax_amount: Money,\n\n    // Business Partner\n    pub business_partner_id: Option<Uuid>,\n    pub business_partner_type: Option<BpType>, // Customer, Vendor, Employee\n\n    // Payment Terms\n    pub payment_terms: Option<PaymentTerms>,\n    pub due_date: Option<NaiveDate>,\n    pub discount_date1: Option<NaiveDate>,\n    pub discount_percent1: Option<Decimal>,\n    pub discount_date2: Option<NaiveDate>,\n    pub discount_percent2: Option<Decimal>,\n\n    // Additional Info\n    pub line_text: Option<String>,\n    pub reference: Option<String>,\n    pub assignment: Option<String>,        // Sorting key for open items\n    pub value_date: Option<NaiveDate>,     // Cash management\n}\n\n// Value Objects\npub struct CompanyCode(String);           // 4-digit code\npub struct FiscalYear(u16);\npub struct Period(u8);                    // 1-16 (including special periods 13-16)\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum DocumentType {\n    SA,  // Standard Document\n    AB,  // Accounting Document\n    KR,  // Vendor Invoice\n    KG,  // Vendor Credit Memo\n    DR,  // Customer Invoice\n    DG,  // Customer Credit Memo\n    KZ,  // Vendor Payment\n    DZ,  // Customer Payment\n    ZP,  // Payment Posting\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum DocumentStatus {\n    Draft,\n    Parked,      // Saved but not posted\n    Posted,      // Posted to ledgers\n    Reversed,    // Cancelled by reversal document\n    Cleared,     // Open item cleared\n}\n\npub struct GlAccount {\n    pub account_number: String,           // 10-digit: 1000000 - Assets, 2000000 - Liabilities\n    pub account_group: AccountGroup,\n    pub account_type: AccountType,        // Balance Sheet, P&L\n}\n\npub struct TaxCode {\n    pub tax_code: String,                 // V1 - Input VAT 13%, A1 - Output VAT 13%\n    pub tax_type: TaxType,                // VAT, Sales Tax, Withholding Tax\n    pub tax_rate: Decimal,\n    pub tax_jurisdiction: String,\n}\n```\n\n#### 1.1.2 总账科目主数据 (GL Account Master Data)\n\n```rust\npub struct GlAccountMaster {\n    pub account_id: Uuid,\n    pub account_number: String,           // 1000000 - 9999999\n\n    // Classification\n    pub account_group: AccountGroup,      // Assets, Liabilities, Equity, Revenue, Expense\n    pub account_type: AccountType,        // Balance Sheet, P&L\n    pub financial_statement_item: FsItem, // For financial reporting\n\n    // Control Parameters\n    pub company_code: CompanyCode,\n    pub chart_of_accounts: ChartOfAccounts,\n    pub account_currency: Option<Currency>, // If blank, all currencies allowed\n    pub only_balances_in_local_currency: bool,\n\n    // Posting Control\n    pub line_item_display: bool,          // Store line items or balances only\n    pub open_item_management: bool,       // Manage clearing of open items\n    pub sort_key: Option<SortKey>,        // Default assignment field\n    pub field_status_group: FieldStatusGroup, // Control required/optional fields\n\n    // Tax\n    pub tax_category: Option<TaxCategory>,\n    pub posting_without_tax_allowed: bool,\n\n    // Cost Accounting\n    pub cost_element: Option<CostElement>,\n    pub cost_element_category: Option<CostElementCategory>,\n\n    // Planning & Budgeting\n    pub planning_level: Option<PlanningLevel>,\n    pub relevant_to_cash_flow: bool,\n\n    // Descriptions\n    pub short_text: String,\n    pub long_text: String,\n\n    // Validity\n    pub valid_from: NaiveDate,\n    pub valid_to: Option<NaiveDate>,\n    pub blocked_for_posting: bool,\n\n    // Audit\n    pub created_at: DateTime<Utc>,\n    pub created_by: UserId,\n    pub last_changed_at: DateTime<Utc>,\n    pub last_changed_by: UserId,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum AccountGroup {\n    Assets,\n    Liabilities,\n    Equity,\n    Revenue,\n    Expense,\n}\n\npub struct FieldStatusGroup {\n    pub group_code: String,\n    pub field_controls: HashMap<FieldName, FieldStatus>,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum FieldStatus {\n    Suppress,      // Hide field\n    Required,      // Mandatory entry\n    Optional,      // Optional entry\n    Display,       // Display only, no entry\n}\n```\n\n#### 1.1.3 客商主数据 (Business Partner Master)\n\n```rust\npub struct BusinessPartner {\n    pub bp_id: Uuid,\n    pub bp_number: String,                // Format: C-100001 (Customer), V-200001 (Vendor)\n    pub bp_type: BusinessPartnerType,\n    pub bp_role: Vec<BpRole>,             // Customer, Vendor, Employee\n\n    // General Data\n    pub name1: String,\n    pub name2: Option<String>,\n    pub search_term: String,\n    pub legal_form: Option<LegalForm>,\n    pub industry_sector: Option<IndustrySector>,\n    pub tax_number1: Option<String>,      // VAT Registration Number\n    pub tax_number2: Option<String>,      // Tax Identification Number\n\n    // Address\n    pub addresses: Vec<BpAddress>,\n    pub primary_address_id: Uuid,\n\n    // Contact Information\n    pub contacts: Vec<BpContact>,\n    pub primary_contact_id: Option<Uuid>,\n\n    // Bank Details\n    pub bank_accounts: Vec<BpBankAccount>,\n    pub primary_bank_account_id: Option<Uuid>,\n\n    // Status\n    pub status: BpStatus,                 // Active, Blocked, Deleted\n    pub blocked_for_posting: bool,\n    pub deletion_flag: bool,\n\n    // Audit\n    pub created_at: DateTime<Utc>,\n    pub created_by: UserId,\n    pub last_changed_at: DateTime<Utc>,\n    pub last_changed_by: UserId,\n}\n\npub struct CustomerData {\n    pub bp_id: Uuid,\n    pub company_code: CompanyCode,\n    pub customer_account_group: CustomerAccountGroup,\n\n    // Reconciliation Account\n    pub reconciliation_account: GlAccount, // Link to GL account (e.g., 1100000 - AR)\n    pub sort_key: Option<SortKey>,\n\n    // Payment Terms\n    pub payment_terms: PaymentTerms,       // e.g., Net 30 days\n    pub payment_methods: Vec<PaymentMethod>,\n    pub tolerance_group: Option<ToleranceGroup>,\n\n    // Dunning\n    pub dunning_procedure: Option<DunningProcedure>,\n    pub dunning_recipient: Option<String>,\n    pub dunning_block: bool,\n\n    // Credit Management\n    pub credit_control_area: CreditControlArea,\n    pub credit_limit: Money,\n    pub credit_exposure: Money,            // Calculated: AR + SO + Deliveries\n    pub risk_category: RiskCategory,\n\n    // Withholding Tax\n    pub withholding_tax_country: Option<Country>,\n    pub withholding_tax_code: Option<WithholdingTaxCode>,\n\n    // Interest Calculation\n    pub interest_indicator: Option<InterestIndicator>,\n    pub last_interest_run_date: Option<NaiveDate>,\n}\n\npub struct VendorData {\n    pub bp_id: Uuid,\n    pub company_code: CompanyCode,\n    pub vendor_account_group: VendorAccountGroup,\n\n    // Reconciliation Account\n    pub reconciliation_account: GlAccount, // Link to GL account (e.g., 2100000 - AP)\n    pub sort_key: Option<SortKey>,\n\n    // Payment Terms\n    pub payment_terms: PaymentTerms,       // e.g., 2%10 Net 30\n    pub payment_methods: Vec<PaymentMethod>,\n    pub payment_block: bool,\n    pub house_bank: Option<HouseBank>,     // Default house bank for payment\n\n    // Tax\n    pub tax_number: Option<String>,\n    pub tax_liable: bool,\n\n    // Evaluation\n    pub vendor_evaluation_score: Option<Decimal>,\n    pub abc_indicator: Option<AbcIndicator>, // A, B, C classification\n}\n\npub struct PaymentTerms {\n    pub terms_code: String,               // Z001, Z030, Z045\n    pub description: String,              // \"Net 30 days\", \"2%10 Net 30\"\n    pub baseline_date: BaselineDate,      // Document date, posting date, entry date\n    pub net_payment_terms: u16,           // Days until payment is due\n    pub discount_terms: Vec<DiscountTerm>,\n}\n\npub struct DiscountTerm {\n    pub discount_days: u16,               // Days from baseline date\n    pub discount_percent: Decimal,        // Discount percentage\n}\n```\n\n### 1.2 API 规格\n\n#### 1.2.1 会计凭证 API\n\n```rust\n// POST /api/v1/financial/documents\n#[derive(Debug, Deserialize, Validate)]\npub struct CreateDocumentRequest {\n    #[validate(length(min = 1))]\n    pub idempotency_key: String,\n\n    pub company_code: String,\n    #[validate(custom = \"validate_posting_date\")]\n    pub posting_date: NaiveDate,\n    pub document_date: NaiveDate,\n    pub document_type: String,\n    pub reference: Option<String>,\n    pub header_text: Option<String>,\n    pub currency: String,\n\n    #[validate(length(min = 2))]\n    #[validate(custom = \"validate_balanced_entries\")]\n    pub line_items: Vec<LineItemRequest>,\n}\n\npub struct LineItemRequest {\n    pub gl_account: String,\n    pub debit_amount: Option<Decimal>,\n    pub credit_amount: Option<Decimal>,\n    pub cost_center: Option<String>,\n    pub profit_center: Option<String>,\n    pub business_partner_id: Option<Uuid>,\n    pub tax_code: Option<String>,\n    pub line_text: Option<String>,\n    pub payment_terms: Option<String>,\n}\n\n#[derive(Debug, Serialize)]\npub struct CreateDocumentResponse {\n    pub document_id: Uuid,\n    pub document_number: String,\n    pub status: String,\n    pub posting_date: NaiveDate,\n    pub total_debit: Decimal,\n    pub total_credit: Decimal,\n    pub validation_messages: Vec<ValidationMessage>,\n}\n\n// POST /api/v1/financial/documents/{document_id}/post\npub struct PostDocumentRequest {\n    pub posting_date: Option<NaiveDate>,  // Override if needed\n    pub posting_period: Option<u8>,\n    pub force_post: bool,                  // Skip warnings\n}\n\npub struct PostDocumentResponse {\n    pub document_id: Uuid,\n    pub document_number: String,\n    pub status: String,\n    pub posted_at: DateTime<Utc>,\n    pub posted_by: String,\n    pub fiscal_year: u16,\n    pub posting_period: u8,\n}\n\n// POST /api/v1/financial/documents/{document_id}/reverse\npub struct ReverseDocumentRequest {\n    pub reversal_reason: String,\n    pub reversal_date: NaiveDate,\n    pub reversal_posting_period: Option<u8>,\n}\n\npub struct ReverseDocumentResponse {\n    pub original_document_id: Uuid,\n    pub reversal_document_id: Uuid,\n    pub reversal_document_number: String,\n    pub reversed_at: DateTime<Utc>,\n}\n\n// GET /api/v1/financial/documents\npub struct ListDocumentsQuery {\n    pub company_code: Option<String>,\n    pub fiscal_year: Option<u16>,\n    pub posting_date_from: Option<NaiveDate>,\n    pub posting_date_to: Option<NaiveDate>,\n    pub document_type: Option<String>,\n    pub status: Option<String>,\n    pub created_by: Option<String>,\n    pub gl_account: Option<String>,\n    pub business_partner_id: Option<Uuid>,\n    pub cost_center: Option<String>,\n    pub page: Option<u32>,\n    pub page_size: Option<u32>,\n    pub sort_by: Option<String>,          // posting_date, document_number, created_at\n    pub sort_order: Option<SortOrder>,    // asc, desc\n}\n\npub struct ListDocumentsResponse {\n    pub documents: Vec<DocumentSummary>,\n    pub total_count: u64,\n    pub page: u32,\n    pub page_size: u32,\n    pub has_more: bool,\n}\n\npub struct DocumentSummary {\n    pub document_id: Uuid,\n    pub document_number: String,\n    pub company_code: String,\n    pub posting_date: NaiveDate,\n    pub document_type: String,\n    pub currency: String,\n    pub total_amount: Decimal,\n    pub status: String,\n    pub created_at: DateTime<Utc>,\n    pub created_by: String,\n}\n\n// GET /api/v1/financial/documents/{document_id}\npub struct GetDocumentResponse {\n    pub document: AccountingDocumentDto,\n    pub line_items: Vec<LineItemDto>,\n    pub audit_trail: Vec<AuditEntry>,\n    pub related_documents: Vec<RelatedDocument>,\n}\n```\n\n#### 1.2.2 科目余额查询 API\n\n```rust\n// GET /api/v1/financial/balances/gl-accounts\npub struct GetGlBalancesQuery {\n    pub company_code: String,\n    pub fiscal_year: u16,\n    pub account_from: Option<String>,\n    pub account_to: Option<String>,\n    pub account_group: Option<String>,\n    pub cost_center: Option<String>,\n    pub profit_center: Option<String>,\n    pub period_from: Option<u8>,\n    pub period_to: Option<u8>,\n    pub currency: Option<String>,\n}\n\npub struct GetGlBalancesResponse {\n    pub balances: Vec<GlAccountBalance>,\n    pub summary: BalanceSummary,\n}\n\npub struct GlAccountBalance {\n    pub account_number: String,\n    pub account_name: String,\n    pub account_type: String,\n    pub opening_balance_debit: Decimal,\n    pub opening_balance_credit: Decimal,\n    pub period_debit: Decimal,\n    pub period_credit: Decimal,\n    pub cumulative_debit: Decimal,\n    pub cumulative_credit: Decimal,\n    pub closing_balance_debit: Decimal,\n    pub closing_balance_credit: Decimal,\n    pub currency: String,\n}\n\n// GET /api/v1/financial/balances/business-partners/{bp_id}\npub struct GetBpBalanceQuery {\n    pub company_code: String,\n    pub fiscal_year: Option<u16>,\n    pub as_of_date: Option<NaiveDate>,\n    pub include_open_items: bool,\n}\n\npub struct GetBpBalanceResponse {\n    pub bp_id: Uuid,\n    pub bp_number: String,\n    pub bp_name: String,\n    pub reconciliation_account: String,\n    pub current_balance: Decimal,\n    pub overdue_balance: Decimal,\n    pub currency: String,\n    pub open_items: Option<Vec<OpenItem>>,\n    pub last_payment_date: Option<NaiveDate>,\n    pub last_payment_amount: Option<Decimal>,\n}\n\npub struct OpenItem {\n    pub document_id: Uuid,\n    pub document_number: String,\n    pub line_item_number: u16,\n    pub posting_date: NaiveDate,\n    pub due_date: NaiveDate,\n    pub amount: Decimal,\n    pub currency: String,\n    pub days_overdue: i32,\n    pub payment_terms: String,\n}\n```\n\n#### 1.2.3 期末关账 API\n\n```rust\n// POST /api/v1/financial/period-close/prepare\npub struct PreparePeriodCloseRequest {\n    pub company_code: String,\n    pub fiscal_year: u16,\n    pub posting_period: u8,\n}\n\npub struct PreparePeriodCloseResponse {\n    pub close_task_id: Uuid,\n    pub status: String,\n    pub pre_close_checks: Vec<PreCloseCheck>,\n    pub warnings: Vec<String>,\n    pub estimated_duration: u64,          // seconds\n}\n\npub struct PreCloseCheck {\n    pub check_id: String,\n    pub check_name: String,\n    pub status: CheckStatus,              // Passed, Failed, Warning\n    pub message: String,\n    pub details: Option<serde_json::Value>,\n}\n\n// Examples of pre-close checks:\n// - All documents posted to correct period\n// - No unbalanced transactions\n// - Bank reconciliation completed\n// - Fixed assets depreciation posted\n// - Accruals and deferrals posted\n// - Foreign currency revaluation completed\n// - Tax calculation and posting completed\n// - Cost allocations completed\n\n// POST /api/v1/financial/period-close/execute\npub struct ExecutePeriodCloseRequest {\n    pub close_task_id: Uuid,\n    pub force_close: bool,                // Close even with warnings\n    pub close_note: Option<String>,\n}\n\npub struct ExecutePeriodCloseResponse {\n    pub close_task_id: Uuid,\n    pub company_code: String,\n    pub fiscal_year: u16,\n    pub posting_period: u8,\n    pub status: String,                   // Closed\n    pub closed_at: DateTime<Utc>,\n    pub closed_by: String,\n    pub close_duration: u64,              // seconds\n    pub post_close_summary: CloseSummary,\n}\n\npub struct CloseSummary {\n    pub total_documents_posted: u64,\n    pub total_debit_amount: Decimal,\n    pub total_credit_amount: Decimal,\n    pub period_end_balances: Vec<AccountBalance>,\n}\n\n// POST /api/v1/financial/period-close/reopen\npub struct ReopenPeriodRequest {\n    pub company_code: String,\n    pub fiscal_year: u16,\n    pub posting_period: u8,\n    pub reopen_reason: String,\n    pub require_approval: bool,\n}\n\npub struct ReopenPeriodResponse {\n    pub status: String,                   // Reopened, PendingApproval\n    pub reopened_at: DateTime<Utc>,\n    pub reopened_by: String,\n    pub approval_required_from: Option<Vec<String>>, // User IDs\n}\n```\n\n### 1.3 领域事件\n\n```rust\n// Financial domain events\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum FinancialDomainEvent {\n    DocumentCreated(DocumentCreated),\n    DocumentPosted(DocumentPosted),\n    DocumentParked(DocumentParked),\n    DocumentReversed(DocumentReversed),\n    LineItemCleared(LineItemCleared),\n    PaymentReceived(PaymentReceived),\n    PaymentMade(PaymentMade),\n    PeriodClosed(PeriodClosed),\n    PeriodReopened(PeriodReopened),\n    GlAccountBalanceUpdated(GlAccountBalanceUpdated),\n    BusinessPartnerBalanceUpdated(BusinessPartnerBalanceUpdated),\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct DocumentPosted {\n    pub event_id: Uuid,\n    pub occurred_at: DateTime<Utc>,\n    pub document_id: Uuid,\n    pub document_number: String,\n    pub company_code: String,\n    pub fiscal_year: u16,\n    pub posting_period: u8,\n    pub posting_date: NaiveDate,\n    pub document_type: String,\n    pub currency: String,\n    pub total_debit: Decimal,\n    pub total_credit: Decimal,\n    pub line_items: Vec<PostedLineItem>,\n    pub posted_by: String,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct PostedLineItem {\n    pub line_number: u16,\n    pub gl_account: String,\n    pub cost_center: Option<String>,\n    pub profit_center: Option<String>,\n    pub debit_amount: Decimal,\n    pub credit_amount: Decimal,\n    pub business_partner_id: Option<Uuid>,\n    pub tax_code: Option<String>,\n    pub tax_amount: Decimal,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct PaymentReceived {\n    pub event_id: Uuid,\n    pub occurred_at: DateTime<Utc>,\n    pub payment_id: Uuid,\n    pub payment_document_id: Uuid,\n    pub payment_document_number: String,\n    pub company_code: String,\n    pub customer_id: Uuid,\n    pub customer_number: String,\n    pub payment_amount: Decimal,\n    pub currency: String,\n    pub payment_date: NaiveDate,\n    pub payment_method: String,\n    pub bank_account: String,\n    pub reference: Option<String>,\n    pub cleared_items: Vec<ClearedItem>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ClearedItem {\n    pub document_id: Uuid,\n    pub document_number: String,\n    pub line_item_number: u16,\n    pub invoice_amount: Decimal,\n    pub cleared_amount: Decimal,\n    pub discount_amount: Decimal,\n    pub remaining_amount: Decimal,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct PeriodClosed {\n    pub event_id: Uuid,\n    pub occurred_at: DateTime<Utc>,\n    pub company_code: String,\n    pub fiscal_year: u16,\n    pub posting_period: u8,\n    pub closed_by: String,\n    pub period_end_date: NaiveDate,\n    pub total_documents: u64,\n    pub total_debit: Decimal,\n    pub total_credit: Decimal,\n    pub close_duration_seconds: u64,\n}\n```\n\n### 1.4 业务规则引擎\n\n```rust\npub struct FinancialBusinessRules {\n    pub rule_engine: Arc<RuleEngine>,\n}\n\nimpl FinancialBusinessRules {\n    // Validation rule: Transaction must be balanced\n    pub fn validate_balanced_transaction(\n        &self,\n        line_items: &[LineItem],\n    ) -> Result<(), DomainError> {\n        let total_debit: Decimal = line_items.iter()\n            .map(|item| item.debit_amount)\n            .sum();\n        let total_credit: Decimal = line_items.iter()\n            .map(|item| item.credit_amount)\n            .sum();\n\n        if (total_debit - total_credit).abs() > Decimal::new(1, 2) { // 0.01 tolerance\n            return Err(DomainError::TransactionUnbalanced {\n                total_debit,\n                total_credit,\n                difference: total_debit - total_credit,\n            });\n        }\n        Ok(())\n    }\n\n    // Validation rule: Posting date must be in open period\n    pub async fn validate_posting_period(\n        &self,\n        company_code: &CompanyCode,\n        posting_date: NaiveDate,\n    ) -> Result<Period, DomainError> {\n        let fiscal_year = self.derive_fiscal_year(company_code, posting_date).await?;\n        let period = self.derive_posting_period(company_code, fiscal_year, posting_date).await?;\n\n        let period_status = self.get_period_status(company_code, fiscal_year, period).await?;\n\n        match period_status {\n            PeriodStatus::Open => Ok(period),\n            PeriodStatus::Closed => Err(DomainError::PeriodClosed {\n                company_code: company_code.clone(),\n                fiscal_year,\n                period,\n            }),\n            PeriodStatus::NotOpened => Err(DomainError::PeriodNotOpened {\n                company_code: company_code.clone(),\n                fiscal_year,\n                period,\n            }),\n        }\n    }\n\n    // Authorization rule: Check user posting authorization\n    pub async fn check_posting_authorization(\n        &self,\n        user_id: &UserId,\n        company_code: &CompanyCode,\n        document_type: &DocumentType,\n        amount: &Money,\n    ) -> Result<(), DomainError> {\n        let user_authorizations = self.get_user_authorizations(user_id).await?;\n\n        let has_auth = user_authorizations.iter().any(|auth| {\n            auth.company_code == *company_code\n                && auth.document_types.contains(document_type)\n                && amount.amount <= auth.amount_limit\n        });\n\n        if !has_auth {\n            return Err(DomainError::InsufficientAuthorization {\n                user_id: user_id.clone(),\n                required_permission: format!(\"post_{}_{}\", company_code.0, document_type),\n                required_amount_limit: amount.amount,\n            });\n        }\n        Ok(())\n    }\n\n    // Business rule: Calculate payment due date\n    pub fn calculate_due_date(\n        &self,\n        baseline_date: NaiveDate,\n        payment_terms: &PaymentTerms,\n    ) -> NaiveDate {\n        baseline_date + Duration::days(payment_terms.net_payment_terms as i64)\n    }\n\n    // Business rule: Calculate discount amounts\n    pub fn calculate_discount(\n        &self,\n        invoice_amount: Decimal,\n        payment_date: NaiveDate,\n        baseline_date: NaiveDate,\n        payment_terms: &PaymentTerms,\n    ) -> Decimal {\n        let days_from_baseline = (payment_date - baseline_date).num_days();\n\n        for discount_term in &payment_terms.discount_terms {\n            if days_from_baseline <= discount_term.discount_days as i64 {\n                return invoice_amount * discount_term.discount_percent / Decimal::from(100);\n            }\n        }\n\n        Decimal::ZERO\n    }\n\n    // Business rule: Foreign currency valuation\n    pub async fn valuate_foreign_currency(\n        &self,\n        company_code: &CompanyCode,\n        foreign_currency: &Currency,\n        foreign_amount: Decimal,\n        valuation_date: NaiveDate,\n    ) -> Result<Decimal, DomainError> {\n        let exchange_rate = self.get_exchange_rate(\n            company_code,\n            foreign_currency,\n            valuation_date,\n        ).await?;\n\n        Ok(foreign_amount * exchange_rate.rate)\n    }\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum PeriodStatus {\n    NotOpened,\n    Open,\n    Closed,\n}\n\npub struct UserAuthorization {\n    pub authorization_id: Uuid,\n    pub user_id: UserId,\n    pub company_code: CompanyCode,\n    pub document_types: Vec<DocumentType>,\n    pub amount_limit: Decimal,\n    pub valid_from: NaiveDate,\n    pub valid_to: Option<NaiveDate>,\n}\n```\n\n### 1.5 集成点\n\n```rust\n// Financial module integration interfaces\n\n// 1. Integration with Controlling (CO)\npub trait ControllingIntegration {\n    // Post cost center/profit center actual data\n    async fn post_actual_costs(\n        &self,\n        document_id: Uuid,\n        cost_postings: Vec<CostPosting>,\n    ) -> Result<(), IntegrationError>;\n\n    // Validate cost object (cost center, internal order, WBS)\n    async fn validate_cost_object(\n        &self,\n        cost_object_type: CostObjectType,\n        cost_object_id: String,\n        validity_date: NaiveDate,\n    ) -> Result<CostObjectValidation, IntegrationError>;\n}\n\npub struct CostPosting {\n    pub cost_element: String,            // From GL account mapping\n    pub cost_center: Option<String>,\n    pub profit_center: Option<String>,\n    pub internal_order: Option<String>,\n    pub wbs_element: Option<String>,\n    pub amount: Decimal,\n    pub quantity: Option<Decimal>,\n    pub unit: Option<String>,\n}\n\n// 2. Integration with Materials Management (MM)\npub trait MaterialsIntegration {\n    // Post invoice verification\n    async fn post_invoice_verification(\n        &self,\n        document_id: Uuid,\n        invoice_data: InvoiceVerificationData,\n    ) -> Result<(), IntegrationError>;\n\n    // Get purchase order details for 3-way match\n    async fn get_purchase_order(\n        &self,\n        po_number: String,\n    ) -> Result<PurchaseOrderDetails, IntegrationError>;\n}\n\n// 3. Integration with Sales & Distribution (SD)\npub trait SalesIntegration {\n    // Create customer invoice from billing document\n    async fn create_customer_invoice(\n        &self,\n        billing_document_id: Uuid,\n    ) -> Result<Uuid, IntegrationError>;\n\n    // Update billing document with accounting document reference\n    async fn update_billing_document_reference(\n        &self,\n        billing_document_id: Uuid,\n        accounting_document_id: Uuid,\n    ) -> Result<(), IntegrationError>;\n}\n\n// 4. Integration with Asset Accounting (AA)\npub trait AssetAccountingIntegration {\n    // Post asset acquisition\n    async fn post_asset_acquisition(\n        &self,\n        document_id: Uuid,\n        asset_postings: Vec<AssetPosting>,\n    ) -> Result<(), IntegrationError>;\n\n    // Post depreciation\n    async fn post_depreciation(\n        &self,\n        company_code: CompanyCode,\n        fiscal_year: FiscalYear,\n        period: Period,\n        depreciation_run_id: Uuid,\n    ) -> Result<Uuid, IntegrationError>;\n}\n\n// 5. Integration with Treasury (TR)\npub trait TreasuryIntegration {\n    // Post payment document to cash management\n    async fn post_cash_transaction(\n        &self,\n        document_id: Uuid,\n        payment_data: CashTransactionData,\n    ) -> Result<(), IntegrationError>;\n\n    // Update liquidity forecast\n    async fn update_liquidity_forecast(\n        &self,\n        company_code: CompanyCode,\n        value_date: NaiveDate,\n        amount: Decimal,\n        currency: Currency,\n    ) -> Result<(), IntegrationError>;\n}\n\n// 6. Integration with Tax Engine\npub trait TaxEngineIntegration {\n    // Calculate tax\n    async fn calculate_tax(\n        &self,\n        tax_calculation_request: TaxCalculationRequest,\n    ) -> Result<TaxCalculationResult, IntegrationError>;\n\n    // Validate tax code\n    async fn validate_tax_code(\n        &self,\n        company_code: CompanyCode,\n        tax_code: String,\n        transaction_date: NaiveDate,\n    ) -> Result<TaxCodeValidation, IntegrationError>;\n}\n\npub struct TaxCalculationRequest {\n    pub company_code: CompanyCode,\n    pub tax_code: String,\n    pub base_amount: Decimal,\n    pub transaction_date: NaiveDate,\n    pub business_place: Option<String>,\n    pub tax_classification: Option<String>,\n}\n\npub struct TaxCalculationResult {\n    pub tax_amount: Decimal,\n    pub tax_base_amount: Decimal,\n    pub tax_rate: Decimal,\n    pub tax_jurisdiction: String,\n    pub tax_account: String,\n}\n```\n\n---\n\n## 第二部分：成本控制模块 (CO - Controlling)\n\n### 2.1 数据模型\n\n#### 2.1.1 成本中心 (Cost Center)\n\n```rust\npub struct CostCenter {\n    pub cost_center_id: Uuid,\n    pub cost_center_code: String,         // 10-digit: CC-1000, CC-2000\n    pub controlling_area: ControllingArea,\n    pub company_code: Option<CompanyCode>,\n\n    // Hierarchy\n    pub cost_center_group: Option<CostCenterGroup>,\n    pub parent_cost_center: Option<String>,\n    pub hierarchy_level: u8,\n\n    // Classification\n    pub cost_center_category: CostCenterCategory,\n    pub cost_center_type: CostCenterType, // Production, Service, Admin, Sales\n    pub activity_type: Option<ActivityType>,\n\n    // Organizational Assignment\n    pub business_area: Option<BusinessArea>,\n    pub functional_area: Option<FunctionalArea>,\n    pub department: Option<Department>,\n    pub responsible_person: Option<UserId>,\n\n    // Control Parameters\n    pub currency: Currency,\n    pub profit_center: Option<ProfitCenter>,\n    pub lock_indicator: bool,             // Lock for actual postings\n    pub statistical_cost_center: bool,    // Only for statistical postings\n\n    // Descriptions\n    pub name: String,\n    pub description: Option<String>,\n\n    // Validity\n    pub valid_from: NaiveDate,\n    pub valid_to: NaiveDate,\n\n    // Audit\n    pub created_at: DateTime<Utc>,\n    pub created_by: UserId,\n    pub last_changed_at: DateTime<Utc>,\n    pub last_changed_by: UserId,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum CostCenterCategory {\n    Production,      // Direct production activities\n    Service,         // Service providing (e.g., maintenance, IT)\n    Administration,  // Administrative functions\n    Sales,          // Sales and marketing\n    Research,       // R&D activities\n}\n\npub struct ControllingArea {\n    pub controlling_area_code: String,    // 4-digit code\n    pub name: String,\n    pub currency: Currency,\n    pub fiscal_year_variant: FiscalYearVariant,\n    pub chart_of_accounts: ChartOfAccounts,\n    pub company_codes: Vec<CompanyCode>,  // Assigned company codes\n}\n```\n\n#### 2.1.2 成本要素 (Cost Element)\n\n```rust\npub struct CostElement {\n    pub cost_element_id: Uuid,\n    pub cost_element_code: String,        // Matches GL account number\n    pub controlling_area: ControllingArea,\n\n    // Classification\n    pub cost_element_category: CostElementCategory,\n    pub cost_element_group: Option<CostElementGroup>,\n\n    // Attributes\n    pub name: String,\n    pub description: Option<String>,\n\n    // Control\n    pub attribute_group: Option<AttributeGroup>,\n    pub default_cost_center: Option<String>,\n    pub default_activity_type: Option<ActivityType>,\n\n    // Validity\n    pub valid_from: NaiveDate,\n    pub valid_to: NaiveDate,\n\n    // Audit\n    pub created_at: DateTime<Utc>,\n    pub created_by: UserId,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum CostElementCategory {\n    Primary,         // Category 1: Primary costs from FI\n    Secondary,       // Category 2: Internal allocations\n    Revenue,         // Category 11: Revenue posting\n    SalesDeduction,  // Category 12: Sales deductions\n    ExternalSettlement, // Category 31: Settlement to FI\n    InternalSettlement, // Category 42: Settlement within CO\n}\n\npub struct CostElementGroup {\n    pub group_code: String,\n    pub group_name: String,\n    pub cost_elements: Vec<String>,\n    pub hierarchy_level: u8,\n}\n```\n\n#### 2.1.3 内部订单 (Internal Order)\n\n```rust\npub struct InternalOrder {\n    pub order_id: Uuid,\n    pub order_number: String,             // Format: IO-2025-000001\n    pub controlling_area: ControllingArea,\n    pub company_code: CompanyCode,\n\n    // Classification\n    pub order_type: OrderType,\n    pub order_category: OrderCategory,    // Overhead, Investment, Accrual\n\n    // Organizational Assignment\n    pub cost_center: Option<String>,\n    pub profit_center: Option<ProfitCenter>,\n    pub business_area: Option<BusinessArea>,\n    pub responsible_person: UserId,\n\n    // Planning\n    pub planning_profile: Option<PlanningProfile>,\n    pub planned_costs: Decimal,\n    pub planned_revenue: Option<Decimal>,\n\n    // Budget Control\n    pub budget_profile: Option<BudgetProfile>,\n    pub original_budget: Decimal,\n    pub current_budget: Decimal,          // After supplements/returns\n    pub available_budget: Decimal,        // Budget - commitments - actuals\n    pub budget_status: BudgetStatus,\n\n    // Actual Data\n    pub actual_costs: Decimal,\n    pub actual_revenue: Decimal,\n    pub commitment_value: Decimal,        // From purchase requisitions/orders\n\n    // Settlement\n    pub settlement_profile: Option<SettlementProfile>,\n    pub settlement_receiver: Option<SettlementReceiver>,\n    pub settlement_rule: Option<SettlementRule>,\n\n    // Status\n    pub system_status: SystemStatus,\n    pub user_status: Option<UserStatus>,\n\n    // Descriptions\n    pub description: String,\n    pub long_text: Option<String>,\n\n    // Validity\n    pub valid_from: NaiveDate,\n    pub valid_to: NaiveDate,\n\n    // Audit\n    pub created_at: DateTime<Utc>,\n    pub created_by: UserId,\n    pub last_changed_at: DateTime<Utc>,\n    pub last_changed_by: UserId,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum OrderCategory {\n    Overhead,        // Overhead orders for indirect costs\n    Investment,      // Capital investment orders\n    Accrual,         // Accrual/deferral orders\n    Revenue,         // Revenue-earning orders\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum SystemStatus {\n    Created,         // CRTD\n    Released,        // REL\n    TechnicallyCompleted, // TECO\n    Closed,          // CLSD\n    Deleted,         // DLT\n}\n\npub struct SettlementRule {\n    pub settlement_rule_id: Uuid,\n    pub order_id: Uuid,\n    pub receivers: Vec<SettlementReceiver>,\n    pub settlement_type: SettlementType, // Full, Percentage, Equivalence numbers\n}\n\npub struct SettlementReceiver {\n    pub receiver_type: ReceiverType,\n    pub receiver_id: String,\n    pub settlement_percentage: Option<Decimal>,\n    pub settlement_amount: Option<Decimal>,\n    pub equivalence_number: Option<Decimal>,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum ReceiverType {\n    CostCenter,\n    InternalOrder,\n    WbsElement,\n    FixedAsset,\n    Material,\n    ProfitCenter,\n    GlAccount,\n}\n```\n\n#### 2.1.4 作业类型 (Activity Type)\n\n```rust\npub struct ActivityType {\n    pub activity_type_id: Uuid,\n    pub activity_type_code: String,       // Format: ACT-LABOR, ACT-MACHINE\n    pub controlling_area: ControllingArea,\n\n    // Classification\n    pub activity_type_group: Option<ActivityTypeGroup>,\n    pub activity_category: ActivityCategory,\n\n    // Unit of Measure\n    pub activity_unit: Unit,              // Hour, KWH, KM, etc.\n\n    // Planning\n    pub plan_activity_price: Option<Decimal>,\n    pub plan_capacity: Option<Decimal>,\n\n    // Actual\n    pub actual_activity_price: Option<Decimal>,\n    pub actual_activity_quantity: Decimal,\n\n    // Allocation\n    pub allocation_method: AllocationMethod,\n    pub allocation_structure: Option<AllocationStructure>,\n\n    // Descriptions\n    pub name: String,\n    pub description: Option<String>,\n\n    // Validity\n    pub valid_from: NaiveDate,\n    pub valid_to: NaiveDate,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum ActivityCategory {\n    ManualEntry,     // Category 1: Manual activity allocation\n    IndirectAllocation, // Category 2: Indirect activity allocation\n    Automatic,       // Category 3: Automatic allocation\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum AllocationMethod {\n    DirectAllocation,\n    AssessmentAllocation,\n    DistributionAllocation,\n    TemplateAllocation,\n}\n```\n\n### 2.2 API 规格\n\n#### 2.2.1 成本中心计划 API\n\n```rust\n// POST /api/v1/controlling/cost-centers/{cost_center}/plans\npub struct CreateCostCenterPlanRequest {\n    pub cost_center: String,\n    pub fiscal_year: u16,\n    pub version: String,                  // Plan version: 0 (original), 1, 2, ...\n    pub plan_profile: String,\n\n    pub cost_element_plans: Vec<CostElementPlan>,\n    pub activity_type_plans: Option<Vec<ActivityTypePlan>>,\n}\n\npub struct CostElementPlan {\n    pub cost_element: String,\n    pub period_values: Vec<PeriodValue>,  // 12 or 16 periods\n    pub total_annual_value: Decimal,\n    pub quantity: Option<Decimal>,\n    pub unit: Option<String>,\n}\n\npub struct PeriodValue {\n    pub period: u8,\n    pub value: Decimal,\n}\n\npub struct ActivityTypePlan {\n    pub activity_type: String,\n    pub plan_capacity: Decimal,           // Available capacity\n    pub plan_activity_price: Decimal,     // Price per unit\n    pub period_distribution: Vec<PeriodValue>,\n}\n\npub struct CreateCostCenterPlanResponse {\n    pub plan_id: Uuid,\n    pub cost_center: String,\n    pub fiscal_year: u16,\n    pub version: String,\n    pub total_plan_costs: Decimal,\n    pub status: String,\n    pub created_at: DateTime<Utc>,\n}\n\n// GET /api/v1/controlling/cost-centers/{cost_center}/plans\npub struct GetCostCenterPlanQuery {\n    pub fiscal_year: u16,\n    pub version: Option<String>,\n    pub include_actuals: bool,\n    pub include_commitments: bool,\n}\n\npub struct GetCostCenterPlanResponse {\n    pub cost_center: String,\n    pub cost_center_name: String,\n    pub fiscal_year: u16,\n    pub version: String,\n    pub currency: String,\n    pub plan_data: Vec<CostElementPlanData>,\n    pub actual_data: Option<Vec<CostElementActualData>>,\n    pub variance_data: Option<Vec<VarianceData>>,\n}\n\npub struct CostElementPlanData {\n    pub cost_element: String,\n    pub cost_element_name: String,\n    pub cost_element_category: String,\n    pub period_values: Vec<PeriodValue>,\n    pub annual_total: Decimal,\n}\n\npub struct VarianceData {\n    pub cost_element: String,\n    pub plan_value: Decimal,\n    pub actual_value: Decimal,\n    pub absolute_variance: Decimal,\n    pub percentage_variance: Decimal,\n}\n```\n\n#### 2.2.2 内部订单 API\n\n```rust\n// POST /api/v1/controlling/internal-orders\npub struct CreateInternalOrderRequest {\n    pub order_type: String,\n    pub company_code: String,\n    pub order_category: String,\n    pub description: String,\n    pub responsible_person: Uuid,\n    pub cost_center: Option<String>,\n    pub profit_center: Option<String>,\n    pub valid_from: NaiveDate,\n    pub valid_to: NaiveDate,\n    pub budget: Option<Decimal>,\n    pub settlement_rule: Option<CreateSettlementRuleRequest>,\n}\n\npub struct CreateSettlementRuleRequest {\n    pub settlement_profile: String,\n    pub receivers: Vec<SettlementReceiverRequest>,\n}\n\npub struct SettlementReceiverRequest {\n    pub receiver_type: String,            // CostCenter, WbsElement, Asset, etc.\n    pub receiver_id: String,\n    pub settlement_percentage: Option<Decimal>,\n}\n\npub struct CreateInternalOrderResponse {\n    pub order_id: Uuid,\n    pub order_number: String,\n    pub status: String,\n    pub created_at: DateTime<Utc>,\n}\n\n// POST /api/v1/controlling/internal-orders/{order_id}/budget\npub struct UpdateBudgetRequest {\n    pub budget_type: String,              // Original, Supplement, Return\n    pub amount: Decimal,\n    pub reason: String,\n    pub approval_id: Option<Uuid>,\n}\n\npub struct UpdateBudgetResponse {\n    pub order_id: Uuid,\n    pub order_number: String,\n    pub original_budget: Decimal,\n    pub current_budget: Decimal,\n    pub available_budget: Decimal,\n    pub updated_at: DateTime<Utc>,\n}\n\n// POST /api/v1/controlling/internal-orders/{order_id}/settle\npub struct SettleInternalOrderRequest {\n    pub settlement_period: u8,\n    pub fiscal_year: u16,\n    pub settlement_type: String,          // Full, Partial\n    pub settlement_percentage: Option<Decimal>,\n    pub test_run: bool,\n}\n\npub struct SettleInternalOrderResponse {\n    pub settlement_id: Uuid,\n    pub settlement_document_id: Option<Uuid>,\n    pub order_id: Uuid,\n    pub order_number: String,\n    pub settled_amount: Decimal,\n    pub settlement_receivers: Vec<SettlementReceiverResult>,\n    pub status: String,\n    pub settled_at: DateTime<Utc>,\n}\n\npub struct SettlementReceiverResult {\n    pub receiver_type: String,\n    pub receiver_id: String,\n    pub settled_amount: Decimal,\n    pub percentage: Decimal,\n}\n\n// GET /api/v1/controlling/internal-orders/{order_id}/actual-costs\npub struct GetOrderActualCostsQuery {\n    pub fiscal_year: u16,\n    pub period_from: Option<u8>,\n    pub period_to: Option<u8>,\n    pub cost_element: Option<String>,\n    pub include_commitments: bool,\n}\n\npub struct GetOrderActualCostsResponse {\n    pub order_id: Uuid,\n    pub order_number: String,\n    pub description: String,\n    pub fiscal_year: u16,\n    pub currency: String,\n    pub actual_line_items: Vec<ActualLineItem>,\n    pub summary: ActualCostsSummary,\n}\n\npub struct ActualLineItem {\n    pub posting_date: NaiveDate,\n    pub posting_period: u8,\n    pub document_number: String,\n    pub cost_element: String,\n    pub cost_element_name: String,\n    pub amount: Decimal,\n    pub quantity: Option<Decimal>,\n    pub unit: Option<String>,\n    pub partner_object_type: Option<String>,\n    pub partner_object_id: Option<String>,\n}\n\npub struct ActualCostsSummary {\n    pub total_actual_costs: Decimal,\n    pub total_commitments: Decimal,\n    pub current_budget: Decimal,\n    pub available_budget: Decimal,\n    pub budget_utilization_percentage: Decimal,\n}\n```\n\n#### 2.2.3 成本分摊/分配 API\n\n```rust\n// POST /api/v1/controlling/allocations/assessment\npub struct CreateAssessmentRequest {\n    pub cycle_name: String,\n    pub fiscal_year: u16,\n    pub period: u8,\n    pub sender_cost_centers: Vec<String>,\n    pub assessment_cost_element: String,\n    pub allocation_base: AllocationBase,\n    pub receivers: Vec<AllocationReceiver>,\n    pub test_run: bool,\n}\n\n#[derive(Debug, Serialize, Deserialize)]\npub enum AllocationBase {\n    FixedAmount,\n    FixedPercentage,\n    Variable { tracing_factor: String },  // e.g., \"NUMBER_OF_EMPLOYEES\"\n    ActivityBased { activity_type: String },\n}\n\npub struct AllocationReceiver {\n    pub cost_center: String,\n    pub percentage: Option<Decimal>,\n    pub fixed_amount: Option<Decimal>,\n    pub tracing_factor_value: Option<Decimal>,\n}\n\npub struct CreateAssessmentResponse {\n    pub assessment_id: Uuid,\n    pub cycle_name: String,\n    pub total_allocated_amount: Decimal,\n    pub allocation_lines: Vec<AllocationLine>,\n    pub status: String,\n    pub executed_at: DateTime<Utc>,\n}\n\npub struct AllocationLine {\n    pub sender_cost_center: String,\n    pub receiver_cost_center: String,\n    pub allocated_amount: Decimal,\n    pub allocation_percentage: Decimal,\n    pub cost_element: String,\n}\n\n// POST /api/v1/controlling/allocations/distribution\npub struct CreateDistributionRequest {\n    pub cycle_name: String,\n    pub fiscal_year: u16,\n    pub period: u8,\n    pub sender_cost_centers: Vec<String>,\n    pub original_cost_elements: Vec<String>, // Cost elements to distribute\n    pub allocation_base: AllocationBase,\n    pub receivers: Vec<AllocationReceiver>,\n    pub test_run: bool,\n}\n\n// Distribution maintains original cost element, unlike assessment\n\n// POST /api/v1/controlling/allocations/activity\npub struct CreateActivityAllocationRequest {\n    pub cycle_name: String,\n    pub fiscal_year: u16,\n    pub period: u8,\n    pub sending_cost_center: String,\n    pub activity_type: String,\n    pub activity_price: Decimal,\n    pub allocations: Vec<ActivityAllocation>,\n    pub test_run: bool,\n}\n\npub struct ActivityAllocation {\n    pub receiver_type: String,            // CostCenter, InternalOrder, WbsElement\n    pub receiver_id: String,\n    pub activity_quantity: Decimal,\n    pub activity_unit: String,\n}\n\npub struct CreateActivityAllocationResponse {\n    pub allocation_id: Uuid,\n    pub sending_cost_center: String,\n    pub activity_type: String,\n    pub total_activity_quantity: Decimal,\n    pub activity_price: Decimal,\n    pub total_allocated_amount: Decimal,\n    pub allocation_lines: Vec<ActivityAllocationLine>,\n    pub status: String,\n}\n\npub struct ActivityAllocationLine {\n    pub receiver_type: String,\n    pub receiver_id: String,\n    pub activity_quantity: Decimal,\n    pub allocated_amount: Decimal,\n}\n```\n\n### 2.3 领域事件\n\n```rust\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum ControllingDomainEvent {\n    CostCenterCreated(CostCenterCreated),\n    CostCenterPlanCreated(CostCenterPlanCreated),\n    InternalOrderCreated(InternalOrderCreated),\n    InternalOrderBudgetUpdated(InternalOrderBudgetUpdated),\n    InternalOrderSettled(InternalOrderSettled),\n    ActualCostsPosted(ActualCostsPosted),\n    AssessmentCycleExecuted(AssessmentCycleExecuted),\n    DistributionCycleExecuted(DistributionCycleExecuted),\n    ActivityAllocationPosted(ActivityAllocationPosted),\n    PeriodEndClosingExecuted(PeriodEndClosingExecuted),\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ActualCostsPosted {\n    pub event_id: Uuid,\n    pub occurred_at: DateTime<Utc>,\n    pub document_id: Uuid,\n    pub company_code: String,\n    pub fiscal_year: u16,\n    pub posting_period: u8,\n    pub postings: Vec<CostPosting>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct CostPosting {\n    pub cost_element: String,\n    pub cost_object_type: String,         // CostCenter, InternalOrder, WbsElement\n    pub cost_object_id: String,\n    pub debit_credit_indicator: String,   // S - Debit, H - Credit\n    pub amount: Decimal,\n    pub quantity: Option<Decimal>,\n    pub unit: Option<String>,\n    pub partner_object_type: Option<String>,\n    pub partner_object_id: Option<String>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct InternalOrderSettled {\n    pub event_id: Uuid,\n    pub occurred_at: DateTime<Utc>,\n    pub settlement_id: Uuid,\n    pub settlement_document_id: Uuid,\n    pub order_id: Uuid,\n    pub order_number: String,\n    pub fiscal_year: u16,\n    pub settlement_period: u8,\n    pub settlement_type: String,\n    pub settled_amount: Decimal,\n    pub receivers: Vec<SettlementReceiverData>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct SettlementReceiverData {\n    pub receiver_type: String,\n    pub receiver_id: String,\n    pub settled_amount: Decimal,\n    pub settlement_cost_element: String,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct AssessmentCycleExecuted {\n    pub event_id: Uuid,\n    pub occurred_at: DateTime<Utc>,\n    pub assessment_id: Uuid,\n    pub cycle_name: String,\n    pub fiscal_year: u16,\n    pub period: u8,\n    pub assessment_cost_element: String,\n    pub total_allocated_amount: Decimal,\n    pub allocations: Vec<AllocationData>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct AllocationData {\n    pub sender_cost_center: String,\n    pub receiver_cost_center: String,\n    pub allocated_amount: Decimal,\n    pub allocation_base_value: Option<Decimal>,\n}\n```\n\n---\n\n## 第三部分：物料管理模块 (MM - Materials Management)\n\n### 3.1 数据模型\n\n#### 3.1.1 物料主数据 (Material Master)\n\n```rust\npub struct MaterialMaster {\n    pub material_id: Uuid,\n    pub material_number: String,          // Format: MAT-000001 or intelligent numbering\n    pub material_type: MaterialType,\n    pub industry_sector: IndustrySector,\n\n    // Basic Data\n    pub basic_data: MaterialBasicData,\n\n    // Classification\n    pub material_group: MaterialGroup,\n    pub product_hierarchy: Option<ProductHierarchy>,\n    pub division: Option<Division>,\n\n    // Purchasing Data (per purchasing organization)\n    pub purchasing_data: HashMap<PurchasingOrg, PurchasingData>,\n\n    // Sales Data (per sales organization)\n    pub sales_data: HashMap<SalesOrg, SalesData>,\n\n    // Storage Data (per plant)\n    pub plant_data: HashMap<Plant, PlantData>,\n\n    // Storage Location Data (per plant/storage location)\n    pub storage_location_data: HashMap<(Plant, StorageLocation), StorageLocationData>,\n\n    // Accounting Data (per valuation area)\n    pub accounting_data: HashMap<ValuationArea, AccountingData>,\n\n    // Quality Management\n    pub quality_data: Option<QualityData>,\n\n    // Status\n    pub material_status: MaterialStatus,\n    pub deletion_flag: bool,\n    pub deletion_date: Option<NaiveDate>,\n\n    // Audit\n    pub created_at: DateTime<Utc>,\n    pub created_by: UserId,\n    pub last_changed_at: DateTime<Utc>,\n    pub last_changed_by: UserId,\n}\n\npub struct MaterialBasicData {\n    pub description: String,\n    pub old_material_number: Option<String>,\n    pub base_unit_of_measure: Unit,\n    pub material_group: String,\n    pub gross_weight: Option<Decimal>,\n    pub net_weight: Option<Decimal>,\n    pub weight_unit: Option<Unit>,\n    pub volume: Option<Decimal>,\n    pub volume_unit: Option<Unit>,\n    pub size_dimensions: Option<String>,\n    pub ean_upc: Option<String>,            // Barcode\n    pub manufacturer_part_number: Option<String>,\n    pub external_material_group: Option<String>,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum MaterialType {\n    ROH,     // Raw material\n    HALB,    // Semi-finished product\n    FERT,    // Finished product\n    HAWA,    // Trading goods\n    VERP,    // Packaging material\n    UNBW,    // Non-valuated material\n    DIEN,    // Services\n    NLAG,    // Non-stock material\n}\n\npub struct PurchasingData {\n    pub purchasing_org: PurchasingOrg,\n    pub purchasing_group: Option<PurchasingGroup>,\n    pub plant: Option<Plant>,\n\n    // Procurement\n    pub automatic_po: bool,\n    pub source_list_required: bool,\n    pub mrp_type: Option<MrpType>,\n    pub reorder_point: Option<Decimal>,\n    pub maximum_stock_level: Option<Decimal>,\n    pub fixed_lot_size: Option<Decimal>,\n    pub procurement_type: ProcurementType, // External, In-house, Both\n\n    // Pricing\n    pub standard_price: Option<Money>,\n    pub price_unit: Option<Decimal>,\n    pub price_control: Option<PriceControl>,\n    pub moving_average_price: Option<Money>,\n\n    // Lead Time\n    pub planned_delivery_time: u16,        // Days\n    pub gr_processing_time: u16,           // Days for goods receipt\n\n    // Vendor\n    pub regular_vendor: Option<Uuid>,\n    pub minimum_order_quantity: Option<Decimal>,\n    pub standard_order_quantity: Option<Decimal>,\n    pub maximum_order_quantity: Option<Decimal>,\n\n    // Quality\n    pub quality_inspection: bool,\n    pub certificate_type: Option<CertificateType>,\n\n    // Batch Management\n    pub batch_management_required: bool,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum ProcurementType {\n    External,     // E - Purchase from vendor\n    InHouse,      // F - In-house production\n    Both,         // X - Both procurement types\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum PriceControl {\n    Standard,     // S - Standard price\n    MovingAverage, // V - Moving average price\n}\n\npub struct PlantData {\n    pub plant: Plant,\n\n    // MRP (Material Requirements Planning)\n    pub mrp_controller: Option<MrpController>,\n    pub mrp_type: MrpType,\n    pub lot_size_procedure: LotSizeProcedure,\n    pub minimum_lot_size: Option<Decimal>,\n    pub maximum_lot_size: Option<Decimal>,\n    pub lot_size_rounding: Option<Decimal>,\n\n    // Stock levels\n    pub safety_stock: Option<Decimal>,\n    pub reorder_point: Option<Decimal>,\n    pub maximum_stock_level: Option<Decimal>,\n\n    // Lead times\n    pub in_house_production_time: Option<u16>, // Days\n    pub gr_processing_time: u16,\n    pub planned_delivery_time: u16,\n\n    // Availability\n    pub availability_check: bool,\n    pub checking_group: Option<CheckingGroup>,\n\n    // Serialization\n    pub serial_number_profile: Option<SerialNumberProfile>,\n\n    // Production\n    pub production_supervisor: Option<UserId>,\n    pub production_scheduler: Option<UserId>,\n    pub backflush: bool,                   // Automatic goods issue in production\n\n    // Warehouse Management\n    pub storage_conditions: Option<StorageConditions>,\n    pub temperature_conditions: Option<TemperatureConditions>,\n    pub hazardous_material: bool,\n    pub hazmat_number: Option<String>,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum MrpType {\n    PD,      // MRP based on consumption\n    VB,      // Manual reorder point planning\n    VM,      // Automatic reorder point planning\n    VV,      // Forecast-based planning\n    ND,      // No planning\n}\n\npub struct AccountingData {\n    pub valuation_area: ValuationArea,    // Typically plant or company code\n    pub valuation_class: ValuationClass,\n    pub price_control: PriceControl,\n    pub moving_price: Money,\n    pub standard_price: Money,\n    pub price_unit: Decimal,\n    pub currency: Currency,\n\n    // Accounts\n    pub valuation_category: Option<ValuationCategory>,\n    pub valuation_type: Option<ValuationType>,\n\n    // Costing\n    pub cost_estimate: Option<CostEstimate>,\n    pub with_quantity_structure: bool,\n    pub material_origin: Option<MaterialOrigin>,\n    pub overhead_group: Option<OverheadGroup>,\n}\n\npub struct CostEstimate {\n    pub cost_estimate_id: Uuid,\n    pub costing_date: NaiveDate,\n    pub costing_version: String,\n    pub costing_lot_size: Decimal,\n    pub total_cost: Money,\n    pub cost_components: Vec<CostComponent>,\n}\n\npub struct CostComponent {\n    pub cost_element: String,\n    pub cost_amount: Money,\n    pub cost_percentage: Decimal,\n}\n```\n\n#### 3.1.2 采购申请 (Purchase Requisition)\n\n```rust\npub struct PurchaseRequisition {\n    pub requisition_id: Uuid,\n    pub requisition_number: String,       // Format: PR-2025-000001\n    pub requisition_type: RequisitionType,\n    pub company_code: CompanyCode,\n    pub purchasing_org: PurchasingOrg,\n    pub purchasing_group: PurchasingGroup,\n\n    // Requester\n    pub requester: UserId,\n    pub cost_center: Option<CostCenter>,\n    pub gl_account: Option<String>,\n    pub internal_order: Option<String>,\n    pub wbs_element: Option<String>,\n\n    // Items\n    pub items: Vec<PurchaseRequisitionItem>,\n\n    // Approval\n    pub approval_status: ApprovalStatus,\n    pub approval_workflow_id: Option<Uuid>,\n    pub approvers: Vec<ApprovalStep>,\n\n    // Source Determination\n    pub source_determination_done: bool,\n\n    // Status\n    pub overall_status: RequisitionStatus,\n    pub deletion_indicator: bool,\n\n    // Audit\n    pub created_at: DateTime<Utc>,\n    pub created_by: UserId,\n    pub last_changed_at: DateTime<Utc>,\n    pub last_changed_by: UserId,\n}\n\npub struct PurchaseRequisitionItem {\n    pub item_number: u16,\n    pub material_id: Option<Uuid>,\n    pub material_number: Option<String>,\n    pub short_text: String,\n    pub quantity: Decimal,\n    pub unit: Unit,\n    pub delivery_date: NaiveDate,\n    pub plant: Plant,\n    pub storage_location: Option<StorageLocation>,\n\n    // Valuation\n    pub valuation_price: Option<Money>,\n    pub currency: Currency,\n    pub estimated_value: Money,\n\n    // Account Assignment\n    pub account_assignment_category: AccountAssignmentCategory,\n    pub cost_center: Option<CostCenter>,\n    pub gl_account: Option<String>,\n    pub internal_order: Option<String>,\n    pub wbs_element: Option<String>,\n    pub asset: Option<String>,\n\n    // Source\n    pub fixed_vendor: Option<Uuid>,\n    pub source_of_supply: Option<SourceOfSupply>,\n    pub purchasing_info_record: Option<Uuid>,\n    pub contract: Option<String>,\n    pub contract_item: Option<u16>,\n\n    // Status\n    pub item_status: RequisitionItemStatus,\n    pub assigned_to_po: Option<PurchaseOrderReference>,\n    pub goods_receipt_qty: Decimal,\n    pub invoice_receipt_qty: Decimal,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum AccountAssignmentCategory {\n    K,       // Cost center\n    A,       // Asset\n    P,       // Project (WBS element)\n    F,       // Order (Internal order)\n    U,       // Unknown (no account assignment)\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum RequisitionStatus {\n    Created,\n    PendingApproval,\n    Approved,\n    Rejected,\n    Assigned,                             // Assigned to PO\n    PartiallyAssigned,\n    Closed,\n}\n\npub struct ApprovalStep {\n    pub step_number: u8,\n    pub approver: UserId,\n    pub approval_required_by: DateTime<Utc>,\n    pub approval_status: ApprovalStepStatus,\n    pub approved_at: Option<DateTime<Utc>>,\n    pub rejection_reason: Option<String>,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum ApprovalStepStatus {\n    Pending,\n    Approved,\n    Rejected,\n    Skipped,\n}\n```\n\n#### 3.1.3 采购订单 (Purchase Order)\n\n```rust\npub struct PurchaseOrder {\n    pub po_id: Uuid,\n    pub po_number: String,                // Format: PO-2025-000001\n    pub po_type: PurchaseOrderType,\n    pub company_code: CompanyCode,\n    pub purchasing_org: PurchasingOrg,\n    pub purchasing_group: PurchasingGroup,\n\n    // Vendor\n    pub vendor_id: Uuid,\n    pub vendor_number: String,\n    pub vendor_name: String,\n\n    // Header Data\n    pub document_date: NaiveDate,\n    pub currency: Currency,\n    pub exchange_rate: Option<ExchangeRate>,\n    pub payment_terms: PaymentTerms,\n    pub incoterms: Option<Incoterms>,\n    pub incoterms_location: Option<String>,\n\n    // Delivery\n    pub collective_number: Option<String>,\n    pub shipping_conditions: Option<ShippingConditions>,\n\n    // Items\n    pub items: Vec<PurchaseOrderItem>,\n\n    // Pricing\n    pub net_order_value: Money,\n    pub gross_order_value: Money,\n    pub tax_amount: Money,\n\n    // Status\n    pub overall_status: PurchaseOrderStatus,\n    pub approval_status: ApprovalStatus,\n    pub deletion_indicator: bool,\n\n    // References\n    pub requisition_numbers: Vec<String>,\n    pub quotation_number: Option<String>,\n    pub contract_number: Option<String>,\n\n    // Audit\n    pub created_at: DateTime<Utc>,\n    pub created_by: UserId,\n    pub last_changed_at: DateTime<Utc>,\n    pub last_changed_by: UserId,\n}\n\npub struct PurchaseOrderItem {\n    pub item_number: u16,\n    pub item_category: ItemCategory,\n    pub material_id: Option<Uuid>,\n    pub material_number: Option<String>,\n    pub short_text: String,\n\n    // Quantity & Delivery\n    pub order_quantity: Decimal,\n    pub unit: Unit,\n    pub delivery_date: NaiveDate,\n    pub plant: Plant,\n    pub storage_location: Option<StorageLocation>,\n\n    // Pricing\n    pub net_price: Money,\n    pub price_unit: Decimal,\n    pub gross_price: Money,\n    pub discount_percentage: Option<Decimal>,\n    pub discount_amount: Option<Money>,\n    pub net_value: Money,\n    pub tax_code: Option<TaxCode>,\n    pub tax_amount: Money,\n    pub gross_value: Money,\n\n    // Account Assignment\n    pub account_assignment_category: AccountAssignmentCategory,\n    pub gl_account: Option<String>,\n    pub cost_center: Option<CostCenter>,\n    pub internal_order: Option<String>,\n    pub wbs_element: Option<String>,\n    pub asset: Option<String>,\n\n    // Goods Receipt\n    pub goods_receipt_indicator: bool,\n    pub goods_receipt_qty: Decimal,\n    pub open_qty: Decimal,\n\n    // Invoice Receipt\n    pub invoice_receipt_indicator: bool,\n    pub evaluated_receipt_settlement: bool, // ERS - auto invoice creation\n    pub invoiced_qty: Decimal,\n\n    // Quality\n    pub quality_inspection_required: bool,\n    pub certificate_type: Option<CertificateType>,\n\n    // Status\n    pub item_status: PurchaseOrderItemStatus,\n    pub confirmation_control: Option<ConfirmationControl>,\n    pub over_delivery_tolerance: Decimal, // Percentage\n    pub under_delivery_tolerance: Decimal,\n    pub unlimited_over_delivery: bool,\n\n    // References\n    pub requisition_number: Option<String>,\n    pub requisition_item: Option<u16>,\n    pub quotation_number: Option<String>,\n    pub quotation_item: Option<u16>,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum PurchaseOrderType {\n    Standard,       // NB - Standard PO\n    Subcontracting, // ZUB - Subcontracting\n    Consignment,    // ZKO - Consignment\n    StockTransfer,  // ZUL - Stock transfer\n    Service,        // ZSE - Service PO\n    Framework,      // ZFO - Framework order\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum PurchaseOrderStatus {\n    Created,\n    Released,\n    PartiallyDelivered,\n    FullyDelivered,\n    PartiallyInvoiced,\n    FullyInvoiced,\n    Closed,\n    Cancelled,\n}\n\npub struct Incoterms {\n    pub incoterm_code: String,            // EXW, FOB, CIF, DDP, etc.\n    pub incoterm_location: String,\n    pub incoterm_version: String,         // Incoterms 2020, etc.\n}\n```\n\n#### 3.1.4 收货单 (Goods Receipt)\n\n```rust\npub struct GoodsReceipt {\n    pub gr_id: Uuid,\n    pub material_document_number: String, // Format: GR-2025-000001\n    pub material_document_year: u16,\n    pub posting_date: NaiveDate,\n    pub document_date: NaiveDate,\n    pub movement_type: MovementType,\n\n    // Header\n    pub company_code: CompanyCode,\n    pub plant: Plant,\n    pub storage_location: Option<StorageLocation>,\n    pub vendor_id: Option<Uuid>,\n    pub header_text: Option<String>,\n\n    // Items\n    pub items: Vec<GoodsReceiptItem>,\n\n    // Status\n    pub status: GoodsReceiptStatus,\n    pub reversed: bool,\n    pub reversal_document: Option<String>,\n\n    // Accounting Document\n    pub accounting_document_id: Option<Uuid>,\n    pub accounting_document_number: Option<String>,\n\n    // Audit\n    pub created_at: DateTime<Utc>,\n    pub created_by: UserId,\n}\n\npub struct GoodsReceiptItem {\n    pub item_number: u16,\n    pub material_id: Uuid,\n    pub material_number: String,\n    pub material_description: String,\n\n    // Quantity\n    pub quantity: Decimal,\n    pub unit: Unit,\n    pub entry_unit: Option<Unit>,          // Different from base unit\n\n    // Location\n    pub plant: Plant,\n    pub storage_location: StorageLocation,\n    pub storage_bin: Option<StorageBin>,\n    pub batch: Option<Batch>,\n    pub serial_numbers: Vec<SerialNumber>,\n\n    // Valuation\n    pub valuation_type: Option<ValuationType>,\n    pub amount_in_local_currency: Money,\n    pub amount_in_document_currency: Option<Money>,\n    pub price_per_unit: Money,\n\n    // Reference\n    pub purchase_order_number: Option<String>,\n    pub po_item_number: Option<u16>,\n    pub delivery_note_number: Option<String>,\n    pub delivery_note_item: Option<u16>,\n\n    // Quality\n    pub quality_inspection_required: bool,\n    pub inspection_lot_number: Option<String>,\n    pub stock_type: StockType,             // Unrestricted, Quality Inspection, Blocked\n\n    // Account Assignment\n    pub gl_account: Option<String>,\n    pub cost_center: Option<CostCenter>,\n    pub internal_order: Option<String>,\n    pub wbs_element: Option<String>,\n\n    // Status\n    pub item_status: GoodsReceiptItemStatus,\n    pub reason_for_movement: Option<ReasonForMovement>,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum MovementType {\n    _101,    // GR for PO into warehouse\n    _102,    // GR reversal for PO\n    _103,    // GR for PO into blocked stock\n    _105,    // GR from blocked to unrestricted\n    _122,    // Return delivery to vendor\n    _161,    // GR for free goods\n    _201,    // GR from storage location to consumption\n    _261,    // GR from production order\n    _262,    // Reversal of 261\n    _301,    // Transfer posting from plant to plant\n    _311,    // Transfer posting from storage location to storage location\n    _551,    // Scrapping from warehouse\n    _561,    // Initial entry of stock balances\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum StockType {\n    Unrestricted,            // Available for use\n    QualityInspection,       // Pending QC\n    Blocked,                 // Blocked for use\n    Returns,                 // Returns stock\n    InTransit,               // In transit between plants\n}\n```\n\n### 3.2 API 规格\n\n#### 3.2.1 物料主数据 API\n\n```rust\n// POST /api/v1/materials/materials\npub struct CreateMaterialRequest {\n    pub material_type: String,\n    pub industry_sector: String,\n    pub basic_data: MaterialBasicDataRequest,\n    pub organizational_levels: OrganizationalLevelsRequest,\n}\n\npub struct MaterialBasicDataRequest {\n    pub description: String,\n    pub base_unit_of_measure: String,\n    pub material_group: String,\n    pub gross_weight: Option<Decimal>,\n    pub weight_unit: Option<String>,\n}\n\npub struct OrganizationalLevelsRequest {\n    pub plants: Vec<String>,\n    pub storage_locations: Option<Vec<(String, String)>>, // (plant, sloc)\n    pub purchasing_orgs: Vec<String>,\n    pub sales_orgs: Option<Vec<String>>,\n}\n\npub struct CreateMaterialResponse {\n    pub material_id: Uuid,\n    pub material_number: String,\n    pub created_at: DateTime<Utc>,\n}\n\n// PUT /api/v1/materials/materials/{material_id}/purchasing-data\npub struct UpdatePurchasingDataRequest {\n    pub purchasing_org: String,\n    pub plant: Option<String>,\n    pub purchasing_group: Option<String>,\n    pub automatic_po: bool,\n    pub planned_delivery_time: u16,\n    pub regular_vendor: Option<Uuid>,\n    pub minimum_order_quantity: Option<Decimal>,\n    pub standard_price: Option<Decimal>,\n    pub price_unit: Option<Decimal>,\n}\n\n// GET /api/v1/materials/materials\npub struct ListMaterialsQuery {\n    pub material_type: Option<String>,\n    pub material_group: Option<String>,\n    pub plant: Option<String>,\n    pub search_term: Option<String>,        // Search in description\n    pub purchasing_org: Option<String>,\n    pub page: Option<u32>,\n    pub page_size: Option<u32>,\n}\n\npub struct ListMaterialsResponse {\n    pub materials: Vec<MaterialSummary>,\n    pub total_count: u64,\n    pub page: u32,\n    pub page_size: u32,\n}\n\n// GET /api/v1/materials/materials/{material_id}/stock\npub struct GetMaterialStockQuery {\n    pub plant: Option<String>,\n    pub storage_location: Option<String>,\n    pub batch: Option<String>,\n    pub stock_type: Option<String>,\n    pub valuation_type: Option<String>,\n}\n\npub struct GetMaterialStockResponse {\n    pub material_id: Uuid,\n    pub material_number: String,\n    pub material_description: String,\n    pub base_unit: String,\n    pub stock_overview: Vec<StockLevel>,\n    pub total_stock: Decimal,\n}\n\npub struct StockLevel {\n    pub plant: String,\n    pub storage_location: String,\n    pub batch: Option<String>,\n    pub stock_type: String,\n    pub unrestricted_stock: Decimal,\n    pub quality_inspection_stock: Decimal,\n    pub blocked_stock: Decimal,\n    pub in_transit_stock: Decimal,\n    pub reserved_stock: Decimal,\n    pub available_stock: Decimal,\n}\n```\n\n#### 3.2.2 采购申请 API\n\n```rust\n// POST /api/v1/materials/purchase-requisitions\npub struct CreatePurchaseRequisitionRequest {\n    pub requisition_type: String,\n    pub company_code: String,\n    pub purchasing_org: String,\n    pub purchasing_group: String,\n    pub items: Vec<CreatePRItemRequest>,\n}\n\npub struct CreatePRItemRequest {\n    pub material_id: Option<Uuid>,\n    pub short_text: String,\n    pub quantity: Decimal,\n    pub unit: String,\n    pub delivery_date: NaiveDate,\n    pub plant: String,\n    pub storage_location: Option<String>,\n    pub account_assignment_category: String,\n    pub cost_center: Option<String>,\n    pub gl_account: Option<String>,\n    pub internal_order: Option<String>,\n    pub fixed_vendor: Option<Uuid>,\n    pub estimated_price: Option<Decimal>,\n}\n\npub struct CreatePurchaseRequisitionResponse {\n    pub requisition_id: Uuid,\n    pub requisition_number: String,\n    pub items: Vec<PRItemSummary>,\n    pub approval_required: bool,\n    pub approval_workflow_id: Option<Uuid>,\n}\n\n// POST /api/v1/materials/purchase-requisitions/{requisition_id}/approve\npub struct ApprovePurchaseRequisitionRequest {\n    pub approver_comment: Option<String>,\n}\n\n// POST /api/v1/materials/purchase-requisitions/{requisition_id}/reject\npub struct RejectPurchaseRequisitionRequest {\n    pub rejection_reason: String,\n}\n\n// POST /api/v1/materials/purchase-requisitions/{requisition_id}/assign-source\npub struct AssignSourceRequest {\n    pub item_assignments: Vec<ItemSourceAssignment>,\n}\n\npub struct ItemSourceAssignment {\n    pub item_number: u16,\n    pub vendor_id: Uuid,\n    pub quotation_number: Option<String>,\n    pub contract_number: Option<String>,\n    pub contract_item: Option<u16>,\n    pub price: Decimal,\n}\n```\n\n#### 3.2.3 采购订单 API\n\n```rust\n// POST /api/v1/materials/purchase-orders\npub struct CreatePurchaseOrderRequest {\n    pub po_type: String,\n    pub company_code: String,\n    pub purchasing_org: String,\n    pub purchasing_group: String,\n    pub vendor_id: Uuid,\n    pub currency: String,\n    pub payment_terms: String,\n    pub incoterms: Option<IncotermsRequest>,\n    pub items: Vec<CreatePOItemRequest>,\n    pub reference_requisitions: Option<Vec<String>>,\n}\n\npub struct CreatePOItemRequest {\n    pub material_id: Option<Uuid>,\n    pub short_text: String,\n    pub order_quantity: Decimal,\n    pub unit: String,\n    pub delivery_date: NaiveDate,\n    pub plant: String,\n    pub storage_location: Option<String>,\n    pub net_price: Decimal,\n    pub price_unit: Option<Decimal>,\n    pub tax_code: Option<String>,\n    pub account_assignment_category: Option<String>,\n    pub gl_account: Option<String>,\n    pub cost_center: Option<String>,\n    pub internal_order: Option<String>,\n    pub wbs_element: Option<String>,\n    pub goods_receipt_required: bool,\n    pub invoice_receipt_required: bool,\n    pub requisition_number: Option<String>,\n    pub requisition_item: Option<u16>,\n}\n\npub struct CreatePurchaseOrderResponse {\n    pub po_id: Uuid,\n    pub po_number: String,\n    pub vendor_number: String,\n    pub vendor_name: String,\n    pub net_order_value: Decimal,\n    pub currency: String,\n    pub items: Vec<POItemSummary>,\n    pub created_at: DateTime<Utc>,\n}\n\n// POST /api/v1/materials/purchase-orders/{po_id}/release\npub struct ReleasePurchaseOrderRequest {\n    pub release_code: Option<String>,\n    pub release_note: Option<String>,\n}\n\n// GET /api/v1/materials/purchase-orders/{po_id}\npub struct GetPurchaseOrderResponse {\n    pub purchase_order: PurchaseOrderDto,\n    pub items: Vec<PurchaseOrderItemDto>,\n    pub vendor: VendorSummary,\n    pub delivery_status: DeliveryStatus,\n    pub invoice_status: InvoiceStatus,\n    pub history: Vec<POHistoryEntry>,\n}\n\npub struct DeliveryStatus {\n    pub overall_status: String,\n    pub items_delivery_status: Vec<ItemDeliveryStatus>,\n}\n\npub struct ItemDeliveryStatus {\n    pub item_number: u16,\n    pub ordered_quantity: Decimal,\n    pub delivered_quantity: Decimal,\n    pub open_quantity: Decimal,\n    pub delivery_completion: Decimal,      // Percentage\n}\n\n// GET /api/v1/materials/purchase-orders\npub struct ListPurchaseOrdersQuery {\n    pub company_code: Option<String>,\n    pub purchasing_org: Option<String>,\n    pub purchasing_group: Option<String>,\n    pub vendor_id: Option<Uuid>,\n    pub material_id: Option<Uuid>,\n    pub po_date_from: Option<NaiveDate>,\n    pub po_date_to: Option<NaiveDate>,\n    pub delivery_date_from: Option<NaiveDate>,\n    pub delivery_date_to: Option<NaiveDate>,\n    pub status: Option<String>,\n    pub page: Option<u32>,\n    pub page_size: Option<u32>,\n}\n```\n\n#### 3.2.4 收货 API\n\n```rust\n// POST /api/v1/materials/goods-receipts\npub struct CreateGoodsReceiptRequest {\n    pub posting_date: NaiveDate,\n    pub document_date: NaiveDate,\n    pub company_code: String,\n    pub header_text: Option<String>,\n    pub items: Vec<CreateGRItemRequest>,\n}\n\npub struct CreateGRItemRequest {\n    pub movement_type: String,\n    pub material_id: Option<Uuid>,\n    pub quantity: Decimal,\n    pub unit: String,\n    pub plant: String,\n    pub storage_location: String,\n    pub storage_bin: Option<String>,\n    pub batch: Option<String>,\n    pub purchase_order_number: Option<String>,\n    pub po_item_number: Option<u16>,\n    pub delivery_note_number: Option<String>,\n    pub stock_type: Option<String>,\n    pub cost_center: Option<String>,\n    pub gl_account: Option<String>,\n    pub reason_for_movement: Option<String>,\n}\n\npub struct CreateGoodsReceiptResponse {\n    pub gr_id: Uuid,\n    pub material_document_number: String,\n    pub material_document_year: u16,\n    pub posting_date: NaiveDate,\n    pub items: Vec<GRItemResult>,\n    pub accounting_document_number: Option<String>,\n    pub posted_at: DateTime<Utc>,\n}\n\npub struct GRItemResult {\n    pub item_number: u16,\n    pub material_number: String,\n    pub quantity: Decimal,\n    pub unit: String,\n    pub plant: String,\n    pub storage_location: String,\n    pub batch: Option<String>,\n    pub amount: Decimal,\n    pub currency: String,\n}\n\n// POST /api/v1/materials/goods-receipts/{gr_id}/reverse\npub struct ReverseGoodsReceiptRequest {\n    pub reversal_reason: String,\n    pub posting_date: Option<NaiveDate>,\n}\n\n// GET /api/v1/materials/goods-receipts\npub struct ListGoodsReceiptsQuery {\n    pub company_code: Option<String>,\n    pub plant: Option<String>,\n    pub material_id: Option<Uuid>,\n    pub posting_date_from: Option<NaiveDate>,\n    pub posting_date_to: Option<NaiveDate>,\n    pub po_number: Option<String>,\n    pub vendor_id: Option<Uuid>,\n    pub movement_type: Option<String>,\n    pub page: Option<u32>,\n    pub page_size: Option<u32>,\n}\n\n// POST /api/v1/materials/goods-issues\npub struct CreateGoodsIssueRequest {\n    pub posting_date: NaiveDate,\n    pub document_date: NaiveDate,\n    pub company_code: String,\n    pub items: Vec<CreateGIItemRequest>,\n}\n\npub struct CreateGIItemRequest {\n    pub movement_type: String,            // 201, 261, etc.\n    pub material_id: Uuid,\n    pub quantity: Decimal,\n    pub unit: String,\n    pub plant: String,\n    pub storage_location: String,\n    pub batch: Option<String>,\n    pub cost_center: Option<String>,\n    pub production_order: Option<String>,\n    pub sales_order: Option<String>,\n    pub sales_order_item: Option<u16>,\n    pub reason_for_movement: Option<String>,\n}\n\n// POST /api/v1/materials/stock-transfers\npub struct CreateStockTransferRequest {\n    pub posting_date: NaiveDate,\n    pub document_date: NaiveDate,\n    pub company_code: String,\n    pub items: Vec<StockTransferItemRequest>,\n}\n\npub struct StockTransferItemRequest {\n    pub material_id: Uuid,\n    pub quantity: Decimal,\n    pub unit: String,\n    pub from_plant: String,\n    pub from_storage_location: String,\n    pub from_batch: Option<String>,\n    pub to_plant: String,\n    pub to_storage_location: String,\n    pub to_batch: Option<String>,\n    pub movement_type: String,            // 301, 311, etc.\n}\n```\n\n### 3.3 领域事件\n\n```rust\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum MaterialsDomainEvent {\n    MaterialCreated(MaterialCreated),\n    MaterialChanged(MaterialChanged),\n    PurchaseRequisitionCreated(PurchaseRequisitionCreated),\n    PurchaseRequisitionApproved(PurchaseRequisitionApproved),\n    PurchaseRequisitionRejected(PurchaseRequisitionRejected),\n    PurchaseOrderCreated(PurchaseOrderCreated),\n    PurchaseOrderChanged(PurchaseOrderChanged),\n    PurchaseOrderReleased(PurchaseOrderReleased),\n    GoodsReceiptPosted(GoodsReceiptPosted),\n    GoodsReceiptReversed(GoodsReceiptReversed),\n    GoodsIssuePosted(GoodsIssuePosted),\n    StockTransferred(StockTransferred),\n    InventoryCountCompleted(InventoryCountCompleted),\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct PurchaseOrderCreated {\n    pub event_id: Uuid,\n    pub occurred_at: DateTime<Utc>,\n    pub po_id: Uuid,\n    pub po_number: String,\n    pub po_type: String,\n    pub company_code: String,\n    pub purchasing_org: String,\n    pub purchasing_group: String,\n    pub vendor_id: Uuid,\n    pub vendor_number: String,\n    pub currency: String,\n    pub net_order_value: Decimal,\n    pub items: Vec<POItemCreated>,\n    pub created_by: String,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct POItemCreated {\n    pub item_number: u16,\n    pub material_id: Option<Uuid>,\n    pub material_number: Option<String>,\n    pub short_text: String,\n    pub order_quantity: Decimal,\n    pub unit: String,\n    pub delivery_date: NaiveDate,\n    pub plant: String,\n    pub net_price: Decimal,\n    pub net_value: Decimal,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct GoodsReceiptPosted {\n    pub event_id: Uuid,\n    pub occurred_at: DateTime<Utc>,\n    pub gr_id: Uuid,\n    pub material_document_number: String,\n    pub material_document_year: u16,\n    pub posting_date: NaiveDate,\n    pub company_code: String,\n    pub vendor_id: Option<Uuid>,\n    pub items: Vec<GRItemPosted>,\n    pub accounting_document_id: Option<Uuid>,\n    pub posted_by: String,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct GRItemPosted {\n    pub item_number: u16,\n    pub movement_type: String,\n    pub material_id: Uuid,\n    pub material_number: String,\n    pub quantity: Decimal,\n    pub unit: String,\n    pub plant: String,\n    pub storage_location: String,\n    pub batch: Option<String>,\n    pub stock_type: String,\n    pub amount: Decimal,\n    pub currency: String,\n    pub purchase_order_number: Option<String>,\n    pub po_item_number: Option<u16>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct StockTransferred {\n    pub event_id: Uuid,\n    pub occurred_at: DateTime<Utc>,\n    pub material_document_number: String,\n    pub posting_date: NaiveDate,\n    pub material_id: Uuid,\n    pub material_number: String,\n    pub quantity: Decimal,\n    pub unit: String,\n    pub from_plant: String,\n    pub from_storage_location: String,\n    pub to_plant: String,\n    pub to_storage_location: String,\n    pub movement_type: String,\n}\n```\n\n---\n\n本文档将继续添加以下模块的详细规格：\n- SD (Sales & Distribution)\n- PP (Production Planning)\n- WM/EWM (Warehouse Management)\n- QM (Quality Management)\n- PM (Plant Maintenance)\n- 以及其他模块...\n\n由于内容较长，建议分批补充。\n\n## 第四部分：销售与分销模块 (SD - Sales & Distribution)\n\n### 4.1 数据模型\n\n#### 4.1.1 客户主数据 (Customer Master Data)\n\n```rust\npub struct Customer {\n    pub customer_id: Uuid,\n    pub customer_number: String,          // Format: C-100001\n    pub account_group: CustomerAccountGroup,\n\n    // General Data\n    pub general_data: CustomerGeneralData,\n\n    // Sales Area Data (per sales organization + distribution channel + division)\n    pub sales_area_data: HashMap<SalesArea, SalesAreaData>,\n\n    // Company Code Data (for FI integration)\n    pub company_code_data: HashMap<CompanyCode, CustomerCompanyCodeData>,\n\n    // Contact Persons\n    pub contacts: Vec<ContactPerson>,\n\n    // Partner Functions\n    pub partner_functions: Vec<PartnerFunction>,\n\n    // Status\n    pub central_deletion_flag: bool,\n    pub central_blocking: bool,\n\n    // Audit\n    pub created_at: DateTime<Utc>,\n    pub created_by: UserId,\n    pub last_changed_at: DateTime<Utc>,\n    pub last_changed_by: UserId,\n}\n\npub struct CustomerGeneralData {\n    pub name1: String,\n    pub name2: Option<String>,\n    pub search_term: String,\n    pub addresses: Vec<CustomerAddress>,\n    pub primary_address_id: Uuid,\n    pub communication: CustomerCommunication,\n    pub tax_classifications: Vec<TaxClassification>,\n    pub industry_code: Option<IndustryCode>,\n    pub nielsen_id: Option<String>,\n}\n\n#[derive(Debug, Clone, Hash, Eq, PartialEq)]\npub struct SalesArea {\n    pub sales_organization: SalesOrganization,\n    pub distribution_channel: DistributionChannel,\n    pub division: Division,\n}\n\npub struct SalesAreaData {\n    pub sales_area: SalesArea,\n\n    // Sales\n    pub sales_office: Option<SalesOffice>,\n    pub sales_group: Option<SalesGroup>,\n    pub customer_group: CustomerGroup,\n    pub customer_classification: CustomerClassification,\n    pub abc_classification: Option<AbcClassification>,\n\n    // Shipping\n    pub shipping_conditions: ShippingConditions,\n    pub delivery_priority: DeliveryPriority,\n    pub complete_delivery_required: bool,\n    pub partial_delivery_per_item: bool,\n    pub max_number_of_partial_deliveries: Option<u8>,\n    pub delivery_plant: Option<Plant>,\n\n    // Billing\n    pub billing_block: Option<BillingBlock>,\n    pub pricing_procedure: PricingProcedure,\n    pub customer_pricing_group: Option<CustomerPricingGroup>,\n    pub incoterms: Option<Incoterms>,\n    pub currency: Currency,\n    pub payment_terms: PaymentTerms,\n    pub account_assignment_group: Option<AccountAssignmentGroup>,\n\n    // Taxes\n    pub tax_classification: HashMap<TaxCategory, TaxClassification>,\n\n    // Credit Management\n    pub credit_control_area: Option<CreditControlArea>,\n    pub credit_limit: Money,\n    pub credit_exposure: Money,\n    pub risk_category: RiskCategory,\n\n    // Documents\n    pub order_combination: bool,\n    pub order_probability: Option<Decimal>,      // Percentage\n\n    // Status\n    pub sales_block: Option<SalesBlock>,\n    pub deletion_flag: bool,\n}\n\npub struct CustomerCompanyCodeData {\n    pub company_code: CompanyCode,\n    pub reconciliation_account: GlAccount,\n    pub payment_terms: PaymentTerms,\n    pub payment_methods: Vec<PaymentMethod>,\n    pub payment_history_record: bool,\n    pub clearing_with_customer: Option<Uuid>,    // Customer for offsetting\n    pub tolerance_group: Option<ToleranceGroup>,\n}\n\npub struct ContactPerson {\n    pub contact_id: Uuid,\n    pub contact_number: String,\n    pub first_name: String,\n    pub last_name: String,\n    pub title: Option<String>,\n    pub function: Option<String>,\n    pub department: Option<String>,\n    pub phone: Option<String>,\n    pub mobile: Option<String>,\n    pub email: Option<String>,\n    pub vip: bool,\n}\n\npub struct PartnerFunction {\n    pub partner_function: PartnerFunctionType,\n    pub partner_number: String,                   // Customer/Vendor/Contact number\n    pub default_partner: bool,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum PartnerFunctionType {\n    SoldTo,        // AG - Sold-to party\n    ShipTo,        // WE - Ship-to party\n    BillTo,        // RE - Bill-to party\n    Payer,         // RG - Payer\n    SalesPartner,  // VK - Sales partner\n    Forwarding,    // SP - Forwarding agent\n}\n```\n\n#### 4.1.2 销售订单 (Sales Order)\n\n```rust\npub struct SalesOrder {\n    pub order_id: Uuid,\n    pub order_number: String,             // Format: SO-2025-000001\n    pub order_type: SalesOrderType,\n    pub sales_organization: SalesOrganization,\n    pub distribution_channel: DistributionChannel,\n    pub division: Division,\n\n    // Header Data\n    pub document_date: NaiveDate,\n    pub pricing_date: NaiveDate,\n    pub requested_delivery_date: NaiveDate,\n    pub purchase_order_number: Option<String>, // Customer PO number\n    pub purchase_order_date: Option<NaiveDate>,\n    pub currency: Currency,\n\n    // Partners\n    pub sold_to_party: Uuid,\n    pub ship_to_party: Uuid,\n    pub bill_to_party: Uuid,\n    pub payer: Uuid,\n    pub partners: Vec<OrderPartner>,\n\n    // Sales Data\n    pub sales_office: Option<SalesOffice>,\n    pub sales_group: Option<SalesGroup>,\n    pub sales_employee: Option<UserId>,\n\n    // Pricing\n    pub pricing_procedure: PricingProcedure,\n    pub customer_pricing_group: Option<CustomerPricingGroup>,\n    pub pricing_date: NaiveDate,\n\n    // Shipping\n    pub shipping_conditions: ShippingConditions,\n    pub shipping_type: Option<ShippingType>,\n    pub delivery_block: Option<DeliveryBlock>,\n    pub complete_delivery: bool,\n    pub incoterms: Option<Incoterms>,\n    pub route: Option<Route>,\n\n    // Payment\n    pub payment_terms: PaymentTerms,\n    pub payment_method: Option<PaymentMethod>,\n    pub payment_card_info: Option<PaymentCardInfo>,\n\n    // Billing\n    pub billing_block: Option<BillingBlock>,\n    pub billing_type: BillingType,\n    pub billing_plan: Option<BillingPlan>,\n\n    // Items\n    pub items: Vec<SalesOrderItem>,\n\n    // Totals\n    pub net_value: Money,\n    pub tax_amount: Money,\n    pub gross_value: Money,\n\n    // Status\n    pub overall_status: SalesOrderStatus,\n    pub delivery_status: DeliveryStatus,\n    pub billing_status: BillingStatus,\n    pub credit_status: CreditStatus,\n    pub rejection_reason: Option<RejectionReason>,\n\n    // References\n    pub quotation_number: Option<String>,\n    pub contract_number: Option<String>,\n    pub project_number: Option<String>,\n\n    // Header Text\n    pub header_notes: Vec<TextElement>,\n\n    // Audit\n    pub created_at: DateTime<Utc>,\n    pub created_by: UserId,\n    pub last_changed_at: DateTime<Utc>,\n    pub last_changed_by: UserId,\n}\n\npub struct SalesOrderItem {\n    pub item_number: u16,\n    pub item_category: ItemCategory,\n    pub higher_level_item: Option<u16>,   // For BOM structures\n\n    // Material\n    pub material_id: Option<Uuid>,\n    pub material_number: Option<String>,\n    pub material_description: String,\n    pub material_group: Option<MaterialGroup>,\n    pub product_hierarchy: Option<ProductHierarchy>,\n\n    // Quantity & UoM\n    pub order_quantity: Decimal,\n    pub sales_unit: Unit,\n    pub target_quantity: Option<Decimal>, // In base unit\n    pub base_unit: Unit,\n\n    // Dates\n    pub requested_delivery_date: NaiveDate,\n    pub confirmed_delivery_date: Option<NaiveDate>,\n\n    // Plant & Shipping Point\n    pub plant: Plant,\n    pub storage_location: Option<StorageLocation>,\n    pub shipping_point: Option<ShippingPoint>,\n\n    // Pricing\n    pub pricing_conditions: Vec<PricingCondition>,\n    pub net_price: Money,\n    pub net_value: Money,\n    pub tax_amount: Money,\n    pub cost: Option<Money>,              // COGS\n    pub margin: Option<Money>,\n\n    // Availability\n    pub availability_date: Option<NaiveDate>,\n    pub confirmed_quantity: Decimal,\n    pub atp_check: AtpCheckResult,\n\n    // Batch & Serial Number\n    pub batch_required: bool,\n    pub batch_number: Option<String>,\n    pub serial_numbers: Vec<String>,\n\n    // Schedule Lines\n    pub schedule_lines: Vec<ScheduleLine>,\n\n    // Status\n    pub item_status: SalesOrderItemStatus,\n    pub delivery_status: ItemDeliveryStatus,\n    pub delivery_qty: Decimal,\n    pub open_delivery_qty: Decimal,\n    pub billing_status: ItemBillingStatus,\n    pub billed_qty: Decimal,\n    pub open_billing_qty: Decimal,\n    pub rejection_reason: Option<RejectionReason>,\n\n    // Item Notes\n    pub item_notes: Vec<TextElement>,\n\n    // Business Data\n    pub cost_center: Option<CostCenter>,\n    pub profit_center: Option<ProfitCenter>,\n    pub wbs_element: Option<WbsElement>,\n}\n\npub struct ScheduleLine {\n    pub schedule_line_number: u16,\n    pub confirmed_quantity: Decimal,\n    pub confirmed_date: NaiveDate,\n    pub delivery_date: NaiveDate,\n}\n\npub struct PricingCondition {\n    pub condition_type: ConditionType,\n    pub condition_description: String,\n    pub calculation_type: CalculationType,\n    pub condition_value: Decimal,\n    pub condition_unit: Option<Unit>,\n    pub condition_amount: Money,\n    pub condition_base_value: Decimal,\n    pub statistical: bool,                // Non-value affecting (e.g., cost)\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum ConditionType {\n    PR00,    // Price\n    K004,    // Material pricing group discount\n    K005,    // Customer discount\n    K007,    // Customer/material pricing group\n    MWST,    // VAT/Sales tax\n    SKTO,    // Cash discount\n    ZB00,    // Rebate\n    VPRS,    // Cost (statistical)\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum SalesOrderType {\n    OR,      // Standard order\n    RE,      // Returns\n    KE,      // Consignment issue\n    KA,      // Consignment pickup\n    CR,      // Credit memo request\n    DR,      // Debit memo request\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum SalesOrderStatus {\n    Created,\n    InProcess,\n    BeingDelivered,\n    Delivered,\n    PartiallyBilled,\n    Billed,\n    Completed,\n    Cancelled,\n}\n\npub struct AtpCheckResult {\n    pub check_executed: bool,\n    pub available_quantity: Decimal,\n    pub shortage_quantity: Decimal,\n    pub earliest_available_date: Option<NaiveDate>,\n}\n```\n\n#### 4.1.3 交货单 (Delivery Document)\n\n```rust\npub struct Delivery {\n    pub delivery_id: Uuid,\n    pub delivery_number: String,          // Format: DL-2025-000001\n    pub delivery_type: DeliveryType,\n    pub shipping_point: ShippingPoint,\n    pub delivery_date: NaiveDate,\n    pub planned_goods_movement_date: NaiveDate,\n    pub actual_goods_movement_date: Option<NaiveDate>,\n\n    // Ship-to Party\n    pub ship_to_party: Uuid,\n    pub ship_to_address: Address,\n\n    // Shipping\n    pub shipping_conditions: ShippingConditions,\n    pub shipping_type: Option<ShippingType>,\n    pub route: Option<Route>,\n    pub means_of_transport: Option<MeansOfTransport>,\n    pub forwarding_agent: Option<Uuid>,\n    pub incoterms: Option<Incoterms>,\n\n    // Weight & Volume\n    pub total_weight: Decimal,\n    pub weight_unit: Unit,\n    pub total_volume: Decimal,\n    pub volume_unit: Unit,\n    pub number_of_packages: u32,\n\n    // Items\n    pub items: Vec<DeliveryItem>,\n\n    // Picking\n    pub picking_status: PickingStatus,\n    pub picked_at: Option<DateTime<Utc>>,\n    pub picked_by: Option<UserId>,\n\n    // Packing\n    pub packing_status: PackingStatus,\n    pub handling_units: Vec<HandlingUnit>,\n\n    // Goods Issue\n    pub goods_issue_status: GoodsIssueStatus,\n    pub goods_issue_date: Option<NaiveDate>,\n    pub material_document_number: Option<String>,\n\n    // Shipment\n    pub shipment_number: Option<String>,\n    pub tracking_number: Option<String>,\n    pub carrier: Option<String>,\n\n    // Status\n    pub overall_status: DeliveryStatus,\n    pub billing_status: BillingStatus,\n    pub billing_block: Option<BillingBlock>,\n\n    // References\n    pub sales_orders: Vec<String>,\n    pub purchase_order_number: Option<String>,\n\n    // Documents\n    pub delivery_notes: Vec<TextElement>,\n    pub packing_list: Option<String>,\n    pub bill_of_lading: Option<String>,\n\n    // Audit\n    pub created_at: DateTime<Utc>,\n    pub created_by: UserId,\n    pub goods_issue_posted_by: Option<UserId>,\n}\n\npub struct DeliveryItem {\n    pub item_number: u16,\n    pub material_id: Uuid,\n    pub material_number: String,\n    pub material_description: String,\n\n    // Quantity\n    pub delivery_quantity: Decimal,\n    pub sales_unit: Unit,\n    pub base_unit: Unit,\n    pub picked_quantity: Decimal,\n    pub confirmed_quantity: Decimal,\n\n    // Storage\n    pub plant: Plant,\n    pub storage_location: StorageLocation,\n    pub batch: Option<String>,\n    pub serial_numbers: Vec<String>,\n\n    // Reference\n    pub sales_order_number: String,\n    pub sales_order_item: u16,\n    pub sales_order_schedule_line: Option<u16>,\n\n    // Picking\n    pub picking_status: ItemPickingStatus,\n    pub pick_quantity: Decimal,\n    pub stock_removal_location: Option<StorageBin>,\n\n    // Status\n    pub goods_issue_status: ItemGoodsIssueStatus,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum DeliveryType {\n    LF,      // Outbound delivery\n    LR,      // Returns delivery\n    NL,      // Replenishment delivery\n}\n\npub struct HandlingUnit {\n    pub handling_unit_id: Uuid,\n    pub handling_unit_number: String,\n    pub packaging_material: String,\n    pub packaging_material_description: String,\n    pub gross_weight: Decimal,\n    pub net_weight: Decimal,\n    pub weight_unit: Unit,\n    pub volume: Decimal,\n    pub volume_unit: Unit,\n    pub contents: Vec<HandlingUnitContent>,\n}\n\npub struct HandlingUnitContent {\n    pub material_id: Uuid,\n    pub material_number: String,\n    pub quantity: Decimal,\n    pub unit: Unit,\n    pub batch: Option<String>,\n}\n```\n\n#### 4.1.4 开票单据 (Billing Document)\n\n```rust\npub struct BillingDocument {\n    pub billing_id: Uuid,\n    pub billing_number: String,           // Format: INV-2025-000001\n    pub billing_type: BillingType,\n    pub billing_category: BillingCategory,\n    pub billing_date: NaiveDate,\n    pub accounting_date: NaiveDate,\n\n    // Partners\n    pub sold_to_party: Uuid,\n    pub bill_to_party: Uuid,\n    pub payer: Uuid,\n\n    // Sales Organization\n    pub sales_organization: SalesOrganization,\n    pub distribution_channel: DistributionChannel,\n    pub division: Division,\n\n    // Payment\n    pub payment_terms: PaymentTerms,\n    pub payment_method: Option<PaymentMethod>,\n    pub due_date: NaiveDate,\n    pub cash_discount_date1: Option<NaiveDate>,\n    pub cash_discount_percent1: Option<Decimal>,\n\n    // Currency\n    pub document_currency: Currency,\n    pub local_currency: Currency,\n    pub exchange_rate: Option<ExchangeRate>,\n\n    // Items\n    pub items: Vec<BillingItem>,\n\n    // Pricing Summary\n    pub net_value: Money,\n    pub tax_amount: Money,\n    pub gross_value: Money,\n    pub cash_discount_base: Money,\n\n    // Accounting\n    pub accounting_document_id: Option<Uuid>,\n    pub accounting_document_number: Option<String>,\n    pub revenue_recognized: bool,\n    pub revenue_recognition_date: Option<NaiveDate>,\n\n    // Status\n    pub billing_status: BillingDocumentStatus,\n    pub cancellation_document: Option<String>,\n    pub cancelled: bool,\n    pub payment_status: PaymentStatus,\n\n    // References\n    pub reference_documents: Vec<ReferenceDocument>,\n    pub customer_po_number: Option<String>,\n    pub external_invoice_number: Option<String>,\n\n    // Tax\n    pub tax_jurisdiction_code: Option<String>,\n    pub tax_summary: Vec<TaxSummary>,\n\n    // Audit\n    pub created_at: DateTime<Utc>,\n    pub created_by: UserId,\n}\n\npub struct BillingItem {\n    pub item_number: u16,\n    pub material_id: Option<Uuid>,\n    pub material_number: Option<String>,\n    pub material_description: String,\n    pub material_group: Option<MaterialGroup>,\n\n    // Quantity\n    pub billing_quantity: Decimal,\n    pub sales_unit: Unit,\n\n    // Pricing\n    pub pricing_conditions: Vec<PricingCondition>,\n    pub net_price: Money,\n    pub net_value: Money,\n    pub tax_code: TaxCode,\n    pub tax_amount: Money,\n    pub cost: Option<Money>,\n    pub margin: Option<Money>,\n\n    // Revenue Recognition\n    pub revenue_element: RevenueElement,\n    pub revenue_account: String,\n\n    // Account Assignment\n    pub cost_center: Option<CostCenter>,\n    pub profit_center: Option<ProfitCenter>,\n    pub wbs_element: Option<WbsElement>,\n\n    // Reference\n    pub sales_order_number: Option<String>,\n    pub sales_order_item: Option<u16>,\n    pub delivery_number: Option<String>,\n    pub delivery_item: Option<u16>,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum BillingType {\n    F2,      // Invoice\n    G2,      // Credit memo\n    L2,      // Debit memo\n    IV,      // Pro forma invoice\n    RE,      // Invoice cancellation\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum BillingCategory {\n    Invoice,\n    CreditMemo,\n    DebitMemo,\n    ProForma,\n    Cancellation,\n}\n\npub struct ReferenceDocument {\n    pub document_type: String,\n    pub document_number: String,\n    pub document_item: Option<u16>,\n}\n\npub struct TaxSummary {\n    pub tax_code: String,\n    pub tax_type: String,\n    pub tax_rate: Decimal,\n    pub tax_base_amount: Money,\n    pub tax_amount: Money,\n    pub tax_jurisdiction: Option<String>,\n}\n```\n\n### 4.2 API 规格\n\n#### 4.2.1 销售订单 API\n\n```rust\n// POST /api/v1/sales/orders\npub struct CreateSalesOrderRequest {\n    pub order_type: String,\n    pub sales_organization: String,\n    pub distribution_channel: String,\n    pub division: String,\n    pub sold_to_party: Uuid,\n    pub ship_to_party: Option<Uuid>,\n    pub bill_to_party: Option<Uuid>,\n    pub payer: Option<Uuid>,\n    pub purchase_order_number: Option<String>,\n    pub requested_delivery_date: NaiveDate,\n    pub items: Vec<CreateSalesOrderItemRequest>,\n}\n\npub struct CreateSalesOrderItemRequest {\n    pub material_id: Option<Uuid>,\n    pub material_description: Option<String>,\n    pub order_quantity: Decimal,\n    pub sales_unit: String,\n    pub requested_delivery_date: Option<NaiveDate>,\n    pub plant: Option<String>,\n    pub pricing_date: Option<NaiveDate>,\n    pub batch: Option<String>,\n    pub manual_price_override: Option<Decimal>,\n}\n\npub struct CreateSalesOrderResponse {\n    pub order_id: Uuid,\n    pub order_number: String,\n    pub order_type: String,\n    pub sold_to_party: String,\n    pub net_value: Decimal,\n    pub currency: String,\n    pub items: Vec<SalesOrderItemSummary>,\n    pub incomplete_data_log: Vec<String>,\n    pub credit_check_result: CreditCheckResult,\n    pub created_at: DateTime<Utc>,\n}\n\npub struct SalesOrderItemSummary {\n    pub item_number: u16,\n    pub material_number: Option<String>,\n    pub material_description: String,\n    pub order_quantity: Decimal,\n    pub confirmed_quantity: Decimal,\n    pub net_price: Decimal,\n    pub net_value: Decimal,\n    pub requested_delivery_date: NaiveDate,\n    pub confirmed_delivery_date: Option<NaiveDate>,\n}\n\npub struct CreditCheckResult {\n    pub credit_check_performed: bool,\n    pub credit_status: String,\n    pub credit_limit: Option<Decimal>,\n    pub credit_exposure: Option<Decimal>,\n    pub available_credit: Option<Decimal>,\n    pub delivery_block: Option<String>,\n}\n\n// PUT /api/v1/sales/orders/{order_id}\npub struct UpdateSalesOrderRequest {\n    pub requested_delivery_date: Option<NaiveDate>,\n    pub purchase_order_number: Option<String>,\n    pub items: Vec<UpdateSalesOrderItemRequest>,\n}\n\npub struct UpdateSalesOrderItemRequest {\n    pub item_number: u16,\n    pub action: ItemUpdateAction,\n    pub order_quantity: Option<Decimal>,\n    pub requested_delivery_date: Option<NaiveDate>,\n    pub reason_for_rejection: Option<String>,\n}\n\n#[derive(Debug, Deserialize)]\npub enum ItemUpdateAction {\n    Update,\n    Delete,\n    Add,\n}\n\n// POST /api/v1/sales/orders/{order_id}/availability-check\npub struct AvailabilityCheckRequest {\n    pub check_rule: String,\n    pub items: Option<Vec<u16>>,          // Specific items, or all if None\n}\n\npub struct AvailabilityCheckResponse {\n    pub order_id: Uuid,\n    pub order_number: String,\n    pub check_timestamp: DateTime<Utc>,\n    pub items: Vec<ItemAvailabilityResult>,\n}\n\npub struct ItemAvailabilityResult {\n    pub item_number: u16,\n    pub material_number: String,\n    pub requested_quantity: Decimal,\n    pub available_quantity: Decimal,\n    pub shortage_quantity: Decimal,\n    pub confirmed_quantity: Decimal,\n    pub confirmed_date: Option<NaiveDate>,\n    pub alternative_materials: Vec<AlternativeMaterial>,\n}\n\npub struct AlternativeMaterial {\n    pub material_id: Uuid,\n    pub material_number: String,\n    pub material_description: String,\n    pub available_quantity: Decimal,\n    pub available_date: NaiveDate,\n}\n\n// GET /api/v1/sales/orders/{order_id}\npub struct GetSalesOrderResponse {\n    pub order: SalesOrderDto,\n    pub items: Vec<SalesOrderItemDto>,\n    pub partners: Vec<OrderPartnerDto>,\n    pub pricing_summary: PricingSummary,\n    pub delivery_status: OrderDeliveryStatus,\n    pub billing_status: OrderBillingStatus,\n    pub documents: Vec<RelatedDocumentDto>,\n    pub incompletion_log: Vec<IncompletionItem>,\n}\n\npub struct OrderDeliveryStatus {\n    pub overall_status: String,\n    pub items: Vec<ItemDeliveryStatusDto>,\n}\n\npub struct ItemDeliveryStatusDto {\n    pub item_number: u16,\n    pub order_quantity: Decimal,\n    pub delivered_quantity: Decimal,\n    pub open_quantity: Decimal,\n    pub delivery_completion_percentage: Decimal,\n}\n\n// GET /api/v1/sales/orders\npub struct ListSalesOrdersQuery {\n    pub sales_organization: Option<String>,\n    pub distribution_channel: Option<String>,\n    pub sold_to_party: Option<Uuid>,\n    pub material_id: Option<Uuid>,\n    pub order_date_from: Option<NaiveDate>,\n    pub order_date_to: Option<NaiveDate>,\n    pub delivery_date_from: Option<NaiveDate>,\n    pub delivery_date_to: Option<NaiveDate>,\n    pub order_status: Option<String>,\n    pub created_by: Option<String>,\n    pub customer_po_number: Option<String>,\n    pub page: Option<u32>,\n    pub page_size: Option<u32>,\n}\n```\n\n#### 4.2.2 交货 API\n\n```rust\n// POST /api/v1/sales/deliveries\npub struct CreateDeliveryRequest {\n    pub delivery_type: String,\n    pub shipping_point: String,\n    pub delivery_date: NaiveDate,\n    pub planned_goods_movement_date: NaiveDate,\n    pub ship_to_party: Uuid,\n    pub sales_orders: Vec<DeliverySourceOrder>,\n    pub complete_delivery: bool,\n}\n\npub struct DeliverySourceOrder {\n    pub sales_order_id: Uuid,\n    pub items: Vec<DeliverySourceItem>,\n}\n\npub struct DeliverySourceItem {\n    pub sales_order_item: u16,\n    pub delivery_quantity: Decimal,\n}\n\npub struct CreateDeliveryResponse {\n    pub delivery_id: Uuid,\n    pub delivery_number: String,\n    pub shipping_point: String,\n    pub delivery_date: NaiveDate,\n    pub ship_to_party: String,\n    pub items: Vec<DeliveryItemSummary>,\n    pub total_weight: Decimal,\n    pub total_volume: Decimal,\n    pub created_at: DateTime<Utc>,\n}\n\npub struct DeliveryItemSummary {\n    pub item_number: u16,\n    pub material_number: String,\n    pub delivery_quantity: Decimal,\n    pub sales_order_reference: String,\n}\n\n// POST /api/v1/sales/deliveries/{delivery_id}/pick\npub struct PickDeliveryRequest {\n    pub items: Vec<PickItemRequest>,\n}\n\npub struct PickItemRequest {\n    pub item_number: u16,\n    pub picked_quantity: Decimal,\n    pub storage_location: String,\n    pub batch: Option<String>,\n    pub storage_bin: Option<String>,\n    pub serial_numbers: Option<Vec<String>>,\n}\n\npub struct PickDeliveryResponse {\n    pub delivery_id: Uuid,\n    pub delivery_number: String,\n    pub picking_status: String,\n    pub picked_at: DateTime<Utc>,\n    pub picked_by: String,\n    pub items: Vec<PickedItemResult>,\n}\n\n// POST /api/v1/sales/deliveries/{delivery_id}/pack\npub struct PackDeliveryRequest {\n    pub handling_units: Vec<CreateHandlingUnitRequest>,\n}\n\npub struct CreateHandlingUnitRequest {\n    pub packaging_material: String,\n    pub contents: Vec<HandlingUnitContentRequest>,\n}\n\npub struct HandlingUnitContentRequest {\n    pub delivery_item: u16,\n    pub quantity: Decimal,\n}\n\npub struct PackDeliveryResponse {\n    pub delivery_id: Uuid,\n    pub packing_status: String,\n    pub handling_units: Vec<HandlingUnitDto>,\n}\n\n// POST /api/v1/sales/deliveries/{delivery_id}/post-goods-issue\npub struct PostGoodsIssueRequest {\n    pub goods_issue_date: NaiveDate,\n    pub actual_goods_movement_date: Option<NaiveDate>,\n}\n\npub struct PostGoodsIssueResponse {\n    pub delivery_id: Uuid,\n    pub delivery_number: String,\n    pub goods_issue_date: NaiveDate,\n    pub material_document_number: String,\n    pub goods_issue_status: String,\n    pub posted_at: DateTime<Utc>,\n}\n\n// GET /api/v1/sales/deliveries/{delivery_id}\npub struct GetDeliveryResponse {\n    pub delivery: DeliveryDto,\n    pub items: Vec<DeliveryItemDto>,\n    pub handling_units: Vec<HandlingUnitDto>,\n    pub shipment: Option<ShipmentDto>,\n    pub related_sales_orders: Vec<String>,\n}\n```\n\n#### 4.2.3 开票 API\n\n```rust\n// POST /api/v1/sales/billing-documents\npub struct CreateBillingDocumentRequest {\n    pub billing_type: String,\n    pub billing_date: NaiveDate,\n    pub source_documents: Vec<BillingSource>,\n    pub billing_block: Option<String>,\n}\n\npub struct BillingSource {\n    pub source_type: String,              // SalesOrder, Delivery\n    pub source_id: Uuid,\n    pub items: Option<Vec<u16>>,          // Specific items to bill\n}\n\npub struct CreateBillingDocumentResponse {\n    pub billing_id: Uuid,\n    pub billing_number: String,\n    pub billing_type: String,\n    pub billing_date: NaiveDate,\n    pub bill_to_party: String,\n    pub net_value: Decimal,\n    pub tax_amount: Decimal,\n    pub gross_value: Decimal,\n    pub currency: String,\n    pub items: Vec<BillingItemSummary>,\n    pub accounting_document_number: Option<String>,\n    pub created_at: DateTime<Utc>,\n}\n\npub struct BillingItemSummary {\n    pub item_number: u16,\n    pub material_number: Option<String>,\n    pub billing_quantity: Decimal,\n    pub net_value: Decimal,\n    pub tax_amount: Decimal,\n}\n\n// POST /api/v1/sales/billing-documents/{billing_id}/cancel\npub struct CancelBillingDocumentRequest {\n    pub cancellation_reason: String,\n    pub cancellation_date: Option<NaiveDate>,\n}\n\npub struct CancelBillingDocumentResponse {\n    pub original_billing_id: Uuid,\n    pub cancellation_document_id: Uuid,\n    pub cancellation_document_number: String,\n    pub cancelled_at: DateTime<Utc>,\n}\n\n// GET /api/v1/sales/billing-documents\npub struct ListBillingDocumentsQuery {\n    pub sales_organization: Option<String>,\n    pub billing_type: Option<String>,\n    pub bill_to_party: Option<Uuid>,\n    pub billing_date_from: Option<NaiveDate>,\n    pub billing_date_to: Option<NaiveDate>,\n    pub payment_status: Option<String>,\n    pub sales_order_number: Option<String>,\n    pub delivery_number: Option<String>,\n    pub page: Option<u32>,\n    pub page_size: Option<u32>,\n}\n\n// POST /api/v1/sales/billing-run\npub struct CreateBillingRunRequest {\n    pub billing_date: NaiveDate,\n    pub sales_organizations: Vec<String>,\n    pub distribution_channels: Option<Vec<String>>,\n    pub billing_types: Vec<String>,\n    pub due_list_variant: Option<String>,\n    pub selection_criteria: BillingSelectionCriteria,\n    pub test_run: bool,\n}\n\npub struct BillingSelectionCriteria {\n    pub sold_to_parties: Option<Vec<Uuid>>,\n    pub delivery_date_from: Option<NaiveDate>,\n    pub delivery_date_to: Option<NaiveDate>,\n    pub billing_block: Option<String>,     // Only process specific billing blocks\n}\n\npub struct CreateBillingRunResponse {\n    pub billing_run_id: Uuid,\n    pub billing_date: NaiveDate,\n    pub test_run: bool,\n    pub created_documents: Vec<BillingDocumentSummary>,\n    pub errors: Vec<BillingError>,\n    pub statistics: BillingRunStatistics,\n    pub executed_at: DateTime<Utc>,\n}\n\npub struct BillingRunStatistics {\n    pub total_documents_processed: u64,\n    pub successful_billings: u64,\n    pub failed_billings: u64,\n    pub total_billed_value: Decimal,\n    pub currency: String,\n}\n```\n\n### 4.3 领域事件\n\n```rust\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum SalesDomainEvent {\n    SalesOrderCreated(SalesOrderCreated),\n    SalesOrderChanged(SalesOrderChanged),\n    SalesOrderCancelled(SalesOrderCancelled),\n    AvailabilityConfirmed(AvailabilityConfirmed),\n    CreditCheckPerformed(CreditCheckPerformed),\n    DeliveryCreated(DeliveryCreated),\n    DeliveryPicked(DeliveryPicked),\n    DeliveryPacked(DeliveryPacked),\n    GoodsIssuePosted(GoodsIssuePosted),\n    BillingDocumentCreated(BillingDocumentCreated),\n    BillingDocumentCancelled(BillingDocumentCancelled),\n    CustomerInvoicePosted(CustomerInvoicePosted),\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct SalesOrderCreated {\n    pub event_id: Uuid,\n    pub occurred_at: DateTime<Utc>,\n    pub order_id: Uuid,\n    pub order_number: String,\n    pub order_type: String,\n    pub sales_organization: String,\n    pub distribution_channel: String,\n    pub division: String,\n    pub sold_to_party: Uuid,\n    pub ship_to_party: Uuid,\n    pub bill_to_party: Uuid,\n    pub payer: Uuid,\n    pub requested_delivery_date: NaiveDate,\n    pub currency: String,\n    pub net_value: Decimal,\n    pub items: Vec<SalesOrderItemCreated>,\n    pub created_by: String,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct SalesOrderItemCreated {\n    pub item_number: u16,\n    pub material_id: Option<Uuid>,\n    pub material_number: Option<String>,\n    pub order_quantity: Decimal,\n    pub sales_unit: String,\n    pub confirmed_quantity: Decimal,\n    pub requested_delivery_date: NaiveDate,\n    pub confirmed_delivery_date: Option<NaiveDate>,\n    pub plant: String,\n    pub net_price: Decimal,\n    pub net_value: Decimal,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct GoodsIssuePosted {\n    pub event_id: Uuid,\n    pub occurred_at: DateTime<Utc>,\n    pub delivery_id: Uuid,\n    pub delivery_number: String,\n    pub material_document_number: String,\n    pub goods_issue_date: NaiveDate,\n    pub ship_to_party: Uuid,\n    pub items: Vec<GoodsIssueItem>,\n    pub posted_by: String,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct GoodsIssueItem {\n    pub item_number: u16,\n    pub material_id: Uuid,\n    pub material_number: String,\n    pub quantity: Decimal,\n    pub unit: String,\n    pub plant: String,\n    pub storage_location: String,\n    pub batch: Option<String>,\n    pub sales_order_number: String,\n    pub sales_order_item: u16,\n    pub value: Decimal,\n    pub currency: String,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct CustomerInvoicePosted {\n    pub event_id: Uuid,\n    pub occurred_at: DateTime<Utc>,\n    pub billing_id: Uuid,\n    pub billing_number: String,\n    pub billing_type: String,\n    pub billing_date: NaiveDate,\n    pub bill_to_party: Uuid,\n    pub payer: Uuid,\n    pub net_value: Decimal,\n    pub tax_amount: Decimal,\n    pub gross_value: Decimal,\n    pub currency: String,\n    pub payment_terms: String,\n    pub due_date: NaiveDate,\n    pub accounting_document_id: Uuid,\n    pub accounting_document_number: String,\n    pub items: Vec<BillingItemPosted>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct BillingItemPosted {\n    pub item_number: u16,\n    pub material_id: Option<Uuid>,\n    pub material_number: Option<String>,\n    pub billing_quantity: Decimal,\n    pub net_value: Decimal,\n    pub tax_amount: Decimal,\n    pub revenue_account: String,\n    pub cost_of_sales_amount: Option<Decimal>,\n    pub profit_center: Option<String>,\n}\n```\n\n---\n\n## 第五部分：生产计划模块 (PP - Production Planning)\n\n### 5.1 数据模型\n\n#### 5.1.1 物料清单 (Bill of Materials - BOM)\n\n```rust\npub struct Bom {\n    pub bom_id: Uuid,\n    pub bom_number: String,\n    pub material_id: Uuid,                // Header material\n    pub material_number: String,\n    pub plant: Plant,\n    pub bom_usage: BomUsage,\n    pub bom_status: BomStatus,\n    pub alternative_bom: String,          // 01, 02, 03...\n\n    // Valid From/To\n    pub valid_from: NaiveDate,\n    pub valid_to: NaiveDate,\n\n    // Quantities\n    pub base_quantity: Decimal,\n    pub base_unit: Unit,\n\n    // Header Data\n    pub bom_text: Option<String>,\n    pub lot_size_from: Option<Decimal>,\n    pub lot_size_to: Option<Decimal>,\n\n    // Items\n    pub items: Vec<BomItem>,\n\n    // Change Management\n    pub engineering_change_number: Option<String>,\n    pub revision_level: String,\n\n    // Audit\n    pub created_at: DateTime<Utc>,\n    pub created_by: UserId,\n    pub last_changed_at: DateTime<Utc>,\n    pub last_changed_by: UserId,\n}\n\npub struct BomItem {\n    pub item_number: String,              // 0010, 0020, 0030...\n    pub item_category: BomItemCategory,\n    pub component_material_id: Uuid,\n    pub component_material_number: String,\n    pub component_description: String,\n\n    // Quantity\n    pub component_quantity: Decimal,\n    pub component_unit: Unit,\n    pub component_scrap: Decimal,         // Percentage\n    pub net_quantity: Decimal,            // Quantity + scrap\n\n    // Item Control\n    pub item_type: ItemType,              // Stock item, non-stock item, variable size\n    pub procurement_type: ProcurementType,\n    pub special_procurement_type: Option<SpecialProcurementType>,\n\n    // Assembly Data\n    pub assembly: Option<String>,         // Sub-assembly identifier\n    pub installation_point: Option<String>,\n\n    // MRP Data\n    pub mrp_indicator: Option<MrpIndicator>,\n    pub bulk_material: bool,\n\n    // Costing\n    pub costing_relevancy: CostingRelevancy,\n    pub cost_element: Option<String>,\n\n    // Operations\n    pub operation_number: Option<String>, // Link to routing operation\n    pub operation_lead_time_offset: Option<i32>, // Days offset\n\n    // Classification\n    pub item_text: Option<String>,\n    pub purchasing_group: Option<String>,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum BomUsage {\n    Production,      // 1 - Production\n    Engineering,     // 2 - Engineering/design\n    Universal,       // 3 - Universal\n    Maintenance,     // 4 - Maintenance\n    Sales,          // 5 - Sales and distribution\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum BomItemCategory {\n    StockItem,       // L - Stock item\n    NonStockItem,    // N - Non-stock item\n    VariableSize,    // V - Variable-size item\n    Document,        // D - Document item\n    TextItem,        // T - Text item\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum SpecialProcurementType {\n    Phantom,         // 50 - Phantom assembly\n    DirectProcurement, // 30 - Direct procurement from external vendor\n    WithdrawalFromSubcontractor, // 40 - Subcontracting\n}\n```\n\n#### 5.1.2 工艺路线 (Routing)\n\n```rust\npub struct Routing {\n    pub routing_id: Uuid,\n    pub routing_number: String,\n    pub material_id: Uuid,\n    pub material_number: String,\n    pub plant: Plant,\n    pub routing_usage: RoutingUsage,\n    pub routing_status: RoutingStatus,\n    pub alternative_routing: String,      // 01, 02, 03...\n\n    // Valid From/To\n    pub valid_from: NaiveDate,\n    pub valid_to: NaiveDate,\n\n    // Lot Size\n    pub lot_size_from: Decimal,\n    pub lot_size_to: Decimal,\n\n    // Operations\n    pub operations: Vec<RoutingOperation>,\n\n    // Sequences (Alternative operation sequences)\n    pub sequences: Vec<RoutingSequence>,\n\n    // Change Management\n    pub engineering_change_number: Option<String>,\n    pub revision_level: String,\n\n    // Audit\n    pub created_at: DateTime<Utc>,\n    pub created_by: UserId,\n    pub last_changed_at: DateTime<Utc>,\n    pub last_changed_by: UserId,\n}\n\npub struct RoutingOperation {\n    pub operation_id: Uuid,\n    pub operation_number: String,         // 0010, 0020, 0030...\n    pub control_key: ControlKey,\n    pub work_center_id: Uuid,\n    pub work_center: String,\n    pub operation_description: String,\n\n    // Standard Values\n    pub base_quantity: Decimal,\n    pub setup_time: Duration,\n    pub machine_time: Duration,\n    pub labor_time: Duration,\n    pub setup_time_unit: TimeUnit,\n    pub machine_time_unit: TimeUnit,\n    pub labor_time_unit: TimeUnit,\n\n    // Formulas (for calculating actual times)\n    pub setup_formula: Option<String>,\n    pub machine_formula: Option<String>,\n    pub labor_formula: Option<String>,\n\n    // Number of Capacities\n    pub number_of_splits: u16,            // Parallel processing\n    pub number_of_time_tickets: u16,\n\n    // Lead Time\n    pub lead_time_offset: i32,            // Days\n\n    // Inspection\n    pub inspection_required: bool,\n    pub inspection_characteristics: Vec<String>,\n\n    // Costing\n    pub activity_type: Option<String>,\n    pub costing_relevancy: CostingRelevancy,\n\n    // Operation Text\n    pub operation_text: Option<String>,\n    pub operation_notes: Vec<TextElement>,\n\n    // Components (BOM items consumed in this operation)\n    pub components: Vec<OperationComponent>,\n}\n\npub struct OperationComponent {\n    pub bom_item_number: String,\n    pub material_id: Uuid,\n    pub material_number: String,\n    pub quantity: Decimal,\n    pub unit: Unit,\n    pub backflush: bool,                  // Auto goods issue on confirmation\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum ControlKey {\n    PP01,    // Internal processing with external processing\n    PP02,    // Internal processing\n    PP03,    // External processing (subcontracting)\n    PP04,    // Inspection\n}\n\npub struct RoutingSequence {\n    pub sequence_number: String,\n    pub sequence_description: String,\n    pub operations: Vec<String>,          // Operation numbers in sequence\n    pub standard: bool,                    // Is this the standard sequence?\n}\n```\n\n#### 5.1.3 生产订单 (Production Order)\n\n```rust\npub struct ProductionOrder {\n    pub order_id: Uuid,\n    pub order_number: String,             // Format: PRO-2025-000001\n    pub order_type: ProductionOrderType,\n    pub material_id: Uuid,\n    pub material_number: String,\n    pub material_description: String,\n    pub plant: Plant,\n\n    // Quantities\n    pub target_quantity: Decimal,\n    pub confirmed_yield: Decimal,\n    pub scrap_quantity: Decimal,\n    pub unit_of_measure: Unit,\n\n    // Dates\n    pub order_start_date: NaiveDate,\n    pub order_finish_date: NaiveDate,\n    pub scheduled_start_date: NaiveDate,\n    pub scheduled_finish_date: NaiveDate,\n    pub actual_start_date: Option<NaiveDate>,\n    pub actual_finish_date: Option<NaiveDate>,\n\n    // Production Version\n    pub production_version: Option<String>,\n    pub bom_id: Uuid,\n    pub routing_id: Uuid,\n\n    // Scheduling\n    pub scheduling_type: SchedulingType,\n    pub lead_time: Duration,\n    pub float_before_production: Duration,\n    pub float_after_production: Duration,\n\n    // Storage Location\n    pub production_storage_location: Option<StorageLocation>,\n    pub goods_recipient: Option<String>,\n\n    // Account Assignment\n    pub cost_center: Option<CostCenter>,\n    pub profit_center: Option<ProfitCenter>,\n    pub wbs_element: Option<WbsElement>,\n    pub sales_order: Option<String>,\n    pub sales_order_item: Option<u16>,\n\n    // Settlement\n    pub settlement_rule: Option<SettlementRule>,\n    pub settlement_receiver: Option<SettlementReceiver>,\n\n    // Operations\n    pub operations: Vec<ProductionOrderOperation>,\n\n    // Components\n    pub components: Vec<ProductionOrderComponent>,\n\n    // Status\n    pub system_status: ProductionOrderStatus,\n    pub user_status: Option<UserStatus>,\n    pub deletion_flag: bool,\n\n    // Costs\n    pub planned_costs: Decimal,\n    pub actual_costs: Decimal,\n    pub variance: Decimal,\n    pub cost_estimate_id: Option<Uuid>,\n\n    // Audit\n    pub created_at: DateTime<Utc>,\n    pub created_by: UserId,\n    pub released_at: Option<DateTime<Utc>>,\n    pub released_by: Option<UserId>,\n}\n\npub struct ProductionOrderOperation {\n    pub operation_id: Uuid,\n    pub operation_number: String,\n    pub control_key: ControlKey,\n    pub work_center_id: Uuid,\n    pub work_center: String,\n    pub operation_description: String,\n\n    // Planned Times\n    pub planned_setup_time: Duration,\n    pub planned_machine_time: Duration,\n    pub planned_labor_time: Duration,\n    pub planned_start_date: NaiveDateTime,\n    pub planned_finish_date: NaiveDateTime,\n\n    // Actual Times\n    pub actual_setup_time: Duration,\n    pub actual_machine_time: Duration,\n    pub actual_labor_time: Duration,\n    pub actual_start_date: Option<NaiveDateTime>,\n    pub actual_finish_date: Option<NaiveDateTime>,\n\n    // Confirmation\n    pub confirmations: Vec<OperationConfirmation>,\n    pub confirmed_yield: Decimal,\n    pub confirmed_scrap: Decimal,\n\n    // Capacity\n    pub capacity_requirements: Vec<CapacityRequirement>,\n\n    // Status\n    pub operation_status: OperationStatus,\n}\n\npub struct OperationConfirmation {\n    pub confirmation_id: Uuid,\n    pub confirmation_number: String,\n    pub confirmation_date: NaiveDate,\n    pub confirmation_time: NaiveTime,\n    pub confirmer: UserId,\n    pub yield_quantity: Decimal,\n    pub scrap_quantity: Decimal,\n    pub scrap_reason: Option<ScrapReason>,\n    pub actual_setup_time: Duration,\n    pub actual_machine_time: Duration,\n    pub actual_labor_time: Duration,\n    pub final_confirmation: bool,\n}\n\npub struct ProductionOrderComponent {\n    pub component_id: Uuid,\n    pub item_number: String,\n    pub material_id: Uuid,\n    pub material_number: String,\n    pub material_description: String,\n\n    // Requirement\n    pub required_quantity: Decimal,\n    pub withdrawn_quantity: Decimal,\n    pub open_quantity: Decimal,\n    pub unit: Unit,\n\n    // Location\n    pub plant: Plant,\n    pub storage_location: StorageLocation,\n    pub batch: Option<String>,\n\n    // BOM Reference\n    pub bom_item_number: Option<String>,\n\n    // Operation Assignment\n    pub operation_number: Option<String>,\n\n    // Backflush\n    pub backflush_indicator: bool,\n\n    // Reservation\n    pub reservation_number: Option<String>,\n\n    // Status\n    pub goods_issue_status: GoodsIssueStatus,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum ProductionOrderType {\n    PP01,    // Standard production order\n    PP02,    // Process order\n    PP03,    // Rework order\n    PP04,    // Refurbishment order\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum ProductionOrderStatus {\n    Created,         // CRTD\n    Released,        // REL\n    PartiallyReleased, // PREL\n    PartiallyConfirmed, // PCNF\n    Confirmed,       // CNF\n    PartiallyDelivered, // PDLV\n    Delivered,       // DLV\n    TechnicallyCompleted, // TECO\n    Closed,          // CLSD\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum SchedulingType {\n    Forward,         // Schedule from start date\n    Backward,        // Schedule from finish date\n    OnlyCapacity,    // Only capacity requirements\n    MidpointScheduling, // Schedule around midpoint\n}\n```\n\n#### 5.1.4 工作中心 (Work Center)\n\n```rust\npub struct WorkCenter {\n    pub work_center_id: Uuid,\n    pub work_center_code: String,\n    pub work_center_category: WorkCenterCategory,\n    pub plant: Plant,\n\n    // Description\n    pub description: String,\n    pub long_text: Option<String>,\n\n    // Person Responsible\n    pub responsible_person: UserId,\n    pub cost_center: CostCenter,\n\n    // Capacity\n    pub capacity_category: CapacityCategory,\n    pub available_capacity: Decimal,\n    pub capacity_unit: Unit,\n    pub number_of_individual_capacities: u16,\n    pub operating_time: OperatingTime,\n\n    // Standard Values\n    pub standard_value_key: Option<StandardValueKey>,\n    pub activity_types: Vec<ActivityType>,\n\n    // Formulas\n    pub setup_formula_key: Option<String>,\n    pub machine_formula_key: Option<String>,\n    pub labor_formula_key: Option<String>,\n\n    // Control\n    pub usage: WorkCenterUsage,\n    pub task_list_usage: TaskListUsage,\n\n    // Location\n    pub location: Option<String>,\n    pub room: Option<String>,\n\n    // Status\n    pub work_center_status: WorkCenterStatus,\n\n    // Validity\n    pub valid_from: NaiveDate,\n    pub valid_to: NaiveDate,\n\n    // Audit\n    pub created_at: DateTime<Utc>,\n    pub created_by: UserId,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum WorkCenterCategory {\n    Machine,         // 0001 - Machine\n    ProductionLine,  // 0002 - Production line\n    WorkStation,     // 0003 - Workstation\n    LaborGroup,      // 0004 - Labor group\n    Mixed,          // 0005 - Mixed work center\n}\n\npub struct OperatingTime {\n    pub factory_calendar: String,\n    pub capacity_utilization: Decimal,    // Percentage\n    pub shifts: Vec<Shift>,\n}\n\npub struct Shift {\n    pub shift_number: u8,\n    pub start_time: NaiveTime,\n    pub end_time: NaiveTime,\n    pub break_duration: Duration,\n}\n\npub struct CapacityRequirement {\n    pub requirement_id: Uuid,\n    pub work_center_id: Uuid,\n    pub start_date: NaiveDateTime,\n    pub end_date: NaiveDateTime,\n    pub required_capacity: Decimal,\n    pub capacity_unit: Unit,\n    pub production_order: Option<String>,\n    pub operation_number: Option<String>,\n}\n```\n\n### 5.2 API 规格\n\n#### 5.2.1 生产订单 API\n\n```rust\n// POST /api/v1/production/orders\npub struct CreateProductionOrderRequest {\n    pub order_type: String,\n    pub material_id: Uuid,\n    pub plant: String,\n    pub target_quantity: Decimal,\n    pub unit_of_measure: String,\n    pub order_start_date: NaiveDate,\n    pub order_finish_date: NaiveDate,\n    pub production_version: Option<String>,\n    pub sales_order: Option<String>,\n    pub sales_order_item: Option<u16>,\n    pub wbs_element: Option<String>,\n    pub scheduling_type: String,\n}\n\npub struct CreateProductionOrderResponse {\n    pub order_id: Uuid,\n    pub order_number: String,\n    pub material_number: String,\n    pub target_quantity: Decimal,\n    pub scheduled_start_date: NaiveDate,\n    pub scheduled_finish_date: NaiveDate,\n    pub operations: Vec<OperationSummary>,\n    pub components: Vec<ComponentRequirement>,\n    pub status: String,\n    pub created_at: DateTime<Utc>,\n}\n\npub struct OperationSummary {\n    pub operation_number: String,\n    pub work_center: String,\n    pub description: String,\n    pub planned_start_date: NaiveDateTime,\n    pub planned_finish_date: NaiveDateTime,\n    pub setup_time: String,\n    pub machine_time: String,\n}\n\npub struct ComponentRequirement {\n    pub item_number: String,\n    pub material_number: String,\n    pub required_quantity: Decimal,\n    pub unit: String,\n    pub storage_location: String,\n    pub backflush: bool,\n}\n\n// POST /api/v1/production/orders/{order_id}/release\npub struct ReleaseProductionOrderRequest {\n    pub release_type: String,             // Full, Operations, Components\n    pub operations: Option<Vec<String>>,  // Specific operations to release\n}\n\npub struct ReleaseProductionOrderResponse {\n    pub order_id: Uuid,\n    pub order_number: String,\n    pub status: String,\n    pub released_operations: Vec<String>,\n    pub reservation_number: Option<String>,\n    pub released_at: DateTime<Utc>,\n}\n\n// POST /api/v1/production/orders/{order_id}/operations/{operation_id}/confirm\npub struct ConfirmOperationRequest {\n    pub confirmation_date: NaiveDate,\n    pub confirmation_time: NaiveTime,\n    pub yield_quantity: Decimal,\n    pub scrap_quantity: Option<Decimal>,\n    pub scrap_reason: Option<String>,\n    pub actual_setup_time: Option<String>,  // Duration string\n    pub actual_machine_time: Option<String>,\n    pub actual_labor_time: Option<String>,\n    pub final_confirmation: bool,\n    pub backflush_components: bool,\n}\n\npub struct ConfirmOperationResponse {\n    pub confirmation_id: Uuid,\n    pub confirmation_number: String,\n    pub order_number: String,\n    pub operation_number: String,\n    pub yield_quantity: Decimal,\n    pub goods_movements: Vec<GoodsMovementSummary>,\n    pub confirmed_at: DateTime<Utc>,\n}\n\npub struct GoodsMovementSummary {\n    pub movement_type: String,\n    pub material_number: String,\n    pub quantity: Decimal,\n    pub material_document_number: String,\n}\n\n// POST /api/v1/production/orders/{order_id}/goods-receipt\npub struct ProductionGoodsReceiptRequest {\n    pub posting_date: NaiveDate,\n    pub quantity: Decimal,\n    pub storage_location: String,\n    pub movement_type: String,            // 101 - GR to warehouse, 131 - GR to stock in quality inspection\n}\n\npub struct ProductionGoodsReceiptResponse {\n    pub order_id: Uuid,\n    pub order_number: String,\n    pub material_document_number: String,\n    pub quantity: Decimal,\n    pub posted_at: DateTime<Utc>,\n}\n\n// GET /api/v1/production/orders/{order_id}\npub struct GetProductionOrderResponse {\n    pub order: ProductionOrderDto,\n    pub operations: Vec<ProductionOrderOperationDto>,\n    pub components: Vec<ProductionOrderComponentDto>,\n    pub confirmations: Vec<OperationConfirmationDto>,\n    pub costs: ProductionOrderCosts,\n    pub status_details: StatusDetails,\n}\n\npub struct ProductionOrderCosts {\n    pub planned_costs: Decimal,\n    pub actual_costs: Decimal,\n    pub variance: Decimal,\n    pub cost_breakdown: Vec<CostComponent>,\n}\n\npub struct StatusDetails {\n    pub overall_status: String,\n    pub operations_completed: u16,\n    pub operations_total: u16,\n    pub components_issued: u16,\n    pub components_total: u16,\n    pub quantity_confirmed: Decimal,\n    pub quantity_delivered: Decimal,\n}\n\n// GET /api/v1/production/orders\npub struct ListProductionOrdersQuery {\n    pub plant: Option<String>,\n    pub material_id: Option<Uuid>,\n    pub order_type: Option<String>,\n    pub start_date_from: Option<NaiveDate>,\n    pub start_date_to: Option<NaiveDate>,\n    pub status: Option<String>,\n    pub work_center: Option<String>,\n    pub sales_order: Option<String>,\n    pub page: Option<u32>,\n    pub page_size: Option<u32>,\n}\n```\n\n#### 5.2.2 能力需求计划 API\n\n```rust\n// GET /api/v1/production/capacity-requirements\npub struct GetCapacityRequirementsQuery {\n    pub plant: String,\n    pub work_centers: Option<Vec<String>>,\n    pub date_from: NaiveDate,\n    pub date_to: NaiveDate,\n    pub requirement_source: Option<String>, // PlannedOrder, ProductionOrder, Both\n}\n\npub struct GetCapacityRequirementsResponse {\n    pub work_centers: Vec<WorkCenterCapacity>,\n    pub total_requirements: Decimal,\n    pub total_available: Decimal,\n    pub utilization_percentage: Decimal,\n}\n\npub struct WorkCenterCapacity {\n    pub work_center_id: Uuid,\n    pub work_center_code: String,\n    pub work_center_description: String,\n    pub period_data: Vec<CapacityPeriod>,\n    pub overload_periods: Vec<OverloadPeriod>,\n}\n\npub struct CapacityPeriod {\n    pub date: NaiveDate,\n    pub available_capacity: Decimal,\n    pub required_capacity: Decimal,\n    pub remaining_capacity: Decimal,\n    pub utilization_percentage: Decimal,\n    pub requirements: Vec<CapacityRequirementDetail>,\n}\n\npub struct CapacityRequirementDetail {\n    pub requirement_id: Uuid,\n    pub order_number: String,\n    pub order_type: String,\n    pub operation_number: String,\n    pub material_number: String,\n    pub required_capacity: Decimal,\n    pub start_time: NaiveDateTime,\n    pub end_time: NaiveDateTime,\n}\n\npub struct OverloadPeriod {\n    pub date: NaiveDate,\n    pub overload_capacity: Decimal,\n    pub overload_percentage: Decimal,\n}\n\n// POST /api/v1/production/capacity-leveling\npub struct CapacityLevelingRequest {\n    pub plant: String,\n    pub work_centers: Vec<String>,\n    pub date_from: NaiveDate,\n    pub date_to: NaiveDate,\n    pub leveling_strategy: LevelingStrategy,\n    pub max_move_days: u16,\n    pub simulation_mode: bool,\n}\n\n#[derive(Debug, Deserialize)]\npub enum LevelingStrategy {\n    MoveForward,     // Move overloaded operations forward\n    MoveBackward,    // Move overloaded operations backward\n    Optimize,        // Optimize across all work centers\n}\n\npub struct CapacityLevelingResponse {\n    pub leveling_id: Uuid,\n    pub simulation_mode: bool,\n    pub moves: Vec<CapacityMove>,\n    pub before_utilization: Decimal,\n    pub after_utilization: Decimal,\n    pub applied_at: Option<DateTime<Utc>>,\n}\n\npub struct CapacityMove {\n    pub order_number: String,\n    pub operation_number: String,\n    pub work_center: String,\n    pub original_start_date: NaiveDateTime,\n    pub new_start_date: NaiveDateTime,\n    pub days_moved: i32,\n}\n```\n\n### 5.3 领域事件\n\n```rust\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum ProductionDomainEvent {\n    ProductionOrderCreated(ProductionOrderCreated),\n    ProductionOrderReleased(ProductionOrderReleased),\n    OperationConfirmed(OperationConfirmed),\n    ProductionGoodsReceiptPosted(ProductionGoodsReceiptPosted),\n    ProductionOrderCompleted(ProductionOrderCompleted),\n    ProductionOrderSettled(ProductionOrderSettled),\n    ComponentWithdrawn(ComponentWithdrawn),\n    ScrapPosted(ScrapPosted),\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ProductionOrderCreated {\n    pub event_id: Uuid,\n    pub occurred_at: DateTime<Utc>,\n    pub order_id: Uuid,\n    pub order_number: String,\n    pub order_type: String,\n    pub material_id: Uuid,\n    pub material_number: String,\n    pub plant: String,\n    pub target_quantity: Decimal,\n    pub unit: String,\n    pub order_start_date: NaiveDate,\n    pub order_finish_date: NaiveDate,\n    pub operations: Vec<OrderOperationCreated>,\n    pub components: Vec<OrderComponentCreated>,\n    pub created_by: String,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct OrderOperationCreated {\n    pub operation_number: String,\n    pub work_center: String,\n    pub planned_start_date: NaiveDateTime,\n    pub planned_finish_date: NaiveDateTime,\n    pub setup_time: String,\n    pub machine_time: String,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct OrderComponentCreated {\n    pub item_number: String,\n    pub material_id: Uuid,\n    pub material_number: String,\n    pub required_quantity: Decimal,\n    pub unit: String,\n    pub storage_location: String,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct OperationConfirmed {\n    pub event_id: Uuid,\n    pub occurred_at: DateTime<Utc>,\n    pub confirmation_id: Uuid,\n    pub confirmation_number: String,\n    pub order_id: Uuid,\n    pub order_number: String,\n    pub operation_number: String,\n    pub work_center: String,\n    pub yield_quantity: Decimal,\n    pub scrap_quantity: Decimal,\n    pub actual_setup_time: String,\n    pub actual_machine_time: String,\n    pub final_confirmation: bool,\n    pub backflushed_components: Vec<BackflushedComponent>,\n    pub confirmed_by: String,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct BackflushedComponent {\n    pub material_id: Uuid,\n    pub material_number: String,\n    pub quantity: Decimal,\n    pub unit: String,\n    pub storage_location: String,\n    pub batch: Option<String>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ProductionGoodsReceiptPosted {\n    pub event_id: Uuid,\n    pub occurred_at: DateTime<Utc>,\n    pub order_id: Uuid,\n    pub order_number: String,\n    pub material_id: Uuid,\n    pub material_number: String,\n    pub quantity: Decimal,\n    pub unit: String,\n    pub plant: String,\n    pub storage_location: String,\n    pub batch: Option<String>,\n    pub material_document_number: String,\n    pub posted_by: String,\n}\n```\n\n---\n\n本文档继续补充中... 下一步将添加:\n- WM/EWM (Warehouse Management) - 仓库管理\n- QM (Quality Management) - 质量管理\n- PM (Plant Maintenance) - 设备维护\n- PS (Project System) - 项目系统\n- HCM (Human Capital Management) - 人力资源\n\n## 第六部分：仓库管理模块 (WM/EWM - Warehouse Management)\n\n### 6.1 数据模型\n\n#### 6.1.1 仓库结构 (Warehouse Structure)\n\n```rust\npub struct Warehouse {\n    pub warehouse_id: Uuid,\n    pub warehouse_number: String,         // 001, 002, 003...\n    pub warehouse_type: WarehouseType,\n    pub plant: Plant,\n    pub company_code: CompanyCode,\n\n    // Description\n    pub description: String,\n    pub address: Address,\n\n    // Organizational Data\n    pub warehouse_manager: UserId,\n    pub storage_sections: Vec<StorageSection>,\n\n    // Control Parameters\n    pub lean_warehouse: bool,\n    pub warehouse_management_active: bool,\n    pub yard_management: bool,\n\n    // Physical Inventory\n    pub physical_inventory_method: PhysicalInventoryMethod,\n\n    // Audit\n    pub created_at: DateTime<Utc>,\n    pub created_by: UserId,\n}\n\npub struct StorageSection {\n    pub section_id: Uuid,\n    pub section_code: String,             // A01, B01, C01...\n    pub description: String,\n    pub storage_type: StorageType,\n    pub storage_bins: Vec<StorageBin>,\n    pub capacity: StorageCapacity,\n}\n\npub struct StorageBin {\n    pub bin_id: Uuid,\n    pub bin_location: String,             // A01-01-01 (Aisle-Row-Level)\n    pub storage_section_id: Uuid,\n    pub bin_type: BinType,\n\n    // Dimensions\n    pub length: Option<Decimal>,\n    pub width: Option<Decimal>,\n    pub height: Option<Decimal>,\n    pub dimension_unit: Option<Unit>,\n    pub volume: Option<Decimal>,\n    pub volume_unit: Option<Unit>,\n\n    // Capacity\n    pub maximum_weight: Option<Decimal>,\n    pub weight_unit: Option<Unit>,\n    pub maximum_quantity: Option<Decimal>,\n\n    // Control\n    pub mixed_storage: bool,              // Allow multiple materials\n    pub addition_to_stock_blocked: bool,\n    pub removal_from_stock_blocked: bool,\n\n    // Stock\n    pub current_stock: Vec<BinStock>,\n\n    // Status\n    pub bin_status: BinStatus,\n}\n\npub struct BinStock {\n    pub material_id: Uuid,\n    pub material_number: String,\n    pub batch: Option<String>,\n    pub quantity: Decimal,\n    pub unit: Unit,\n    pub stock_type: StockType,\n    pub special_stock_indicator: Option<SpecialStockIndicator>,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum WarehouseType {\n    StandardWarehouse,\n    DistributionCenter,\n    TransitWarehouse,\n    ProductionWarehouse,\n    ReturnWarehouse,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum StorageType {\n    HighRackStorage,\n    BlockStorage,\n    ShelfStorage,\n    OpenStorage,\n    BulkStorage,\n    HazardousGoodsStorage,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum BinType {\n    FixedBin,                             // Fixed location for material\n    RandomBin,                            // Random storage\n    ReceivingArea,\n    ShippingArea,\n    QualityInspectionArea,\n    BlockedArea,\n}\n```\n\n#### 6.1.2 仓库任务 (Warehouse Task)\n\n```rust\npub struct WarehouseTask {\n    pub task_id: Uuid,\n    pub task_number: String,\n    pub task_type: WarehouseTaskType,\n    pub warehouse_number: String,\n    pub priority: TaskPriority,\n\n    // Source\n    pub source_storage_type: Option<String>,\n    pub source_bin: Option<String>,\n    pub source_handling_unit: Option<String>,\n\n    // Destination\n    pub destination_storage_type: String,\n    pub destination_bin: Option<String>,\n    pub destination_handling_unit: Option<String>,\n\n    // Material\n    pub material_id: Uuid,\n    pub material_number: String,\n    pub material_description: String,\n    pub batch: Option<String>,\n    pub serial_numbers: Vec<String>,\n\n    // Quantity\n    pub source_quantity: Decimal,\n    pub destination_quantity: Decimal,\n    pub unit: Unit,\n\n    // Stock Type\n    pub stock_type: StockType,\n    pub special_stock_indicator: Option<SpecialStockIndicator>,\n\n    // Assignment\n    pub assigned_to: Option<UserId>,\n    pub resource: Option<Resource>,        // Forklift, person, etc.\n    pub assigned_at: Option<DateTime<Utc>>,\n\n    // Timing\n    pub earliest_start: Option<DateTime<Utc>>,\n    pub latest_finish: Option<DateTime<Utc>>,\n    pub actual_start: Option<DateTime<Utc>>,\n    pub actual_finish: Option<DateTime<Utc>>,\n\n    // Status\n    pub task_status: WarehouseTaskStatus,\n    pub confirmation: Option<TaskConfirmation>,\n\n    // Reference\n    pub reference_document_type: Option<String>,\n    pub reference_document_number: Option<String>,\n    pub reference_item: Option<String>,\n\n    // Created\n    pub created_at: DateTime<Utc>,\n    pub created_by: UserId,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum WarehouseTaskType {\n    PutAway,         // Goods receipt putaway\n    PickItem,        // Outbound delivery picking\n    Replenishment,   // Replenish picking bins\n    Relocation,      // Stock relocation\n    Counting,        // Physical inventory count\n    Scrapping,       // Scrap posting\n    Loading,         // Load onto vehicle\n    Unloading,       // Unload from vehicle\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum TaskPriority {\n    Low,\n    Normal,\n    High,\n    Urgent,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum WarehouseTaskStatus {\n    Created,\n    Released,\n    Assigned,\n    InProgress,\n    Confirmed,\n    Cancelled,\n}\n\npub struct TaskConfirmation {\n    pub confirmed_at: DateTime<Utc>,\n    pub confirmed_by: UserId,\n    pub confirmed_quantity: Decimal,\n    pub actual_source_bin: Option<String>,\n    pub actual_destination_bin: String,\n    pub deviation_reason: Option<String>,\n}\n```\n\n#### 6.1.3 搬运单元 (Handling Unit)\n\n```rust\npub struct HandlingUnit {\n    pub hu_id: Uuid,\n    pub hu_number: String,                // HU-2025-000001\n    pub hu_type: HandlingUnitType,\n    pub packaging_material_id: Uuid,\n    pub packaging_material_number: String,\n\n    // Location\n    pub warehouse_number: Option<String>,\n    pub storage_type: Option<String>,\n    pub storage_bin: Option<String>,\n    pub plant: Option<Plant>,\n    pub storage_location: Option<StorageLocation>,\n\n    // Identification\n    pub sscc: Option<String>,             // Serial Shipping Container Code\n    pub barcode: Option<String>,\n    pub rfid_tag: Option<String>,\n\n    // Physical Attributes\n    pub gross_weight: Decimal,\n    pub net_weight: Decimal,\n    pub tare_weight: Decimal,\n    pub weight_unit: Unit,\n    pub volume: Decimal,\n    pub volume_unit: Unit,\n\n    // Contents\n    pub contents: Vec<HandlingUnitContent>,\n    pub nested_handling_units: Vec<String>, // HU numbers of nested HUs\n\n    // Hierarchy\n    pub higher_level_hu: Option<String>,  // Parent HU\n    pub top_level_hu: String,             // Top of hierarchy\n\n    // Status\n    pub hu_status: HandlingUnitStatus,\n    pub restricted_use: bool,\n    pub quarantine: bool,\n\n    // Assignment\n    pub shipment_number: Option<String>,\n    pub delivery_number: Option<String>,\n    pub warehouse_order: Option<String>,\n\n    // Audit\n    pub created_at: DateTime<Utc>,\n    pub created_by: UserId,\n    pub last_changed_at: DateTime<Utc>,\n}\n\npub struct HandlingUnitContent {\n    pub material_id: Uuid,\n    pub material_number: String,\n    pub quantity: Decimal,\n    pub unit: Unit,\n    pub batch: Option<String>,\n    pub serial_numbers: Vec<String>,\n    pub stock_type: StockType,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum HandlingUnitType {\n    Pallet,\n    Carton,\n    Container,\n    Cage,\n    Drum,\n    Bag,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum HandlingUnitStatus {\n    Empty,\n    Loaded,\n    InTransit,\n    AtDestination,\n    Unpacked,\n}\n```\n\n#### 6.1.4 库存盘点 (Physical Inventory)\n\n```rust\npub struct PhysicalInventory {\n    pub inventory_id: Uuid,\n    pub inventory_number: String,\n    pub inventory_type: PhysicalInventoryType,\n    pub warehouse_number: Option<String>,\n    pub plant: Plant,\n    pub storage_location: Option<StorageLocation>,\n\n    // Planning\n    pub planned_date: NaiveDate,\n    pub freeze_book_inventory: bool,\n    pub block_goods_movements: bool,\n\n    // Scope\n    pub inventory_scope: InventoryScope,\n    pub materials: Vec<Uuid>,\n    pub storage_bins: Vec<String>,\n\n    // Count Documents\n    pub count_documents: Vec<CountDocument>,\n\n    // Status\n    pub status: PhysicalInventoryStatus,\n    pub posted: bool,\n\n    // Results\n    pub differences: Vec<InventoryDifference>,\n\n    // Audit\n    pub created_at: DateTime<Utc>,\n    pub created_by: UserId,\n    pub counted_at: Option<DateTime<Utc>>,\n    pub posted_at: Option<DateTime<Utc>>,\n}\n\npub struct CountDocument {\n    pub document_id: Uuid,\n    pub document_number: String,\n    pub counter: UserId,\n    pub count_date: NaiveDate,\n    pub items: Vec<CountItem>,\n    pub status: CountDocumentStatus,\n}\n\npub struct CountItem {\n    pub item_number: u16,\n    pub material_id: Uuid,\n    pub material_number: String,\n    pub batch: Option<String>,\n    pub storage_bin: Option<String>,\n    pub book_inventory_quantity: Decimal,\n    pub counted_quantity: Decimal,\n    pub unit: Unit,\n    pub count_status: CountStatus,\n    pub recount_required: bool,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum PhysicalInventoryType {\n    CycleCount,      // Regular cycle counting\n    AnnualInventory, // Year-end full inventory\n    SpotCheck,       // Random spot checks\n    EventDriven,     // Triggered by specific events\n}\n\npub struct InventoryScope {\n    pub scope_type: ScopeType,\n    pub include_zero_stock: bool,\n    pub include_negative_stock: bool,\n    pub stock_types: Vec<StockType>,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum ScopeType {\n    FullInventory,\n    MaterialSelection,\n    StorageBinSelection,\n    ABCClassification,\n}\n\npub struct InventoryDifference {\n    pub material_id: Uuid,\n    pub material_number: String,\n    pub batch: Option<String>,\n    pub storage_bin: Option<String>,\n    pub book_quantity: Decimal,\n    pub counted_quantity: Decimal,\n    pub difference_quantity: Decimal,\n    pub difference_value: Money,\n    pub reason_code: Option<ReasonCode>,\n    pub approved_for_posting: bool,\n}\n```\n\n### 6.2 API 规格\n\n#### 6.2.1 仓库任务 API\n\n```rust\n// POST /api/v1/warehouse/tasks\npub struct CreateWarehouseTaskRequest {\n    pub task_type: String,\n    pub warehouse_number: String,\n    pub material_id: Uuid,\n    pub quantity: Decimal,\n    pub unit: String,\n    pub source_bin: Option<String>,\n    pub destination_bin: Option<String>,\n    pub batch: Option<String>,\n    pub priority: Option<String>,\n    pub reference_document_type: Option<String>,\n    pub reference_document_number: Option<String>,\n}\n\npub struct CreateWarehouseTaskResponse {\n    pub task_id: Uuid,\n    pub task_number: String,\n    pub task_type: String,\n    pub material_number: String,\n    pub quantity: Decimal,\n    pub source_bin: Option<String>,\n    pub destination_bin: Option<String>,\n    pub status: String,\n    pub created_at: DateTime<Utc>,\n}\n\n// POST /api/v1/warehouse/tasks/{task_id}/assign\npub struct AssignWarehouseTaskRequest {\n    pub assignee: Uuid,\n    pub resource: Option<String>,         // Resource ID (forklift, etc.)\n}\n\n// POST /api/v1/warehouse/tasks/{task_id}/confirm\npub struct ConfirmWarehouseTaskRequest {\n    pub confirmed_quantity: Decimal,\n    pub actual_source_bin: Option<String>,\n    pub actual_destination_bin: String,\n    pub deviation_reason: Option<String>,\n}\n\npub struct ConfirmWarehouseTaskResponse {\n    pub task_id: Uuid,\n    pub task_number: String,\n    pub status: String,\n    pub confirmed_at: DateTime<Utc>,\n    pub confirmed_by: String,\n}\n\n// GET /api/v1/warehouse/tasks\npub struct ListWarehouseTasksQuery {\n    pub warehouse_number: Option<String>,\n    pub task_type: Option<String>,\n    pub status: Option<String>,\n    pub assigned_to: Option<Uuid>,\n    pub material_id: Option<Uuid>,\n    pub priority: Option<String>,\n    pub created_date_from: Option<NaiveDate>,\n    pub created_date_to: Option<NaiveDate>,\n    pub page: Option<u32>,\n    pub page_size: Option<u32>,\n}\n\n// POST /api/v1/warehouse/wave-picking\npub struct CreateWavePickingRequest {\n    pub warehouse_number: String,\n    pub wave_name: String,\n    pub deliveries: Vec<String>,          // Delivery numbers to include\n    pub picking_strategy: PickingStrategy,\n    pub grouping_criteria: Vec<GroupingCriterion>,\n}\n\n#[derive(Debug, Deserialize)]\npub enum PickingStrategy {\n    SingleOrder,     // Pick one order at a time\n    BatchPicking,    // Pick multiple orders together\n    ZonePicking,     // Pick by warehouse zone\n    ClusterPicking,  // Pick to multiple orders simultaneously\n}\n\n#[derive(Debug, Deserialize)]\npub enum GroupingCriterion {\n    ShipToParty,\n    Route,\n    ShippingPoint,\n    Priority,\n}\n\npub struct CreateWavePickingResponse {\n    pub wave_id: Uuid,\n    pub wave_number: String,\n    pub tasks_created: u32,\n    pub deliveries_included: Vec<String>,\n    pub created_at: DateTime<Utc>,\n}\n```\n\n#### 6.2.2 搬运单元 API\n\n```rust\n// POST /api/v1/warehouse/handling-units\npub struct CreateHandlingUnitRequest {\n    pub hu_type: String,\n    pub packaging_material_id: Uuid,\n    pub contents: Vec<HUContentRequest>,\n    pub warehouse_number: Option<String>,\n    pub storage_bin: Option<String>,\n    pub generate_sscc: bool,\n}\n\npub struct HUContentRequest {\n    pub material_id: Uuid,\n    pub quantity: Decimal,\n    pub unit: String,\n    pub batch: Option<String>,\n}\n\npub struct CreateHandlingUnitResponse {\n    pub hu_id: Uuid,\n    pub hu_number: String,\n    pub sscc: Option<String>,\n    pub barcode: String,\n    pub gross_weight: Decimal,\n    pub volume: Decimal,\n    pub created_at: DateTime<Utc>,\n}\n\n// POST /api/v1/warehouse/handling-units/{hu_id}/pack\npub struct PackHandlingUnitRequest {\n    pub items: Vec<PackItemRequest>,\n}\n\npub struct PackItemRequest {\n    pub material_id: Uuid,\n    pub quantity: Decimal,\n    pub unit: String,\n    pub batch: Option<String>,\n    pub serial_numbers: Option<Vec<String>>,\n}\n\n// POST /api/v1/warehouse/handling-units/{hu_id}/unpack\npub struct UnpackHandlingUnitRequest {\n    pub reason: String,\n}\n\npub struct UnpackHandlingUnitResponse {\n    pub hu_id: Uuid,\n    pub hu_number: String,\n    pub unpacked_contents: Vec<UnpackedContent>,\n    pub unpacked_at: DateTime<Utc>,\n}\n\npub struct UnpackedContent {\n    pub material_id: Uuid,\n    pub material_number: String,\n    pub quantity: Decimal,\n    pub unit: String,\n    pub destination_bin: Option<String>,\n}\n\n// PUT /api/v1/warehouse/handling-units/{hu_id}/location\npub struct UpdateHULocationRequest {\n    pub warehouse_number: Option<String>,\n    pub storage_bin: Option<String>,\n    pub movement_type: String,\n}\n\n// GET /api/v1/warehouse/handling-units/{hu_id}\npub struct GetHandlingUnitResponse {\n    pub handling_unit: HandlingUnitDto,\n    pub contents: Vec<HUContentDto>,\n    pub nested_hus: Vec<NestedHUDto>,\n    pub location_history: Vec<LocationHistoryEntry>,\n}\n```\n\n#### 6.2.3 库存盘点 API\n\n```rust\n// POST /api/v1/warehouse/physical-inventories\npub struct CreatePhysicalInventoryRequest {\n    pub inventory_type: String,\n    pub warehouse_number: Option<String>,\n    pub plant: String,\n    pub storage_location: Option<String>,\n    pub planned_date: NaiveDate,\n    pub inventory_scope: InventoryScopeRequest,\n    pub freeze_book_inventory: bool,\n    pub block_goods_movements: bool,\n}\n\npub struct InventoryScopeRequest {\n    pub scope_type: String,\n    pub materials: Option<Vec<Uuid>>,\n    pub storage_bins: Option<Vec<String>>,\n    pub include_zero_stock: bool,\n}\n\npub struct CreatePhysicalInventoryResponse {\n    pub inventory_id: Uuid,\n    pub inventory_number: String,\n    pub planned_date: NaiveDate,\n    pub count_documents: Vec<CountDocumentSummary>,\n    pub total_items: u32,\n    pub created_at: DateTime<Utc>,\n}\n\n// POST /api/v1/warehouse/physical-inventories/{inventory_id}/count\npub struct RecordCountRequest {\n    pub counter: Uuid,\n    pub count_date: NaiveDate,\n    pub counts: Vec<CountEntryRequest>,\n}\n\npub struct CountEntryRequest {\n    pub material_id: Uuid,\n    pub batch: Option<String>,\n    pub storage_bin: Option<String>,\n    pub counted_quantity: Decimal,\n    pub unit: String,\n}\n\npub struct RecordCountResponse {\n    pub count_document_id: Uuid,\n    pub count_document_number: String,\n    pub items_counted: u32,\n    pub differences_found: u32,\n    pub recounts_required: Vec<RecountItem>,\n}\n\npub struct RecountItem {\n    pub material_number: String,\n    pub storage_bin: Option<String>,\n    pub book_quantity: Decimal,\n    pub counted_quantity: Decimal,\n    pub difference: Decimal,\n    pub reason: String,\n}\n\n// POST /api/v1/warehouse/physical-inventories/{inventory_id}/post\npub struct PostPhysicalInventoryRequest {\n    pub posting_date: NaiveDate,\n    pub approval_required: bool,\n}\n\npub struct PostPhysicalInventoryResponse {\n    pub inventory_id: Uuid,\n    pub inventory_number: String,\n    pub material_documents: Vec<String>,\n    pub total_differences: u32,\n    pub total_difference_value: Decimal,\n    pub posted_at: DateTime<Utc>,\n}\n\n// GET /api/v1/warehouse/physical-inventories/{inventory_id}/differences\npub struct GetInventoryDifferencesResponse {\n    pub inventory_number: String,\n    pub differences: Vec<InventoryDifferenceDto>,\n    pub summary: DifferenceSummary,\n}\n\npub struct DifferenceSummary {\n    pub total_items_with_differences: u32,\n    pub total_positive_differences_value: Decimal,\n    pub total_negative_differences_value: Decimal,\n    pub net_difference_value: Decimal,\n    pub currency: String,\n}\n```\n\n### 6.3 领域事件\n\n```rust\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum WarehouseDomainEvent {\n    WarehouseTaskCreated(WarehouseTaskCreated),\n    WarehouseTaskAssigned(WarehouseTaskAssigned),\n    WarehouseTaskConfirmed(WarehouseTaskConfirmed),\n    HandlingUnitCreated(HandlingUnitCreated),\n    HandlingUnitPacked(HandlingUnitPacked),\n    HandlingUnitUnpacked(HandlingUnitUnpacked),\n    HandlingUnitMoved(HandlingUnitMoved),\n    PhysicalInventoryCreated(PhysicalInventoryCreated),\n    PhysicalInventoryCountRecorded(PhysicalInventoryCountRecorded),\n    PhysicalInventoryPosted(PhysicalInventoryPosted),\n    StockRelocated(StockRelocated),\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct WarehouseTaskConfirmed {\n    pub event_id: Uuid,\n    pub occurred_at: DateTime<Utc>,\n    pub task_id: Uuid,\n    pub task_number: String,\n    pub task_type: String,\n    pub warehouse_number: String,\n    pub material_id: Uuid,\n    pub material_number: String,\n    pub confirmed_quantity: Decimal,\n    pub unit: String,\n    pub source_bin: Option<String>,\n    pub destination_bin: String,\n    pub batch: Option<String>,\n    pub confirmed_by: String,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct HandlingUnitCreated {\n    pub event_id: Uuid,\n    pub occurred_at: DateTime<Utc>,\n    pub hu_id: Uuid,\n    pub hu_number: String,\n    pub hu_type: String,\n    pub sscc: Option<String>,\n    pub packaging_material: String,\n    pub contents: Vec<HUContentData>,\n    pub gross_weight: Decimal,\n    pub volume: Decimal,\n    pub created_by: String,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct HUContentData {\n    pub material_id: Uuid,\n    pub material_number: String,\n    pub quantity: Decimal,\n    pub unit: String,\n    pub batch: Option<String>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct PhysicalInventoryPosted {\n    pub event_id: Uuid,\n    pub occurred_at: DateTime<Utc>,\n    pub inventory_id: Uuid,\n    pub inventory_number: String,\n    pub plant: String,\n    pub posting_date: NaiveDate,\n    pub differences: Vec<PostedDifference>,\n    pub total_difference_value: Decimal,\n    pub currency: String,\n    pub material_documents: Vec<String>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct PostedDifference {\n    pub material_id: Uuid,\n    pub material_number: String,\n    pub storage_bin: Option<String>,\n    pub batch: Option<String>,\n    pub difference_quantity: Decimal,\n    pub difference_value: Decimal,\n}\n```\n\n---\n\n## 第七部分：质量管理模块 (QM - Quality Management)\n\n### 7.1 数据模型\n\n#### 7.1.1 质量检验批次 (Inspection Lot)\n\n```rust\npub struct InspectionLot {\n    pub lot_id: Uuid,\n    pub lot_number: String,               // Format: QL-2025-000001\n    pub inspection_lot_origin: InspectionLotOrigin,\n    pub material_id: Uuid,\n    pub material_number: String,\n    pub batch: Option<String>,\n\n    // Organizational Data\n    pub plant: Plant,\n    pub vendor: Option<Uuid>,\n    pub customer: Option<Uuid>,\n\n    // Inspection Scope\n    pub inspection_lot_quantity: Decimal,\n    pub unit_of_measure: Unit,\n    pub sample_quantity: Decimal,\n\n    // Dates\n    pub inspection_start_date: NaiveDate,\n    pub inspection_end_date: Option<NaiveDate>,\n    pub actual_start_date: Option<NaiveDate>,\n    pub actual_end_date: Option<NaiveDate>,\n\n    // Inspection Plan\n    pub inspection_plan_id: Option<Uuid>,\n    pub inspection_operations: Vec<InspectionOperation>,\n\n    // Results\n    pub usage_decision: Option<UsageDecision>,\n    pub quality_score: Option<Decimal>,\n    pub defect_quantity: Decimal,\n    pub scrap_quantity: Decimal,\n\n    // Status\n    pub inspection_lot_status: InspectionLotStatus,\n    pub quality_level: Option<QualityLevel>,\n\n    // Reference Documents\n    pub purchase_order: Option<String>,\n    pub production_order: Option<String>,\n    pub delivery_note: Option<String>,\n    pub goods_receipt_document: Option<String>,\n\n    // Assignment\n    pub inspector: Option<UserId>,\n    pub quality_engineer: Option<UserId>,\n\n    // Audit\n    pub created_at: DateTime<Utc>,\n    pub created_by: UserId,\n    pub completed_at: Option<DateTime<Utc>>,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum InspectionLotOrigin {\n    GoodsReceipt,         // 01 - Inspection during goods receipt\n    GoodsIssue,          // 02 - Inspection during goods issue\n    ProductionOrder,     // 03 - In-process inspection\n    DeliveryToCustomer,  // 04 - Final inspection before delivery\n    StockTransfer,       // 05 - Inspection during stock transfer\n    Recurring,           // 06 - Recurring inspection (stability testing)\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum UsageDecision {\n    Accepted,            // A - Unrestricted use\n    Rejected,            // R - Rejected\n    AcceptedWithConcession, // C - Accepted with concession\n    ReturnToVendor,      // V - Return to vendor\n    Rework,             // W - Rework required\n    Sample,             // S - Sample only\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum InspectionLotStatus {\n    Created,\n    Released,\n    ResultsRecorded,\n    UsageDecisionMade,\n    Completed,\n    Cancelled,\n}\n\npub struct InspectionOperation {\n    pub operation_id: Uuid,\n    pub operation_number: String,\n    pub operation_description: String,\n    pub work_center: Option<String>,\n    pub inspector: Option<UserId>,\n\n    // Characteristics to Inspect\n    pub characteristics: Vec<InspectionCharacteristic>,\n\n    // Timing\n    pub planned_start: Option<NaiveDateTime>,\n    pub planned_end: Option<NaiveDateTime>,\n    pub actual_start: Option<NaiveDateTime>,\n    pub actual_end: Option<NaiveDateTime>,\n\n    // Status\n    pub operation_status: InspectionOperationStatus,\n    pub inspection_completed: bool,\n}\n\npub struct InspectionCharacteristic {\n    pub characteristic_id: Uuid,\n    pub characteristic_code: String,\n    pub characteristic_description: String,\n    pub characteristic_type: CharacteristicType,\n\n    // Specification\n    pub target_value: Option<Decimal>,\n    pub lower_specification_limit: Option<Decimal>,\n    pub upper_specification_limit: Option<Decimal>,\n    pub lower_tolerance: Option<Decimal>,\n    pub upper_tolerance: Option<Decimal>,\n\n    // Sampling\n    pub sample_size: u32,\n    pub sampling_procedure: Option<SamplingProcedure>,\n\n    // Results\n    pub results: Vec<InspectionResult>,\n    pub mean_value: Option<Decimal>,\n    pub standard_deviation: Option<Decimal>,\n\n    // Decision\n    pub characteristic_decision: Option<CharacteristicDecision>,\n    pub defect_class: Option<DefectClass>,\n\n    // Measurement\n    pub unit_of_measure: Option<Unit>,\n    pub measurement_method: Option<String>,\n    pub inspection_equipment: Option<String>,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum CharacteristicType {\n    Quantitative,        // Measured value (length, weight, etc.)\n    Qualitative,         // Attribute (pass/fail, color, etc.)\n    Text,               // Text description\n}\n\npub struct InspectionResult {\n    pub result_id: Uuid,\n    pub sample_number: u32,\n    pub measured_value: Option<Decimal>,\n    pub attribute_value: Option<String>,\n    pub text_value: Option<String>,\n    pub recorded_at: DateTime<Utc>,\n    pub recorded_by: UserId,\n    pub measurement_equipment_id: Option<String>,\n    pub within_specification: bool,\n    pub defect_code: Option<DefectCode>,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum CharacteristicDecision {\n    Accepted,\n    Rejected,\n    AcceptedWithDeviation,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum DefectClass {\n    Critical,\n    Major,\n    Minor,\n}\n```\n\n#### 7.1.2 质量证书 (Quality Certificate)\n\n```rust\npub struct QualityCertificate {\n    pub certificate_id: Uuid,\n    pub certificate_number: String,\n    pub certificate_type: QualityCertificateType,\n    pub material_id: Uuid,\n    pub material_number: String,\n    pub batch: Option<String>,\n\n    // Origin\n    pub manufacturer: Option<String>,\n    pub production_date: Option<NaiveDate>,\n    pub production_location: Option<String>,\n\n    // Related Documents\n    pub inspection_lot_number: Option<String>,\n    pub purchase_order: Option<String>,\n    pub delivery_note: Option<String>,\n\n    // Certificate Data\n    pub certificate_characteristics: Vec<CertificateCharacteristic>,\n    pub certificate_text: Option<String>,\n    pub certificate_pdf: Option<String>,  // File path or URL\n\n    // Validity\n    pub issue_date: NaiveDate,\n    pub valid_until: Option<NaiveDate>,\n    pub issuer: String,\n    pub authorized_signatory: String,\n    pub digital_signature: Option<String>,\n\n    // Status\n    pub certificate_status: CertificateStatus,\n    pub verified: bool,\n    pub verified_by: Option<UserId>,\n    pub verified_at: Option<DateTime<Utc>>,\n\n    // Audit\n    pub created_at: DateTime<Utc>,\n    pub created_by: UserId,\n}\n\npub struct CertificateCharacteristic {\n    pub characteristic_code: String,\n    pub characteristic_description: String,\n    pub certified_value: String,\n    pub specification_limit: Option<String>,\n    pub test_method: Option<String>,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum QualityCertificateType {\n    MaterialCertificate,     // 3.1 - Material test certificate\n    InspectionCertificate,   // 3.2 - Inspection certificate\n    ComplianceCertificate,   // Regulatory compliance\n    AnalysisCertificate,     // Certificate of analysis\n    ConformityCertificate,   // Declaration of conformity\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum CertificateStatus {\n    Draft,\n    Issued,\n    Verified,\n    Expired,\n    Revoked,\n}\n```\n\n#### 7.1.3 质量通知 (Quality Notification)\n\n```rust\npub struct QualityNotification {\n    pub notification_id: Uuid,\n    pub notification_number: String,      // Format: QN-2025-000001\n    pub notification_type: QualityNotificationType,\n    pub priority: NotificationPriority,\n\n    // Description\n    pub short_text: String,\n    pub long_text: Option<String>,\n    pub defect_description: String,\n\n    // Material\n    pub material_id: Option<Uuid>,\n    pub material_number: Option<String>,\n    pub batch: Option<String>,\n    pub serial_number: Option<String>,\n\n    // Location\n    pub plant: Option<Plant>,\n    pub storage_location: Option<StorageLocation>,\n\n    // Business Partners\n    pub vendor: Option<Uuid>,\n    pub customer: Option<Uuid>,\n    pub manufacturer: Option<String>,\n\n    // Reference Documents\n    pub purchase_order: Option<String>,\n    pub sales_order: Option<String>,\n    pub delivery_note: Option<String>,\n    pub inspection_lot: Option<String>,\n\n    // Defect Data\n    pub defect_code: Option<DefectCode>,\n    pub defect_location: Option<DefectLocation>,\n    pub defect_quantity: Option<Decimal>,\n    pub defect_percentage: Option<Decimal>,\n\n    // Root Cause Analysis\n    pub root_cause_code: Option<String>,\n    pub root_cause_description: Option<String>,\n\n    // Tasks\n    pub tasks: Vec<QualityTask>,\n\n    // Status\n    pub notification_status: NotificationStatus,\n    pub responsible_person: Option<UserId>,\n    pub assigned_to: Option<UserId>,\n\n    // Dates\n    pub required_end_date: Option<NaiveDate>,\n    pub actual_end_date: Option<NaiveDate>,\n\n    // Costs\n    pub estimated_cost: Option<Money>,\n    pub actual_cost: Option<Money>,\n\n    // Audit\n    pub created_at: DateTime<Utc>,\n    pub created_by: UserId,\n    pub completed_at: Option<DateTime<Utc>>,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum QualityNotificationType {\n    CustomerComplaint,       // Q1 - Customer complaint\n    VendorComplaint,        // Q2 - Complaint to vendor\n    InternalProblem,        // Q3 - Internal quality problem\n    AuditFinding,          // Q4 - Quality audit finding\n    ProcessDeviation,      // Q5 - Process deviation\n}\n\npub struct QualityTask {\n    pub task_id: Uuid,\n    pub task_code: String,\n    pub task_description: String,\n    pub task_type: TaskType,\n    pub responsible_person: Option<UserId>,\n    pub planned_start: Option<NaiveDate>,\n    pub planned_end: Option<NaiveDate>,\n    pub actual_start: Option<NaiveDate>,\n    pub actual_end: Option<NaiveDate>,\n    pub task_status: TaskStatus,\n    pub completion_note: Option<String>,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum TaskType {\n    Containment,         // Immediate containment action\n    RootCauseAnalysis,   // Investigate root cause\n    CorrectiveAction,    // Implement corrective action\n    PreventiveAction,    // Implement preventive action\n    Verification,        // Verify effectiveness\n}\n```\n\n### 7.2 API 规格\n\n```rust\n// POST /api/v1/quality/inspection-lots\npub struct CreateInspectionLotRequest {\n    pub inspection_lot_origin: String,\n    pub material_id: Uuid,\n    pub batch: Option<String>,\n    pub plant: String,\n    pub inspection_lot_quantity: Decimal,\n    pub unit_of_measure: String,\n    pub vendor: Option<Uuid>,\n    pub purchase_order: Option<String>,\n    pub production_order: Option<String>,\n    pub goods_receipt_document: Option<String>,\n    pub inspection_plan_id: Option<Uuid>,\n}\n\npub struct CreateInspectionLotResponse {\n    pub lot_id: Uuid,\n    pub lot_number: String,\n    pub material_number: String,\n    pub inspection_operations: Vec<InspectionOperationSummary>,\n    pub inspector_assigned: Option<String>,\n    pub status: String,\n    pub created_at: DateTime<Utc>,\n}\n\n// POST /api/v1/quality/inspection-lots/{lot_id}/record-results\npub struct RecordInspectionResultsRequest {\n    pub operation_number: String,\n    pub results: Vec<CharacteristicResultRequest>,\n    pub inspector: Uuid,\n}\n\npub struct CharacteristicResultRequest {\n    pub characteristic_code: String,\n    pub sample_results: Vec<SampleResultRequest>,\n}\n\npub struct SampleResultRequest {\n    pub sample_number: u32,\n    pub measured_value: Option<Decimal>,\n    pub attribute_value: Option<String>,\n    pub defect_code: Option<String>,\n}\n\n// POST /api/v1/quality/inspection-lots/{lot_id}/usage-decision\npub struct MakeUsageDecisionRequest {\n    pub usage_decision: String,           // Accepted, Rejected, etc.\n    pub quality_score: Option<Decimal>,\n    pub defect_quantity: Option<Decimal>,\n    pub scrap_quantity: Option<Decimal>,\n    pub decision_note: Option<String>,\n}\n\npub struct MakeUsageDecisionResponse {\n    pub lot_id: Uuid,\n    pub lot_number: String,\n    pub usage_decision: String,\n    pub quality_score: Option<Decimal>,\n    pub stock_posting_action: Option<String>,\n    pub decided_at: DateTime<Utc>,\n    pub decided_by: String,\n}\n\n// POST /api/v1/quality/notifications\npub struct CreateQualityNotificationRequest {\n    pub notification_type: String,\n    pub priority: String,\n    pub short_text: String,\n    pub long_text: Option<String>,\n    pub material_id: Option<Uuid>,\n    pub batch: Option<String>,\n    pub plant: Option<String>,\n    pub defect_code: Option<String>,\n    pub defect_quantity: Option<Decimal>,\n    pub vendor: Option<Uuid>,\n    pub customer: Option<Uuid>,\n    pub reference_documents: Option<ReferenceDocumentsRequest>,\n}\n\npub struct CreateQualityNotificationResponse {\n    pub notification_id: Uuid,\n    pub notification_number: String,\n    pub notification_type: String,\n    pub priority: String,\n    pub assigned_to: Option<String>,\n    pub status: String,\n    pub created_at: DateTime<Utc>,\n}\n\n// POST /api/v1/quality/certificates\npub struct CreateQualityCertificateRequest {\n    pub certificate_type: String,\n    pub material_id: Uuid,\n    pub batch: Option<String>,\n    pub inspection_lot_number: Option<String>,\n    pub manufacturer: Option<String>,\n    pub production_date: Option<NaiveDate>,\n    pub characteristics: Vec<CertificateCharacteristicRequest>,\n    pub certificate_pdf: Option<String>,\n    pub issuer: String,\n    pub authorized_signatory: String,\n}\n\npub struct CertificateCharacteristicRequest {\n    pub characteristic_code: String,\n    pub characteristic_description: String,\n    pub certified_value: String,\n    pub specification_limit: Option<String>,\n}\n\npub struct CreateQualityCertificateResponse {\n    pub certificate_id: Uuid,\n    pub certificate_number: String,\n    pub material_number: String,\n    pub issue_date: NaiveDate,\n    pub status: String,\n    pub created_at: DateTime<Utc>,\n}\n```\n\n### 7.3 领域事件\n\n```rust\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum QualityDomainEvent {\n    InspectionLotCreated(InspectionLotCreated),\n    InspectionResultsRecorded(InspectionResultsRecorded),\n    UsageDecisionMade(UsageDecisionMade),\n    QualityNotificationCreated(QualityNotificationCreated),\n    QualityNotificationCompleted(QualityNotificationCompleted),\n    QualityCertificateIssued(QualityCertificateIssued),\n    DefectDetected(DefectDetected),\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct InspectionLotCreated {\n    pub event_id: Uuid,\n    pub occurred_at: DateTime<Utc>,\n    pub lot_id: Uuid,\n    pub lot_number: String,\n    pub inspection_lot_origin: String,\n    pub material_id: Uuid,\n    pub material_number: String,\n    pub batch: Option<String>,\n    pub plant: String,\n    pub inspection_lot_quantity: Decimal,\n    pub unit: String,\n    pub inspector_assigned: Option<String>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct UsageDecisionMade {\n    pub event_id: Uuid,\n    pub occurred_at: DateTime<Utc>,\n    pub lot_id: Uuid,\n    pub lot_number: String,\n    pub material_id: Uuid,\n    pub material_number: String,\n    pub batch: Option<String>,\n    pub usage_decision: String,\n    pub quality_score: Option<Decimal>,\n    pub defect_quantity: Decimal,\n    pub stock_posting_required: bool,\n    pub target_stock_type: Option<String>,\n    pub decided_by: String,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct DefectDetected {\n    pub event_id: Uuid,\n    pub occurred_at: DateTime<Utc>,\n    pub material_id: Uuid,\n    pub material_number: String,\n    pub batch: Option<String>,\n    pub defect_code: String,\n    pub defect_quantity: Decimal,\n    pub defect_location: Option<String>,\n    pub inspection_lot: Option<String>,\n    pub notification_created: Option<String>,\n}\n```\n\n---\n\n本文档将继续补充以下模块：\n- PM (Plant Maintenance) - 设备维护\n- PS (Project System) - 项目系统\n- HCM (Human Capital Management) - 人力资源\n- TR (Treasury) - 资金管理\n- 更多...\n\n---\n\n## 第八部分：跨模块集成架构\n\n### 8.1 核心业务流程事件链\n\n#### 8.1.1 采购到付款流程 (P2P - Procure to Pay)\n\n```rust\n// Event Chain: PR → PO → GR → IV → Payment\npub struct P2PEventChain {\n    pub chain_id: Uuid,\n    pub process_started_at: DateTime<Utc>,\n    pub current_stage: P2PStage,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum P2PStage {\n    // Stage 1: Procurement Request\n    PurchaseRequisitionCreated {\n        requisition_id: Uuid,\n        requisition_number: String,\n        requester: UserId,\n        total_value: Decimal,\n    },\n    PurchaseRequisitionApproved {\n        approved_at: DateTime<Utc>,\n        approved_by: UserId,\n    },\n    \n    // Stage 2: Purchase Order\n    PurchaseOrderCreated {\n        po_id: Uuid,\n        po_number: String,\n        vendor_id: Uuid,\n        po_value: Decimal,\n    },\n    PurchaseOrderReleased {\n        released_at: DateTime<Utc>,\n    },\n    \n    // Stage 3: Goods Receipt\n    GoodsReceiptPosted {\n        gr_id: Uuid,\n        material_document_number: String,\n        received_quantity: Decimal,\n        gr_value: Decimal,\n    },\n    \n    // Stage 4: Invoice Verification\n    InvoiceReceived {\n        invoice_id: Uuid,\n        invoice_number: String,\n        invoice_amount: Decimal,\n        invoice_date: NaiveDate,\n    },\n    ThreeWayMatchCompleted {\n        po_quantity: Decimal,\n        gr_quantity: Decimal,\n        invoice_quantity: Decimal,\n        price_variance: Decimal,\n        quantity_variance: Decimal,\n        match_result: MatchResult,\n    },\n    InvoicePosted {\n        accounting_document_id: Uuid,\n        accounting_document_number: String,\n        posted_at: DateTime<Utc>,\n    },\n    \n    // Stage 5: Payment\n    PaymentProposed {\n        payment_run_id: Uuid,\n        payment_method: String,\n        payment_amount: Decimal,\n        payment_date: NaiveDate,\n    },\n    PaymentExecuted {\n        payment_document_id: Uuid,\n        paid_amount: Decimal,\n        paid_at: DateTime<Utc>,\n    },\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum MatchResult {\n    ExactMatch,\n    WithinTolerance,\n    RequireKILLERproval,\n    Blocked,\n}\n```\n\n#### 8.1.2 订单到收款流程 (O2C - Order to Cash)\n\n```rust\n// Event Chain: SO → Delivery → PGI → Billing → Payment\npub struct O2CEventChain {\n    pub chain_id: Uuid,\n    pub process_started_at: DateTime<Utc>,\n    pub current_stage: O2CStage,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum O2CStage {\n    // Stage 1: Sales Order\n    SalesOrderCreated {\n        order_id: Uuid,\n        order_number: String,\n        customer_id: Uuid,\n        order_value: Decimal,\n    },\n    CreditCheckPassed {\n        credit_limit: Decimal,\n        credit_exposure: Decimal,\n        available_credit: Decimal,\n    },\n    AvailabilityConfirmed {\n        confirmed_quantity: Decimal,\n        confirmed_date: NaiveDate,\n    },\n    \n    // Stage 2: Delivery\n    DeliveryCreated {\n        delivery_id: Uuid,\n        delivery_number: String,\n        ship_to_party: Uuid,\n    },\n    DeliveryPicked {\n        picked_at: DateTime<Utc>,\n        picked_by: UserId,\n    },\n    \n    // Stage 3: Goods Issue\n    GoodsIssuePosted {\n        material_document_number: String,\n        goods_issue_date: NaiveDate,\n        cogs_amount: Decimal,\n    },\n    \n    // Stage 4: Billing\n    BillingDocumentCreated {\n        billing_id: Uuid,\n        billing_number: String,\n        invoice_amount: Decimal,\n        due_date: NaiveDate,\n    },\n    RevenueRecognized {\n        revenue_amount: Decimal,\n        revenue_account: String,\n        accounting_document_id: Uuid,\n    },\n    \n    // Stage 5: Payment\n    PaymentReceived {\n        payment_id: Uuid,\n        payment_amount: Decimal,\n        payment_date: NaiveDate,\n        payment_method: String,\n    },\n    InvoiceCleared {\n        cleared_amount: Decimal,\n        remaining_open_amount: Decimal,\n    },\n}\n```\n\n#### 8.1.3 生产订单流程 (Make to Stock/Order)\n\n```rust\n// Event Chain: SO/Forecast → Production Order → Manufacturing → GR → Delivery\npub struct ProductionEventChain {\n    pub chain_id: Uuid,\n    pub production_strategy: ProductionStrategy,\n    pub current_stage: ProductionStage,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum ProductionStrategy {\n    MakeToStock,     // MTS - Produce based on forecast\n    MakeToOrder,     // MTO - Produce based on sales order\n    AssembleToOrder, // ATO - Final assembly based on order\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum ProductionStage {\n    // Planning\n    DemandCreated {\n        demand_id: Uuid,\n        demand_type: String,  // Sales order, forecast, safety stock\n        material_id: Uuid,\n        required_quantity: Decimal,\n        required_date: NaiveDate,\n    },\n    MrpRunExecuted {\n        mrp_run_id: Uuid,\n        planned_orders_created: u32,\n        purchase_requisitions_created: u32,\n    },\n    \n    // Production Order\n    ProductionOrderCreated {\n        order_id: Uuid,\n        order_number: String,\n        target_quantity: Decimal,\n        scheduled_start: NaiveDate,\n        scheduled_finish: NaiveDate,\n    },\n    ProductionOrderReleased {\n        released_at: DateTime<Utc>,\n        components_reserved: Vec<ComponentReservation>,\n    },\n    \n    // Manufacturing\n    ComponentsIssued {\n        materials_withdrawn: Vec<MaterialWithdrawal>,\n        total_value: Decimal,\n    },\n    OperationConfirmed {\n        operation_number: String,\n        work_center: String,\n        yield_quantity: Decimal,\n        actual_time: String,\n    },\n    \n    // Completion\n    ProductionGoodsReceiptPosted {\n        material_document_number: String,\n        quantity_produced: Decimal,\n        production_cost: Decimal,\n    },\n    ProductionOrderSettled {\n        settlement_document: String,\n        settled_amount: Decimal,\n        variance: Decimal,\n    },\n}\n\npub struct ComponentReservation {\n    pub material_id: Uuid,\n    pub material_number: String,\n    pub reserved_quantity: Decimal,\n    pub reservation_number: String,\n}\n\npub struct MaterialWithdrawal {\n    pub material_id: Uuid,\n    pub material_number: String,\n    pub withdrawn_quantity: Decimal,\n    pub value: Decimal,\n}\n```\n\n### 8.2 领域间消息路由\n\n```rust\n// Event Router Configuration\npub struct EventRoutingConfig {\n    pub routes: HashMap<EventType, Vec<SubscriberConfig>>,\n}\n\npub struct SubscriberConfig {\n    pub subscriber_service: String,\n    pub topic: String,\n    pub consumer_group: String,\n    pub retry_policy: RetryPolicy,\n    pub dead_letter_queue: String,\n}\n\n// Example routing configuration\npub fn default_event_routing() -> EventRoutingConfig {\n    let mut routes = HashMap::new();\n    \n    // Financial events routing\n    routes.insert(\n        EventType::DocumentPosted,\n        vec![\n            SubscriberConfig {\n                subscriber_service: \"controlling-service\".to_string(),\n                topic: \"financial.document-posted\".to_string(),\n                consumer_group: \"co-actual-postings\".to_string(),\n                retry_policy: RetryPolicy::ExponentialBackoff { max_attempts: 5 },\n                dead_letter_queue: \"financial.dlq\".to_string(),\n            },\n            SubscriberConfig {\n                subscriber_service: \"bi-service\".to_string(),\n                topic: \"financial.document-posted\".to_string(),\n                consumer_group: \"bi-financial-analytics\".to_string(),\n                retry_policy: RetryPolicy::ExponentialBackoff { max_attempts: 3 },\n                dead_letter_queue: \"bi.dlq\".to_string(),\n            },\n        ],\n    );\n    \n    // Goods Receipt events routing\n    routes.insert(\n        EventType::GoodsReceiptPosted,\n        vec![\n            SubscriberConfig {\n                subscriber_service: \"financial-service\".to_string(),\n                topic: \"materials.goods-receipt-posted\".to_string(),\n                consumer_group: \"fi-inventory-accounting\".to_string(),\n                retry_policy: RetryPolicy::ExponentialBackoff { max_attempts: 5 },\n                dead_letter_queue: \"materials.dlq\".to_string(),\n            },\n            SubscriberConfig {\n                subscriber_service: \"quality-service\".to_string(),\n                topic: \"materials.goods-receipt-posted\".to_string(),\n                consumer_group: \"qm-inspection-trigger\".to_string(),\n                retry_policy: RetryPolicy::Immediate { max_attempts: 3 },\n                dead_letter_queue: \"quality.dlq\".to_string(),\n            },\n            SubscriberConfig {\n                subscriber_service: \"warehouse-service\".to_string(),\n                topic: \"materials.goods-receipt-posted\".to_string(),\n                consumer_group: \"wm-putaway-tasks\".to_string(),\n                retry_policy: RetryPolicy::ExponentialBackoff { max_attempts: 5 },\n                dead_letter_queue: \"warehouse.dlq\".to_string(),\n            },\n        ],\n    );\n    \n    // Sales Order events routing\n    routes.insert(\n        EventType::SalesOrderCreated,\n        vec![\n            SubscriberConfig {\n                subscriber_service: \"materials-service\".to_string(),\n                topic: \"sales.order-created\".to_string(),\n                consumer_group: \"mm-atp-check\".to_string(),\n                retry_policy: RetryPolicy::ExponentialBackoff { max_attempts: 5 },\n                dead_letter_queue: \"sales.dlq\".to_string(),\n            },\n            SubscriberConfig {\n                subscriber_service: \"credit-management-service\".to_string(),\n                topic: \"sales.order-created\".to_string(),\n                consumer_group: \"fscm-credit-check\".to_string(),\n                retry_policy: RetryPolicy::Immediate { max_attempts: 3 },\n                dead_letter_queue: \"credit.dlq\".to_string(),\n            },\n            SubscriberConfig {\n                subscriber_service: \"production-service\".to_string(),\n                topic: \"sales.order-created\".to_string(),\n                consumer_group: \"pp-demand-creation\".to_string(),\n                retry_policy: RetryPolicy::ExponentialBackoff { max_attempts: 3 },\n                dead_letter_queue: \"production.dlq\".to_string(),\n            },\n        ],\n    );\n    \n    EventRoutingConfig { routes }\n}\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\npub enum EventType {\n    // Financial\n    DocumentPosted,\n    PaymentReceived,\n    PeriodClosed,\n    \n    // Materials\n    GoodsReceiptPosted,\n    PurchaseOrderCreated,\n    \n    // Sales\n    SalesOrderCreated,\n    DeliveryCreated,\n    BillingDocumentCreated,\n    \n    // Production\n    ProductionOrderCreated,\n    OperationConfirmed,\n    \n    // Quality\n    InspectionLotCreated,\n    UsageDecisionMade,\n    \n    // Warehouse\n    WarehouseTaskConfirmed,\n    PhysicalInventoryPosted,\n}\n\n#[derive(Debug, Clone)]\npub enum RetryPolicy {\n    Immediate { max_attempts: u8 },\n    ExponentialBackoff { max_attempts: u8 },\n    FixedDelay { delay_seconds: u64, max_attempts: u8 },\n}\n```\n\n### 8.3 主数据同步策略\n\n```rust\n// Master Data Synchronization\npub struct MasterDataSyncService {\n    pub mdg_client: Arc<MdgServiceClient>,\n    pub event_publisher: Arc<EventPublisher>,\n}\n\nimpl MasterDataSyncService {\n    // Material Master Data sync from MDG to all consuming systems\n    pub async fn sync_material_master(\n        &self,\n        material_id: Uuid,\n    ) -> Result<SyncResult, SyncError> {\n        // 1. Fetch from MDG (golden record)\n        let material_master = self.mdg_client\n            .get_material_master(material_id)\n            .await?;\n        \n        // 2. Publish to consuming systems\n        let event = MaterialMasterChanged {\n            material_id,\n            change_timestamp: Utc::now(),\n            change_type: ChangeType::Update,\n            material_data: material_master,\n        };\n        \n        // Consuming systems: MM, SD, PP, WM, QM, FI/CO\n        self.event_publisher.publish(\n            \"mdg.material-master-changed\",\n            &event,\n        ).await?;\n        \n        Ok(SyncResult {\n            sync_id: Uuid::new_v4(),\n            synced_at: Utc::now(),\n            target_systems: vec![\n                \"materials-service\",\n                \"sales-service\",\n                \"production-service\",\n                \"warehouse-service\",\n                \"quality-service\",\n                \"financial-service\",\n            ],\n        })\n    }\n    \n    // Business Partner sync from MDG to FI, SD, MM\n    pub async fn sync_business_partner(\n        &self,\n        bp_id: Uuid,\n    ) -> Result<SyncResult, SyncError> {\n        let bp_master = self.mdg_client\n            .get_business_partner(bp_id)\n            .await?;\n        \n        let event = BusinessPartnerChanged {\n            bp_id,\n            change_timestamp: Utc::now(),\n            change_type: ChangeType::Update,\n            bp_data: bp_master,\n        };\n        \n        self.event_publisher.publish(\n            \"mdg.business-partner-changed\",\n            &event,\n        ).await?;\n        \n        Ok(SyncResult {\n            sync_id: Uuid::new_v4(),\n            synced_at: Utc::now(),\n            target_systems: vec![\n                \"financial-service\",   // Customer/Vendor accounting\n                \"sales-service\",       // Customer sales data\n                \"materials-service\",   // Vendor purchasing data\n                \"credit-service\",      // Credit management\n            ],\n        })\n    }\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum ChangeType {\n    Create,\n    Update,\n    Delete,\n    Block,\n    Unblock,\n}\n```\n\n### 8.4 数据一致性保障\n\n```rust\n// Saga Coordinator for cross-module transactions\npub struct SagaCoordinator {\n    pub saga_store: Arc<SagaStore>,\n    pub event_publisher: Arc<EventPublisher>,\n    pub compensation_handler: Arc<CompensationHandler>,\n}\n\nimpl SagaCoordinator {\n    // Example: Order-to-Cash Saga\n    pub async fn execute_order_to_cash_saga(\n        &self,\n        request: CreateSalesOrderRequest,\n    ) -> Result<O2CSagaResult, SagaError> {\n        let saga_id = Uuid::new_v4();\n        let mut saga = O2CSaga::new(saga_id, request);\n        \n        // Step 1: Create Sales Order\n        match self.create_sales_order(&mut saga).await {\n            Ok(_) => {},\n            Err(e) => {\n                self.compensate_saga(&saga).await?;\n                return Err(e);\n            }\n        }\n        \n        // Step 2: Check Credit Limit\n        match self.check_credit_limit(&mut saga).await {\n            Ok(_) => {},\n            Err(e) => {\n                self.compensate_saga(&saga).await?;\n                return Err(e);\n            }\n        }\n        \n        // Step 3: Reserve Inventory (ATP Check)\n        match self.reserve_inventory(&mut saga).await {\n            Ok(_) => {},\n            Err(e) => {\n                self.compensate_saga(&saga).await?;\n                return Err(e);\n            }\n        }\n        \n        // Step 4: Calculate Pricing\n        match self.calculate_pricing(&mut saga).await {\n            Ok(_) => {},\n            Err(e) => {\n                self.compensate_saga(&saga).await?;\n                return Err(e);\n            }\n        }\n        \n        // Saga completed successfully\n        saga.mark_completed();\n        self.saga_store.save(&saga).await?;\n        \n        Ok(O2CSagaResult {\n            saga_id,\n            order_id: saga.order_id.unwrap(),\n            order_number: saga.order_number.clone().unwrap(),\n            completed_at: Utc::now(),\n        })\n    }\n    \n    async fn compensate_saga(&self, saga: &O2CSaga) -> Result<(), SagaError> {\n        // Execute compensations in reverse order\n        for step in saga.completed_steps.iter().rev() {\n            match step {\n                SagaStep::SalesOrderCreated { order_id } => {\n                    self.compensation_handler\n                        .delete_sales_order(*order_id)\n                        .await?;\n                }\n                SagaStep::InventoryReserved { reservation_id } => {\n                    self.compensation_handler\n                        .release_reservation(*reservation_id)\n                        .await?;\n                }\n                SagaStep::CreditBlocked { block_id } => {\n                    self.compensation_handler\n                        .release_credit_block(*block_id)\n                        .await?;\n                }\n                _ => {}\n            }\n        }\n        Ok(())\n    }\n}\n\npub struct O2CSaga {\n    pub saga_id: Uuid,\n    pub request: CreateSalesOrderRequest,\n    pub order_id: Option<Uuid>,\n    pub order_number: Option<String>,\n    pub completed_steps: Vec<SagaStep>,\n    pub status: SagaStatus,\n    pub created_at: DateTime<Utc>,\n    pub completed_at: Option<DateTime<Utc>>,\n}\n\n#[derive(Debug, Clone)]\npub enum SagaStep {\n    SalesOrderCreated { order_id: Uuid },\n    CreditBlocked { block_id: Uuid },\n    InventoryReserved { reservation_id: Uuid },\n    PricingCalculated { total_value: Decimal },\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum SagaStatus {\n    InProgress,\n    Completed,\n    Compensating,\n    Compensated,\n    Failed,\n}\n```\n\n---\n\n## 总结与实施指南\n\n### 核心设计原则\n\n1. **领域驱动设计 (DDD)**\n   - 每个模块都有清晰的领域边界\n   - 聚合根负责维护业务不变性\n   - 值对象确保数据完整性\n\n2. **事件驱动架构**\n   - 所有状态变更通过领域事件传播\n   - 异步事件处理提高系统可扩展性\n   - 事件溯源支持完整审计追踪\n\n3. **微服务架构**\n   - 每个业务模块独立部署\n   - 服务间通过事件和API通信\n   - 数据库按服务隔离\n\n4. **API 优先**\n   - RESTful API 设计规范\n   - gRPC 用于服务间高性能通信\n   - GraphQL 用于复杂查询场景\n\n### 技术栈推荐\n\n```rust\n// Core dependencies\n[dependencies]\n# Web framework\naxum = \"0.7\"\ntower = \"0.4\"\ntower-http = \"0.5\"\n\n# Async runtime\ntokio = { version = \"1.35\", features = [\"full\"] }\n\n# Serialization\nserde = { version = \"1.0\", features = [\"derive\"] }\nserde_json = \"1.0\"\n\n# Database\nsqlx = { version = \"0.7\", features = [\"postgres\", \"runtime-tokio-native-tls\", \"uuid\", \"chrono\", \"decimal\"] }\nsea-orm = \"0.12\"\n\n# gRPC\ntonic = \"0.11\"\nprost = \"0.12\"\n\n# Event streaming\nrdkafka = \"0.36\"\n\n# Caching\nredis = { version = \"0.24\", features = [\"tokio-comp\"] }\n\n# Observability\ntracing = \"0.1\"\ntracing-subscriber = \"0.3\"\nopentelemetry = \"0.21\"\n\n# Validation\nvalidator = { version = \"0.16\", features = [\"derive\"] }\n\n# Error handling\nthiserror = \"1.0\"\nanyhow = \"1.0\"\n\n# Money & Decimal\nrust_decimal = \"1.33\"\nrust_decimal_macros = \"1.33\"\n\n# UUID\nuuid = { version = \"1.6\", features = [\"v4\", \"serde\"] }\n\n# DateTime\nchrono = { version = \"0.4\", features = [\"serde\"] }\n\n# Authentication\njsonwebtoken = \"9.2\"\n\n# Configuration\nconfig = \"0.14\"\n```\n\n### 数据库设计原则\n\n1. **分区策略**\n   - 按fiscal_year分区交易表\n   - 按posting_date分区高频表\n   - 归档历史数据到冷存储\n\n2. **索引优化**\n   - 复合索引支持常见查询模式\n   - 部分索引减少索引大小\n   - 使用BRIN索引处理时序数据\n\n3. **性能优化**\n   - 读写分离（主从复制）\n   - 物化视图加速报表查询\n   - 连接池管理数据库连接\n\n### 监控指标\n\n```rust\n// Business metrics\npub static ORDER_CREATED_TOTAL: Lazy<IntCounter> = Lazy::new(|| {\n    register_int_counter!(\"erp_orders_created_total\", \"Total orders created\")\n});\n\npub static ORDER_VALUE: Lazy<Histogram> = Lazy::new(|| {\n    register_histogram!(\"erp_order_value_usd\", \"Order value in USD\")\n});\n\n// Technical metrics\npub static API_REQUEST_DURATION: Lazy<HistogramVec> = Lazy::new(|| {\n    register_histogram_vec!(\n        \"erp_api_request_duration_seconds\",\n        \"API request duration\",\n        &[\"service\", \"endpoint\", \"method\", \"status\"]\n    )\n});\n\npub static DATABASE_QUERY_DURATION: Lazy<HistogramVec> = Lazy::new(|| {\n    register_histogram_vec!(\n        \"erp_db_query_duration_seconds\",\n        \"Database query duration\",\n        &[\"service\", \"query_type\"]\n    )\n});\n```\n\n### 部署架构建议\n\n```yaml\n# Kubernetes namespace per environment\napiVersion: v1\nkind: Namespace\nmetadata:\n  name: erp-production\n  labels:\n    environment: production\n    \n---\n# Service mesh with Istio\napiVersion: networking.istio.io/v1beta1\nkind: VirtualService\nmetadata:\n  name: financial-service\nspec:\n  hosts:\n  - financial-service\n  http:\n  - match:\n    - headers:\n        x-api-version:\n          exact: \"v1\"\n    route:\n    - destination:\n        host: financial-service\n        subset: v1\n  - route:\n    - destination:\n        host: financial-service\n        subset: v2\n      weight: 10\n    - destination:\n        host: financial-service\n        subset: v1\n      weight: 90\n```\n\n---\n\n## 下一步工作\n\n本文档已完成以下模块的详细规格：\n\n✅ **FI (Financial Accounting)** - 财务会计  \n✅ **CO (Controlling)** - 成本控制  \n✅ **MM (Materials Management)** - 物料管理  \n✅ **SD (Sales & Distribution)** - 销售分销  \n✅ **PP (Production Planning)** - 生产计划  \n✅ **WM/EWM (Warehouse Management)** - 仓库管理  \n✅ **QM (Quality Management)** - 质量管理  \n\n**待补充模块** (可根据需要继续扩展):\n- PM (Plant Maintenance) - 设备维护\n- PS (Project System) - 项目系统\n- HCM (Human Capital Management) - 人力资源\n- TR (Treasury) - 资金管理\n- BW/BI (Business Intelligence) - 商业智能\n\n文档提供了:\n- ✅ 完整的数据模型定义\n- ✅ RESTful API 规格\n- ✅ 领域事件定义\n- ✅ 业务规则实现\n- ✅ 跨模块集成架构\n- ✅ 实施技术指南\n\n此文档可作为开发团队的技术蓝图，配合 **Rust-Abc-Enhanced.md** (12个月开发计划) 和 **Rust-Implementation-Guide.md** (实施指南) 使用。\n\n## 第九部分：设备维护模块 (PM - Plant Maintenance)\n\n### 9.1 数据模型\n\n#### 9.1.1 技术对象 (Technical Object)\n\n```rust\npub struct Equipment {\n    pub equipment_id: Uuid,\n    pub equipment_number: String,         // Format: EQP-000001\n    pub equipment_category: EquipmentCategory,\n    \n    // Description\n    pub description: String,\n    pub long_text: Option<String>,\n    \n    // Classification\n    pub equipment_class: EquipmentClass,\n    pub object_type: ObjectType,\n    pub abc_indicator: Option<AbcIndicator>,\n    \n    // Technical Data\n    pub manufacturer: Option<String>,\n    pub model_number: Option<String>,\n    pub serial_number: Option<String>,\n    pub manufacturing_date: Option<NaiveDate>,\n    pub acquisition_date: Option<NaiveDate>,\n    pub acquisition_value: Option<Money>,\n    \n    // Location\n    pub plant: Plant,\n    pub maintenance_plant: Plant,\n    pub location: Option<Location>,\n    pub room: Option<String>,\n    pub functional_location: Option<String>,\n    pub cost_center: CostCenter,\n    \n    // Organizational Assignment\n    pub maintenance_planner_group: PlannerGroup,\n    pub maintenance_work_center: WorkCenter,\n    pub responsible_person: Option<UserId>,\n    \n    // Technical Specifications\n    pub technical_characteristics: Vec<TechnicalCharacteristic>,\n    pub capacity: Option<Capacity>,\n    pub weight: Option<Weight>,\n    pub dimensions: Option<Dimensions>,\n    \n    // Maintenance Strategy\n    pub maintenance_strategy: Option<MaintenanceStrategy>,\n    pub maintenance_plans: Vec<Uuid>,  // References to maintenance plans\n    pub task_lists: Vec<Uuid>,         // References to task lists\n    \n    // Status\n    pub system_status: EquipmentStatus,\n    pub user_status: Option<UserStatus>,\n    pub availability_status: AvailabilityStatus,\n    \n    // Performance Tracking\n    pub total_operating_hours: Decimal,\n    pub total_downtime_hours: Decimal,\n    pub last_maintenance_date: Option<NaiveDate>,\n    pub next_maintenance_date: Option<NaiveDate>,\n    pub mtbf: Option<Decimal>,         // Mean Time Between Failures\n    pub mttr: Option<Decimal>,         // Mean Time To Repair\n    \n    // Hierarchical Structure\n    pub superior_equipment: Option<String>,\n    pub structure_indicator: Option<StructureIndicator>,\n    \n    // Asset Link\n    pub asset_number: Option<String>,  // Link to FI-AA\n    \n    // Audit\n    pub created_at: DateTime<Utc>,\n    pub created_by: UserId,\n    pub last_changed_at: DateTime<Utc>,\n    pub last_changed_by: UserId,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum EquipmentCategory {\n    MachineEquipment,      // M - Machines\n    ProductionResource,    // P - Production resources\n    TransportEquipment,    // T - Transport equipment\n    TestEquipment,        // E - Test equipment\n    BuildingComponent,     // B - Building components\n    Tool,                 // L - Tools\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum AvailabilityStatus {\n    Available,\n    InMaintenance,\n    Breakdown,\n    Reserved,\n    Decommissioned,\n}\n\npub struct FunctionalLocation {\n    pub floc_id: Uuid,\n    pub floc_number: String,           // Format: SITE-AREA-ZONE-SYSTEM\n    pub description: String,\n    \n    // Hierarchy\n    pub superior_floc: Option<String>,\n    pub structure_indicator: StructureIndicator,\n    pub level: u8,\n    \n    // Organizational Data\n    pub plant: Plant,\n    pub maintenance_plant: Plant,\n    pub location: Option<Location>,\n    pub cost_center: CostCenter,\n    pub planner_group: PlannerGroup,\n    pub work_center: WorkCenter,\n    \n    // Category\n    pub floc_category: FlocCategory,\n    \n    // Status\n    pub system_status: FlocStatus,\n    \n    // Equipment installed at this location\n    pub installed_equipment: Vec<String>,\n    \n    // Audit\n    pub created_at: DateTime<Utc>,\n    pub created_by: UserId,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum FlocCategory {\n    Site,\n    Building,\n    ProductionLine,\n    Area,\n    System,\n    Subsystem,\n}\n```\n\n#### 9.1.2 维护计划 (Maintenance Plan)\n\n```rust\npub struct MaintenancePlan {\n    pub plan_id: Uuid,\n    pub plan_number: String,           // Format: MP-2025-000001\n    pub maintenance_strategy: MaintenanceStrategy,\n    \n    // Object Reference\n    pub object_type: MaintenanceObjectType,\n    pub object_id: Uuid,\n    pub object_number: String,\n    \n    // Planning Data\n    pub scheduling_indicator: SchedulingIndicator,\n    pub cycle_unit: CycleUnit,\n    pub cycle_length: Decimal,\n    pub cycle_start_date: NaiveDate,\n    pub cycle_text: String,\n    \n    // Task List\n    pub task_list_type: TaskListType,\n    pub task_list_group: String,\n    pub task_list_counter: String,\n    \n    // Scheduling Parameters\n    pub scheduling_period: Period,\n    pub factory_calendar: String,\n    pub shift_factor: Decimal,\n    pub lead_time: Duration,\n    pub offset_start: Option<Duration>,\n    pub offset_end: Option<Duration>,\n    \n    // Call Objects (Work orders to be generated)\n    pub call_horizon: u16,             // Days\n    pub order_type: String,\n    pub priority: MaintenancePriority,\n    pub work_center: WorkCenter,\n    pub planner_group: PlannerGroup,\n    \n    // Schedule\n    pub scheduled_calls: Vec<ScheduledCall>,\n    pub last_call_date: Option<NaiveDate>,\n    pub next_call_date: Option<NaiveDate>,\n    \n    // Status\n    pub plan_status: MaintenancePlanStatus,\n    \n    // Audit\n    pub created_at: DateTime<Utc>,\n    pub created_by: UserId,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum MaintenanceStrategy {\n    TimeBasedSingleCycle,      // 01 - Time-based, single cycle\n    TimeBasedMultipleCycle,    // 02 - Time-based, strategy plan\n    PerformanceBased,          // 03 - Performance-based (running hours)\n    ConditionBased,            // 04 - Condition-based monitoring\n    PredictiveMaintenance,     // 05 - Predictive using IoT/AI\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum SchedulingIndicator {\n    TimeBased,             // 1 - Time-based\n    FactoryCalendar,       // 2 - Factory calendar\n    PerformanceBased,      // 3 - Performance-based (meter reading)\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum CycleUnit {\n    Days,\n    Weeks,\n    Months,\n    Years,\n    OperatingHours,\n    ProductionQuantity,\n    Kilometers,\n}\n\npub struct ScheduledCall {\n    pub call_id: Uuid,\n    pub call_number: u32,\n    pub planned_date: NaiveDate,\n    pub planned_start: NaiveDateTime,\n    pub planned_finish: NaiveDateTime,\n    pub call_status: CallStatus,\n    pub work_order_id: Option<Uuid>,\n    pub work_order_number: Option<String>,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum CallStatus {\n    Planned,\n    OrderCreated,\n    Released,\n    InProgress,\n    Completed,\n    Cancelled,\n}\n```\n\n#### 9.1.3 维护工单 (Maintenance Order)\n\n```rust\npub struct MaintenanceOrder {\n    pub order_id: Uuid,\n    pub order_number: String,          // Format: MO-2025-000001\n    pub order_type: MaintenanceOrderType,\n    pub priority: MaintenancePriority,\n    \n    // Object Reference\n    pub equipment_id: Option<Uuid>,\n    pub equipment_number: Option<String>,\n    pub functional_location: Option<String>,\n    \n    // Description\n    pub short_text: String,\n    pub long_text: Option<String>,\n    pub malfunction_start: Option<NaiveDateTime>,\n    pub malfunction_end: Option<NaiveDateTime>,\n    \n    // Organizational Data\n    pub plant: Plant,\n    pub maintenance_plant: Plant,\n    pub planner_group: PlannerGroup,\n    pub main_work_center: WorkCenter,\n    pub cost_center: CostCenter,\n    \n    // Planning\n    pub system_condition: Option<SystemCondition>,\n    pub scheduling_type: SchedulingType,\n    pub basic_start_date: NaiveDate,\n    pub basic_finish_date: NaiveDate,\n    pub scheduled_start_date: NaiveDateTime,\n    pub scheduled_finish_date: NaiveDateTime,\n    pub actual_start_date: Option<NaiveDateTime>,\n    pub actual_finish_date: Option<NaiveDateTime>,\n    \n    // Operations\n    pub operations: Vec<MaintenanceOperation>,\n    \n    // Materials/Components\n    pub components: Vec<MaintenanceComponent>,\n    \n    // Costs\n    pub planned_costs: Decimal,\n    pub actual_costs: Decimal,\n    pub variance: Decimal,\n    \n    // Status\n    pub system_status: MaintenanceOrderStatus,\n    pub user_status: Option<UserStatus>,\n    \n    // References\n    pub notification_id: Option<Uuid>,\n    pub maintenance_plan_id: Option<Uuid>,\n    pub maintenance_plan_call: Option<String>,\n    \n    // Settlement\n    pub settlement_rule: Option<SettlementRule>,\n    pub settled: bool,\n    pub settlement_date: Option<NaiveDate>,\n    \n    // Audit\n    pub created_at: DateTime<Utc>,\n    pub created_by: UserId,\n    pub released_at: Option<DateTime<Utc>>,\n    pub completed_at: Option<DateTime<Utc>>,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum MaintenanceOrderType {\n    BreakdownMaintenance,      // PM01 - Corrective maintenance\n    PreventiveMaintenance,     // PM02 - Preventive maintenance\n    PredictiveMaintenance,     // PM03 - Predictive maintenance\n    Inspection,               // PM04 - Inspection\n    Calibration,              // PM05 - Calibration\n    Overhaul,                 // PM06 - Overhaul/refurbishment\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum MaintenancePriority {\n    VeryHigh,      // 1 - Immediate action required\n    High,          // 2 - Urgent\n    Medium,        // 3 - Normal\n    Low,           // 4 - Can be scheduled\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum SystemCondition {\n    EquipmentDown,         // Equipment must be shut down\n    EquipmentRunning,      // Can perform while running\n    ProductionShutdown,    // Requires production line shutdown\n}\n\npub struct MaintenanceOperation {\n    pub operation_id: Uuid,\n    pub operation_number: String,\n    pub control_key: ControlKey,\n    pub description: String,\n    pub work_center: WorkCenter,\n    \n    // Work\n    pub work_duration: Duration,\n    pub number_of_capacities: u16,\n    pub actual_work_duration: Option<Duration>,\n    \n    // Schedule\n    pub earliest_start: NaiveDateTime,\n    pub latest_finish: NaiveDateTime,\n    pub actual_start: Option<NaiveDateTime>,\n    pub actual_finish: Option<NaiveDateTime>,\n    \n    // Confirmation\n    pub confirmations: Vec<OperationConfirmation>,\n    pub operation_status: OperationStatus,\n    \n    // Personnel\n    pub required_personnel: Vec<PersonnelRequirement>,\n    pub assigned_personnel: Vec<UserId>,\n    \n    // Activity Type (for costing)\n    pub activity_type: Option<String>,\n}\n\npub struct PersonnelRequirement {\n    pub qualification: String,\n    pub number_required: u16,\n    pub work_duration: Duration,\n}\n\npub struct MaintenanceComponent {\n    pub component_id: Uuid,\n    pub item_number: String,\n    pub material_id: Uuid,\n    pub material_number: String,\n    pub material_description: String,\n    \n    // Requirement\n    pub requirement_quantity: Decimal,\n    pub requirement_date: NaiveDate,\n    pub unit: Unit,\n    \n    // Withdrawal\n    pub withdrawn_quantity: Decimal,\n    pub return_quantity: Decimal,\n    \n    // Location\n    pub plant: Plant,\n    pub storage_location: StorageLocation,\n    pub batch: Option<String>,\n    \n    // Item Category\n    pub item_category: ItemCategory,\n    pub component_type: ComponentType,\n    \n    // Reservation\n    pub reservation_number: Option<String>,\n    \n    // Status\n    pub goods_movement_status: GoodsMovementStatus,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum ComponentType {\n    SparePart,\n    ConsumableMaterial,\n    Tool,\n    Service,\n}\n```\n\n#### 9.1.4 维护通知 (Maintenance Notification)\n\n```rust\npub struct MaintenanceNotification {\n    pub notification_id: Uuid,\n    pub notification_number: String,   // Format: MN-2025-000001\n    pub notification_type: MaintenanceNotificationType,\n    pub priority: MaintenancePriority,\n    \n    // Object Reference\n    pub equipment_id: Option<Uuid>,\n    pub equipment_number: Option<String>,\n    pub functional_location: Option<String>,\n    \n    // Description\n    pub short_text: String,\n    pub long_text: Option<String>,\n    \n    // Malfunction Details\n    pub malfunction_start: Option<NaiveDateTime>,\n    pub malfunction_end: Option<NaiveDateTime>,\n    pub breakdown: bool,\n    pub effect: Option<MalfunctionEffect>,\n    \n    // Damage\n    pub damage_code: Option<DamageCode>,\n    pub cause_code: Option<CauseCode>,\n    pub object_part: Option<ObjectPart>,\n    pub damage_text: Option<String>,\n    \n    // Items (for multi-item notifications)\n    pub items: Vec<NotificationItem>,\n    \n    // Tasks\n    pub tasks: Vec<MaintenanceTask>,\n    \n    // Organizational Data\n    pub plant: Plant,\n    pub planner_group: PlannerGroup,\n    pub reported_by: UserId,\n    pub responsible_person: Option<UserId>,\n    \n    // Dates\n    pub required_start_date: Option<NaiveDate>,\n    pub required_end_date: Option<NaiveDate>,\n    \n    // Work Order\n    pub work_order_created: bool,\n    pub work_order_id: Option<Uuid>,\n    pub work_order_number: Option<String>,\n    \n    // Status\n    pub notification_status: NotificationStatus,\n    \n    // Completion\n    pub completion_text: Option<String>,\n    pub completed_at: Option<DateTime<Utc>>,\n    pub completed_by: Option<UserId>,\n    \n    // Audit\n    pub created_at: DateTime<Utc>,\n    pub created_by: UserId,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum MaintenanceNotificationType {\n    MalfunctionReport,     // M1 - Malfunction/problem report\n    MaintenanceRequest,    // M2 - Maintenance request\n    ActivityReport,        // M3 - Activity/work completion report\n    InspectionReport,      // M4 - Inspection report\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum MalfunctionEffect {\n    EquipmentDown,\n    PerformanceDegraded,\n    QualityIssue,\n    SafetyRisk,\n    MinorIssue,\n}\n\npub struct NotificationItem {\n    pub item_id: Uuid,\n    pub item_number: u16,\n    pub object_part: ObjectPart,\n    pub damage_code: DamageCode,\n    pub cause_code: Option<CauseCode>,\n    pub item_text: String,\n    pub start_date: Option<NaiveDateTime>,\n    pub end_date: Option<NaiveDateTime>,\n}\n\npub struct MaintenanceTask {\n    pub task_id: Uuid,\n    pub task_code: String,\n    pub task_text: String,\n    pub responsible_person: Option<UserId>,\n    pub planned_start: Option<NaiveDate>,\n    pub planned_finish: Option<NaiveDate>,\n    pub actual_start: Option<NaiveDate>,\n    pub actual_finish: Option<NaiveDate>,\n    pub task_status: TaskStatus,\n    pub completion_note: Option<String>,\n}\n\npub struct DamageCode {\n    pub code_group: String,\n    pub code: String,\n    pub description: String,\n}\n\npub struct CauseCode {\n    pub code_group: String,\n    pub code: String,\n    pub description: String,\n}\n\npub struct ObjectPart {\n    pub part_code: String,\n    pub part_description: String,\n}\n```\n\n### 9.2 API 规格\n\n#### 9.2.1 设备管理 API\n\n```rust\n// POST /api/v1/maintenance/equipment\npub struct CreateEquipmentRequest {\n    pub equipment_category: String,\n    pub description: String,\n    pub plant: String,\n    pub maintenance_plant: String,\n    pub planner_group: String,\n    pub work_center: String,\n    pub cost_center: String,\n    pub manufacturer: Option<String>,\n    pub model_number: Option<String>,\n    pub serial_number: Option<String>,\n    pub functional_location: Option<String>,\n    pub superior_equipment: Option<String>,\n}\n\npub struct CreateEquipmentResponse {\n    pub equipment_id: Uuid,\n    pub equipment_number: String,\n    pub description: String,\n    pub status: String,\n    pub created_at: DateTime<Utc>,\n}\n\n// PUT /api/v1/maintenance/equipment/{equipment_id}/status\npub struct UpdateEquipmentStatusRequest {\n    pub availability_status: String,\n    pub reason: Option<String>,\n}\n\n// POST /api/v1/maintenance/equipment/{equipment_id}/meter-reading\npub struct RecordMeterReadingRequest {\n    pub reading_date: NaiveDateTime,\n    pub meter_type: String,           // Operating hours, production count, km\n    pub reading_value: Decimal,\n    pub recorded_by: Uuid,\n}\n\n// GET /api/v1/maintenance/equipment/{equipment_id}/history\npub struct GetEquipmentHistoryQuery {\n    pub history_type: Option<String>, // Maintenance, Breakdowns, All\n    pub date_from: Option<NaiveDate>,\n    pub date_to: Option<NaiveDate>,\n}\n\npub struct GetEquipmentHistoryResponse {\n    pub equipment_number: String,\n    pub equipment_description: String,\n    pub history_entries: Vec<EquipmentHistoryEntry>,\n    pub statistics: EquipmentStatistics,\n}\n\npub struct EquipmentStatistics {\n    pub total_operating_hours: Decimal,\n    pub total_downtime_hours: Decimal,\n    pub number_of_breakdowns: u32,\n    pub mtbf: Decimal,\n    pub mttr: Decimal,\n    pub availability_percentage: Decimal,\n}\n```\n\n#### 9.2.2 维护计划 API\n\n```rust\n// POST /api/v1/maintenance/maintenance-plans\npub struct CreateMaintenancePlanRequest {\n    pub maintenance_strategy: String,\n    pub object_type: String,          // Equipment, FunctionalLocation\n    pub object_id: Uuid,\n    pub scheduling_indicator: String,\n    pub cycle_unit: String,\n    pub cycle_length: Decimal,\n    pub cycle_start_date: NaiveDate,\n    pub task_list_group: String,\n    pub order_type: String,\n    pub priority: String,\n    pub work_center: String,\n    pub planner_group: String,\n    pub call_horizon: u16,\n}\n\npub struct CreateMaintenancePlanResponse {\n    pub plan_id: Uuid,\n    pub plan_number: String,\n    pub next_call_date: NaiveDate,\n    pub scheduled_calls_count: u32,\n    pub created_at: DateTime<Utc>,\n}\n\n// POST /api/v1/maintenance/maintenance-plans/{plan_id}/schedule\npub struct ScheduleMaintenancePlanRequest {\n    pub scheduling_period_from: NaiveDate,\n    pub scheduling_period_to: NaiveDate,\n    pub immediate_call: bool,\n}\n\npub struct ScheduleMaintenancePlanResponse {\n    pub plan_id: Uuid,\n    pub plan_number: String,\n    pub calls_scheduled: Vec<ScheduledCallSummary>,\n    pub next_call_date: NaiveDate,\n}\n\npub struct ScheduledCallSummary {\n    pub call_number: u32,\n    pub planned_date: NaiveDate,\n    pub work_order_created: bool,\n    pub work_order_number: Option<String>,\n}\n\n// POST /api/v1/maintenance/maintenance-plans/{plan_id}/generate-orders\npub struct GenerateMaintenanceOrdersRequest {\n    pub call_numbers: Option<Vec<u32>>, // Specific calls, or all if None\n}\n\npub struct GenerateMaintenanceOrdersResponse {\n    pub plan_id: Uuid,\n    pub orders_generated: Vec<GeneratedOrderSummary>,\n}\n\npub struct GeneratedOrderSummary {\n    pub order_id: Uuid,\n    pub order_number: String,\n    pub call_number: u32,\n    pub planned_start: NaiveDateTime,\n    pub planned_finish: NaiveDateTime,\n}\n```\n\n#### 9.2.3 维护工单 API\n\n```rust\n// POST /api/v1/maintenance/maintenance-orders\npub struct CreateMaintenanceOrderRequest {\n    pub order_type: String,\n    pub priority: String,\n    pub short_text: String,\n    pub equipment_id: Option<Uuid>,\n    pub functional_location: Option<String>,\n    pub plant: String,\n    pub planner_group: String,\n    pub work_center: String,\n    pub basic_start_date: NaiveDate,\n    pub basic_finish_date: NaiveDate,\n    pub notification_id: Option<Uuid>,\n}\n\npub struct CreateMaintenanceOrderResponse {\n    pub order_id: Uuid,\n    pub order_number: String,\n    pub equipment_number: Option<String>,\n    pub scheduled_start: NaiveDateTime,\n    pub scheduled_finish: NaiveDateTime,\n    pub operations: Vec<OperationSummary>,\n    pub components: Vec<ComponentRequirement>,\n    pub status: String,\n    pub created_at: DateTime<Utc>,\n}\n\n// POST /api/v1/maintenance/maintenance-orders/{order_id}/release\npub struct ReleaseMaintenanceOrderRequest {\n    pub release_type: String,         // Full, Operations, Materials\n}\n\n// POST /api/v1/maintenance/maintenance-orders/{order_id}/operations/{operation_id}/confirm\npub struct ConfirmMaintenanceOperationRequest {\n    pub confirmation_date: NaiveDateTime,\n    pub actual_work_duration: String, // Duration string\n    pub work_performed: String,\n    pub final_confirmation: bool,\n    pub assigned_personnel: Vec<Uuid>,\n}\n\n// POST /api/v1/maintenance/maintenance-orders/{order_id}/complete\npub struct CompleteMaintenanceOrderRequest {\n    pub completion_date: NaiveDateTime,\n    pub completion_note: Option<String>,\n    pub equipment_status_after: Option<String>,\n}\n\npub struct CompleteMaintenanceOrderResponse {\n    pub order_id: Uuid,\n    pub order_number: String,\n    pub actual_costs: Decimal,\n    pub variance: Decimal,\n    pub completed_at: DateTime<Utc>,\n}\n\n// GET /api/v1/maintenance/maintenance-orders\npub struct ListMaintenanceOrdersQuery {\n    pub plant: Option<String>,\n    pub equipment_id: Option<Uuid>,\n    pub order_type: Option<String>,\n    pub status: Option<String>,\n    pub priority: Option<String>,\n    pub planner_group: Option<String>,\n    pub start_date_from: Option<NaiveDate>,\n    pub start_date_to: Option<NaiveDate>,\n    pub page: Option<u32>,\n    pub page_size: Option<u32>,\n}\n```\n\n#### 9.2.4 维护通知 API\n\n```rust\n// POST /api/v1/maintenance/notifications\npub struct CreateMaintenanceNotificationRequest {\n    pub notification_type: String,\n    pub priority: String,\n    pub short_text: String,\n    pub long_text: Option<String>,\n    pub equipment_id: Option<Uuid>,\n    pub functional_location: Option<String>,\n    pub breakdown: bool,\n    pub malfunction_start: Option<NaiveDateTime>,\n    pub effect: Option<String>,\n    pub damage_code: Option<String>,\n    pub cause_code: Option<String>,\n}\n\npub struct CreateMaintenanceNotificationResponse {\n    pub notification_id: Uuid,\n    pub notification_number: String,\n    pub equipment_number: Option<String>,\n    pub priority: String,\n    pub status: String,\n    pub created_at: DateTime<Utc>,\n}\n\n// POST /api/v1/maintenance/notifications/{notification_id}/create-order\npub struct CreateOrderFromNotificationRequest {\n    pub order_type: String,\n    pub planned_start: NaiveDate,\n    pub planned_finish: NaiveDate,\n}\n\npub struct CreateOrderFromNotificationResponse {\n    pub notification_id: Uuid,\n    pub order_id: Uuid,\n    pub order_number: String,\n    pub created_at: DateTime<Utc>,\n}\n\n// POST /api/v1/maintenance/notifications/{notification_id}/complete\npub struct CompleteNotificationRequest {\n    pub completion_text: String,\n    pub malfunction_end: Option<NaiveDateTime>,\n}\n```\n\n### 9.3 领域事件\n\n```rust\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum MaintenanceDomainEvent {\n    EquipmentCreated(EquipmentCreated),\n    EquipmentStatusChanged(EquipmentStatusChanged),\n    EquipmentBreakdown(EquipmentBreakdown),\n    MaintenancePlanCreated(MaintenancePlanCreated),\n    MaintenanceCallScheduled(MaintenanceCallScheduled),\n    MaintenanceOrderCreated(MaintenanceOrderCreated),\n    MaintenanceOrderReleased(MaintenanceOrderReleased),\n    MaintenanceOperationConfirmed(MaintenanceOperationConfirmed),\n    MaintenanceOrderCompleted(MaintenanceOrderCompleted),\n    MaintenanceNotificationCreated(MaintenanceNotificationCreated),\n    MeterReadingRecorded(MeterReadingRecorded),\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct EquipmentBreakdown {\n    pub event_id: Uuid,\n    pub occurred_at: DateTime<Utc>,\n    pub equipment_id: Uuid,\n    pub equipment_number: String,\n    pub equipment_description: String,\n    pub breakdown_start: NaiveDateTime,\n    pub plant: String,\n    pub functional_location: Option<String>,\n    pub notification_id: Option<Uuid>,\n    pub notification_number: Option<String>,\n    pub reported_by: String,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct MaintenanceOrderCompleted {\n    pub event_id: Uuid,\n    pub occurred_at: DateTime<Utc>,\n    pub order_id: Uuid,\n    pub order_number: String,\n    pub order_type: String,\n    pub equipment_id: Option<Uuid>,\n    pub equipment_number: Option<String>,\n    pub actual_start: NaiveDateTime,\n    pub actual_finish: NaiveDateTime,\n    pub total_duration_hours: Decimal,\n    pub planned_costs: Decimal,\n    pub actual_costs: Decimal,\n    pub variance: Decimal,\n    pub work_performed: String,\n    pub equipment_status_after: Option<String>,\n    pub completed_by: String,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct MeterReadingRecorded {\n    pub event_id: Uuid,\n    pub occurred_at: DateTime<Utc>,\n    pub equipment_id: Uuid,\n    pub equipment_number: String,\n    pub reading_date: NaiveDateTime,\n    pub meter_type: String,\n    pub reading_value: Decimal,\n    pub previous_reading_value: Option<Decimal>,\n    pub increment: Option<Decimal>,\n    pub recorded_by: String,\n}\n```\n\n---\n\n## 第十部分：项目系统模块 (PS - Project System)\n\n### 10.1 数据模型\n\n#### 10.1.1 项目定义 (Project Definition)\n\n```rust\npub struct Project {\n    pub project_id: Uuid,\n    pub project_number: String,        // Format: PRJ-2025-000001\n    pub project_profile: ProjectProfile,\n    \n    // Description\n    pub project_name: String,\n    pub project_description: String,\n    pub project_type: ProjectType,\n    \n    // Organizational Data\n    pub company_code: CompanyCode,\n    pub controlling_area: ControllingArea,\n    pub plant: Option<Plant>,\n    pub business_area: Option<BusinessArea>,\n    \n    // Responsible Persons\n    pub project_manager: UserId,\n    pub applicant: Option<UserId>,\n    pub person_responsible: Option<UserId>,\n    \n    // Dates\n    pub start_date: NaiveDate,\n    pub finish_date: NaiveDate,\n    pub actual_start_date: Option<NaiveDate>,\n    pub actual_finish_date: Option<NaiveDate>,\n    \n    // Budget\n    pub original_budget: Money,\n    pub current_budget: Money,\n    pub budget_currency: Currency,\n    \n    // Work Breakdown Structure\n    pub wbs_elements: Vec<WbsElement>,\n    \n    // Networks (activities)\n    pub networks: Vec<Network>,\n    \n    // Status\n    pub system_status: ProjectStatus,\n    pub user_status: Option<UserStatus>,\n    \n    // Progress\n    pub progress_percentage: Decimal,\n    pub milestone_status: Vec<MilestoneStatus>,\n    \n    // Financials\n    pub planned_costs: Money,\n    pub actual_costs: Money,\n    pub committed_costs: Money,\n    pub planned_revenue: Money,\n    pub actual_revenue: Money,\n    \n    // Audit\n    pub created_at: DateTime<Utc>,\n    pub created_by: UserId,\n    pub last_changed_at: DateTime<Utc>,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum ProjectType {\n    InternalProject,       // Internal development/improvement\n    CustomerProject,       // Project for external customer\n    CapitalInvestment,     // Capital investment project\n    R&D,                  // Research & development\n    MaintenanceProject,    // Major maintenance/shutdown\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum ProjectStatus {\n    Created,\n    Released,\n    InProgress,\n    Completed,\n    Closed,\n    Cancelled,\n}\n```\n\n#### 10.1.2 工作分解结构 (WBS - Work Breakdown Structure)\n\n```rust\npub struct WbsElement {\n    pub wbs_id: Uuid,\n    pub wbs_element_code: String,      // Format: PRJ-2025-0001.1.1\n    pub project_id: Uuid,\n    \n    // Description\n    pub description: String,\n    pub long_text: Option<String>,\n    \n    // Hierarchy\n    pub level: u8,\n    pub superior_wbs: Option<String>,\n    pub left_number: u32,              // For hierarchical queries\n    pub right_number: u32,\n    \n    // Type\n    pub wbs_type: WbsType,\n    pub account_assignment_element: bool,\n    pub billing_element: bool,\n    pub planning_element: bool,\n    \n    // Organizational Data\n    pub company_code: CompanyCode,\n    pub cost_center: Option<CostCenter>,\n    pub profit_center: Option<ProfitCenter>,\n    pub responsible_person: UserId,\n    \n    // Dates\n    pub start_date: NaiveDate,\n    pub finish_date: NaiveDate,\n    pub scheduled_start: Option<NaiveDate>,\n    pub scheduled_finish: Option<NaiveDate>,\n    pub actual_start: Option<NaiveDate>,\n    pub actual_finish: Option<NaiveDate>,\n    \n    // Budget\n    pub budget: Money,\n    pub budget_type: BudgetType,\n    \n    // Planning\n    pub planned_costs: Money,\n    pub planned_revenue: Option<Money>,\n    \n    // Actuals\n    pub actual_costs: Money,\n    pub committed_costs: Money,\n    pub actual_revenue: Money,\n    pub invoiced_revenue: Money,\n    \n    // Progress\n    pub progress_percentage: Decimal,\n    pub earned_value: Option<Money>,\n    \n    // Status\n    pub wbs_status: WbsStatus,\n    \n    // Statistical Key Figures\n    pub key_figures: HashMap<String, Decimal>,\n    \n    // Children\n    pub child_wbs_elements: Vec<String>,\n    pub activities: Vec<String>,        // Network activities assigned\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum WbsType {\n    Phase,\n    Deliverable,\n    Task,\n    Milestone,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum BudgetType {\n    Overall,           // Overall budget for element\n    Annual,           // Annual budget\n    Period,           // Period-specific budget\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum WbsStatus {\n    Created,\n    Released,\n    InProgress,\n    Completed,\n    TechnicallyCompleted,\n    Closed,\n}\n```\n\n#### 10.1.3 网络活动 (Network & Activities)\n\n```rust\npub struct Network {\n    pub network_id: Uuid,\n    pub network_number: String,        // Format: NET-2025-000001\n    pub network_type: NetworkType,\n    pub project_id: Uuid,\n    \n    // Description\n    pub description: String,\n    pub long_text: Option<String>,\n    \n    // Organizational Data\n    pub company_code: CompanyCode,\n    pub plant: Plant,\n    pub planner_group: PlannerGroup,\n    pub responsible_person: UserId,\n    \n    // WBS Assignment\n    pub wbs_element: Option<String>,\n    \n    // Dates\n    pub start_date: NaiveDate,\n    pub finish_date: NaiveDate,\n    pub scheduled_start: NaiveDateTime,\n    pub scheduled_finish: NaiveDateTime,\n    \n    // Scheduling\n    pub scheduling_type: SchedulingType,\n    pub network_profile: NetworkProfile,\n    \n    // Activities\n    pub activities: Vec<Activity>,\n    \n    // Relationships\n    pub relationships: Vec<ActivityRelationship>,\n    \n    // Critical Path\n    pub critical_path: Vec<String>,    // Activity numbers on critical path\n    \n    // Status\n    pub network_status: NetworkStatus,\n    \n    // Costs\n    pub planned_costs: Money,\n    pub actual_costs: Money,\n}\n\npub struct Activity {\n    pub activity_id: Uuid,\n    pub activity_number: String,\n    pub network_id: Uuid,\n    pub control_key: ControlKey,\n    \n    // Description\n    pub description: String,\n    pub long_text: Option<String>,\n    pub activity_type: ActivityType,\n    \n    // Work Center\n    pub work_center: Option<WorkCenter>,\n    pub work: Duration,\n    pub number_of_capacities: u16,\n    \n    // Dates\n    pub earliest_start: NaiveDateTime,\n    pub earliest_finish: NaiveDateTime,\n    pub latest_start: NaiveDateTime,\n    pub latest_finish: NaiveDateTime,\n    pub scheduled_start: NaiveDateTime,\n    pub scheduled_finish: NaiveDateTime,\n    pub actual_start: Option<NaiveDateTime>,\n    pub actual_finish: Option<NaiveDateTime>,\n    \n    // Float\n    pub total_float: Duration,\n    pub free_float: Duration,\n    pub on_critical_path: bool,\n    \n    // Costs\n    pub planned_activity_costs: Money,\n    pub actual_activity_costs: Money,\n    \n    // Account Assignment\n    pub wbs_element: Option<String>,\n    pub cost_center: Option<CostCenter>,\n    \n    // Materials\n    pub material_components: Vec<ActivityComponent>,\n    \n    // Progress\n    pub progress_percentage: Decimal,\n    \n    // Confirmations\n    pub confirmations: Vec<ActivityConfirmation>,\n    \n    // Status\n    pub activity_status: ActivityStatus,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum ActivityType {\n    InternalProcessing,\n    ExternalProcessing,\n    ServiceActivity,\n    Milestone,\n    WaitingTime,\n}\n\npub struct ActivityRelationship {\n    pub relationship_id: Uuid,\n    pub predecessor_activity: String,\n    pub successor_activity: String,\n    pub relationship_type: RelationshipType,\n    pub lag_time: Duration,           // Can be negative for lead time\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum RelationshipType {\n    FinishToStart,     // FS - Predecessor must finish before successor starts\n    StartToStart,      // SS - Successor can start when predecessor starts\n    FinishToFinish,    // FF - Successor finishes when predecessor finishes\n    StartToFinish,     // SF - Successor finishes when predecessor starts\n}\n\npub struct ActivityComponent {\n    pub component_id: Uuid,\n    pub item_number: String,\n    pub material_id: Uuid,\n    pub material_number: String,\n    pub requirement_quantity: Decimal,\n    pub unit: Unit,\n    pub plant: Plant,\n    pub storage_location: Option<StorageLocation>,\n    pub requirement_date: NaiveDate,\n    pub reservation_number: Option<String>,\n}\n\npub struct ActivityConfirmation {\n    pub confirmation_id: Uuid,\n    pub confirmation_date: NaiveDate,\n    pub actual_work: Duration,\n    pub progress_percentage: Decimal,\n    pub remaining_work: Duration,\n    pub confirmed_by: UserId,\n}\n```\n\n#### 10.1.4 项目预算与控制 (Project Budget)\n\n```rust\npub struct ProjectBudget {\n    pub budget_id: Uuid,\n    pub project_id: Uuid,\n    pub wbs_element: Option<String>,\n    pub fiscal_year: u16,\n    \n    // Budget Types\n    pub original_budget: Money,\n    pub supplements: Vec<BudgetSupplement>,\n    pub returns: Vec<BudgetReturn>,\n    pub current_budget: Money,\n    \n    // Distribution\n    pub annual_distribution: Vec<AnnualBudget>,\n    pub period_distribution: Vec<PeriodBudget>,\n    \n    // Budget Profile\n    pub budget_profile: BudgetProfile,\n    pub tolerance_limits: ToleranceLimits,\n    pub budget_control_active: bool,\n    \n    // Status\n    pub budget_status: BudgetStatus,\n    \n    // Approval\n    pub approval_required: bool,\n    pub approved_by: Option<UserId>,\n    pub approved_at: Option<DateTime<Utc>>,\n}\n\npub struct BudgetSupplement {\n    pub supplement_id: Uuid,\n    pub amount: Money,\n    pub reason: String,\n    pub approval_id: Option<Uuid>,\n    pub created_at: DateTime<Utc>,\n    pub created_by: UserId,\n}\n\npub struct BudgetReturn {\n    pub return_id: Uuid,\n    pub amount: Money,\n    pub reason: String,\n    pub created_at: DateTime<Utc>,\n    pub created_by: UserId,\n}\n\npub struct AnnualBudget {\n    pub fiscal_year: u16,\n    pub budget_amount: Money,\n}\n\npub struct PeriodBudget {\n    pub fiscal_year: u16,\n    pub period: u8,\n    pub budget_amount: Money,\n}\n\npub struct ToleranceLimits {\n    pub lower_warning_limit: Decimal,  // Percentage\n    pub upper_warning_limit: Decimal,\n    pub lower_error_limit: Decimal,\n    pub upper_error_limit: Decimal,\n}\n```\n\n### 10.2 API 规格\n\n```rust\n// POST /api/v1/projects/projects\npub struct CreateProjectRequest {\n    pub project_name: String,\n    pub project_description: String,\n    pub project_type: String,\n    pub company_code: String,\n    pub project_manager: Uuid,\n    pub start_date: NaiveDate,\n    pub finish_date: NaiveDate,\n    pub original_budget: Decimal,\n    pub currency: String,\n}\n\npub struct CreateProjectResponse {\n    pub project_id: Uuid,\n    pub project_number: String,\n    pub project_name: String,\n    pub status: String,\n    pub created_at: DateTime<Utc>,\n}\n\n// POST /api/v1/projects/projects/{project_id}/wbs-elements\npub struct CreateWbsElementRequest {\n    pub description: String,\n    pub superior_wbs: Option<String>,\n    pub wbs_type: String,\n    pub responsible_person: Uuid,\n    pub start_date: NaiveDate,\n    pub finish_date: NaiveDate,\n    pub budget: Option<Decimal>,\n    pub account_assignment_element: bool,\n}\n\n// POST /api/v1/projects/networks\npub struct CreateNetworkRequest {\n    pub description: String,\n    pub project_id: Uuid,\n    pub wbs_element: Option<String>,\n    pub plant: String,\n    pub start_date: NaiveDate,\n    pub finish_date: NaiveDate,\n    pub activities: Vec<CreateActivityRequest>,\n    pub relationships: Vec<CreateRelationshipRequest>,\n}\n\npub struct CreateActivityRequest {\n    pub activity_number: String,\n    pub description: String,\n    pub activity_type: String,\n    pub work_duration: String,       // Duration\n    pub work_center: Option<String>,\n    pub wbs_element: Option<String>,\n}\n\npub struct CreateRelationshipRequest {\n    pub predecessor_activity: String,\n    pub successor_activity: String,\n    pub relationship_type: String,\n    pub lag_time: Option<String>,    // Duration\n}\n\n// POST /api/v1/projects/networks/{network_id}/schedule\npub struct ScheduleNetworkRequest {\n    pub scheduling_type: String,     // Forward, Backward\n    pub scheduling_date: NaiveDate,\n}\n\npub struct ScheduleNetworkResponse {\n    pub network_id: Uuid,\n    pub network_number: String,\n    pub scheduled_start: NaiveDateTime,\n    pub scheduled_finish: NaiveDateTime,\n    pub critical_path: Vec<CriticalPathActivity>,\n    pub total_duration_days: Decimal,\n}\n\npub struct CriticalPathActivity {\n    pub activity_number: String,\n    pub description: String,\n    pub scheduled_start: NaiveDateTime,\n    pub scheduled_finish: NaiveDateTime,\n    pub duration: String,\n}\n\n// POST /api/v1/projects/activities/{activity_id}/confirm\npub struct ConfirmActivityRequest {\n    pub confirmation_date: NaiveDate,\n    pub actual_work: String,         // Duration\n    pub progress_percentage: Decimal,\n    pub remaining_work: Option<String>,\n}\n\n// GET /api/v1/projects/projects/{project_id}/financials\npub struct GetProjectFinancialsResponse {\n    pub project_number: String,\n    pub project_name: String,\n    pub currency: String,\n    pub budget_data: BudgetData,\n    pub cost_data: CostData,\n    pub revenue_data: RevenueData,\n    pub earned_value_analysis: EarnedValueAnalysis,\n}\n\npub struct BudgetData {\n    pub original_budget: Decimal,\n    pub current_budget: Decimal,\n    pub budget_supplements: Decimal,\n    pub budget_returns: Decimal,\n}\n\npub struct CostData {\n    pub planned_costs: Decimal,\n    pub actual_costs: Decimal,\n    pub committed_costs: Decimal,\n    pub total_costs: Decimal,\n    pub cost_variance: Decimal,\n    pub cost_variance_percentage: Decimal,\n}\n\npub struct RevenueData {\n    pub planned_revenue: Decimal,\n    pub actual_revenue: Decimal,\n    pub invoiced_revenue: Decimal,\n    pub unbilled_revenue: Decimal,\n}\n\npub struct EarnedValueAnalysis {\n    pub planned_value: Decimal,        // PV - Planned Value\n    pub earned_value: Decimal,         // EV - Earned Value\n    pub actual_cost: Decimal,          // AC - Actual Cost\n    pub cost_variance: Decimal,        // CV = EV - AC\n    pub schedule_variance: Decimal,    // SV = EV - PV\n    pub cost_performance_index: Decimal,    // CPI = EV / AC\n    pub schedule_performance_index: Decimal, // SPI = EV / PV\n    pub estimate_at_completion: Decimal,    // EAC\n    pub estimate_to_complete: Decimal,      // ETC\n    pub variance_at_completion: Decimal,    // VAC\n}\n```\n\n### 10.3 领域事件\n\n```rust\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum ProjectDomainEvent {\n    ProjectCreated(ProjectCreated),\n    ProjectStatusChanged(ProjectStatusChanged),\n    WbsElementCreated(WbsElementCreated),\n    NetworkCreated(NetworkCreated),\n    ActivityConfirmed(ActivityConfirmed),\n    ProjectMilestoneReached(ProjectMilestoneReached),\n    ProjectBudgetExceeded(ProjectBudgetExceeded),\n    ProjectCompleted(ProjectCompleted),\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ProjectCreated {\n    pub event_id: Uuid,\n    pub occurred_at: DateTime<Utc>,\n    pub project_id: Uuid,\n    pub project_number: String,\n    pub project_name: String,\n    pub project_type: String,\n    pub project_manager: String,\n    pub start_date: NaiveDate,\n    pub finish_date: NaiveDate,\n    pub original_budget: Decimal,\n    pub currency: String,\n    pub created_by: String,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ProjectBudgetExceeded {\n    pub event_id: Uuid,\n    pub occurred_at: DateTime<Utc>,\n    pub project_id: Uuid,\n    pub project_number: String,\n    pub wbs_element: Option<String>,\n    pub current_budget: Decimal,\n    pub actual_costs: Decimal,\n    pub committed_costs: Decimal,\n    pub total_costs: Decimal,\n    pub budget_utilization_percentage: Decimal,\n    pub exceeded_by: Decimal,\n}\n```\n\n文档将继续补充 HCM, TR, BW/BI 模块...\n\n## 第十一部分：人力资源管理模块 (HCM - Human Capital Management)\n\n### 11.1 数据模型\n\n#### 11.1.1 员工主数据 (Employee Master Data)\n\n```rust\npub struct Employee {\n    pub employee_id: Uuid,\n    pub employee_number: String,       // Format: EMP-000001\n    pub personnel_number: String,      // Legacy/external system number\n    \n    // Personal Information\n    pub personal_data: PersonalData,\n    \n    // Employment Data\n    pub organizational_assignment: OrganizationalAssignment,\n    pub employment_details: EmploymentDetails,\n    \n    // Compensation\n    pub compensation_data: CompensationData,\n    \n    // Time Management\n    pub work_schedule: WorkSchedule,\n    pub time_recording_profile: TimeRecordingProfile,\n    \n    // Payroll\n    pub payroll_area: PayrollArea,\n    pub payment_method: PaymentMethod,\n    pub bank_details: Vec<EmployeeBankAccount>,\n    \n    // Tax & Social Security\n    pub tax_data: TaxData,\n    pub social_security_data: SocialSecurityData,\n    \n    // Absence Entitlements\n    pub leave_entitlements: Vec<LeaveEntitlement>,\n    \n    // Qualifications & Skills\n    pub qualifications: Vec<Qualification>,\n    pub competencies: Vec<Competency>,\n    \n    // Status\n    pub employment_status: EmploymentStatus,\n    pub action_type: Option<ActionType>,  // Hire, Termination, Transfer, etc.\n    pub action_reason: Option<String>,\n    \n    // Dates\n    pub hire_date: NaiveDate,\n    pub seniority_date: Option<NaiveDate>,\n    pub probation_end_date: Option<NaiveDate>,\n    pub termination_date: Option<NaiveDate>,\n    \n    // Audit\n    pub created_at: DateTime<Utc>,\n    pub created_by: UserId,\n    pub last_changed_at: DateTime<Utc>,\n}\n\npub struct PersonalData {\n    pub first_name: String,\n    pub last_name: String,\n    pub middle_name: Option<String>,\n    pub preferred_name: Option<String>,\n    pub title: Option<String>,\n    pub gender: Gender,\n    pub date_of_birth: NaiveDate,\n    pub place_of_birth: Option<String>,\n    pub nationality: Country,\n    pub marital_status: MaritalStatus,\n    pub number_of_children: Option<u8>,\n    \n    // Contact\n    pub personal_email: Option<String>,\n    pub mobile_phone: Option<String>,\n    pub home_phone: Option<String>,\n    pub emergency_contact: Option<EmergencyContact>,\n    \n    // Address\n    pub home_address: Address,\n}\n\npub struct OrganizationalAssignment {\n    pub company_code: CompanyCode,\n    pub personnel_area: PersonnelArea,\n    pub personnel_subarea: PersonnelSubarea,\n    pub organizational_unit: OrganizationalUnit,\n    pub department: Department,\n    pub cost_center: CostCenter,\n    pub position: Position,\n    pub job: Job,\n    pub manager: Option<Uuid>,          // Reports to\n    pub valid_from: NaiveDate,\n    pub valid_to: Option<NaiveDate>,\n}\n\npub struct EmploymentDetails {\n    pub employee_group: EmployeeGroup,   // Active, retiree, etc.\n    pub employee_subgroup: EmployeeSubgroup, // Full-time, part-time, contractor\n    pub contract_type: ContractType,\n    pub employment_percentage: Decimal,\n    pub probation_period_months: Option<u8>,\n    pub notice_period_days: u16,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum EmployeeGroup {\n    Active,\n    Retiree,\n    Pensioner,\n    External,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum EmployeeSubgroup {\n    FullTime,\n    PartTime,\n    Contractor,\n    Intern,\n    Temporary,\n}\n\npub struct CompensationData {\n    pub basic_pay: BasicPay,\n    pub allowances: Vec<Allowance>,\n    pub bonuses: Vec<Bonus>,\n    pub total_annual_compensation: Money,\n}\n\npub struct BasicPay {\n    pub pay_scale_type: PayScaleType,\n    pub pay_scale_area: String,\n    pub pay_scale_group: String,\n    pub pay_scale_level: String,\n    pub annual_salary: Money,\n    pub hourly_rate: Option<Money>,\n    pub currency: Currency,\n    pub effective_date: NaiveDate,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum PayScaleType {\n    MonthlySalary,\n    HourlyWage,\n    DailyWage,\n    PieceRate,\n    Commission,\n}\n\npub struct Allowance {\n    pub allowance_type: String,        // Housing, transport, meal, etc.\n    pub amount: Money,\n    pub frequency: PaymentFrequency,\n    pub taxable: bool,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum PaymentFrequency {\n    Monthly,\n    BiWeekly,\n    Weekly,\n    Daily,\n    OneTime,\n}\n\npub struct WorkSchedule {\n    pub work_schedule_rule: String,\n    pub weekly_working_hours: Decimal,\n    pub daily_working_hours: Decimal,\n    pub working_days_per_week: Decimal,\n    pub shift_group: Option<String>,\n}\n\npub struct LeaveEntitlement {\n    pub leave_type: LeaveType,\n    pub entitlement_days: Decimal,\n    pub used_days: Decimal,\n    pub remaining_days: Decimal,\n    pub validity_start: NaiveDate,\n    pub validity_end: NaiveDate,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum LeaveType {\n    AnnualLeave,\n    SickLeave,\n    MaternityLeave,\n    PaternityLeave,\n    UnpaidLeave,\n    StudyLeave,\n    Sabbatical,\n}\n\npub struct Qualification {\n    pub qualification_id: Uuid,\n    pub qualification_type: String,\n    pub qualification_name: String,\n    pub institution: Option<String>,\n    pub obtained_date: NaiveDate,\n    pub expiry_date: Option<NaiveDate>,\n    pub certificate_number: Option<String>,\n}\n\npub struct Competency {\n    pub competency_id: Uuid,\n    pub competency_type: String,\n    pub competency_name: String,\n    pub proficiency_level: ProficiencyLevel,\n    pub years_of_experience: Option<Decimal>,\n    pub last_used_date: Option<NaiveDate>,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum ProficiencyLevel {\n    Beginner,\n    Intermediate,\n    Advanced,\n    Expert,\n}\n```\n\n#### 11.1.2 考勤管理 (Time & Attendance)\n\n```rust\npub struct TimeRecord {\n    pub record_id: Uuid,\n    pub employee_id: Uuid,\n    pub employee_number: String,\n    pub recording_date: NaiveDate,\n    \n    // Clock In/Out\n    pub clock_in: Option<NaiveDateTime>,\n    pub clock_out: Option<NaiveDateTime>,\n    \n    // Time Type\n    pub time_type: TimeType,\n    pub hours: Decimal,\n    \n    // Break\n    pub break_hours: Decimal,\n    \n    // Calculated Times\n    pub regular_hours: Decimal,\n    pub overtime_hours: Decimal,\n    pub night_shift_hours: Decimal,\n    pub weekend_hours: Decimal,\n    pub holiday_hours: Decimal,\n    \n    // Cost Assignment\n    pub cost_center: Option<CostCenter>,\n    pub internal_order: Option<String>,\n    pub wbs_element: Option<String>,\n    pub activity_type: Option<String>,\n    \n    // Approval\n    pub approval_status: ApprovalStatus,\n    pub approved_by: Option<UserId>,\n    pub approved_at: Option<DateTime<Utc>>,\n    \n    // Status\n    pub record_status: TimeRecordStatus,\n    pub payroll_relevant: bool,\n    pub transferred_to_payroll: bool,\n    \n    // Audit\n    pub created_at: DateTime<Utc>,\n    pub created_by: UserId,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum TimeType {\n    WorkingTime,\n    Overtime,\n    OnCall,\n    Travel,\n    Training,\n}\n\npub struct AbsenceRecord {\n    pub absence_id: Uuid,\n    pub employee_id: Uuid,\n    pub employee_number: String,\n    \n    // Absence Details\n    pub absence_type: AbsenceType,\n    pub start_date: NaiveDate,\n    pub end_date: NaiveDate,\n    pub start_time: Option<NaiveTime>,\n    pub end_time: Option<NaiveTime>,\n    pub absence_days: Decimal,\n    pub absence_hours: Decimal,\n    \n    // Reason\n    pub reason: Option<String>,\n    pub attachment: Option<String>,      // Medical certificate, etc.\n    \n    // Leave Quota Deduction\n    pub deduct_from_quota: bool,\n    pub quota_deducted: Decimal,\n    \n    // Approval\n    pub approval_required: bool,\n    pub approval_status: ApprovalStatus,\n    pub approved_by: Option<UserId>,\n    pub approved_at: Option<DateTime<Utc>>,\n    \n    // Status\n    pub absence_status: AbsenceStatus,\n    \n    // Audit\n    pub created_at: DateTime<Utc>,\n    pub created_by: UserId,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum AbsenceType {\n    AnnualLeave,\n    SickLeave,\n    MaternityLeave,\n    PaternityLeave,\n    UnpaidLeave,\n    PublicHoliday,\n    CompensatoryTimeOff,\n    Training,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum AbsenceStatus {\n    Requested,\n    Approved,\n    Rejected,\n    Cancelled,\n    Taken,\n}\n```\n\n#### 11.1.3 薪资运算 (Payroll)\n\n```rust\npub struct PayrollRun {\n    pub payroll_run_id: Uuid,\n    pub payroll_period: PayrollPeriod,\n    pub payroll_area: PayrollArea,\n    pub company_code: CompanyCode,\n    \n    // Run Details\n    pub run_date: NaiveDate,\n    pub payment_date: NaiveDate,\n    pub accounting_period: Period,\n    \n    // Scope\n    pub personnel_numbers: Vec<String>,\n    pub total_employees: u32,\n    pub successful_count: u32,\n    pub error_count: u32,\n    \n    // Results\n    pub payslips: Vec<Uuid>,             // References to payslip records\n    pub total_gross_pay: Money,\n    pub total_net_pay: Money,\n    pub total_employer_contributions: Money,\n    \n    // Accounting Integration\n    pub accounting_documents: Vec<Uuid>,\n    pub posted_to_fi: bool,\n    pub posting_date: Option<NaiveDate>,\n    \n    // Status\n    pub payroll_status: PayrollStatus,\n    \n    // Audit\n    pub executed_at: DateTime<Utc>,\n    pub executed_by: UserId,\n}\n\npub struct Payslip {\n    pub payslip_id: Uuid,\n    pub payroll_run_id: Uuid,\n    pub employee_id: Uuid,\n    pub employee_number: String,\n    pub payroll_period: PayrollPeriod,\n    \n    // Earnings\n    pub basic_salary: Money,\n    pub allowances: Vec<PayslipItem>,\n    pub overtime_pay: Money,\n    pub bonuses: Vec<PayslipItem>,\n    pub gross_earnings: Money,\n    \n    // Deductions\n    pub income_tax: Money,\n    pub social_security: Money,\n    pub pension_contribution: Money,\n    pub health_insurance: Money,\n    pub other_deductions: Vec<PayslipItem>,\n    pub total_deductions: Money,\n    \n    // Net Pay\n    pub net_pay: Money,\n    pub currency: Currency,\n    \n    // Employer Contributions\n    pub employer_social_security: Money,\n    pub employer_pension: Money,\n    pub employer_health_insurance: Money,\n    pub total_employer_contributions: Money,\n    \n    // Payment\n    pub payment_method: PaymentMethod,\n    pub bank_account_number: Option<String>,\n    pub payment_reference: Option<String>,\n    \n    // Year-to-Date Totals\n    pub ytd_gross_earnings: Money,\n    pub ytd_deductions: Money,\n    pub ytd_net_pay: Money,\n    \n    // Status\n    pub payslip_status: PayslipStatus,\n    \n    // Generated\n    pub generated_at: DateTime<Utc>,\n}\n\npub struct PayslipItem {\n    pub item_type: String,\n    pub description: String,\n    pub amount: Money,\n    pub quantity: Option<Decimal>,\n    pub rate: Option<Money>,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub struct PayrollPeriod {\n    pub year: u16,\n    pub period: u8,                    // 1-12 for monthly, 1-26 for biweekly\n    pub period_start: NaiveDate,\n    pub period_end: NaiveDate,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum PayrollStatus {\n    InProgress,\n    Completed,\n    Released,\n    Posted,\n    Corrected,\n}\n```\n\n### 11.2 API 规格\n\n```rust\n// POST /api/v1/hr/employees\npub struct CreateEmployeeRequest {\n    pub first_name: String,\n    pub last_name: String,\n    pub date_of_birth: NaiveDate,\n    pub gender: String,\n    pub nationality: String,\n    pub hire_date: NaiveDate,\n    pub company_code: String,\n    pub organizational_unit: String,\n    pub position: String,\n    pub employee_group: String,\n    pub employee_subgroup: String,\n    pub basic_annual_salary: Decimal,\n    pub currency: String,\n}\n\n// POST /api/v1/hr/time-records\npub struct CreateTimeRecordRequest {\n    pub employee_id: Uuid,\n    pub recording_date: NaiveDate,\n    pub clock_in: NaiveDateTime,\n    pub clock_out: Option<NaiveDateTime>,\n    pub time_type: String,\n    pub cost_center: Option<String>,\n}\n\n// POST /api/v1/hr/absences\npub struct CreateAbsenceRequest {\n    pub employee_id: Uuid,\n    pub absence_type: String,\n    pub start_date: NaiveDate,\n    pub end_date: NaiveDate,\n    pub reason: Option<String>,\n    pub attachment: Option<String>,\n}\n\n// POST /api/v1/hr/payroll-runs\npub struct ExecutePayrollRunRequest {\n    pub payroll_area: String,\n    pub payroll_period: PayrollPeriodRequest,\n    pub payment_date: NaiveDate,\n    pub personnel_numbers: Option<Vec<String>>, // All if None\n    pub simulation: bool,\n}\n\npub struct ExecutePayrollRunResponse {\n    pub payroll_run_id: Uuid,\n    pub total_employees: u32,\n    pub successful_count: u32,\n    pub error_count: u32,\n    pub total_gross_pay: Decimal,\n    pub total_net_pay: Decimal,\n    pub errors: Vec<PayrollError>,\n    pub executed_at: DateTime<Utc>,\n}\n\npub struct PayrollError {\n    pub employee_number: String,\n    pub error_code: String,\n    pub error_message: String,\n}\n\n// GET /api/v1/hr/employees/{employee_id}/payslip\npub struct GetPayslipQuery {\n    pub payroll_period_year: u16,\n    pub payroll_period_number: u8,\n}\n```\n\n### 11.3 领域事件\n\n```rust\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum HcmDomainEvent {\n    EmployeeHired(EmployeeHired),\n    EmployeeTerminated(EmployeeTerminated),\n    EmployeeTransferred(EmployeeTransferred),\n    AbsenceRequested(AbsenceRequested),\n    AbsenceApproved(AbsenceApproved),\n    TimeRecordSubmitted(TimeRecordSubmitted),\n    PayrollRunCompleted(PayrollRunCompleted),\n    PayslipGenerated(PayslipGenerated),\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct EmployeeHired {\n    pub event_id: Uuid,\n    pub occurred_at: DateTime<Utc>,\n    pub employee_id: Uuid,\n    pub employee_number: String,\n    pub first_name: String,\n    pub last_name: String,\n    pub hire_date: NaiveDate,\n    pub company_code: String,\n    pub organizational_unit: String,\n    pub position: String,\n    pub annual_salary: Decimal,\n    pub currency: String,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct PayrollRunCompleted {\n    pub event_id: Uuid,\n    pub occurred_at: DateTime<Utc>,\n    pub payroll_run_id: Uuid,\n    pub payroll_period: PayrollPeriod,\n    pub payroll_area: String,\n    pub total_employees: u32,\n    pub total_gross_pay: Decimal,\n    pub total_net_pay: Decimal,\n    pub total_employer_contributions: Decimal,\n    pub currency: String,\n    pub payment_date: NaiveDate,\n}\n```\n\n---\n\n## 第十二部分：资金管理模块 (TR - Treasury)\n\n### 12.1 数据模型\n\n#### 12.1.1 现金管理 (Cash Management)\n\n```rust\npub struct BankAccount {\n    pub bank_account_id: Uuid,\n    pub house_bank: HouseBank,\n    pub account_id: String,\n    pub bank_account_number: String,\n    pub iban: Option<String>,\n    pub swift_code: Option<String>,\n    \n    // Bank Details\n    pub bank_name: String,\n    pub bank_branch: Option<String>,\n    pub bank_country: Country,\n    \n    // Account Details\n    pub account_holder: String,\n    pub account_currency: Currency,\n    pub account_type: BankAccountType,\n    \n    // Company Assignment\n    pub company_code: CompanyCode,\n    pub gl_account: String,           // Link to FI GL account\n    \n    // Control\n    pub available_for_payment: bool,\n    pub available_for_receipts: bool,\n    pub planning_type: Option<PlanningType>,\n    \n    // Balance\n    pub current_balance: Money,\n    pub available_balance: Money,\n    pub ledger_balance: Money,\n    pub last_statement_date: Option<NaiveDate>,\n    \n    // Limits\n    pub overdraft_limit: Option<Money>,\n    pub maximum_balance: Option<Money>,\n    \n    // Status\n    pub account_status: BankAccountStatus,\n    \n    // Audit\n    pub created_at: DateTime<Utc>,\n    pub created_by: UserId,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum BankAccountType {\n    Checking,\n    Savings,\n    TimeDeposit,\n    CreditLine,\n    LoanAccount,\n}\n\npub struct CashPosition {\n    pub position_id: Uuid,\n    pub company_code: CompanyCode,\n    pub value_date: NaiveDate,\n    pub currency: Currency,\n    \n    // Opening Balance\n    pub opening_balance: Money,\n    \n    // Inflows\n    pub customer_payments_received: Money,\n    pub loan_disbursements: Money,\n    pub investment_maturities: Money,\n    pub other_inflows: Money,\n    pub total_inflows: Money,\n    \n    // Outflows\n    pub vendor_payments_made: Money,\n    pub salary_payments: Money,\n    pub loan_repayments: Money,\n    pub investment_purchases: Money,\n    pub tax_payments: Money,\n    pub other_outflows: Money,\n    pub total_outflows: Money,\n    \n    // Closing Balance\n    pub closing_balance: Money,\n    \n    // Calculated\n    pub net_cash_flow: Money,\n    pub cumulative_cash_flow: Money,\n    \n    // Status\n    pub position_type: CashPositionType,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum CashPositionType {\n    Actual,\n    Planned,\n    Forecast,\n}\n```\n\n#### 12.1.2 流动性预测 (Liquidity Forecast)\n\n```rust\npub struct LiquidityForecast {\n    pub forecast_id: Uuid,\n    pub company_code: CompanyCode,\n    pub currency: Currency,\n    pub forecast_date: NaiveDate,\n    pub forecast_horizon_days: u16,\n    \n    // Forecast Method\n    pub forecast_method: ForecastMethod,\n    pub confidence_level: Decimal,       // Percentage\n    \n    // Daily Forecast\n    pub daily_forecasts: Vec<DailyLiquidityForecast>,\n    \n    // Summary\n    pub minimum_balance_date: NaiveDate,\n    pub minimum_balance_amount: Money,\n    pub maximum_balance_date: NaiveDate,\n    pub maximum_balance_amount: Money,\n    \n    // Alerts\n    pub liquidity_alerts: Vec<LiquidityAlert>,\n    \n    // Status\n    pub forecast_status: ForecastStatus,\n    \n    // Generated\n    pub generated_at: DateTime<Utc>,\n    pub generated_by: UserId,\n}\n\npub struct DailyLiquidityForecast {\n    pub value_date: NaiveDate,\n    pub opening_balance: Money,\n    pub expected_inflows: Money,\n    pub expected_outflows: Money,\n    pub closing_balance: Money,\n    pub inflow_details: Vec<CashFlowItem>,\n    pub outflow_details: Vec<CashFlowItem>,\n}\n\npub struct CashFlowItem {\n    pub item_type: CashFlowType,\n    pub description: String,\n    pub amount: Money,\n    pub confidence: Decimal,            // Percentage\n    pub source_document: Option<String>,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum CashFlowType {\n    CustomerPayment,\n    VendorPayment,\n    SalaryPayment,\n    TaxPayment,\n    LoanPayment,\n    InvestmentMaturity,\n    DividendPayment,\n    InterestIncome,\n    InterestExpense,\n    Other,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum ForecastMethod {\n    RuleBased,              // Based on payment terms\n    HistoricalAverage,      // Based on historical patterns\n    MachineLearning,        // ML-based prediction\n    Manual,                 // Manual entry\n}\n\npub struct LiquidityAlert {\n    pub alert_id: Uuid,\n    pub alert_type: AlertType,\n    pub severity: AlertSeverity,\n    pub value_date: NaiveDate,\n    pub forecasted_balance: Money,\n    pub threshold: Money,\n    pub message: String,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum AlertType {\n    InsufficientFunds,\n    ExcessCash,\n    CreditLimitExceeded,\n    LargePaymentDue,\n}\n```\n\n#### 12.1.3 金融交易 (Financial Transactions)\n\n```rust\npub struct FinancialTransaction {\n    pub transaction_id: Uuid,\n    pub transaction_type: FinancialTransactionType,\n    pub transaction_number: String,\n    \n    // Parties\n    pub company_code: CompanyCode,\n    pub counterparty: Option<Counterparty>,\n    \n    // Financial Details\n    pub transaction_currency: Currency,\n    pub transaction_amount: Money,\n    pub local_currency: Currency,\n    pub local_amount: Money,\n    pub exchange_rate: Option<ExchangeRate>,\n    \n    // Dates\n    pub trade_date: NaiveDate,\n    pub value_date: NaiveDate,\n    pub maturity_date: Option<NaiveDate>,\n    \n    // Terms\n    pub interest_rate: Option<Decimal>,\n    pub tenor_days: Option<u16>,\n    \n    // Settlement\n    pub settlement_account: Option<Uuid>,\n    pub settlement_status: SettlementStatus,\n    pub settled_date: Option<NaiveDate>,\n    \n    // Accounting\n    pub accounting_document_id: Option<Uuid>,\n    pub accounting_treatment: AccountingTreatment,\n    \n    // Status\n    pub transaction_status: TransactionStatus,\n    \n    // Audit\n    pub created_at: DateTime<Utc>,\n    pub created_by: UserId,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum FinancialTransactionType {\n    ForeignExchange,        // FX spot/forward\n    MoneyMarketDeposit,    // Time deposit\n    MoneyMarketLoan,       // Short-term borrowing\n    FxForwardContract,     // FX hedging\n    InterestRateSwap,      // Interest rate hedging\n    CommodityHedge,        // Commodity price hedging\n}\n\npub struct Counterparty {\n    pub counterparty_id: Uuid,\n    pub counterparty_name: String,\n    pub counterparty_type: CounterpartyType,\n    pub credit_rating: Option<CreditRating>,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum CounterpartyType {\n    Bank,\n    CorporateEntity,\n    GovernmentEntity,\n    InvestmentFund,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum SettlementStatus {\n    Pending,\n    Settled,\n    Failed,\n    Cancelled,\n}\n```\n\n### 12.2 API 规格\n\n```rust\n// POST /api/v1/treasury/bank-accounts\npub struct CreateBankAccountRequest {\n    pub house_bank: String,\n    pub account_id: String,\n    pub bank_account_number: String,\n    pub iban: Option<String>,\n    pub swift_code: Option<String>,\n    pub bank_name: String,\n    pub account_currency: String,\n    pub company_code: String,\n    pub gl_account: String,\n}\n\n// POST /api/v1/treasury/cash-positions\npub struct RecordCashPositionRequest {\n    pub company_code: String,\n    pub value_date: NaiveDate,\n    pub currency: String,\n    pub opening_balance: Decimal,\n    pub inflows: CashFlowsRequest,\n    pub outflows: CashFlowsRequest,\n}\n\n// POST /api/v1/treasury/liquidity-forecast\npub struct GenerateLiquidityForecastRequest {\n    pub company_code: String,\n    pub currency: String,\n    pub forecast_horizon_days: u16,\n    pub forecast_method: String,\n}\n\npub struct GenerateLiquidityForecastResponse {\n    pub forecast_id: Uuid,\n    pub forecast_date: NaiveDate,\n    pub daily_forecasts: Vec<DailyForecastSummary>,\n    pub minimum_balance: ForecastExtreme,\n    pub maximum_balance: ForecastExtreme,\n    pub alerts: Vec<LiquidityAlertDto>,\n}\n\npub struct ForecastExtreme {\n    pub date: NaiveDate,\n    pub amount: Decimal,\n}\n\n// POST /api/v1/treasury/financial-transactions\npub struct CreateFinancialTransactionRequest {\n    pub transaction_type: String,\n    pub company_code: String,\n    pub counterparty_id: Option<Uuid>,\n    pub transaction_currency: String,\n    pub transaction_amount: Decimal,\n    pub trade_date: NaiveDate,\n    pub value_date: NaiveDate,\n    pub maturity_date: Option<NaiveDate>,\n    pub interest_rate: Option<Decimal>,\n}\n\n// GET /api/v1/treasury/cash-flow-analysis\npub struct GetCashFlowAnalysisQuery {\n    pub company_code: String,\n    pub currency: String,\n    pub date_from: NaiveDate,\n    pub date_to: NaiveDate,\n    pub analysis_type: String,        // Daily, Weekly, Monthly\n}\n\npub struct GetCashFlowAnalysisResponse {\n    pub company_code: String,\n    pub currency: String,\n    pub period_from: NaiveDate,\n    pub period_to: NaiveDate,\n    pub periods: Vec<PeriodCashFlow>,\n    pub total_inflows: Decimal,\n    pub total_outflows: Decimal,\n    pub net_cash_flow: Decimal,\n}\n\npub struct PeriodCashFlow {\n    pub period_start: NaiveDate,\n    pub period_end: NaiveDate,\n    pub opening_balance: Decimal,\n    pub inflows: Decimal,\n    pub outflows: Decimal,\n    pub closing_balance: Decimal,\n}\n```\n\n### 12.3 领域事件\n\n```rust\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum TreasuryDomainEvent {\n    BankAccountCreated(BankAccountCreated),\n    CashPositionRecorded(CashPositionRecorded),\n    LiquidityAlertTriggered(LiquidityAlertTriggered),\n    FinancialTransactionExecuted(FinancialTransactionExecuted),\n    PaymentExecuted(PaymentExecuted),\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct LiquidityAlertTriggered {\n    pub event_id: Uuid,\n    pub occurred_at: DateTime<Utc>,\n    pub alert_id: Uuid,\n    pub alert_type: String,\n    pub severity: String,\n    pub company_code: String,\n    pub value_date: NaiveDate,\n    pub forecasted_balance: Decimal,\n    pub threshold: Decimal,\n    pub currency: String,\n    pub message: String,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct FinancialTransactionExecuted {\n    pub event_id: Uuid,\n    pub occurred_at: DateTime<Utc>,\n    pub transaction_id: Uuid,\n    pub transaction_number: String,\n    pub transaction_type: String,\n    pub company_code: String,\n    pub transaction_currency: String,\n    pub transaction_amount: Decimal,\n    pub trade_date: NaiveDate,\n    pub value_date: NaiveDate,\n    pub counterparty: Option<String>,\n    pub created_by: String,\n}\n```\n\n---\n\n## 总结\n\n本 **Rust ERP Domain Specifications** 文档现已完成12个核心模块的详细技术规格：\n\n✅ **FI (Financial Accounting)** - 财务会计  \n✅ **CO (Controlling)** - 成本控制  \n✅ **MM (Materials Management)** - 物料管理  \n✅ **SD (Sales & Distribution)** - 销售分销  \n✅ **PP (Production Planning)** - 生产计划  \n✅ **WM/EWM (Warehouse Management)** - 仓库管理  \n✅ **QM (Quality Management)** - 质量管理  \n✅ **PM (Plant Maintenance)** - 设备维护  \n✅ **PS (Project System)** - 项目系统  \n✅ **HCM (Human Capital Management)** - 人力资源  \n✅ **TR (Treasury)** - 资金管理  \n✅ **Cross-Module Integration** - 跨模块集成架构\n\n每个模块包含：\n- 📊 完整的领域数据模型（Rust structs）\n- 🔌 RESTful API 规格（Request/Response DTOs）\n- 📡 领域事件定义（Event-driven架构）\n- 🔄 业务流程事件链（P2P, O2C, Production）\n- 🏗️ 集成架构设计（Event routing, Saga pattern）\n\n配合已有文档使用：\n1. **Rust-BOM.md** → 功能清单 (WHAT)\n2. **Rust-Abc-Enhanced.md** → 12月开发计划 (WHEN)\n3. **Rust-Implementation-Guide.md** → 技术实施指南 (HOW)\n4. **Rust-Domain-Specifications.md** (本文档) → API与数据模型 (WHAT EXACTLY)\n\n您的开发团队现在拥有完整的技术蓝图来构建生产级 Rust ERP 系统！🚀\n\n## 第十三部分：商业智能与数据仓库 (BW/BI - Business Intelligence & Data Warehouse)\n\n### 13.1 数据仓库架构\n\n#### 13.1.1 分层架构设计\n\n```rust\n// Data Warehouse Layered Architecture\npub struct DataWarehouseArchitecture {\n    pub staging_layer: StagingLayer,\n    pub ods_layer: OdsLayer,              // Operational Data Store\n    pub dw_layer: DwLayer,                // Data Warehouse Core\n    pub data_mart_layer: DataMartLayer,   // Subject-specific data marts\n    pub semantic_layer: SemanticLayer,    // Business view\n}\n\n// Staging Layer - Raw data from source systems\npub struct StagingLayer {\n    pub staging_tables: Vec<StagingTable>,\n    pub extraction_logs: Vec<ExtractionLog>,\n    pub data_quality_checks: Vec<QualityCheck>,\n}\n\npub struct StagingTable {\n    pub table_name: String,\n    pub source_system: String,           // FI, MM, SD, etc.\n    pub last_extracted_at: DateTime<Utc>,\n    pub row_count: u64,\n    pub extraction_mode: ExtractionMode,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum ExtractionMode {\n    Full,                  // Full extraction\n    Incremental,          // Only changes since last extraction\n    Delta,                // Change data capture (CDC)\n    RealTime,             // Real-time streaming\n}\n\n// ODS Layer - Integrated operational data\npub struct OdsLayer {\n    pub entities: Vec<OdsEntity>,\n    pub update_frequency: UpdateFrequency,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum UpdateFrequency {\n    RealTime,\n    Hourly,\n    Daily,\n    Weekly,\n}\n\n// Data Warehouse Core - Historical, integrated data\npub struct DwLayer {\n    pub fact_tables: Vec<FactTable>,\n    pub dimension_tables: Vec<DimensionTable>,\n    pub bridge_tables: Vec<BridgeTable>,\n}\n\n// Data Mart Layer - Subject-specific aggregated data\npub struct DataMartLayer {\n    pub data_marts: Vec<DataMart>,\n}\n\npub struct DataMart {\n    pub mart_id: Uuid,\n    pub mart_name: String,\n    pub subject_area: SubjectArea,\n    pub fact_tables: Vec<String>,\n    pub dimensions: Vec<String>,\n    pub refresh_schedule: RefreshSchedule,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum SubjectArea {\n    Financial,\n    Sales,\n    Purchasing,\n    Inventory,\n    Production,\n    HumanResources,\n    CustomerAnalytics,\n}\n```\n\n#### 13.1.2 维度建模 - 星型模式\n\n```rust\n// Fact Table - Measures and foreign keys to dimensions\npub struct FactTable {\n    pub fact_id: Uuid,\n    pub table_name: String,\n    pub fact_type: FactType,\n    pub grain: String,                    // e.g., \"One row per document line item\"\n    \n    // Dimension Foreign Keys\n    pub dimension_keys: Vec<DimensionKey>,\n    \n    // Measures (Additive, Semi-additive, Non-additive)\n    pub measures: Vec<Measure>,\n    \n    // Degenerate Dimensions (dimensions stored in fact table)\n    pub degenerate_dimensions: Vec<DegenerateDimension>,\n    \n    // Partitioning\n    pub partitioned_by: Option<String>,  // e.g., \"posting_date\"\n    pub partition_type: PartitionType,\n    \n    // Metadata\n    pub row_count: u64,\n    pub last_updated: DateTime<Utc>,\n    pub data_retention_days: u16,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum FactType {\n    Transaction,          // e.g., Sales transactions, GL postings\n    PeriodicSnapshot,    // e.g., Daily inventory levels\n    AccumulatingSnapshot, // e.g., Order fulfillment pipeline\n}\n\npub struct DimensionKey {\n    pub dimension_name: String,\n    pub foreign_key_column: String,\n    pub relationship_type: RelationshipType,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum RelationshipType {\n    ManyToOne,\n    ManyToMany,          // Requires bridge table\n}\n\npub struct Measure {\n    pub measure_name: String,\n    pub column_name: String,\n    pub data_type: MeasureDataType,\n    pub aggregation_type: AggregationType,\n    pub additivity: Additivity,\n    pub unit: Option<String>,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum AggregationType {\n    Sum,\n    Average,\n    Count,\n    DistinctCount,\n    Min,\n    Max,\n    StandardDeviation,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum Additivity {\n    Additive,            // Can sum across all dimensions (e.g., sales amount)\n    SemiAdditive,        // Can sum across some dimensions (e.g., inventory balance)\n    NonAdditive,         // Cannot sum (e.g., ratios, percentages)\n}\n\n// Dimension Table - Descriptive attributes\npub struct DimensionTable {\n    pub dimension_id: Uuid,\n    pub table_name: String,\n    pub dimension_type: DimensionType,\n    \n    // Surrogate Key\n    pub surrogate_key_column: String,\n    \n    // Natural Key (from source system)\n    pub natural_key_columns: Vec<String>,\n    \n    // Attributes\n    pub attributes: Vec<DimensionAttribute>,\n    \n    // Hierarchy\n    pub hierarchies: Vec<Hierarchy>,\n    \n    // Slowly Changing Dimension (SCD) Type\n    pub scd_type: ScdType,\n    \n    // Metadata\n    pub row_count: u64,\n    pub last_updated: DateTime<Utc>,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum DimensionType {\n    Standard,\n    Conformed,           // Shared across multiple fact tables\n    Degenerate,          // Stored in fact table\n    RolePlayingCustomer, // Same dimension used multiple times with different roles\n    Junk,               // Low-cardinality flags\n    Date,               // Time dimension\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum ScdType {\n    Type0,              // No changes tracked\n    Type1,              // Overwrite old value\n    Type2,              // Create new row with version\n    Type3,              // Add new column for old value\n    Type4,              // Separate history table\n    Type6,              // Hybrid (1+2+3)\n}\n\npub struct DimensionAttribute {\n    pub attribute_name: String,\n    pub column_name: String,\n    pub data_type: AttributeDataType,\n    pub is_hierarchical: bool,\n    pub parent_attribute: Option<String>,\n}\n\npub struct Hierarchy {\n    pub hierarchy_name: String,\n    pub levels: Vec<HierarchyLevel>,\n}\n\npub struct HierarchyLevel {\n    pub level_number: u8,\n    pub level_name: String,\n    pub attribute_name: String,\n}\n```\n\n#### 13.1.3 主要事实表设计\n\n```rust\n// Financial Fact Tables\npub struct FactGlPosting {\n    // Surrogate Key\n    pub gl_posting_key: i64,\n    \n    // Dimension Keys\n    pub date_key: i32,\n    pub company_code_key: i32,\n    pub account_key: i32,\n    pub cost_center_key: Option<i32>,\n    pub profit_center_key: Option<i32>,\n    pub business_partner_key: Option<i32>,\n    pub currency_key: i32,\n    \n    // Degenerate Dimensions\n    pub document_number: String,\n    pub line_item_number: u16,\n    pub posting_key: String,             // Debit/Credit indicator\n    \n    // Measures\n    pub amount_in_document_currency: Decimal,\n    pub amount_in_local_currency: Decimal,\n    pub amount_in_group_currency: Decimal,\n    pub quantity: Option<Decimal>,\n    \n    // Metadata\n    pub source_system_id: String,\n    pub load_timestamp: DateTime<Utc>,\n}\n\n// Sales Fact Tables\npub struct FactSalesOrder {\n    // Surrogate Key\n    pub sales_order_key: i64,\n    \n    // Dimension Keys\n    pub order_date_key: i32,\n    pub requested_delivery_date_key: i32,\n    pub customer_key: i32,\n    pub sold_to_party_key: i32,\n    pub ship_to_party_key: i32,\n    pub bill_to_party_key: i32,\n    pub material_key: i32,\n    pub sales_org_key: i32,\n    pub distribution_channel_key: i32,\n    pub division_key: i32,\n    pub plant_key: i32,\n    pub sales_employee_key: Option<i32>,\n    \n    // Degenerate Dimensions\n    pub order_number: String,\n    pub item_number: u16,\n    pub order_type: String,\n    pub order_category: String,\n    \n    // Measures (Additive)\n    pub order_quantity: Decimal,\n    pub confirmed_quantity: Decimal,\n    pub delivered_quantity: Decimal,\n    pub billed_quantity: Decimal,\n    pub net_value: Decimal,\n    pub cost: Decimal,\n    pub gross_margin: Decimal,\n    \n    // Measures (Semi-additive)\n    pub net_price_per_unit: Decimal,\n    \n    // Measures (Non-additive)\n    pub gross_margin_percentage: Decimal,\n    \n    // Flags (Junk Dimension candidates)\n    pub credit_check_passed: bool,\n    pub delivery_complete_flag: bool,\n    pub billing_complete_flag: bool,\n    \n    // Metadata\n    pub current_status: String,\n    pub load_timestamp: DateTime<Utc>,\n}\n\n// Inventory Fact Tables (Periodic Snapshot)\npub struct FactInventoryDaily {\n    // Surrogate Key\n    pub inventory_snapshot_key: i64,\n    \n    // Dimension Keys\n    pub date_key: i32,\n    pub material_key: i32,\n    pub plant_key: i32,\n    pub storage_location_key: i32,\n    pub batch_key: Option<i32>,\n    pub stock_type_key: i32,\n    \n    // Measures (Semi-additive - can't sum across time)\n    pub unrestricted_stock_quantity: Decimal,\n    pub quality_inspection_quantity: Decimal,\n    pub blocked_stock_quantity: Decimal,\n    pub total_stock_quantity: Decimal,\n    pub stock_value: Decimal,\n    \n    // Measures (Additive)\n    pub receipts_quantity: Decimal,\n    pub issues_quantity: Decimal,\n    pub adjustments_quantity: Decimal,\n    \n    // Calculated Measures\n    pub days_of_supply: Option<Decimal>,\n    pub stock_turnover_ratio: Option<Decimal>,\n    \n    // Metadata\n    pub load_timestamp: DateTime<Utc>,\n}\n\n// Production Fact Tables\npub struct FactProductionOrder {\n    // Surrogate Key\n    pub production_order_key: i64,\n    \n    // Dimension Keys\n    pub order_date_key: i32,\n    pub start_date_key: i32,\n    pub finish_date_key: i32,\n    pub material_key: i32,\n    pub plant_key: i32,\n    pub production_supervisor_key: Option<i32>,\n    pub bom_key: Option<i32>,\n    pub routing_key: Option<i32>,\n    \n    // Degenerate Dimensions\n    pub order_number: String,\n    pub order_type: String,\n    \n    // Measures\n    pub target_quantity: Decimal,\n    pub confirmed_yield_quantity: Decimal,\n    pub scrap_quantity: Decimal,\n    pub planned_costs: Decimal,\n    pub actual_costs: Decimal,\n    pub cost_variance: Decimal,\n    pub planned_duration_hours: Decimal,\n    pub actual_duration_hours: Decimal,\n    \n    // Flags\n    pub on_time_completion: bool,\n    pub within_budget: bool,\n    \n    // Metadata\n    pub current_status: String,\n    pub load_timestamp: DateTime<Utc>,\n}\n\n// Purchasing Fact Tables\npub struct FactPurchaseOrder {\n    // Surrogate Key\n    pub po_key: i64,\n    \n    // Dimension Keys\n    pub po_date_key: i32,\n    pub delivery_date_key: i32,\n    pub vendor_key: i32,\n    pub material_key: i32,\n    pub plant_key: i32,\n    pub purchasing_org_key: i32,\n    pub purchasing_group_key: i32,\n    pub buyer_key: Option<i32>,\n    \n    // Degenerate Dimensions\n    pub po_number: String,\n    pub item_number: u16,\n    pub po_type: String,\n    \n    // Measures\n    pub order_quantity: Decimal,\n    pub received_quantity: Decimal,\n    pub invoiced_quantity: Decimal,\n    pub net_value: Decimal,\n    pub net_price_per_unit: Decimal,\n    \n    // Lead Time Measures\n    pub planned_delivery_days: i32,\n    pub actual_delivery_days: Option<i32>,\n    pub delivery_variance_days: Option<i32>,\n    \n    // Quality Measures\n    pub rejected_quantity: Decimal,\n    pub quality_defect_rate: Decimal,\n    \n    // Flags\n    pub on_time_delivery: Option<bool>,\n    pub quality_passed: Option<bool>,\n    \n    // Metadata\n    pub current_status: String,\n    pub load_timestamp: DateTime<Utc>,\n}\n```\n\n#### 13.1.4 主要维度表设计\n\n```rust\n// Date Dimension (Type 2 SCD - but typically not changed)\npub struct DimDate {\n    pub date_key: i32,                   // Surrogate key: YYYYMMDD (e.g., 20250101)\n    pub full_date: NaiveDate,\n    pub day_of_week: u8,                 // 1-7\n    pub day_name: String,                // Monday, Tuesday, etc.\n    pub day_of_month: u8,\n    pub day_of_year: u16,\n    pub week_of_year: u8,\n    pub iso_week: u8,\n    pub month: u8,\n    pub month_name: String,\n    pub quarter: u8,\n    pub quarter_name: String,\n    pub year: i32,\n    pub fiscal_year: i32,\n    pub fiscal_period: u8,\n    pub fiscal_quarter: u8,\n    pub is_weekend: bool,\n    pub is_holiday: bool,\n    pub holiday_name: Option<String>,\n    pub is_working_day: bool,\n    pub week_start_date: NaiveDate,\n    pub week_end_date: NaiveDate,\n    pub month_start_date: NaiveDate,\n    pub month_end_date: NaiveDate,\n    pub quarter_start_date: NaiveDate,\n    pub quarter_end_date: NaiveDate,\n    pub year_start_date: NaiveDate,\n    pub year_end_date: NaiveDate,\n}\n\n// Material Dimension (Type 2 SCD)\npub struct DimMaterial {\n    pub material_key: i32,               // Surrogate key\n    pub material_number: String,         // Natural key\n    pub material_description: String,\n    pub material_type: String,\n    pub material_group: String,\n    pub material_group_desc: String,\n    pub base_unit_of_measure: String,\n    pub product_hierarchy_level1: String,\n    pub product_hierarchy_level2: String,\n    pub product_hierarchy_level3: String,\n    pub product_hierarchy_level4: String,\n    pub gross_weight: Option<Decimal>,\n    pub net_weight: Option<Decimal>,\n    pub weight_unit: Option<String>,\n    pub volume: Option<Decimal>,\n    pub volume_unit: Option<String>,\n    pub abc_indicator: Option<String>,\n    \n    // SCD Type 2 fields\n    pub effective_from_date: NaiveDate,\n    pub effective_to_date: Option<NaiveDate>,\n    pub is_current: bool,\n    pub version: u32,\n    \n    // Audit\n    pub source_system_id: String,\n    pub created_timestamp: DateTime<Utc>,\n    pub last_updated_timestamp: DateTime<Utc>,\n}\n\n// Customer Dimension (Type 2 SCD)\npub struct DimCustomer {\n    pub customer_key: i32,               // Surrogate key\n    pub customer_number: String,         // Natural key\n    pub customer_name: String,\n    pub customer_group: String,\n    pub customer_group_desc: String,\n    pub industry_sector: String,\n    pub country: String,\n    pub region: String,\n    pub city: String,\n    pub postal_code: String,\n    pub credit_limit: Decimal,\n    pub payment_terms: String,\n    pub abc_classification: Option<String>,\n    pub customer_since_date: NaiveDate,\n    \n    // Hierarchy (for aggregation)\n    pub sales_region: String,\n    pub sales_district: String,\n    pub sales_territory: String,\n    \n    // SCD Type 2 fields\n    pub effective_from_date: NaiveDate,\n    pub effective_to_date: Option<NaiveDate>,\n    pub is_current: bool,\n    pub version: u32,\n    \n    // Audit\n    pub source_system_id: String,\n    pub created_timestamp: DateTime<Utc>,\n    pub last_updated_timestamp: DateTime<Utc>,\n}\n\n// Vendor Dimension (Type 2 SCD)\npub struct DimVendor {\n    pub vendor_key: i32,\n    pub vendor_number: String,\n    pub vendor_name: String,\n    pub vendor_group: String,\n    pub country: String,\n    pub region: String,\n    pub city: String,\n    pub payment_terms: String,\n    pub currency: String,\n    pub abc_indicator: Option<String>,\n    pub vendor_since_date: NaiveDate,\n    \n    // Performance Metrics (Type 1 SCD - overwrite)\n    pub on_time_delivery_rate: Decimal,\n    pub quality_rating: Decimal,\n    pub last_performance_review_date: Option<NaiveDate>,\n    \n    // SCD Type 2 fields\n    pub effective_from_date: NaiveDate,\n    pub effective_to_date: Option<NaiveDate>,\n    pub is_current: bool,\n    pub version: u32,\n    \n    // Audit\n    pub source_system_id: String,\n    pub created_timestamp: DateTime<Utc>,\n    pub last_updated_timestamp: DateTime<Utc>,\n}\n\n// Account Dimension (Chart of Accounts)\npub struct DimAccount {\n    pub account_key: i32,\n    pub account_number: String,\n    pub account_name: String,\n    pub account_group: String,\n    pub account_type: String,            // Asset, Liability, Equity, Revenue, Expense\n    pub financial_statement_item: String,\n    pub balance_sheet_category: Option<String>,\n    pub profit_loss_category: Option<String>,\n    \n    // Hierarchy\n    pub account_level1: String,\n    pub account_level2: String,\n    pub account_level3: String,\n    pub account_level4: String,\n    \n    // Attributes\n    pub line_item_display: bool,\n    pub cost_element: Option<String>,\n    \n    // SCD Type 1 (typically)\n    pub is_active: bool,\n    \n    // Audit\n    pub source_system_id: String,\n    pub created_timestamp: DateTime<Utc>,\n    pub last_updated_timestamp: DateTime<Utc>,\n}\n\n// Plant Dimension\npub struct DimPlant {\n    pub plant_key: i32,\n    pub plant_code: String,\n    pub plant_name: String,\n    pub company_code: String,\n    pub company_name: String,\n    pub country: String,\n    pub region: String,\n    pub city: String,\n    pub plant_category: String,\n    pub factory_calendar: String,\n    \n    // Hierarchy\n    pub country_region: String,\n    pub business_unit: String,\n    \n    // Attributes\n    pub is_active: bool,\n    \n    // Audit\n    pub source_system_id: String,\n    pub created_timestamp: DateTime<Utc>,\n    pub last_updated_timestamp: DateTime<Utc>,\n}\n```\n\n### 13.2 ETL流程设计\n\n#### 13.2.1 ETL框架\n\n```rust\npub struct EtlPipeline {\n    pub pipeline_id: Uuid,\n    pub pipeline_name: String,\n    pub pipeline_type: PipelineType,\n    pub source_system: String,\n    pub target_table: String,\n    \n    // Stages\n    pub extraction: ExtractionConfig,\n    pub transformation: TransformationConfig,\n    pub loading: LoadingConfig,\n    \n    // Scheduling\n    pub schedule: EtlSchedule,\n    pub execution_mode: ExecutionMode,\n    \n    // Monitoring\n    pub last_run: Option<EtlRun>,\n    pub status: PipelineStatus,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum PipelineType {\n    BatchFull,\n    BatchIncremental,\n    StreamingRealTime,\n    MicroBatch,\n}\n\npub struct ExtractionConfig {\n    pub extraction_method: ExtractionMethod,\n    pub source_query: Option<String>,\n    pub change_detection_column: Option<String>, // For incremental\n    pub watermark_column: Option<String>,        // For streaming\n    pub parallelism: u8,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum ExtractionMethod {\n    FullTableScan,\n    IncrementalTimestamp,\n    IncrementalCdc,              // Change Data Capture\n    LogBasedReplication,\n    ApiPolling,\n    EventStreaming,\n}\n\npub struct TransformationConfig {\n    pub transformations: Vec<Transformation>,\n    pub data_quality_rules: Vec<DataQualityRule>,\n}\n\npub struct Transformation {\n    pub transformation_id: Uuid,\n    pub transformation_type: TransformationType,\n    pub transformation_logic: String,     // SQL, Rust code, or config\n    pub order: u8,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum TransformationType {\n    Mapping,                  // Column mapping\n    Filtering,               // Row filtering\n    Aggregation,             // Grouping and aggregation\n    Joining,                 // Join with other tables\n    Lookup,                  // Dimension lookup for surrogate keys\n    Calculation,             // Derived columns\n    Deduplication,           // Remove duplicates\n    DataCleansing,          // Fix data quality issues\n    SlowlyChangingDimension, // SCD Type 2 logic\n}\n\npub struct LoadingConfig {\n    pub loading_method: LoadingMethod,\n    pub merge_key_columns: Vec<String>,\n    pub partition_column: Option<String>,\n    pub error_handling: ErrorHandling,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum LoadingMethod {\n    TruncateAndLoad,         // Full refresh\n    InsertOnly,             // Append only\n    Upsert,                 // Insert or update based on key\n    MergeWithScd,           // SCD Type 2 merge\n    DeltaMerge,             // Efficient merge for large tables\n}\n\npub struct EtlRun {\n    pub run_id: Uuid,\n    pub pipeline_id: Uuid,\n    pub start_time: DateTime<Utc>,\n    pub end_time: Option<DateTime<Utc>>,\n    pub status: EtlRunStatus,\n    \n    // Metrics\n    pub rows_extracted: u64,\n    pub rows_transformed: u64,\n    pub rows_loaded: u64,\n    pub rows_rejected: u64,\n    pub duration_seconds: u64,\n    \n    // Errors\n    pub error_message: Option<String>,\n    pub error_details: Option<String>,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum EtlRunStatus {\n    Running,\n    Success,\n    PartialSuccess,\n    Failed,\n    Cancelled,\n}\n```\n\n#### 13.2.2 数据质量管理\n\n```rust\npub struct DataQualityRule {\n    pub rule_id: Uuid,\n    pub rule_name: String,\n    pub rule_type: DataQualityRuleType,\n    pub rule_definition: String,\n    pub severity: QualityIssueSeverity,\n    pub action_on_failure: QualityActionOnFailure,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum DataQualityRuleType {\n    Completeness,           // Check for nulls\n    Uniqueness,            // Check for duplicates\n    Validity,              // Check data format/range\n    Consistency,           // Cross-field validation\n    Accuracy,              // Compare with reference data\n    Timeliness,            // Check data freshness\n    Referential,           // Foreign key validation\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum QualityIssueSeverity {\n    Critical,              // Must fix before loading\n    Warning,               // Load but flag for review\n    Info,                  // Log only\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum QualityActionOnFailure {\n    RejectRow,\n    RejectBatch,\n    LogAndContinue,\n    UseDefaultValue,\n    QuarantineRow,\n}\n\npub struct DataQualityReport {\n    pub report_id: Uuid,\n    pub etl_run_id: Uuid,\n    pub generated_at: DateTime<Utc>,\n    pub total_rows: u64,\n    pub passed_rows: u64,\n    pub failed_rows: u64,\n    pub rule_results: Vec<RuleResult>,\n}\n\npub struct RuleResult {\n    pub rule_id: Uuid,\n    pub rule_name: String,\n    pub passed: bool,\n    pub failed_count: u64,\n    pub sample_failures: Vec<String>,\n}\n```\n\n#### 13.2.3 SCD Type 2 实现\n\n```rust\n// SCD Type 2 Merge Logic for Dimension Tables\npub async fn merge_dimension_scd_type2(\n    staging_data: Vec<StagingDimensionRow>,\n    target_table: &str,\n    natural_key_columns: Vec<String>,\n    attribute_columns: Vec<String>,\n) -> Result<ScdMergeResult, EtlError> {\n    \n    // Step 1: Identify new records (INSERT)\n    let new_records = identify_new_records(\n        &staging_data,\n        target_table,\n        &natural_key_columns,\n    ).await?;\n    \n    // Step 2: Identify changed records (UPDATE old + INSERT new)\n    let changed_records = identify_changed_records(\n        &staging_data,\n        target_table,\n        &natural_key_columns,\n        &attribute_columns,\n    ).await?;\n    \n    // Step 3: Close out old versions\n    // UPDATE target_table\n    // SET effective_to_date = CURRENT_DATE - 1,\n    //     is_current = FALSE\n    // WHERE natural_key IN (changed_records)\n    //   AND is_current = TRUE\n    \n    // Step 4: Insert new versions\n    // INSERT INTO target_table (...)\n    // VALUES (..., effective_from_date = CURRENT_DATE, is_current = TRUE)\n    \n    // Step 5: Insert brand new records\n    // INSERT INTO target_table (...)\n    // VALUES (..., effective_from_date = CURRENT_DATE, is_current = TRUE)\n    \n    Ok(ScdMergeResult {\n        new_records_inserted: new_records.len(),\n        changed_records_updated: changed_records.len(),\n        unchanged_records: staging_data.len() - new_records.len() - changed_records.len(),\n    })\n}\n\npub struct ScdMergeResult {\n    pub new_records_inserted: usize,\n    pub changed_records_updated: usize,\n    pub unchanged_records: usize,\n}\n```\n\n### 13.3 OLAP多维分析\n\n#### 13.3.1 OLAP Cube定义\n\n```rust\npub struct OlapCube {\n    pub cube_id: Uuid,\n    pub cube_name: String,\n    pub subject_area: SubjectArea,\n    \n    // Fact Table\n    pub fact_table: String,\n    \n    // Dimensions\n    pub dimensions: Vec<CubeDimension>,\n    \n    // Measures\n    pub measures: Vec<CubeMeasure>,\n    \n    // Calculated Measures\n    pub calculated_measures: Vec<CalculatedMeasure>,\n    \n    // Aggregations (Pre-calculated for performance)\n    pub aggregations: Vec<Aggregation>,\n    \n    // Metadata\n    pub created_at: DateTime<Utc>,\n    pub last_processed: Option<DateTime<Utc>>,\n}\n\npub struct CubeDimension {\n    pub dimension_name: String,\n    pub dimension_table: String,\n    pub key_column: String,\n    pub attributes: Vec<String>,\n    pub hierarchies: Vec<DimensionHierarchy>,\n    pub default_member: Option<String>,\n}\n\npub struct DimensionHierarchy {\n    pub hierarchy_name: String,\n    pub all_member_name: String,\n    pub levels: Vec<HierarchyLevel>,\n}\n\npub struct CubeMeasure {\n    pub measure_name: String,\n    pub source_column: String,\n    pub aggregation_function: AggregationFunction,\n    pub format_string: String,\n    pub visible: bool,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum AggregationFunction {\n    Sum,\n    Avg,\n    Min,\n    Max,\n    Count,\n    DistinctCount,\n}\n\npub struct CalculatedMeasure {\n    pub measure_name: String,\n    pub formula: String,               // MDX or custom expression\n    pub format_string: String,\n}\n\n// Example: Sales Analysis Cube\npub fn create_sales_analysis_cube() -> OlapCube {\n    OlapCube {\n        cube_id: Uuid::new_v4(),\n        cube_name: \"Sales Analysis\".to_string(),\n        subject_area: SubjectArea::Sales,\n        fact_table: \"fact_sales_order\".to_string(),\n        dimensions: vec![\n            CubeDimension {\n                dimension_name: \"Time\".to_string(),\n                dimension_table: \"dim_date\".to_string(),\n                key_column: \"date_key\".to_string(),\n                attributes: vec![\n                    \"full_date\".to_string(),\n                    \"day_name\".to_string(),\n                    \"month_name\".to_string(),\n                    \"quarter_name\".to_string(),\n                    \"year\".to_string(),\n                ],\n                hierarchies: vec![\n                    DimensionHierarchy {\n                        hierarchy_name: \"Calendar\".to_string(),\n                        all_member_name: \"All Periods\".to_string(),\n                        levels: vec![\n                            HierarchyLevel {\n                                level_number: 1,\n                                level_name: \"Year\".to_string(),\n                                attribute_name: \"year\".to_string(),\n                            },\n                            HierarchyLevel {\n                                level_number: 2,\n                                level_name: \"Quarter\".to_string(),\n                                attribute_name: \"quarter_name\".to_string(),\n                            },\n                            HierarchyLevel {\n                                level_number: 3,\n                                level_name: \"Month\".to_string(),\n                                attribute_name: \"month_name\".to_string(),\n                            },\n                            HierarchyLevel {\n                                level_number: 4,\n                                level_name: \"Date\".to_string(),\n                                attribute_name: \"full_date\".to_string(),\n                            },\n                        ],\n                    },\n                ],\n                default_member: None,\n            },\n            CubeDimension {\n                dimension_name: \"Customer\".to_string(),\n                dimension_table: \"dim_customer\".to_string(),\n                key_column: \"customer_key\".to_string(),\n                attributes: vec![\n                    \"customer_name\".to_string(),\n                    \"customer_group\".to_string(),\n                    \"country\".to_string(),\n                    \"region\".to_string(),\n                ],\n                hierarchies: vec![\n                    DimensionHierarchy {\n                        hierarchy_name: \"Geography\".to_string(),\n                        all_member_name: \"All Customers\".to_string(),\n                        levels: vec![\n                            HierarchyLevel {\n                                level_number: 1,\n                                level_name: \"Region\".to_string(),\n                                attribute_name: \"sales_region\".to_string(),\n                            },\n                            HierarchyLevel {\n                                level_number: 2,\n                                level_name: \"Country\".to_string(),\n                                attribute_name: \"country\".to_string(),\n                            },\n                            HierarchyLevel {\n                                level_number: 3,\n                                level_name: \"Customer\".to_string(),\n                                attribute_name: \"customer_name\".to_string(),\n                            },\n                        ],\n                    },\n                ],\n                default_member: None,\n            },\n            CubeDimension {\n                dimension_name: \"Product\".to_string(),\n                dimension_table: \"dim_material\".to_string(),\n                key_column: \"material_key\".to_string(),\n                attributes: vec![\n                    \"material_description\".to_string(),\n                    \"material_group\".to_string(),\n                    \"product_hierarchy_level1\".to_string(),\n                ],\n                hierarchies: vec![\n                    DimensionHierarchy {\n                        hierarchy_name: \"Product Hierarchy\".to_string(),\n                        all_member_name: \"All Products\".to_string(),\n                        levels: vec![\n                            HierarchyLevel {\n                                level_number: 1,\n                                level_name: \"Division\".to_string(),\n                                attribute_name: \"product_hierarchy_level1\".to_string(),\n                            },\n                            HierarchyLevel {\n                                level_number: 2,\n                                level_name: \"Category\".to_string(),\n                                attribute_name: \"product_hierarchy_level2\".to_string(),\n                            },\n                            HierarchyLevel {\n                                level_number: 3,\n                                level_name: \"Group\".to_string(),\n                                attribute_name: \"material_group\".to_string(),\n                            },\n                            HierarchyLevel {\n                                level_number: 4,\n                                level_name: \"Product\".to_string(),\n                                attribute_name: \"material_description\".to_string(),\n                            },\n                        ],\n                    },\n                ],\n                default_member: None,\n            },\n        ],\n        measures: vec![\n            CubeMeasure {\n                measure_name: \"Net Sales\".to_string(),\n                source_column: \"net_value\".to_string(),\n                aggregation_function: AggregationFunction::Sum,\n                format_string: \"#,##0.00\".to_string(),\n                visible: true,\n            },\n            CubeMeasure {\n                measure_name: \"Cost\".to_string(),\n                source_column: \"cost\".to_string(),\n                aggregation_function: AggregationFunction::Sum,\n                format_string: \"#,##0.00\".to_string(),\n                visible: true,\n            },\n            CubeMeasure {\n                measure_name: \"Quantity\".to_string(),\n                source_column: \"order_quantity\".to_string(),\n                aggregation_function: AggregationFunction::Sum,\n                format_string: \"#,##0\".to_string(),\n                visible: true,\n            },\n            CubeMeasure {\n                measure_name: \"Order Count\".to_string(),\n                source_column: \"sales_order_key\".to_string(),\n                aggregation_function: AggregationFunction::DistinctCount,\n                format_string: \"#,##0\".to_string(),\n                visible: true,\n            },\n        ],\n        calculated_measures: vec![\n            CalculatedMeasure {\n                measure_name: \"Gross Margin\".to_string(),\n                formula: \"[Net Sales] - [Cost]\".to_string(),\n                format_string: \"#,##0.00\".to_string(),\n            },\n            CalculatedMeasure {\n                measure_name: \"Gross Margin %\".to_string(),\n                formula: \"([Net Sales] - [Cost]) / [Net Sales]\".to_string(),\n                format_string: \"0.00%\".to_string(),\n            },\n            CalculatedMeasure {\n                measure_name: \"Average Order Value\".to_string(),\n                formula: \"[Net Sales] / [Order Count]\".to_string(),\n                format_string: \"#,##0.00\".to_string(),\n            },\n        ],\n        aggregations: vec![],\n        created_at: Utc::now(),\n        last_processed: None,\n    }\n}\n```\n\n#### 13.3.2 MDX查询引擎\n\n```rust\n// Multi-Dimensional eXpressions (MDX) Query\npub struct MdxQuery {\n    pub select_clause: SelectClause,\n    pub from_clause: String,           // Cube name\n    pub where_clause: Option<WhereClause>,\n    pub with_clause: Option<WithClause>,\n}\n\npub struct SelectClause {\n    pub columns_axis: Vec<DimensionExpression>,\n    pub rows_axis: Vec<DimensionExpression>,\n    pub measures: Vec<MeasureExpression>,\n}\n\n// Example MDX Query:\n// SELECT\n//   {[Measures].[Net Sales], [Measures].[Gross Margin %]} ON COLUMNS,\n//   {[Time].[Calendar].[Year].Members} ON ROWS\n// FROM [Sales Analysis]\n// WHERE [Product].[Product Hierarchy].[Division].[Electronics]\n\npub async fn execute_mdx_query(\n    query: MdxQuery,\n    cube: &OlapCube,\n) -> Result<MdxResult, AnalysisError> {\n    // Parse MDX query\n    // Generate SQL from MDX\n    // Execute against star schema\n    // Format results as multi-dimensional result set\n    todo!()\n}\n\npub struct MdxResult {\n    pub column_headers: Vec<String>,\n    pub row_headers: Vec<String>,\n    pub cells: Vec<Vec<CellValue>>,\n}\n\npub enum CellValue {\n    Number(Decimal),\n    String(String),\n    Null,\n}\n```\n\n### 13.4 实时数据处理\n\n```rust\n// Real-time streaming data pipeline\npub struct StreamingPipeline {\n    pub pipeline_id: Uuid,\n    pub pipeline_name: String,\n    pub source_topic: String,          // Kafka topic\n    pub sink_table: String,\n    \n    // Processing\n    pub window_type: WindowType,\n    pub window_size: Duration,\n    pub aggregations: Vec<StreamAggregation>,\n    \n    // Watermark (for handling late data)\n    pub watermark_column: String,\n    pub allowed_lateness: Duration,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum WindowType {\n    Tumbling,              // Fixed, non-overlapping windows\n    Sliding,              // Overlapping windows\n    Session,              // Dynamic windows based on activity\n}\n\npub struct StreamAggregation {\n    pub aggregation_name: String,\n    pub aggregation_function: AggregationFunction,\n    pub measure_column: String,\n    pub group_by_columns: Vec<String>,\n}\n\n// Real-time Sales Dashboard\n// Updates every minute with latest sales data\npub async fn process_realtime_sales_stream(\n    kafka_consumer: &KafkaConsumer,\n) -> Result<(), StreamError> {\n    loop {\n        let messages = kafka_consumer.poll_messages().await?;\n        \n        for message in messages {\n            let sales_event: SalesOrderCreated = \n                serde_json::from_slice(&message.payload)?;\n            \n            // Update real-time aggregates\n            update_realtime_sales_aggregate(sales_event).await?;\n        }\n    }\n}\n\npub async fn update_realtime_sales_aggregate(\n    event: SalesOrderCreated,\n) -> Result<(), StreamError> {\n    // Upsert into real-time aggregate table\n    // UPDATE or INSERT aggregate_sales_realtime\n    // SET net_sales = net_sales + event.net_value,\n    //     order_count = order_count + 1,\n    //     last_updated = NOW()\n    // WHERE date = TODAY AND customer_id = event.customer_id\n    Ok(())\n}\n```\n\n文档继续...\n\n### 13.5 报表与仪表板\n\n#### 13.5.1 报表定义\n\n```rust\npub struct Report {\n    pub report_id: Uuid,\n    pub report_name: String,\n    pub report_type: ReportType,\n    pub category: ReportCategory,\n    \n    // Data Source\n    pub data_source: DataSource,\n    pub query: QueryDefinition,\n    \n    // Layout\n    pub layout: ReportLayout,\n    pub parameters: Vec<ReportParameter>,\n    \n    // Visualization\n    pub visualizations: Vec<Visualization>,\n    \n    // Scheduling\n    pub schedule: Option<ReportSchedule>,\n    pub output_formats: Vec<OutputFormat>,\n    pub distribution_list: Vec<String>,\n    \n    // Security\n    pub access_control: AccessControl,\n    \n    // Metadata\n    pub created_by: UserId,\n    pub created_at: DateTime<Utc>,\n    pub last_modified_at: DateTime<Utc>,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum ReportType {\n    Operational,          // Transactional detailed reports\n    Analytical,          // Aggregated analytical reports\n    Dashboard,           // KPI dashboard\n    AdHoc,              // User-defined queries\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum ReportCategory {\n    Financial,\n    Sales,\n    Purchasing,\n    Inventory,\n    Production,\n    HumanResources,\n    Executive,\n}\n\npub struct QueryDefinition {\n    pub query_type: QueryType,\n    pub sql_query: Option<String>,\n    pub mdx_query: Option<String>,\n    pub cube_name: Option<String>,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum QueryType {\n    DirectSql,\n    MdxCube,\n    StoredProcedure,\n    RestApi,\n}\n\npub struct ReportLayout {\n    pub page_size: PageSize,\n    pub orientation: PageOrientation,\n    pub sections: Vec<ReportSection>,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum PageSize {\n    A4,\n    Letter,\n    Legal,\n    Custom { width_mm: u16, height_mm: u16 },\n}\n\npub struct ReportSection {\n    pub section_type: SectionType,\n    pub section_name: String,\n    pub content: SectionContent,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum SectionType {\n    Header,\n    Body,\n    Footer,\n    GroupHeader,\n    GroupFooter,\n}\n\npub struct ReportParameter {\n    pub parameter_name: String,\n    pub parameter_type: ParameterType,\n    pub default_value: Option<String>,\n    pub is_required: bool,\n    pub display_label: String,\n    pub data_source: Option<ParameterDataSource>,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum ParameterType {\n    Text,\n    Number,\n    Date,\n    DateRange,\n    SingleSelect,\n    MultiSelect,\n    Boolean,\n}\n\npub struct Visualization {\n    pub viz_id: Uuid,\n    pub viz_type: VisualizationType,\n    pub title: String,\n    pub data_query: QueryDefinition,\n    pub config: VisualizationConfig,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum VisualizationType {\n    Table,\n    PivotTable,\n    LineChart,\n    BarChart,\n    PieChart,\n    ScatterPlot,\n    Heatmap,\n    GaugeChart,\n    TreeMap,\n    Waterfall,\n    FunnelChart,\n    GeoMap,\n}\n\npub struct VisualizationConfig {\n    pub x_axis: Option<AxisConfig>,\n    pub y_axis: Option<AxisConfig>,\n    pub series: Vec<SeriesConfig>,\n    pub colors: Vec<String>,\n    pub legend: LegendConfig,\n    pub tooltip: TooltipConfig,\n}\n\n// Standard Financial Reports\npub struct StandardReports;\n\nimpl StandardReports {\n    // Balance Sheet\n    pub fn balance_sheet() -> Report {\n        Report {\n            report_id: Uuid::new_v4(),\n            report_name: \"Balance Sheet\".to_string(),\n            report_type: ReportType::Financial,\n            category: ReportCategory::Financial,\n            data_source: DataSource::Cube(\"Financial Analysis\".to_string()),\n            query: QueryDefinition {\n                query_type: QueryType::MdxCube,\n                sql_query: None,\n                mdx_query: Some(\"\n                    SELECT\n                      {[Measures].[Closing Balance]} ON COLUMNS,\n                      {[Account].[Financial Statement].[Asset].Children,\n                       [Account].[Financial Statement].[Liability].Children,\n                       [Account].[Financial Statement].[Equity].Children} ON ROWS\n                    FROM [Financial Analysis]\n                    WHERE [Time].[Fiscal Period].[Last Period]\n                \".to_string()),\n                cube_name: Some(\"Financial Analysis\".to_string()),\n            },\n            layout: ReportLayout {\n                page_size: PageSize::A4,\n                orientation: PageOrientation::Portrait,\n                sections: vec![\n                    ReportSection {\n                        section_type: SectionType::Header,\n                        section_name: \"Report Header\".to_string(),\n                        content: SectionContent::Text {\n                            content: \"Balance Sheet\".to_string(),\n                            style: TextStyle::Heading1,\n                        },\n                    },\n                    ReportSection {\n                        section_type: SectionType::Body,\n                        section_name: \"Assets\".to_string(),\n                        content: SectionContent::Table {\n                            columns: vec![\n                                \"Account\".to_string(),\n                                \"Current Period\".to_string(),\n                                \"Previous Period\".to_string(),\n                                \"Variance\".to_string(),\n                            ],\n                        },\n                    },\n                ],\n            },\n            parameters: vec![\n                ReportParameter {\n                    parameter_name: \"CompanyCode\".to_string(),\n                    parameter_type: ParameterType::SingleSelect,\n                    default_value: None,\n                    is_required: true,\n                    display_label: \"Company Code\".to_string(),\n                    data_source: Some(ParameterDataSource::Query(\n                        \"SELECT DISTINCT company_code FROM dim_company\".to_string()\n                    )),\n                },\n                ReportParameter {\n                    parameter_name: \"FiscalYear\".to_string(),\n                    parameter_type: ParameterType::Number,\n                    default_value: Some(\"2025\".to_string()),\n                    is_required: true,\n                    display_label: \"Fiscal Year\".to_string(),\n                    data_source: None,\n                },\n                ReportParameter {\n                    parameter_name: \"Period\".to_string(),\n                    parameter_type: ParameterType::Number,\n                    default_value: Some(\"12\".to_string()),\n                    is_required: true,\n                    display_label: \"Period\".to_string(),\n                    data_source: None,\n                },\n            ],\n            visualizations: vec![],\n            schedule: None,\n            output_formats: vec![OutputFormat::Pdf, OutputFormat::Excel],\n            distribution_list: vec![],\n            access_control: AccessControl {\n                owner: UserId::nil(),\n                allowed_roles: vec![\"CFO\".to_string(), \"Controller\".to_string()],\n                allowed_users: vec![],\n            },\n            created_by: UserId::nil(),\n            created_at: Utc::now(),\n            last_modified_at: Utc::now(),\n        }\n    }\n    \n    // Profit & Loss Statement\n    pub fn profit_loss_statement() -> Report {\n        // Similar structure to Balance Sheet\n        todo!()\n    }\n    \n    // Cash Flow Statement\n    pub fn cash_flow_statement() -> Report {\n        todo!()\n    }\n    \n    // Sales Performance Report\n    pub fn sales_performance_report() -> Report {\n        todo!()\n    }\n    \n    // Inventory Aging Report\n    pub fn inventory_aging_report() -> Report {\n        todo!()\n    }\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum OutputFormat {\n    Pdf,\n    Excel,\n    Csv,\n    Json,\n    Html,\n}\n```\n\n#### 13.5.2 仪表板设计\n\n```rust\npub struct Dashboard {\n    pub dashboard_id: Uuid,\n    pub dashboard_name: String,\n    pub dashboard_type: DashboardType,\n    pub category: ReportCategory,\n    \n    // Layout\n    pub layout: DashboardLayout,\n    pub widgets: Vec<DashboardWidget>,\n    \n    // Refresh\n    pub refresh_interval_seconds: Option<u32>,\n    pub auto_refresh: bool,\n    \n    // Filters (apply to all widgets)\n    pub global_filters: Vec<DashboardFilter>,\n    \n    // Security\n    pub access_control: AccessControl,\n    \n    // Metadata\n    pub created_by: UserId,\n    pub created_at: DateTime<Utc>,\n    pub last_viewed_at: Option<DateTime<Utc>>,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum DashboardType {\n    Executive,           // High-level KPIs for executives\n    Operational,        // Operational metrics for managers\n    Analytical,         // Detailed analysis for analysts\n    RealTime,          // Real-time monitoring\n}\n\npub struct DashboardLayout {\n    pub rows: Vec<LayoutRow>,\n    pub responsive: bool,\n}\n\npub struct LayoutRow {\n    pub row_height: u16,\n    pub columns: Vec<LayoutColumn>,\n}\n\npub struct LayoutColumn {\n    pub width_percentage: u8,\n    pub widget_id: Uuid,\n}\n\npub struct DashboardWidget {\n    pub widget_id: Uuid,\n    pub widget_type: WidgetType,\n    pub title: String,\n    pub data_source: DataSource,\n    pub visualization: Visualization,\n    pub refresh_interval_seconds: Option<u32>,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum WidgetType {\n    Kpi,                // Single number with trend\n    Chart,\n    Table,\n    PivotTable,\n    Text,\n    Image,\n}\n\npub struct DashboardFilter {\n    pub filter_name: String,\n    pub dimension: String,\n    pub filter_type: FilterType,\n    pub selected_values: Vec<String>,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum FilterType {\n    SingleSelect,\n    MultiSelect,\n    DateRange,\n    NumberRange,\n}\n\n// Executive Dashboard Example\npub fn create_executive_dashboard() -> Dashboard {\n    Dashboard {\n        dashboard_id: Uuid::new_v4(),\n        dashboard_name: \"Executive Dashboard\".to_string(),\n        dashboard_type: DashboardType::Executive,\n        category: ReportCategory::Executive,\n        layout: DashboardLayout {\n            rows: vec![\n                // Row 1: Key KPIs\n                LayoutRow {\n                    row_height: 150,\n                    columns: vec![\n                        LayoutColumn {\n                            width_percentage: 25,\n                            widget_id: Uuid::new_v4(), // Revenue KPI\n                        },\n                        LayoutColumn {\n                            width_percentage: 25,\n                            widget_id: Uuid::new_v4(), // Gross Margin KPI\n                        },\n                        LayoutColumn {\n                            width_percentage: 25,\n                            widget_id: Uuid::new_v4(), // EBITDA KPI\n                        },\n                        LayoutColumn {\n                            width_percentage: 25,\n                            widget_id: Uuid::new_v4(), // Cash Balance KPI\n                        },\n                    ],\n                },\n                // Row 2: Charts\n                LayoutRow {\n                    row_height: 400,\n                    columns: vec![\n                        LayoutColumn {\n                            width_percentage: 60,\n                            widget_id: Uuid::new_v4(), // Revenue Trend Chart\n                        },\n                        LayoutColumn {\n                            width_percentage: 40,\n                            widget_id: Uuid::new_v4(), // Top Products Pie Chart\n                        },\n                    ],\n                },\n                // Row 3: Detailed Tables\n                LayoutRow {\n                    row_height: 300,\n                    columns: vec![\n                        LayoutColumn {\n                            width_percentage: 100,\n                            widget_id: Uuid::new_v4(), // Sales by Region Table\n                        },\n                    ],\n                },\n            ],\n            responsive: true,\n        },\n        widgets: vec![\n            // Revenue KPI Widget\n            DashboardWidget {\n                widget_id: Uuid::new_v4(),\n                widget_type: WidgetType::Kpi,\n                title: \"Total Revenue\".to_string(),\n                data_source: DataSource::Cube(\"Sales Analysis\".to_string()),\n                visualization: Visualization {\n                    viz_id: Uuid::new_v4(),\n                    viz_type: VisualizationType::GaugeChart,\n                    title: \"Total Revenue\".to_string(),\n                    data_query: QueryDefinition {\n                        query_type: QueryType::MdxCube,\n                        sql_query: None,\n                        mdx_query: Some(\"\n                            SELECT {[Measures].[Net Sales]} ON COLUMNS\n                            FROM [Sales Analysis]\n                            WHERE [Time].[Calendar].[Current Month]\n                        \".to_string()),\n                        cube_name: Some(\"Sales Analysis\".to_string()),\n                    },\n                    config: VisualizationConfig {\n                        x_axis: None,\n                        y_axis: None,\n                        series: vec![],\n                        colors: vec![\"#4CAF50\".to_string()],\n                        legend: LegendConfig { show: false, position: LegendPosition::Right },\n                        tooltip: TooltipConfig { enabled: true },\n                    },\n                },\n                refresh_interval_seconds: Some(300), // 5 minutes\n            },\n            // More widgets...\n        ],\n        refresh_interval_seconds: Some(300),\n        auto_refresh: true,\n        global_filters: vec![\n            DashboardFilter {\n                filter_name: \"Time Period\".to_string(),\n                dimension: \"Time\".to_string(),\n                filter_type: FilterType::DateRange,\n                selected_values: vec![\"Last 12 Months\".to_string()],\n            },\n        ],\n        access_control: AccessControl {\n            owner: UserId::nil(),\n            allowed_roles: vec![\"Executive\".to_string(), \"CEO\".to_string(), \"CFO\".to_string()],\n            allowed_users: vec![],\n        },\n        created_by: UserId::nil(),\n        created_at: Utc::now(),\n        last_viewed_at: None,\n    }\n}\n```\n\n### 13.6 API 规格\n\n#### 13.6.1 数据仓库管理 API\n\n```rust\n// POST /api/v1/bi/etl-pipelines/{pipeline_id}/execute\npub struct ExecuteEtlPipelineRequest {\n    pub execution_mode: String,        // Full, Incremental\n    pub parameters: HashMap<String, String>,\n}\n\npub struct ExecuteEtlPipelineResponse {\n    pub run_id: Uuid,\n    pub pipeline_id: Uuid,\n    pub status: String,\n    pub started_at: DateTime<Utc>,\n}\n\n// GET /api/v1/bi/etl-pipelines/{pipeline_id}/runs/{run_id}\npub struct GetEtlRunStatusResponse {\n    pub run_id: Uuid,\n    pub pipeline_id: Uuid,\n    pub status: String,\n    pub started_at: DateTime<Utc>,\n    pub completed_at: Option<DateTime<Utc>>,\n    pub duration_seconds: Option<u64>,\n    pub rows_extracted: u64,\n    pub rows_loaded: u64,\n    pub rows_rejected: u64,\n    pub error_message: Option<String>,\n}\n\n// POST /api/v1/bi/dimensions/{dimension_name}/refresh\npub struct RefreshDimensionRequest {\n    pub refresh_type: String,          // Full, Incremental, SCD\n}\n\n// GET /api/v1/bi/data-quality/report\npub struct GetDataQualityReportQuery {\n    pub etl_run_id: Option<Uuid>,\n    pub date_from: Option<NaiveDate>,\n    pub date_to: Option<NaiveDate>,\n    pub severity: Option<String>,\n}\n\npub struct GetDataQualityReportResponse {\n    pub total_checks: u64,\n    pub passed_checks: u64,\n    pub failed_checks: u64,\n    pub quality_score: Decimal,\n    pub rule_results: Vec<RuleResultDto>,\n}\n```\n\n#### 13.6.2 OLAP查询 API\n\n```rust\n// POST /api/v1/bi/cubes/{cube_name}/query\npub struct ExecuteCubeQueryRequest {\n    pub query_type: String,            // MDX, SQL\n    pub query: String,\n    pub parameters: Option<HashMap<String, String>>,\n}\n\npub struct ExecuteCubeQueryResponse {\n    pub query_id: Uuid,\n    pub result_set: ResultSet,\n    pub execution_time_ms: u64,\n    pub row_count: u64,\n}\n\npub struct ResultSet {\n    pub columns: Vec<ColumnMetadata>,\n    pub rows: Vec<Vec<serde_json::Value>>,\n}\n\npub struct ColumnMetadata {\n    pub column_name: String,\n    pub data_type: String,\n    pub format: Option<String>,\n}\n\n// POST /api/v1/bi/cubes/{cube_name}/drill-down\npub struct DrillDownRequest {\n    pub current_level: String,\n    pub hierarchy: String,\n    pub member: String,\n    pub measures: Vec<String>,\n}\n\n// POST /api/v1/bi/cubes/{cube_name}/drill-through\npub struct DrillThroughRequest {\n    pub cell_coordinates: HashMap<String, String>,\n    pub max_rows: Option<u32>,\n}\n\npub struct DrillThroughResponse {\n    pub fact_table_rows: Vec<FactTableRow>,\n    pub total_count: u64,\n}\n```\n\n#### 13.6.3 报表与仪表板 API\n\n```rust\n// POST /api/v1/bi/reports\npub struct CreateReportRequest {\n    pub report_name: String,\n    pub report_type: String,\n    pub category: String,\n    pub data_source: DataSourceRequest,\n    pub query: QueryDefinitionRequest,\n    pub layout: ReportLayoutRequest,\n    pub parameters: Vec<ReportParameterRequest>,\n}\n\n// POST /api/v1/bi/reports/{report_id}/execute\npub struct ExecuteReportRequest {\n    pub parameters: HashMap<String, String>,\n    pub output_format: String,\n}\n\npub struct ExecuteReportResponse {\n    pub report_execution_id: Uuid,\n    pub status: String,\n    pub output_url: Option<String>,    // URL to download the report\n}\n\n// GET /api/v1/bi/reports/{report_id}/executions/{execution_id}/status\npub struct GetReportExecutionStatusResponse {\n    pub execution_id: Uuid,\n    pub status: String,\n    pub started_at: DateTime<Utc>,\n    pub completed_at: Option<DateTime<Utc>>,\n    pub output_url: Option<String>,\n    pub error_message: Option<String>,\n}\n\n// POST /api/v1/bi/dashboards\npub struct CreateDashboardRequest {\n    pub dashboard_name: String,\n    pub dashboard_type: String,\n    pub category: String,\n    pub layout: DashboardLayoutRequest,\n    pub widgets: Vec<DashboardWidgetRequest>,\n}\n\n// GET /api/v1/bi/dashboards/{dashboard_id}\npub struct GetDashboardResponse {\n    pub dashboard: DashboardDto,\n    pub widgets: Vec<DashboardWidgetDto>,\n    pub data: HashMap<Uuid, WidgetData>, // widget_id -> data\n}\n\n// POST /api/v1/bi/dashboards/{dashboard_id}/refresh\npub struct RefreshDashboardRequest {\n    pub widget_ids: Option<Vec<Uuid>>,  // Specific widgets or all if None\n}\n\npub struct RefreshDashboardResponse {\n    pub dashboard_id: Uuid,\n    pub refreshed_widgets: Vec<Uuid>,\n    pub updated_at: DateTime<Utc>,\n}\n```\n\n#### 13.6.4 实时分析 API\n\n```rust\n// GET /api/v1/bi/realtime/sales/summary\npub struct GetRealtimeSalesSummaryQuery {\n    pub time_window_minutes: Option<u32>,\n    pub group_by: Option<Vec<String>>, // customer, product, region\n}\n\npub struct GetRealtimeSalesSummaryResponse {\n    pub as_of_timestamp: DateTime<Utc>,\n    pub time_window: String,\n    pub metrics: RealtimeMetrics,\n    pub breakdown: Vec<RealtimeBreakdown>,\n}\n\npub struct RealtimeMetrics {\n    pub total_orders: u64,\n    pub total_sales: Decimal,\n    pub average_order_value: Decimal,\n    pub orders_per_minute: Decimal,\n}\n\n// WebSocket endpoint for real-time updates\n// ws://api/v1/bi/realtime/stream\npub struct RealtimeStreamMessage {\n    pub message_type: String,          // MetricUpdate, Alert\n    pub timestamp: DateTime<Utc>,\n    pub metric_name: String,\n    pub metric_value: serde_json::Value,\n}\n```\n\n### 13.7 数据治理\n\n```rust\npub struct DataLineage {\n    pub lineage_id: Uuid,\n    pub target_table: String,\n    pub target_column: Option<String>,\n    pub lineage_graph: LineageGraph,\n}\n\npub struct LineageGraph {\n    pub nodes: Vec<LineageNode>,\n    pub edges: Vec<LineageEdge>,\n}\n\npub struct LineageNode {\n    pub node_id: String,\n    pub node_type: LineageNodeType,\n    pub object_name: String,\n    pub schema_name: Option<String>,\n    pub database_name: Option<String>,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum LineageNodeType {\n    SourceTable,\n    StagingTable,\n    TransformationProcess,\n    DimensionTable,\n    FactTable,\n    Cube,\n    Report,\n}\n\npub struct LineageEdge {\n    pub from_node_id: String,\n    pub to_node_id: String,\n    pub transformation_type: Option<String>,\n}\n\npub struct DataCatalog {\n    pub catalog_entries: Vec<CatalogEntry>,\n}\n\npub struct CatalogEntry {\n    pub entry_id: Uuid,\n    pub object_type: CatalogObjectType,\n    pub object_name: String,\n    pub description: String,\n    pub tags: Vec<String>,\n    pub owner: UserId,\n    pub steward: Option<UserId>,\n    pub sensitivity_classification: SensitivityLevel,\n    pub retention_policy: RetentionPolicy,\n    pub usage_statistics: UsageStatistics,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum SensitivityLevel {\n    Public,\n    Internal,\n    Confidential,\n    HighlyConfidential,\n}\n\npub struct RetentionPolicy {\n    pub retention_period_days: u32,\n    pub archive_after_days: Option<u32>,\n    pub delete_after_days: Option<u32>,\n}\n\npub struct UsageStatistics {\n    pub query_count_last_30_days: u64,\n    pub unique_users_last_30_days: u64,\n    pub last_accessed_at: Option<DateTime<Utc>>,\n}\n```\n\n### 13.8 性能优化策略\n\n```rust\npub struct AggregationTable {\n    pub agg_table_id: Uuid,\n    pub agg_table_name: String,\n    pub base_fact_table: String,\n    pub dimensions: Vec<String>,\n    pub measures: Vec<String>,\n    pub aggregation_level: AggregationLevel,\n    pub refresh_strategy: RefreshStrategy,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum AggregationLevel {\n    Daily,\n    Weekly,\n    Monthly,\n    Quarterly,\n    Yearly,\n    Custom,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum RefreshStrategy {\n    FullRefresh,\n    IncrementalAppend,\n    IncrementalMerge,\n}\n\n// Partitioning Strategy\npub struct PartitioningConfig {\n    pub table_name: String,\n    pub partition_type: PartitionType,\n    pub partition_column: String,\n    pub partitions: Vec<Partition>,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum PartitionType {\n    Range,               // Range partitioning (e.g., by date)\n    List,                // List partitioning (e.g., by country)\n    Hash,                // Hash partitioning\n}\n\npub struct Partition {\n    pub partition_name: String,\n    pub partition_value: PartitionValue,\n    pub row_count: u64,\n    pub size_mb: u64,\n}\n\npub enum PartitionValue {\n    Range { start: String, end: String },\n    List { values: Vec<String> },\n    Hash { hash_value: u32 },\n}\n\n// Materialized View for performance\npub struct MaterializedView {\n    pub view_id: Uuid,\n    pub view_name: String,\n    pub view_definition: String,         // SQL definition\n    pub base_tables: Vec<String>,\n    pub refresh_method: RefreshMethod,\n    pub refresh_schedule: Option<RefreshSchedule>,\n    pub last_refreshed_at: Option<DateTime<Utc>>,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum RefreshMethod {\n    Complete,            // Full refresh\n    Fast,               // Incremental based on logs\n    Force,              // Force complete refresh\n    OnDemand,           // Manual refresh only\n}\n```\n\n### 13.9 领域事件\n\n```rust\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum BiDomainEvent {\n    EtlPipelineExecuted(EtlPipelineExecuted),\n    DataQualityIssueDetected(DataQualityIssueDetected),\n    DimensionUpdated(DimensionUpdated),\n    CubeProcessed(CubeProcessed),\n    ReportGenerated(ReportGenerated),\n    DashboardViewed(DashboardViewed),\n    AlertTriggered(AlertTriggered),\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct EtlPipelineExecuted {\n    pub event_id: Uuid,\n    pub occurred_at: DateTime<Utc>,\n    pub run_id: Uuid,\n    pub pipeline_id: Uuid,\n    pub pipeline_name: String,\n    pub status: String,\n    pub duration_seconds: u64,\n    pub rows_extracted: u64,\n    pub rows_loaded: u64,\n    pub rows_rejected: u64,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct DataQualityIssueDetected {\n    pub event_id: Uuid,\n    pub occurred_at: DateTime<Utc>,\n    pub etl_run_id: Uuid,\n    pub rule_id: Uuid,\n    pub rule_name: String,\n    pub severity: String,\n    pub table_name: String,\n    pub failed_row_count: u64,\n    pub sample_failures: Vec<String>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct CubeProcessed {\n    pub event_id: Uuid,\n    pub occurred_at: DateTime<Utc>,\n    pub cube_id: Uuid,\n    pub cube_name: String,\n    pub processing_type: String,\n    pub duration_seconds: u64,\n    pub aggregation_count: u64,\n}\n```\n\n---\n\n## 结语：完整的 Rust ERP 技术蓝图\n\n本 **Rust Domain Specifications** 文档现已完整，涵盖 **13个核心业务模块**：\n\n### 业务模块 (12个)\n1. ✅ **FI (Financial Accounting)** - 财务会计\n2. ✅ **CO (Controlling)** - 成本控制\n3. ✅ **MM (Materials Management)** - 物料管理\n4. ✅ **SD (Sales & Distribution)** - 销售分销\n5. ✅ **PP (Production Planning)** - 生产计划\n6. ✅ **WM/EWM (Warehouse Management)** - 仓库管理\n7. ✅ **QM (Quality Management)** - 质量管理\n8. ✅ **PM (Plant Maintenance)** - 设备维护\n9. ✅ **PS (Project System)** - 项目系统\n10. ✅ **HCM (Human Capital Management)** - 人力资源\n11. ✅ **TR (Treasury)** - 资金管理\n12. ✅ **Cross-Module Integration** - 跨模块集成\n\n### 分析模块 (1个)\n13. ✅ **BW/BI (Business Intelligence)** - 商业智能与数据仓库\n    - 分层架构（Staging → ODS → DW → Data Mart → Semantic）\n    - 维度建模（星型/雪花模式）\n    - 12个核心事实表和8个主维度表\n    - ETL框架（提取、转换、加载）\n    - 数据质量管理\n    - SCD Type 2 实现\n    - OLAP多维分析\n    - MDX查询引擎\n    - 实时数据流处理\n    - 标准财务报表（资产负债表、损益表、现金流量表）\n    - 高管仪表板\n    - 数据治理（血缘分析、数据目录）\n    - 性能优化（聚合表、分区、物化视图）\n\n## 📚 完整文档体系\n\n您现在拥有完整的4份技术文档：\n\n| 文档 | 用途 | 内容 |\n|------|------|------|\n| **Rust-BOM.md** | 功能清单 | 15个业务领域的完整功能列表 |\n| **Rust-Abc-Enhanced.md** | 开发计划 | 5人团队12个月详细时间表 |\n| **Rust-Implementation-Guide.md** | 实施指南 | 技术标准、架构模式、最佳实践 |\n| **Rust-Domain-Specifications.md** | 领域规格 | 数据模型、API、事件、业务规则 |\n\n## 🎯 技术亮点\n\n### 数据仓库架构\n- **5层架构**：Staging → ODS → DW → Data Mart → Semantic Layer\n- **星型模式**：12个事实表 + 8个核心维度表\n- **SCD处理**：支持Type 0-6的缓慢变化维度\n\n### ETL能力\n- **多种提取模式**：Full、Incremental、CDC、Real-time\n- **数据质量**：7种质量规则类型\n- **错误处理**：拒绝行/批次、隔离、使用默认值\n\n### 分析能力\n- **OLAP Cube**：多维分析、钻取、上卷、切片、切块\n- **MDX查询**：支持复杂多维查询\n- **实时分析**：流式处理、滚动窗口、会话窗口\n\n### 报表系统\n- **标准报表**：资产负债表、损益表、现金流量表\n- **可视化**：12种图表类型\n- **仪表板**：响应式布局、自动刷新\n\n### 性能优化\n- **聚合表**：预计算常用聚合\n- **分区**：Range/List/Hash分区\n- **物化视图**：快速查询响应\n\n## 🚀 下一步行动\n\n1. **架构设计评审** - 与架构师评审整体技术方案\n2. **数据库设计** - 创建DDL脚本和初始数据\n3. **API开发** - 基于API规格实现RESTful接口\n4. **ETL开发** - 实现数据抽取、转换、加载流程\n5. **报表开发** - 开发标准报表和仪表板\n6. **集成测试** - 验证端到端业务流程\n\n您的团队现在拥有构建世界级企业ERP系统所需的完整技术蓝图！🎉\n", "md/Rust-Git.md": "# Rust ERP 系统 - 项目管理与协作补充文档\n\n**文档类型**: 项目管理补充文档\n**关联文档**: Rust-ERP系统-5人团队12个月开发计划.md\n**文档版本**: v1.0\n**创建日期**: 2025-12-21\n\n---\n\n## 目录\n\n1. [团队协作与沟通机制](#一团队协作与沟通机制)\n2. [会议制度详细说明](#二会议制度详细说明)\n3. [知识管理与文档体系](#三知识管理与文档体系)\n4. [培训与能力建设](#四培训与能力建设)\n5. [预算与资源规划](#五预算与资源规划)\n6. [供应商与第三方管理](#六供应商与第三方管理)\n7. [数据迁移策略](#七数据迁移策略)\n8. [用户培训与推广](#八用户培训与推广)\n9. [上线检查清单](#九上线检查清单)\n10. [应急响应预案](#十应急响应预案)\n11. [运维交接计划](#十一运维交接计划)\n12. [长期演进路线图](#十二长期演进路线图)\n\n---\n\n## 一、团队协作与沟通机制\n\n### 1.1 沟通渠道分层\n\n#### 即时沟通（实时性要求高）\n- **工具**: Slack / 企业微信 / Discord\n- **频道划分**:\n  - `#general`: 全员公告、重要通知\n  - `#development`: 技术讨论、问题求助\n  - `#architecture`: 架构设计讨论\n  - `#devops`: 运维、部署相关\n  - `#financial-module`: 财务模块讨论\n  - `#supply-chain-module`: 供应链模块讨论\n  - `#random`: 闲聊、团建\n- **响应时间要求**:\n  - 紧急问题（生产故障）: 15分钟内响应\n  - 阻塞性问题（开发被卡住）: 1小时内响应\n  - 普通问题: 工作日内响应\n\n#### 异步沟通（非紧急、需深度思考）\n- **工具**: GitHub Discussions / Notion\n- **使用场景**:\n  - 技术方案设计讨论\n  - RFC（Request for Comments）提案\n  - 架构决策记录（ADR）\n  - 复杂问题分析\n- **响应时间**: 48小时内回复\n\n#### 文档沟通（持久化知识）\n- **工具**: Confluence / Notion / GitHub Wiki\n- **内容类型**:\n  - 技术文档（架构设计、API文档）\n  - 流程文档（开发规范、发布流程）\n  - 会议纪要\n  - 问题总结（Post-mortem）\n\n### 1.2 代码协作流程\n\n#### Git 工作流（GitFlow 改进版）\n\n**分支策略**:\n```\nmain (生产分支)\n  ├── release/v1.0 (发布分支)\n  ├── develop (开发主分支)\n  │   ├── feature/financial-gl-001 (功能分支)\n  │   ├── feature/materials-purchase-002 (功能分支)\n  │   └── bugfix/fix-balance-calculation (缺陷修复)\n  └── hotfix/critical-security-patch (紧急修复)\n```\n\n**分支命名规范**:\n- 功能分支: `feature/<模块>-<简短描述>-<任务编号>`\n  - 示例: `feature/financial-account-creation-FIN-001`\n- 缺陷修复: `bugfix/<问题描述>-<Issue编号>`\n  - 示例: `bugfix/fix-null-pointer-ISS-123`\n- 紧急修复: `hotfix/<问题描述>`\n  - 示例: `hotfix/security-jwt-validation`\n\n**Pull Request 流程**:\n1. **创建 PR** (Pull Request)\n   - 标题格式: `[模块] 简短描述 (#任务编号)`\n   - 示例: `[Financial] 实现会计科目创建功能 (#FIN-001)`\n   - 描述模板:\n     ```\n     ## 变更内容\n     - 实现了什么功能\n     - 修复了什么问题\n\n     ## 测试覆盖\n     - [ ] 单元测试\n     - [ ] 集成测试\n     - [ ] 手动测试场景\n\n     ## 截图/录屏\n     （如有UI变更）\n\n     ## 相关文档\n     - 链接到设计文档\n     - 链接到API文档更新\n\n     ## 检查清单\n     - [ ] 代码遵循开发规范\n     - [ ] 通过 cargo fmt 和 clippy\n     - [ ] 测试覆盖率 > 80%\n     - [ ] 更新了相关文档\n     - [ ] 更新了 CHANGELOG\n     ```\n\n2. **代码评审** (Code Review)\n   - 至少1人批准（小改动）\n   - 至少2人批准（架构变更、核心逻辑）\n   - 架构师强制评审（跨服务变更）\n   - 评审要点:\n     - ✅ 业务逻辑正确性\n     - ✅ 代码可读性和可维护性\n     - ✅ 性能影响分析\n     - ✅ 安全漏洞检查\n     - ✅ 测试覆盖充分性\n     - ✅ 文档完整性\n\n3. **自动化检查** (CI)\n   - 编译通过\n   - 代码格式检查通过\n   - Clippy 无警告\n   - 所有测试通过\n   - 代码覆盖率不降低\n   - 安全审计通过\n\n4. **合并策略**\n   - 功能分支 → develop: Squash and Merge（保持历史清晰）\n   - develop → release: Merge Commit（保留完整历史）\n   - release → main: Merge Commit（记录发布点）\n   - hotfix → main + develop: Cherry-pick（同步修复）\n\n### 1.3 任务管理与跟踪\n\n#### 任务看板（Kanban Board）\n\n**工具**: Jira / GitHub Projects / Linear\n\n**看板列划分**:\n```\n待办 (Backlog) → 就绪 (Ready) → 进行中 (In Progress) →\n评审中 (In Review) → 测试中 (Testing) → 完成 (Done)\n```\n\n**任务卡片信息**:\n- **标题**: 简短描述（动词开头）\n  - 示例: \"实现会计科目创建API\"\n- **描述**: 详细需求、验收标准\n- **指派人**: 责任人（单一责任）\n- **优先级**: P0（紧急）、P1（高）、P2（中）、P3（低）\n- **标签**:\n  - 模块: `financial`, `materials`, `sales`\n  - 类型: `feature`, `bug`, `refactor`, `docs`\n  - 阶段: `phase-1`, `phase-2`\n- **预估工时**: 以天为单位（0.5天、1天、2天、3天）\n- **实际工时**: 跟踪记录\n- **依赖关系**: 前置任务、阻塞任务\n\n#### 任务优先级定义\n\n| 优先级 | 定义 | 响应时间 | 示例 |\n|-------|------|---------|------|\n| P0 - 紧急 | 生产故障、安全漏洞、核心功能阻塞 | 立即处理 | 数据库连接失败、用户无法登录 |\n| P1 - 高 | 影响关键功能、即将到来的里程碑 | 当天处理 | 财务过账失败、发版前缺陷 |\n| P2 - 中 | 正常功能开发、一般性缺陷 | 本周处理 | 新增报表功能、UI优化 |\n| P3 - 低 | 优化改进、技术债务、文档完善 | 有空处理 | 代码重构、注释补充 |\n\n### 1.4 跨团队协作机制\n\n#### 与业务团队协作\n\n**业务需求收集流程**:\n```\n业务提出需求 → 产品经理整理 → 技术可行性评估 →\n需求优先级排序 → Sprint 规划纳入 → 开发实现 →\n业务验收 → 上线发布\n```\n\n**需求澄清会议**:\n- **时间**: 每个 Sprint 开始前一周\n- **参与人**: 产品经理、业务代表、技术架构师、相关开发者\n- **输出**:\n  - 明确的需求文档\n  - 验收标准（Acceptance Criteria）\n  - UI/UX 原型（如有）\n  - 数据字典\n\n#### 与运维团队协作\n\n**发布协调流程**:\n```\n开发完成 → 提交发布申请 → 运维审核 →\n预发布环境部署 → 回归测试 → 生产环境发布 →\n发布验证 → 监控观察\n```\n\n**发布窗口**:\n- **常规发布**: 每周三、周五下午 3:00-5:00\n- **紧急发布**: 24小时随时（需总监批准）\n- **禁止发布**: 周末、节假日、重大活动期间\n\n**发布检查清单** (见第九章详细说明)\n\n---\n\n## 二、会议制度详细说明\n\n### 2.1 每日站会 (Daily Standup)\n\n**时间**: 每天上午 9:30-9:45（15分钟）\n**地点**: 线下会议室 / 线上视频会议\n**参与人**: 全体开发团队成员\n**主持人**: 轮流（每周轮换）\n\n**会议议程**:\n每人回答三个问题（每人最多3分钟）:\n1. **昨天完成了什么?** (Yesterday)\n   - 完成的任务\n   - 合并的 PR\n   - 解决的问题\n2. **今天计划做什么?** (Today)\n   - 计划开始的任务\n   - 计划提交的 PR\n   - 需要协调的事项\n3. **遇到什么阻碍?** (Blockers)\n   - 技术难题\n   - 依赖等待\n   - 资源不足\n\n**会议规则**:\n- ❌ 不讨论技术细节（会后单独讨论）\n- ❌ 不责怪或追究责任\n- ✅ 简洁明了，避免冗长\n- ✅ 识别阻碍，会后跟进\n- ✅ 站着开会（保持简短）\n\n**会议输出**:\n- 更新看板状态\n- 记录阻碍事项\n- 安排会后讨论\n\n### 2.2 Sprint 计划会议 (Sprint Planning)\n\n**时间**: 每个 Sprint 第一天上午 9:00-11:00（2小时）\n**频率**: 每两周一次\n**参与人**: 全体团队 + 产品经理（如有）\n**主持人**: 架构师（开发者A）\n\n**会议议程**:\n\n**第一部分：确定 Sprint 目标（30分钟）**\n- 回顾产品 Backlog\n- 讨论业务优先级\n- 确定本 Sprint 要完成的功能\n- 定义 Sprint 目标（一句话概括）\n  - 示例: \"完成财务模块应收应付功能并通过集成测试\"\n\n**第二部分：任务拆解与工时估算（60分钟）**\n- 将用户故事拆解为技术任务\n- 估算每个任务的工时（Planning Poker 方法）\n- 分配任务责任人\n- 识别风险和依赖\n\n**第三部分：Sprint 承诺（30分钟）**\n- 团队确认能否完成任务\n- 调整任务范围（如超出团队容量）\n- 最终确定 Sprint Backlog\n\n**会议输出**:\n- Sprint 目标文档\n- Sprint Backlog（任务清单）\n- 风险登记表\n- 团队承诺\n\n### 2.3 Sprint 评审会议 (Sprint Review)\n\n**时间**: 每个 Sprint 最后一天下午 2:00-3:30（90分钟）\n**参与人**: 全体团队 + 业务干系人 + 产品经理\n**主持人**: 各模块负责人轮流\n\n**会议议程**:\n\n**第一部分：功能演示（60分钟）**\n- 各模块负责人演示已完成功能\n- 现场操作，展示实际效果\n- 回答业务方问题\n- 收集反馈意见\n\n**第二部分：数据回顾（15分钟）**\n- Sprint 燃尽图分析\n- 完成任务数 vs. 计划任务数\n- 缺陷统计（新增、修复、遗留）\n- 代码质量指标（覆盖率、技术债务）\n\n**第三部分：反馈讨论（15分钟）**\n- 业务方提出改进建议\n- 讨论下个 Sprint 优先级\n- 调整产品 Backlog\n\n**会议输出**:\n- Sprint 评审报告\n- 业务反馈清单\n- 下个 Sprint 候选任务\n\n### 2.4 Sprint 回顾会议 (Sprint Retrospective)\n\n**时间**: Sprint 评审会议之后 3:30-4:30（60分钟）\n**参与人**: 仅开发团队（无业务方）\n**主持人**: 轮流（促进开放讨论）\n\n**会议议程**:\n\n**第一部分：数据收集（15分钟）**\n使用便利贴或在线白板，每人写下：\n- 😊 **做得好的事** (What went well)\n- 😞 **需要改进的事** (What didn't go well)\n- 💡 **改进建议** (Action items)\n\n**第二部分：分组讨论（30分钟）**\n- 将相似主题归类\n- 投票选出最重要的3-5项\n- 深入讨论根本原因\n\n**第三部分：行动计划（15分钟）**\n- 为每项改进制定具体行动\n- 分配责任人\n- 设定完成时间\n- 下次回顾时检查执行情况\n\n**常见回顾主题**:\n- ✅ 技术：代码质量、技术债务、工具链\n- ✅ 流程：开发流程、发布流程、协作方式\n- ✅ 团队：沟通效率、知识共享、团队氛围\n- ✅ 环境：办公环境、开发环境、测试环境\n\n**会议输出**:\n- 改进行动清单（SMART 目标）\n- 责任人和截止日期\n- 下次回顾的跟踪事项\n\n### 2.5 技术分享会 (Tech Sharing)\n\n**时间**: 每周五下午 4:00-5:00（60分钟）\n**频率**: 每周一次\n**参与人**: 全体技术团队\n**主持人**: 分享者\n\n**分享主题**:\n- 新技术探索（Rust 新特性、新 crate）\n- 最佳实践分享（设计模式、性能优化）\n- 踩坑经验（遇到的问题及解决方案）\n- 开源项目介绍\n- 行业趋势分析\n\n**分享形式**:\n- 演讲（30分钟）\n- Demo 演示（15分钟）\n- Q&A 讨论（15分钟）\n\n**轮值安排**:\n- 每人每月至少分享一次\n- 提前一周确定主题和分享人\n- 分享材料提前2天发布\n\n**会议输出**:\n- 分享 PPT/文档归档\n- 知识库更新\n- 录屏视频（供缺席者观看）\n\n### 2.6 架构评审会议 (Architecture Review)\n\n**时间**: 按需召开（重大技术决策前）\n**时长**: 1-2小时\n**参与人**: 架构师 + 相关模块负责人 + 技术专家\n**主持人**: 架构师（开发者A）\n\n**会议场景**:\n- 新服务设计评审\n- 跨服务接口设计\n- 数据库 Schema 变更\n- 重大性能优化\n- 技术选型决策\n\n**会议流程**:\n1. **方案介绍**（15分钟）\n   - 背景和目标\n   - 设计方案\n   - 技术选型理由\n2. **方案评审**（30分钟）\n   - 架构一致性检查\n   - 性能影响分析\n   - 安全风险评估\n   - 可维护性评估\n3. **讨论与决策**（15分钟）\n   - 提出改进建议\n   - 讨论替代方案\n   - 投票或架构师裁决\n\n**会议输出**:\n- 架构决策记录（ADR - Architecture Decision Record）\n- 行动项清单\n- 更新架构文档\n\n### 2.7 问题复盘会议 (Post-mortem)\n\n**时间**: 重大事故后 24-48 小时内\n**时长**: 1-2 小时\n**参与人**: 相关开发者 + 运维 + 管理层\n**主持人**: 中立第三方（非直接责任人）\n\n**会议原则**:\n- 🚫 **无责备文化** (Blameless)\n  - 聚焦系统改进，而非追究个人责任\n  - 假设每个人在当时情况下做了最好的决策\n- ✅ **事实导向**\n  - 基于日志、监控数据、时间线\n  - 避免主观猜测\n\n**会议议程**:\n1. **时间线重建**（30分钟）\n   - 何时发现问题\n   - 采取了哪些措施\n   - 何时恢复正常\n2. **根本原因分析**（30分钟）\n   - 使用 5 Whys 方法\n   - 识别直接原因和根本原因\n   - 区分症状和病因\n3. **改进措施**（30分钟）\n   - 短期修复（防止再次发生）\n   - 长期改进（系统性提升）\n   - 流程优化\n   - 工具改进\n\n**会议输出**:\n- Post-mortem 报告（公开发布）\n- 行动项清单（JIRA Tickets）\n- 监控告警优化\n- 文档更新\n\n---\n\n## 三、知识管理与文档体系\n\n### 3.1 文档分类与存储\n\n#### 文档金字塔结构\n\n```\n                    /\\\n                   /愿景\\\n                  /战略文档\\\n                 /----------\\\n                /架构设计文档 \\\n               / Architecture \\\n              /----------------\\\n             /   技术规范文档    \\\n            / Standards & Specs \\\n           /---------------------\\\n          /      操作手册         \\\n         /   Runbooks & Guides   \\\n        /-------------------------\\\n       /        API 文档           \\\n      /    OpenAPI & Proto Docs   \\\n     /-----------------------------\\\n    /          代码注释             \\\n   /      Inline Documentation    \\\n  /---------------------------------\\\n```\n\n#### 文档存储策略\n\n| 文档类型 | 存储位置 | 工具 | 更新频率 | 责任人 |\n|---------|---------|------|---------|-------|\n| **战略文档** | Confluence | Notion | 季度 | 架构师 |\n| 系统架构设计 | GitHub Wiki | Markdown | 月度 | 架构师 |\n| API 文档 | 代码仓库 `/docs` | OpenAPI/Protobuf | 实时 | 各模块负责人 |\n| 操作手册 | Confluence | Wiki | 按需 | DevOps |\n| 会议纪要 | Confluence | Notion | 会后24h | 会议主持人 |\n| 技术规范 | GitHub `/docs/rfcs` | Markdown | 按需 | 架构师 |\n| 故障复盘 | Confluence | Wiki | 事后48h | 事故负责人 |\n| 代码注释 | 代码仓库 | Rustdoc | 实时 | 开发者 |\n\n### 3.2 文档模板\n\n#### 架构设计文档模板 (ADR - Architecture Decision Record)\n\n**文件命名**: `ADR-001-选择-PostgreSQL-作为主数据库.md`\n\n**模板结构**:\n```markdown\n# ADR-001: 选择 PostgreSQL 作为主数据库\n\n**状态**: 已批准 | 草稿 | 已废弃\n**日期**: 2025-12-21\n**决策者**: 开发者A, 开发者D\n**相关方**: 全体开发团队\n\n## 背景 (Context)\n描述需要做出决策的背景和问题\n\n## 决策 (Decision)\n我们决定使用 PostgreSQL 作为主数据库，原因如下：\n1. 原因一\n2. 原因二\n3. 原因三\n\n## 考虑的方案 (Alternatives Considered)\n### 方案1: MySQL\n- 优点: ...\n- 缺点: ...\n- 为何未选择: ...\n\n### 方案2: MongoDB\n- 优点: ...\n- 缺点: ...\n- 为何未选择: ...\n\n## 后果 (Consequences)\n### 积极影响\n- ...\n### 消极影响\n- ...\n### 风险\n- ...\n\n## 实施计划\n1. 步骤一\n2. 步骤二\n\n## 参考资料\n- [链接1](url)\n- [链接2](url)\n```\n\n#### API 文档模板\n\n**使用工具**: OpenAPI 3.0 (REST) + Protobuf (gRPC)\n\n**REST API 示例**:\n```yaml\nopenapi: 3.0.0\ninfo:\n  title: Financial Service API\n  version: 1.0.0\n  description: |\n    财务服务 API，提供会计科目管理、交易过账等功能。\n\n    ## 认证方式\n    使用 JWT Bearer Token\n\n    ## 限流\n    - 普通用户: 100 req/min\n    - 高级用户: 1000 req/min\n```\n\n#### 操作手册模板 (Runbook)\n\n**场景**: 数据库主从切换操作手册\n\n**模板结构**:\n```markdown\n# 数据库主从切换操作手册\n\n## 适用场景\n- 主库故障\n- 计划性维护\n- 升级操作\n\n## 前置条件检查\n- [ ] 备库延迟 < 1秒\n- [ ] 备库状态健康\n- [ ] 已通知相关团队\n\n## 操作步骤\n### 1. 停止写入流量\n**命令**:\n`kubectl scale deployment financial-service --replicas=0`\n\n**预期结果**:\n所有 Pod 停止，无写入流量\n\n**回滚方法**:\n`kubectl scale deployment financial-service --replicas=3`\n\n### 2. 验证数据同步完成\n**命令**:\n`psql -h backup-db -c \"SELECT pg_last_wal_replay_lsn();\"`\n\n**预期结果**:\nLSN 与主库一致\n\n### 3. 提升备库为主库\n**命令**:\n`pg_ctl promote -D /var/lib/postgresql/data`\n\n**验证**:\n`psql -c \"SELECT pg_is_in_recovery();\"`\n结果应为 `f` (false)\n\n## 验证步骤\n- [ ] 新主库可写入\n- [ ] 应用连接正常\n- [ ] 监控指标正常\n\n## 回滚方案\n如果切换失败，执行以下步骤...\n\n## 联系方式\n- 主责: 开发者D (电话: xxx)\n- 备份: 开发者A (电话: xxx)\n```\n\n### 3.3 知识共享机制\n\n#### 知识库建设\n\n**Confluence/Notion 空间结构**:\n```\nERP 项目空间\n├── 📁 项目管理\n│   ├── 项目章程\n│   ├── 里程碑跟踪\n│   └── 风险日志\n├── 📁 架构设计\n│   ├── 系统架构图\n│   ├── 数据架构\n│   ├── ADR 决策记录\n│   └── 技术选型\n├── 📁 开发规范\n│   ├── 代码规范\n│   ├── Git 工作流\n│   ├── 测试规范\n│   └── 安全规范\n├── 📁 API 文档\n│   ├── Financial Service\n│   ├── Materials Service\n│   └── Sales Service\n├── 📁 运维手册\n│   ├── 部署指南\n│   ├── 监控告警\n│   ├── 故障排查\n│   └── 应急预案\n├── 📁 会议纪要\n│   ├── 2025-01 月度会议\n│   └── Sprint 回顾\n├── 📁 培训材料\n│   ├── Rust 入门\n│   ├── DDD 设计\n│   └── K8s 运维\n└── 📁 常见问题 (FAQ)\n    ├── 技术 FAQ\n    └── 业务 FAQ\n```\n\n#### 知识萃取流程\n\n**每个 Sprint 结束后**:\n1. **识别可复用知识**\n   - 解决的技术难题\n   - 业务逻辑理解\n   - 最佳实践总结\n2. **编写知识文档**\n   - 问题描述\n   - 解决方案\n   - 适用场景\n   - 示例演示\n3. **发布到知识库**\n   - 分类归档\n   - 添加标签\n   - 关联相关文档\n4. **分享会宣讲**\n   - 技术分享会介绍\n   - 演示实际应用\n\n#### 新人入职知识路径\n\n**第1周：环境搭建与基础知识**\n- Day 1-2: 账号开通、工具安装\n- Day 3-4: 阅读架构文档、代码规范\n- Day 5: 搭建本地开发环境\n\n**第2周：代码熟悉**\n- Day 6-8: 阅读共享库代码\n- Day 9-10: 运行示例服务，理解流程\n\n**第3周：小任务实践**\n- Day 11-15: 认领 P3 低优先级任务，导师指导\n\n**第4周：独立开发**\n- Day 16-20: 独立完成一个功能模块\n\n---\n\n## 四、培训与能力建设\n\n### 4.1 技能矩阵\n\n#### 团队技能评估表\n\n| 技能领域 | 开发者A | 开发者B | 开发者C | 开发者D | 开发者E | 团队目标 |\n|---------|--------|--------|--------|--------|--------|---------|\n| **Rust 语言** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ | 全员 ⭐⭐⭐⭐ |\n| **DDD 设计** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐ | ⭐⭐ | 全员 ⭐⭐⭐ |\n| **微服务架构** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐ | 全员 ⭐⭐⭐ |\n| **Kubernetes** | ⭐⭐⭐ | ⭐⭐ | ⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐ | 3人 ⭐⭐⭐ |\n| **PostgreSQL** | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐ | 3人 ⭐⭐⭐⭐ |\n| **Kafka** | ⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐ | 3人 ⭐⭐⭐ |\n| **财务业务** | ⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐ | ⭐ | ⭐ | 1人专精 |\n| **供应链业务** | ⭐⭐ | ⭐ | ⭐⭐⭐⭐⭐ | ⭐ | ⭐ | 1人专精 |\n| **HR 业务** | ⭐⭐ | ⭐ | ⭐ | ⭐ | ⭐⭐⭐⭐ | 1人专精 |\n\n**评级标准**:\n- ⭐ 初学者：需要指导才能完成任务\n- ⭐⭐ 新手：能完成基础任务\n- ⭐⭐⭐ 胜任者：能独立完成大部分任务\n- ⭐⭐⭐⭐ 熟练者：能处理复杂场景，可指导他人\n- ⭐⭐⭐⭐⭐ 专家：深度理解，能解决疑难问题\n\n### 4.2 培训计划\n\n#### 第1-2个月：基础能力建设\n\n**Rust 语言深化培训**（全员必修）\n- **时间**: 每周二、四晚上 7:00-9:00\n- **形式**: 在线课程 + 代码练习\n- **内容**:\n  - Week 1-2: 所有权系统、借用检查器、生命周期\n  - Week 3-4: Trait 系统、泛型、错误处理\n  - Week 5-6: 异步编程、Tokio 运行时\n  - Week 7-8: 宏编程、unsafe Rust\n- **考核**: 每周编程作业 + 月度测试\n\n**DDD 领域驱动设计工作坊**（全员必修）\n- **时间**: 第1个月周末集中培训（2天）\n- **讲师**: 外部 DDD 专家 + 架构师\n- **内容**:\n  - 限界上下文划分\n  - 聚合根设计\n  - 值对象与实体\n  - 领域事件建模\n  - Event Sourcing 实践\n- **产出**: 财务模块 DDD 设计文档\n\n#### 第3-4个月：专项技能培训\n\n**微服务架构最佳实践**（全员）\n- 服务拆分策略\n- 服务间通信（gRPC/Kafka）\n- 分布式事务（Saga 模式）\n- 服务治理（限流、熔断、降级）\n\n**Kubernetes 运维培训**（开发者D 主讲，其他人参加）\n- Deployment、Service、Ingress\n- ConfigMap、Secret 管理\n- HPA 自动扩缩容\n- 故障排查与日志查看\n\n#### 第5-6个月：业务知识培训\n\n**财务业务培训**（业务专家 + 开发者B）\n- 会计基础知识\n- 借贷记账法\n- 财务报表（资产负债表、利润表、现金流量表）\n- 成本核算方法\n\n**供应链业务培训**（业务专家 + 开发者C）\n- 采购流程\n- 库存管理（FIFO/LIFO）\n- MRP 物料需求计划\n- 销售订单处理流程\n\n#### 持续学习机制\n\n**每周技术分享**（见第二章会议制度）\n\n**每月读书会**\n- **形式**: 共读一本技术书籍\n- **推荐书单**:\n  - 《领域驱动设计》（Eric Evans）\n  - 《实现领域驱动设计》（Vaughn Vernon）\n  - 《微服务架构设计模式》（Chris Richardson）\n  - 《深入理解 Rust 并发编程》\n  - 《数据密集型应用系统设计》（DDIA）\n\n**外部技术会议参与**\n- **预算**: 每人每年 5000 元会议差旅费\n- **推荐会议**:\n  - RustConf\n  - QCon 全球软件开发大会\n  - ArchSummit 全球架构师峰会\n  - KubeCon\n- **参会后**: 必须向团队分享心得\n\n**在线课程报销**\n- **预算**: 每人每年 2000 元在线课程费用\n- **平台**: Udemy、Coursera、极客时间、慕课网\n- **要求**: 完成课程并通过考核\n\n### 4.3 导师制度\n\n#### 导师-学员配对\n\n**配对原则**:\n- 技能互补（导师强项 = 学员弱项）\n- 模块相关（导师负责的模块）\n- 自愿报名\n\n**配对示例**:\n- 开发者A（Rust 专家）→ 开发者E（Rust 提升）\n- 开发者B（财务业务）→ 开发者A（业务理解）\n- 开发者D（K8s 专家）→ 全员（运维能力）\n\n#### 导师职责\n\n**代码评审**:\n- 优先评审学员的 PR\n- 详细注释，解释为何这样改\n- 结对编程（Pair Programming）每周至少1次\n\n**知识传授**:\n- 每周1对1会议（30分钟）\n- 解答学员疑问\n- 推荐学习资源\n\n**职业发展**:\n- 帮助制定学习计划\n- 识别技能短板\n- 提供成长建议\n\n#### 学员职责\n\n**主动学习**:\n- 完成导师布置的学习任务\n- 提前准备问题清单\n- 记录学习笔记\n\n**实践应用**:\n- 将学到的知识应用到实际项目\n- 主动承担有挑战的任务\n- 分享学习心得\n\n---\n\n## 五、预算与资源规划\n\n### 5.1 人力成本预算\n\n#### 人员薪资预算（年度）\n\n| 成员 | 职级 | 月薪（元）| 年薪（元）| 五险一金（元）| 总成本（元）|\n|-----|------|----------|----------|------------|-----------|\n| 开发者A | 资深架构师 | 40,000 | 480,000 | 144,000 | 624,000 |\n| 开发者B | 高级开发工程师 | 30,000 | 360,000 | 108,000 | 468,000 |\n| 开发者C | 高级开发工程师 | 30,000 | 360,000 | 108,000 | 468,000 |\n| 开发者D | 高级 DevOps 工程师 | 28,000 | 336,000 | 100,800 | 436,800 |\n| 开发者E | 中级全栈工程师 | 22,000 | 264,000 | 79,200 | 343,200 |\n| **合计** | - | **150,000** | **1,800,000** | **540,000** | **2,340,000** |\n\n**其他人力成本**:\n- 招聘费用: 50,000 元（猎头费、招聘广告）\n- 员工培训: 50,000 元（外部培训、课程费用）\n- 团建活动: 30,000 元（每季度一次）\n- **人力成本总计**: 2,470,000 元\n\n### 5.2 基础设施成本预算\n\n#### 云服务费用（月度）\n\n**计算资源（Kubernetes 集群）**:\n| 环境 | 节点规格 | 节点数 | 单价（元/月）| 小计（元/月）|\n|-----|---------|-------|------------|------------|\n| 生产环境 | 8核32G | 10 | 1,500 | 15,000 |\n| 预发布环境 | 4核16G | 3 | 800 | 2,400 |\n| 测试环境 | 4核16G | 3 | 800 | 2,400 |\n| 开发环境 | 2核8G | 5 | 400 | 2,000 |\n| **合计** | - | **21** | - | **21,800** |\n\n**数据库服务（PostgreSQL + Redis）**:\n| 服务 | 规格 | 实例数 | 单价（元/月）| 小计（元/月）|\n|-----|------|-------|------------|------------|\n| PostgreSQL 主库 | 16核64G | 1 | 5,000 | 5,000 |\n| PostgreSQL 从库 | 16核64G | 2 | 5,000 | 10,000 |\n| Redis 集群 | 8核32G | 3 | 2,000 | 6,000 |\n| **合计** | - | **6** | - | **21,000** |\n\n**消息队列（Kafka）**:\n| 服务 | 规格 | 实例数 | 单价（元/月）| 小计（元/月）|\n|-----|------|-------|------------|------------|\n| Kafka Broker | 8核32G | 3 | 2,500 | 7,500 |\n| ZooKeeper | 4核16G | 3 | 800 | 2,400 |\n| **合计** | - | **6** | - | **9,900** |\n\n**对象存储与CDN**:\n- 对象存储（文件、备份）: 2,000 元/月\n- CDN 流量费: 1,000 元/月\n- **小计**: 3,000 元/月\n\n**监控与日志**:\n- Prometheus + Grafana: 1,500 元/月（托管服务）\n- Loki 日志存储: 2,000 元/月\n- Jaeger 追踪存储: 1,000 元/月\n- **小计**: 4,500 元/月\n\n**域名与证书**:\n- 域名注册续费: 100 元/月\n- SSL 证书: 200 元/月\n- **小计**: 300 元/月\n\n**基础设施月度总计**: 60,500 元/月\n**基础设施年度总计**: 726,000 元/年\n\n### 5.3 软件与工具成本\n\n#### 开发工具与服务（年度）\n\n| 工具/服务 | 用途 | 用户数 | 单价（元/年）| 总价（元/年）|\n|-----------|------|-------|------------|------------|\n| GitHub Team | 代码托管 | 5 | 300 | 1,500 |\n| Jira Software | 项目管理 | 5 | 500 | 2,500 |\n| Confluence | 文档管理 | 5 | 400 | 2,000 |\n| Slack/企业微信 | 团队沟通 | 5 | 200 | 1,000 |\n| JetBrains All Products | IDE授权 | 5 | 1,500 | 7,500 |\n| Postman Team | API 测试 | 5 | 300 | 1,500 |\n| Figma Professional | UI 设计 | 1 | 1,000 | 1,000 |\n| **合计** | - | - | - | **17,000** |\n\n#### 监控与 APM 服务\n\n| 服务 | 用途 | 费用（元/年）|\n|------|------|------------|\n| Datadog APM | 应用性能监控 | 30,000 |\n| PagerDuty | 告警通知 | 10,000 |\n| **合计** | - | **40,000** |\n\n**软件工具年度总计**: 57,000 元\n\n### 5.4 其他成本\n\n| 项目 | 金额（元/年）| 说明 |\n|------|------------|------|\n| 办公设备 | 50,000 | MacBook Pro、显示器、键鼠等 |\n| 办公场地 | 120,000 | 工位租赁、水电网费 |\n| 差旅费 | 30,000 | 出差、会议参加 |\n| 书籍资料 | 10,000 | 技术书籍、订阅 |\n| 应急储备金 | 100,000 | 预留 10% 应急 |\n| **合计** | **310,000** | - |\n\n### 5.5 预算总表\n\n| 类别 | 年度预算（元）| 占比 |\n|------|-------------|------|\n| 人力成本 | 2,470,000 | 68.2% |\n| 基础设施 | 726,000 | 20.0% |\n| 软件工具 | 57,000 | 1.6% |\n| 其他成本 | 310,000 | 8.6% |\n| **总计** | **3,563,000** | **100%** |\n\n**按月分摊**: 296,917 元/月\n\n### 5.6 成本优化策略\n\n**云资源优化**:\n- 使用预留实例（Reserved Instances）节省 30-50%\n- 非工作时间关闭测试/开发环境\n- 使用 Spot 实例运行批处理任务\n\n**开源替代方案**:\n- 使用 Grafana Cloud 免费版（小规模）\n- 使用 GitLab CE 替代 GitHub（私有化部署）\n- 使用 Mattermost 替代 Slack（开源）\n\n**批量采购**:\n- 提前续费享受折扣（云服务年付 15% 折扣）\n- 团队授权批量购买（JetBrains 5 用户以上 20% 折扣）\n\n**预期节省**: 约 15-20% 年度成本（约 50-70 万元）\n\n---\n\n## 六、供应商与第三方管理\n\n### 6.1 供应商清单\n\n#### 云服务提供商\n\n**主供应商: 阿里云 / AWS / Azure**\n- **服务范围**: 计算、存储、数据库、网络\n- **合同周期**: 1年\n- **付款方式**: 按月后付费\n- **SLA 承诺**: 99.95% 可用性\n- **联系人**:\n  - 销售经理: 张三（电话：xxx）\n  - 技术支持: 400-xxx-xxxx\n- **升级路径**:\n  - 技术支持 → 客户经理 → 架构师支持\n\n#### 第三方 SaaS 服务\n\n**Datadog (监控服务)**\n- **服务内容**: APM、基础设施监控、日志管理\n- **定价**: $15/主机/月\n- **合同**: 年付，12个月\n- **技术支持**: 邮件 + 在线文档\n\n**PagerDuty (告警服务)**\n- **服务内容**: 事故管理、值班排班、告警路由\n- **定价**: $21/用户/月\n- **合同**: 月付，可随时取消\n- **集成**: 与 Datadog、Prometheus 集成\n\n### 6.2 供应商管理流程\n\n#### 供应商选型评估\n\n**评估维度**:\n```\n技术能力 (30%)\n  ├── 功能完整性\n  ├── 性能指标\n  ├── 安全合规\n  └── 技术支持质量\n\n商务条款 (25%)\n  ├── 价格竞争力\n  ├── 合同灵活性\n  ├── 付款条件\n  └── SLA 承诺\n\n稳定性 (25%)\n  ├── 公司背景\n  ├── 客户案例\n  ├── 历史可用性\n  └── 财务健康度\n\n生态兼容性 (20%)\n  ├── API 开放性\n  ├── 集成便利性\n  ├── 迁移成本\n  └── 社区活跃度\n```\n\n**评分标准**: 总分 100 分，80 分以上合格\n\n#### 合同管理\n\n**合同审核清单**:\n- ✅ SLA 可用性承诺（≥ 99.9%）\n- ✅ 故障赔偿条款（按宕机时间按比例退费）\n- ✅ 数据所有权归属（数据属于客户）\n- ✅ 数据导出权利（随时可导出全部数据）\n- ✅ 提前终止条款（提前 30 天通知）\n- ✅ 价格锁定期（至少 1 年价格不变）\n- ✅ 技术支持响应时间（P0: 15分钟，P1: 1小时）\n- ✅ 安全与合规（ISO27001、SOC2 认证）\n\n**合同续签提醒**:\n- 提前 60 天开始续签评估\n- 提前 30 天完成商务谈判\n- 提前 15 天完成合同签署\n\n### 6.3 风险管理\n\n#### 供应商锁定风险\n\n**避免策略**:\n- 使用开源标准（Kubernetes、Kafka 而非专有服务）\n- 避免使用云厂商专有 API\n- 保持多云架构能力（至少在架构设计上支持）\n- 定期演练迁移流程\n\n**应急预案**:\n- 备份云账号（备用云厂商账号已开通）\n- 数据定期异地备份（每日全量备份到对象存储）\n- 核心服务容器化（可快速迁移）\n\n#### 服务中断风险\n\n**监控策略**:\n- 订阅云厂商状态页（Status Page）\n- 配置多渠道告警（邮件、短信、电话）\n- 定期查看服务健康报告\n\n**应对措施**:\n- P0 故障：立即联系供应商技术支持 + 启动应急预案\n- P1 故障：1 小时内联系技术支持\n- 定期故障演练（每季度一次）\n\n---\n\n## 七、数据迁移策略\n\n### 7.1 数据迁移总体规划\n\n#### 迁移范围\n\n**源系统**: 旧 ERP 系统（假设为传统 KILLER ECC 或其他系统）\n**目标系统**: Rust ERP 微服务系统\n\n**数据分类**:\n```\n主数据 (Master Data)\n  ├── 客户主数据 (Customer)\n  ├── 供应商主数据 (Vendor)\n  ├── 物料主数据 (Material)\n  ├── 会计科目表 (Chart of Accounts)\n  ├── 成本中心 (Cost Center)\n  ├── 员工主数据 (Employee)\n  └── 组织架构 (Organizational Structure)\n\n交易数据 (Transactional Data)\n  ├── 财务凭证 (Journal Entries)\n  ├── 采购订单 (Purchase Orders)\n  ├── 销售订单 (Sales Orders)\n  ├── 库存移动 (Inventory Movements)\n  ├── 生产订单 (Production Orders)\n  └── 工资单 (Payroll Records)\n\n历史数据 (Historical Data)\n  ├── 已关闭会计期间数据\n  ├── 已完成订单\n  └── 归档单据\n```\n\n#### 迁移策略选择\n\n| 数据类型 | 迁移策略 | 迁移时间 | 原因 |\n|---------|---------|---------|------|\n| 主数据 | Big Bang（一次性）| 上线前 1 周 | 数据量小，变化频率低 |\n| 当期交易数据 | Big Bang | 上线当天 | 确保数据一致性 |\n| 历史交易数据 | 渐进式 | 上线后 3 个月 | 数据量大，优先级低 |\n| 归档数据 | 按需迁移 | 上线后 6 个月 | 访问频率极低 |\n\n### 7.2 迁移实施计划\n\n#### 第 11 个月（上线前 1 个月）：迁移准备\n\n**Week 1-2: 数据分析**\n- **数据盘点**:\n  - 统计各类数据表数量\n  - 评估数据总量（行数、存储大小）\n  - 识别数据质量问题（重复、缺失、格式错误）\n- **数据建模映射**:\n  - 源系统表结构 → 目标系统表结构映射\n  - 字段对应关系表\n  - 数据转换规则（币种转换、单位换算）\n\n**Week 3: 迁移工具开发**\n- 开发数据抽取工具（Extract）\n  - 从旧系统数据库读取数据\n  - 支持增量抽取（基于时间戳）\n- 开发数据转换工具（Transform）\n  - 数据清洗（去重、格式化）\n  - 业务规则转换\n  - 数据验证\n- 开发数据加载工具（Load）\n  - 批量插入目标数据库\n  - 事务控制\n  - 错误处理和回滚\n\n**Week 4: 试迁移（第1次）**\n- 迁移测试环境数据\n- 验证数据完整性\n- 记录问题和优化点\n- 评估迁移耗时\n\n#### 第 12 个月（上线月）：正式迁移\n\n**Day 1-7: 主数据迁移**\n- **Day 1-2**: 客户、供应商、物料主数据\n- **Day 3-4**: 会计科目、成本中心\n- **Day 5-6**: 员工、组织架构\n- **Day 7**: 数据验证和修正\n\n**Day 8-14: 试迁移（第2次）**\n- 迁移预发布环境全量数据\n- 端到端业务流程测试\n- 性能测试（大数据量查询）\n- 用户验收测试（UAT）\n\n**上线当天: 最终迁移**\n- **00:00-02:00**: 停止旧系统写入，导出最终数据\n- **02:00-06:00**: 执行数据迁移\n- **06:00-08:00**: 数据验证\n- **08:00-09:00**: 系统切换，启动新系统\n- **09:00-18:00**: 监控运行，快速响应问题\n\n### 7.3 数据验证策略\n\n#### 验证维度\n\n**数量验证**:\n- 源表记录数 = 目标表记录数\n- 按类别分组统计一致\n\n**完整性验证**:\n- 必填字段无空值\n- 外键关联完整（无孤儿记录）\n- 主键唯一性\n\n**准确性验证**:\n- 抽样对比明细数据\n- 关键金额字段求和对比\n- 状态字段枚举值检查\n\n**一致性验证**:\n- 跨表数据逻辑一致\n  - 示例: 订单总金额 = Σ 订单行金额\n  - 示例: 科目余额 = Σ 分录借方 - Σ 分录贷方\n\n#### 验证工具\n\n**SQL 对比脚本**:\n```sql\n-- 数量验证示例\nSELECT\n  '源系统' AS source,\n  COUNT(*) AS record_count\nFROM legacy_erp.customers\nUNION ALL\nSELECT\n  '目标系统' AS source,\n  COUNT(*) AS record_count\nFROM rust_erp.customers;\n\n-- 金额汇总对比\nSELECT\n  SUM(total_amount) AS total\nFROM legacy_erp.sales_orders\nWHERE status = 'COMPLETED';\n\nSELECT\n  SUM(total_amount) AS total\nFROM rust_erp.sales_orders\nWHERE status = 'COMPLETED';\n```\n\n**自动化验证报告**:\n- 每次迁移后自动生成验证报告\n- 高亮不一致的数据\n- 提供钻取明细的 SQL\n\n### 7.4 数据回滚方案\n\n#### 回滚触发条件\n\n**强制回滚**:\n- 数据丢失 > 1%\n- 核心业务无法运行\n- 数据一致性严重破坏（账不平）\n\n**可选回滚**:\n- 性能严重下降（响应时间 > 5秒）\n- 发现大量数据质量问题\n- 用户强烈抵制新系统\n\n#### 回滚操作步骤\n\n**Step 1: 停止新系统**\n- 关闭所有微服务\n- 阻止外部流量\n\n**Step 2: 恢复旧系统**\n- 启动旧系统服务\n- 恢复数据库到备份点\n- 切换 DNS 和负载均衡\n\n**Step 3: 数据补录**\n- 手动补录新系统运行期间的数据（如有）\n- 通知用户数据恢复完成\n\n**Step 4: 问题分析**\n- 复盘迁移失败原因\n- 制定改进方案\n- 安排下次迁移时间\n\n**回滚时间要求**: < 1 小时\n\n### 7.5 历史数据归档策略\n\n**归档策略**:\n- **3年内数据**: 在线存储（PostgreSQL 主库）\n- **3-7年数据**: 冷存储（PostgreSQL 归档库）\n- **7年以上数据**: 对象存储（S3/OSS）+ 元数据索引\n\n**访问方式**:\n- 在线数据: 直接查询\n- 冷存储数据: 慢查询（可接受 10 秒延迟）\n- 归档数据: 申请后 24 小时内恢复\n\n---\n\n## 八、用户培训与推广\n\n### 8.1 用户分层培训\n\n#### 用户角色分类\n\n| 角色 | 人数 | 使用频率 | 培训重点 |\n|-----|------|---------|---------|\n| **系统管理员** | 2-3 | 每天 | 系统配置、用户管理、权限分配、故障排查 |\n| **财务会计** | 10-15 | 每天 | 凭证录入、账簿查询、报表生成、期末结账 |\n| **采购人员** | 5-8 | 每天 | 采购申请、采购订单、收货、发票校验 |\n| **销售人员** | 10-15 | 每天 | 销售订单、发货、开票、客户管理 |\n| **仓库管理员** | 3-5 | 每天 | 入库、出库、移库、盘点 |\n| **HR 专员** | 3-5 | 每天 | 员工管理、考勤、薪资核算 |\n| **生产计划员** | 2-3 | 每天 | BOM 管理、生产订单、MRP 运行 |\n| **高层管理者** | 5-10 | 每周 | 仪表盘查看、报表分析、决策支持 |\n| **普通员工** | 50+ | 偶尔 | 自助服务（请假、报销、工资单查询）|\n\n### 8.2 培训计划\n\n#### 第 11 个月：培训准备\n\n**Week 1-2: 培训材料开发**\n- **用户手册编写**:\n  - 快速入门指南（10 页以内）\n  - 分模块操作手册（每个模块 20-30 页）\n  - 常见问题 FAQ\n  - 视频教程（每个功能 5-10 分钟）\n- **培训环境准备**:\n  - 搭建培训专用系统（隔离生产）\n  - 准备测试数据\n  - 配置培训账号\n\n**Week 3-4: 培训师培养**\n- 选拔内部培训师（2-3 人）\n- 培训师培训（Train the Trainer）\n- 试讲和演练\n\n#### 第 12 个月：正式培训\n\n**Week 1: 系统管理员培训**（2天集中培训）\n- **Day 1**:\n  - 系统架构概览\n  - 用户管理和权限配置\n  - 系统参数设置\n  - 基础数据维护\n- **Day 2**:\n  - 日常监控和巡检\n  - 常见问题排查\n  - 数据备份和恢复\n  - 应急响应流程\n\n**Week 2: 核心用户培训**（按模块分批）\n- **财务模块**（2天）:\n  - Day 1: 会计科目、凭证录入、审批流程\n  - Day 2: 账簿查询、期末结账、报表生成\n- **供应链模块**（2天）:\n  - Day 1: 采购订单、收货、库存管理\n  - Day 2: 销售订单、发货、开票\n- **HR 模块**（1天）:\n  - 员工管理、考勤、薪资核算\n\n**Week 3: 全员培训**（分批进行）\n- 每批 20-30 人\n- 4 小时集中培训\n- 重点: 自助服务功能使用\n\n**Week 4: 强化训练**\n- 模拟实际业务场景\n- 端到端流程演练\n- 考核测试（合格才能上线使用）\n\n### 8.3 培训方式\n\n#### 线下集中培训\n- **优点**: 互动性强、效果好\n- **缺点**: 组织成本高\n- **适用**: 核心用户、系统管理员\n\n#### 在线视频培训\n- **优点**: 可重复观看、成本低\n- **缺点**: 缺乏互动\n- **适用**: 全员培训、远程用户\n\n#### 实操演练\n- **优点**: 加深理解、发现问题\n- **缺点**: 需要培训环境\n- **适用**: 所有用户\n\n#### 导师辅导\n- **优点**: 个性化、及时解答\n- **缺点**: 人力成本高\n- **适用**: 重点用户、疑难问题\n\n### 8.4 培训效果评估\n\n#### 培训考核\n\n**理论考试**:\n- 选择题 + 简答题\n- 及格分数: 80 分\n- 不及格: 补考或重新培训\n\n**实操考核**:\n- 完成指定业务场景\n- 评估标准: 准确性、效率\n- 不合格: 一对一辅导\n\n**上岗认证**:\n- 理论 + 实操双合格\n- 颁发上岗证书\n- 记录在系统中\n\n#### 培训效果跟踪\n\n**上线后第 1 周**:\n- 每天现场支持\n- 收集问题和反馈\n- 快速答疑\n\n**上线后第 1 个月**:\n- 每周回访\n- 统计高频问题\n- 补充培训材料\n\n**上线后第 3 个月**:\n- 用户满意度调查\n- 识别培训缺失环节\n- 安排进阶培训\n\n### 8.5 持续支持机制\n\n#### 帮助中心建设\n\n**在线帮助系统**:\n- 集成在系统内（右上角帮助按钮）\n- 上下文敏感帮助（根据当前页面显示相关文档）\n- 全文搜索功能\n\n**视频库**:\n- 分类整理（按模块、按角色）\n- 每个功能录制操作视频\n- 支持弹幕提问\n\n**FAQ 知识库**:\n- 持续更新常见问题\n- 用户可评价答案有用性\n- 搜索引擎优化\n\n#### 用户支持团队\n\n**一线支持（Help Desk）**:\n- **人员**: 2-3 人轮班\n- **渠道**: 电话、在线聊天、工单系统\n- **响应时间**: 15 分钟内响应\n- **解决能力**: 80% 的常见问题\n\n**二线支持（技术团队）**:\n- **人员**: 开发团队轮值（每周轮换）\n- **响应时间**: 1 小时内响应\n- **解决能力**: 复杂技术问题、缺陷修复\n\n**升级路径**:\n```\n用户 → 一线支持（FAQ 查询）→ 二线支持（技术团队）→ 架构师\n```\n\n---\n\n## 后续章节\n\n第九章至第十二章的内容请参阅：**《Rust-ERP系统-上线运维与演进计划补充文档.md》**\n\n该文档包含：\n- ✅ 第九章：上线检查清单（上线前4周至上线当天详细执行清单）\n- ✅ 第十章：应急响应预案（故障等级、4个常见故障应急预案、应急演练）\n- ✅ 第十一章：运维交接计划（运维团队建设、交接内容、双周陪跑期）\n- ✅ 第十二章：长期演进路线图（3年演进规划、SaaS化、智能化）\n\n---\n\n**文档版本**: v1.0\n**最后更新**: 2025-12-21\n**维护者**: Rust ERP 项目组\n**下次审阅**: 2026-01-21\n\n---\n\n**相关文档**:\n- 主文档：《Rust-ERP系统-5人团队12个月开发计划.md》\n- 补充文档（上线运维）：《Rust-ERP系统-上线运维与演进计划补充文档.md》\n- 技术文档：《Rust-DDD-微服务架构最佳实践.md》\n- 架构文档：《Rust-ERP系统架构设计文档.md》\n", "md/Rust-Implementation-Guide.md": "# Rust ERP 系统 - 实施技术指南\n\n**配套文档**: Rust-Abc-Enhanced.md\n**版本**: v1.0\n**创建日期**: 2025-12-22\n**说明**: 本文档提供12个月开发计划的详细技术实施指南\n\n---\n\n## 目录\n\n1. [API设计规范与示例](#一api设计规范与示例)\n2. [数据库设计模式与迁移](#二数据库设计模式与迁移)\n3. [分布式事务处理（Saga模式）](#三分布式事务处理saga模式)\n4. [安全加固详细方案](#四安全加固详细方案)\n5. [监控告警详细配置](#五监控告警详细配置)\n6. [测试策略详细方案](#六测试策略详细方案)\n7. [Kubernetes部署配置](#七kubernetes部署配置)\n8. [CI/CD Pipeline详细配置](#八cicd-pipeline详细配置)\n9. [运维Runbook模板](#九运维runbook模板)\n10. [代码规范和最佳实践](#十代码规范和最佳实践)\n\n---\n\n## 一、API设计规范与示例\n\n### 1.1 REST API 设计规范\n\n#### 1.1.1 URL命名规范\n\n```\n格式: /api/{version}/{domain}/{resource}\n\n示例:\n- /api/v1/financial/accounts\n- /api/v1/financial/transactions\n- /api/v1/materials/purchase-orders\n- /api/v1/sales/orders\n```\n\n#### 1.1.2 HTTP方法语义\n\n| 方法 | 语义 | 幂等性 | 示例 |\n|-----|------|--------|------|\n| GET | 查询资源 | 是 | GET /api/v1/financial/accounts/123 |\n| POST | 创建资源 | 否* | POST /api/v1/financial/transactions |\n| PUT | 完整更新资源 | 是 | PUT /api/v1/financial/accounts/123 |\n| PATCH | 部分更新资源 | 否 | PATCH /api/v1/financial/accounts/123 |\n| DELETE | 删除资源 | 是 | DELETE /api/v1/financial/accounts/123 |\n\n*注：POST通过Idempotency-Key实现幂等\n\n#### 1.1.3 请求幂等性设计\n\n**所有写操作（POST/PATCH）必须支持幂等性**\n\n```rust\n// HTTP Header\nIdempotency-Key: 550e8400-e29b-41d4-a716-446655440000\n\n// 服务端实现\n#[derive(Debug, Deserialize)]\npub struct CreateTransactionRequest {\n    pub idempotency_key: Uuid,  // 必填\n    pub posting_date: NaiveDate,\n    pub company_code: String,\n    pub journal_entries: Vec<JournalEntryDto>,\n}\n\n// Handler\npub async fn create_transaction(\n    State(state): State<AppState>,\n    headers: HeaderMap,\n    Json(req): Json<CreateTransactionRequest>,\n) -> Result<Json<TransactionResponse>, ApiError> {\n    // 1. 检查幂等键是否已存在\n    if let Some(cached) = state.redis\n        .get::<String>(&format!(\"idempotency:{}\", req.idempotency_key))\n        .await?\n    {\n        // 返回缓存的响应\n        return Ok(Json(serde_json::from_str(&cached)?));\n    }\n\n    // 2. 执行业务逻辑\n    let result = state.transaction_service\n        .create_transaction(req)\n        .await?;\n\n    // 3. 缓存响应（TTL 24小时）\n    state.redis\n        .set_ex(\n            &format!(\"idempotency:{}\", req.idempotency_key),\n            serde_json::to_string(&result)?,\n            86400,\n        )\n        .await?;\n\n    Ok(Json(result))\n}\n```\n\n#### 1.1.4 统一错误响应格式\n\n```rust\n#[derive(Debug, Serialize)]\npub struct ApiError {\n    /// 错误码（业务错误码）\n    pub code: String,\n    /// 错误消息（用户友好）\n    pub message: String,\n    /// 详细错误（开发调试用）\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub details: Option<Vec<ErrorDetail>>,\n    /// 追踪ID\n    pub trace_id: String,\n    /// 时间戳\n    pub timestamp: DateTime<Utc>,\n}\n\n#[derive(Debug, Serialize)]\npub struct ErrorDetail {\n    pub field: String,\n    pub message: String,\n}\n\n// 错误码设计\npub mod error_codes {\n    // 4xx 客户端错误\n    pub const INVALID_REQUEST: &str = \"ERR_INVALID_REQUEST\";\n    pub const UNAUTHORIZED: &str = \"ERR_UNAUTHORIZED\";\n    pub const FORBIDDEN: &str = \"ERR_FORBIDDEN\";\n    pub const NOT_FOUND: &str = \"ERR_NOT_FOUND\";\n    pub const CONFLICT: &str = \"ERR_CONFLICT\";\n    pub const VALIDATION_FAILED: &str = \"ERR_VALIDATION_FAILED\";\n\n    // 5xx 服务端错误\n    pub const INTERNAL_ERROR: &str = \"ERR_INTERNAL\";\n    pub const SERVICE_UNAVAILABLE: &str = \"ERR_SERVICE_UNAVAILABLE\";\n    pub const TIMEOUT: &str = \"ERR_TIMEOUT\";\n\n    // 业务错误\n    pub const INSUFFICIENT_BALANCE: &str = \"FIN_INSUFFICIENT_BALANCE\";\n    pub const CREDIT_LIMIT_EXCEEDED: &str = \"FSCM_CREDIT_LIMIT_EXCEEDED\";\n    pub const INVENTORY_NOT_AVAILABLE: &str = \"MM_INVENTORY_NOT_AVAILABLE\";\n    pub const DUPLICATE_TRANSACTION: &str = \"FIN_DUPLICATE_TRANSACTION\";\n}\n\n// 错误响应示例\n{\n  \"code\": \"ERR_VALIDATION_FAILED\",\n  \"message\": \"Validation failed for the request\",\n  \"details\": [\n    {\n      \"field\": \"posting_date\",\n      \"message\": \"Posting date cannot be in the future\"\n    },\n    {\n      \"field\": \"journal_entries\",\n      \"message\": \"Debit and credit amounts must be balanced\"\n    }\n  ],\n  \"trace_id\": \"4bf92f3577b34da6a3ce929d0e0e4736\",\n  \"timestamp\": \"2025-12-22T10:30:00Z\"\n}\n```\n\n#### 1.1.5 分页查询规范\n\n```rust\n// 请求参数\n#[derive(Debug, Deserialize)]\npub struct PaginationParams {\n    #[serde(default = \"default_page\")]\n    pub page: u32,  // 页码（从1开始）\n\n    #[serde(default = \"default_page_size\")]\n    pub page_size: u32,  // 每页大小（默认20）\n\n    #[serde(default)]\n    pub sort_by: Option<String>,  // 排序字段\n\n    #[serde(default)]\n    pub sort_order: SortOrder,  // 排序方向\n}\n\n#[derive(Debug, Deserialize)]\n#[serde(rename_all = \"lowercase\")]\npub enum SortOrder {\n    Asc,\n    Desc,\n}\n\nfn default_page() -> u32 { 1 }\nfn default_page_size() -> u32 { 20 }\n\n// 响应格式\n#[derive(Debug, Serialize)]\npub struct PaginatedResponse<T> {\n    pub data: Vec<T>,\n    pub pagination: PaginationMeta,\n}\n\n#[derive(Debug, Serialize)]\npub struct PaginationMeta {\n    pub page: u32,\n    pub page_size: u32,\n    pub total_pages: u32,\n    pub total_items: u64,\n    pub has_next: bool,\n    pub has_previous: bool,\n}\n\n// 查询示例\n// GET /api/v1/financial/transactions?page=2&page_size=50&sort_by=posting_date&sort_order=desc\n```\n\n#### 1.1.6 完整API示例：财务凭证接口\n\n```rust\n// src/api/http/handlers/transaction_handler.rs\n\nuse axum::{\n    extract::{Path, Query, State},\n    http::{HeaderMap, StatusCode},\n    response::IntoResponse,\n    Json,\n};\nuse uuid::Uuid;\n\n/// 创建财务凭证\n/// POST /api/v1/financial/transactions\n#[utoipa::path(\n    post,\n    path = \"/api/v1/financial/transactions\",\n    request_body = CreateTransactionRequest,\n    responses(\n        (status = 201, description = \"Transaction created successfully\", body = TransactionResponse),\n        (status = 400, description = \"Invalid request\", body = ApiError),\n        (status = 409, description = \"Duplicate transaction\", body = ApiError),\n    ),\n    tag = \"Financial Transactions\"\n)]\npub async fn create_transaction(\n    State(state): State<AppState>,\n    headers: HeaderMap,\n    Json(req): Json<CreateTransactionRequest>,\n) -> Result<impl IntoResponse, ApiError> {\n    // 提取追踪ID\n    let trace_id = extract_trace_id(&headers);\n\n    // 执行命令\n    let command = CreateTransactionCommand {\n        idempotency_key: req.idempotency_key,\n        posting_date: req.posting_date,\n        document_date: req.document_date,\n        company_code: req.company_code,\n        fiscal_year: req.fiscal_year,\n        journal_entries: req.journal_entries.into_iter().map(Into::into).collect(),\n    };\n\n    let result = state.command_bus\n        .dispatch(command)\n        .await\n        .map_err(|e| ApiError::from_domain_error(e, trace_id.clone()))?;\n\n    Ok((\n        StatusCode::CREATED,\n        Json(TransactionResponse::from(result)),\n    ))\n}\n\n/// 查询财务凭证详情\n/// GET /api/v1/financial/transactions/{id}\n#[utoipa::path(\n    get,\n    path = \"/api/v1/financial/transactions/{id}\",\n    params(\n        (\"id\" = Uuid, Path, description = \"Transaction ID\")\n    ),\n    responses(\n        (status = 200, description = \"Transaction found\", body = TransactionResponse),\n        (status = 404, description = \"Transaction not found\", body = ApiError),\n    ),\n    tag = \"Financial Transactions\"\n)]\npub async fn get_transaction(\n    State(state): State<AppState>,\n    Path(id): Path<Uuid>,\n) -> Result<Json<TransactionResponse>, ApiError> {\n    let query = GetTransactionQuery { transaction_id: id };\n\n    let result = state.query_bus\n        .dispatch(query)\n        .await\n        .map_err(|e| ApiError::from_domain_error(e, trace_id()))?;\n\n    Ok(Json(result))\n}\n\n/// 查询财务凭证列表\n/// GET /api/v1/financial/transactions\n#[utoipa::path(\n    get,\n    path = \"/api/v1/financial/transactions\",\n    params(\n        PaginationParams,\n        TransactionFilterParams,\n    ),\n    responses(\n        (status = 200, description = \"List of transactions\", body = PaginatedResponse<TransactionResponse>),\n    ),\n    tag = \"Financial Transactions\"\n)]\npub async fn list_transactions(\n    State(state): State<AppState>,\n    Query(pagination): Query<PaginationParams>,\n    Query(filters): Query<TransactionFilterParams>,\n) -> Result<Json<PaginatedResponse<TransactionResponse>>, ApiError> {\n    let query = ListTransactionsQuery {\n        page: pagination.page,\n        page_size: pagination.page_size,\n        company_code: filters.company_code,\n        posting_date_from: filters.posting_date_from,\n        posting_date_to: filters.posting_date_to,\n        status: filters.status,\n    };\n\n    let result = state.query_bus\n        .dispatch(query)\n        .await\n        .map_err(|e| ApiError::from_domain_error(e, trace_id()))?;\n\n    Ok(Json(result))\n}\n\n/// 冲销财务凭证\n/// POST /api/v1/financial/transactions/{id}/reverse\n#[utoipa::path(\n    post,\n    path = \"/api/v1/financial/transactions/{id}/reverse\",\n    params(\n        (\"id\" = Uuid, Path, description = \"Transaction ID to reverse\")\n    ),\n    request_body = ReverseTransactionRequest,\n    responses(\n        (status = 200, description = \"Transaction reversed successfully\", body = TransactionResponse),\n        (status = 404, description = \"Transaction not found\", body = ApiError),\n        (status = 409, description = \"Transaction already reversed\", body = ApiError),\n    ),\n    tag = \"Financial Transactions\"\n)]\npub async fn reverse_transaction(\n    State(state): State<AppState>,\n    Path(id): Path<Uuid>,\n    Json(req): Json<ReverseTransactionRequest>,\n) -> Result<Json<TransactionResponse>, ApiError> {\n    let command = ReverseTransactionCommand {\n        transaction_id: id,\n        reversal_date: req.reversal_date,\n        reason: req.reason,\n    };\n\n    let result = state.command_bus\n        .dispatch(command)\n        .await\n        .map_err(|e| ApiError::from_domain_error(e, trace_id()))?;\n\n    Ok(Json(result))\n}\n\n// DTOs\n#[derive(Debug, Deserialize, utoipa::ToSchema)]\npub struct CreateTransactionRequest {\n    #[schema(example = \"550e8400-e29b-41d4-a716-446655440000\")]\n    pub idempotency_key: Uuid,\n\n    #[schema(example = \"2025-12-22\")]\n    pub posting_date: NaiveDate,\n\n    #[schema(example = \"2025-12-20\")]\n    pub document_date: NaiveDate,\n\n    #[schema(example = \"1000\")]\n    pub company_code: String,\n\n    #[schema(example = 2025)]\n    pub fiscal_year: i32,\n\n    pub journal_entries: Vec<JournalEntryDto>,\n}\n\n#[derive(Debug, Deserialize, utoipa::ToSchema)]\npub struct JournalEntryDto {\n    #[schema(example = \"100000\")]\n    pub account_number: String,\n\n    #[schema(example = 10000.00)]\n    pub debit_amount: Decimal,\n\n    #[schema(example = 0.00)]\n    pub credit_amount: Decimal,\n\n    #[schema(example = \"USD\")]\n    pub currency: String,\n\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub cost_center: Option<String>,\n\n    #[serde(skip_serializing_if = \"Option::is_none\")]\n    pub profit_center: Option<String>,\n}\n\n#[derive(Debug, Serialize, utoipa::ToSchema)]\npub struct TransactionResponse {\n    pub transaction_id: Uuid,\n    pub transaction_number: String,\n    pub posting_date: NaiveDate,\n    pub document_date: NaiveDate,\n    pub company_code: String,\n    pub fiscal_year: i32,\n    pub status: TransactionStatus,\n    pub journal_entries: Vec<JournalEntryDto>,\n    pub created_at: DateTime<Utc>,\n    pub created_by: String,\n}\n\n#[derive(Debug, Deserialize)]\npub struct TransactionFilterParams {\n    pub company_code: Option<String>,\n    pub posting_date_from: Option<NaiveDate>,\n    pub posting_date_to: Option<NaiveDate>,\n    pub status: Option<TransactionStatus>,\n}\n```\n\n### 1.2 gRPC API 设计规范\n\n#### 1.2.1 Protobuf 命名规范\n\n```protobuf\n// proto/financial/v1/transaction_service.proto\n\nsyntax = \"proto3\";\n\npackage erp.financial.v1;\n\nimport \"google/protobuf/timestamp.proto\";\nimport \"google/protobuf/empty.proto\";\n\n// 服务定义\nservice TransactionService {\n  // 创建财务凭证（幂等）\n  rpc CreateTransaction(CreateTransactionRequest) returns (CreateTransactionResponse);\n\n  // 查询财务凭证\n  rpc GetTransaction(GetTransactionRequest) returns (GetTransactionResponse);\n\n  // 查询财务凭证列表\n  rpc ListTransactions(ListTransactionsRequest) returns (ListTransactionsResponse);\n\n  // 冲销财务凭证\n  rpc ReverseTransaction(ReverseTransactionRequest) returns (ReverseTransactionResponse);\n\n  // 批量创建财务凭证（幂等）\n  rpc BatchCreateTransactions(BatchCreateTransactionsRequest) returns (BatchCreateTransactionsResponse);\n}\n\n// 请求消息\nmessage CreateTransactionRequest {\n  // 幂等键（必填）\n  string idempotency_key = 1;\n\n  // 过账日期\n  string posting_date = 2;  // ISO 8601 格式: \"2025-12-22\"\n\n  // 凭证日期\n  string document_date = 3;\n\n  // 公司代码\n  string company_code = 4;\n\n  // 会计年度\n  int32 fiscal_year = 5;\n\n  // 分录\n  repeated JournalEntry journal_entries = 6;\n\n  // 附件（可选）\n  repeated Attachment attachments = 7;\n}\n\nmessage JournalEntry {\n  string account_number = 1;\n  double debit_amount = 2;\n  double credit_amount = 3;\n  string currency = 4;\n  optional string cost_center = 5;\n  optional string profit_center = 6;\n  optional string text = 7;\n}\n\nmessage Attachment {\n  string filename = 1;\n  string content_type = 2;\n  bytes content = 3;\n}\n\n// 响应消息\nmessage CreateTransactionResponse {\n  string transaction_id = 1;\n  string transaction_number = 2;\n  TransactionStatus status = 3;\n  google.protobuf.Timestamp created_at = 4;\n}\n\nenum TransactionStatus {\n  TRANSACTION_STATUS_UNSPECIFIED = 0;\n  TRANSACTION_STATUS_DRAFT = 1;\n  TRANSACTION_STATUS_POSTED = 2;\n  TRANSACTION_STATUS_REVERSED = 3;\n}\n\n// 查询请求\nmessage GetTransactionRequest {\n  string transaction_id = 1;\n}\n\nmessage GetTransactionResponse {\n  Transaction transaction = 1;\n}\n\nmessage Transaction {\n  string transaction_id = 1;\n  string transaction_number = 2;\n  string posting_date = 3;\n  string document_date = 4;\n  string company_code = 5;\n  int32 fiscal_year = 6;\n  TransactionStatus status = 7;\n  repeated JournalEntry journal_entries = 8;\n  google.protobuf.Timestamp created_at = 9;\n  string created_by = 10;\n}\n\n// 列表查询\nmessage ListTransactionsRequest {\n  int32 page = 1;\n  int32 page_size = 2;\n  optional string company_code = 3;\n  optional string posting_date_from = 4;\n  optional string posting_date_to = 5;\n  optional TransactionStatus status = 6;\n}\n\nmessage ListTransactionsResponse {\n  repeated Transaction transactions = 1;\n  PaginationMeta pagination = 2;\n}\n\nmessage PaginationMeta {\n  int32 page = 1;\n  int32 page_size = 2;\n  int32 total_pages = 3;\n  int64 total_items = 4;\n  bool has_next = 5;\n  bool has_previous = 6;\n}\n```\n\n#### 1.2.2 gRPC 服务端实现\n\n```rust\n// src/api/grpc/services/transaction_service.rs\n\nuse tonic::{Request, Response, Status};\nuse uuid::Uuid;\n\npub mod financial {\n    tonic::include_proto!(\"erp.financial.v1\");\n}\n\nuse financial::{\n    transaction_service_server::TransactionService,\n    CreateTransactionRequest, CreateTransactionResponse,\n    GetTransactionRequest, GetTransactionResponse,\n    ListTransactionsRequest, ListTransactionsResponse,\n};\n\npub struct TransactionServiceImpl {\n    command_bus: Arc<CommandBus>,\n    query_bus: Arc<QueryBus>,\n}\n\n#[tonic::async_trait]\nimpl TransactionService for TransactionServiceImpl {\n    async fn create_transaction(\n        &self,\n        request: Request<CreateTransactionRequest>,\n    ) -> Result<Response<CreateTransactionResponse>, Status> {\n        // 提取元数据\n        let metadata = request.metadata();\n        let trace_id = metadata\n            .get(\"x-trace-id\")\n            .and_then(|v| v.to_str().ok())\n            .unwrap_or(\"unknown\");\n\n        let req = request.into_inner();\n\n        // 验证幂等键\n        let idempotency_key = Uuid::parse_str(&req.idempotency_key)\n            .map_err(|_| Status::invalid_argument(\"Invalid idempotency key\"))?;\n\n        // 构建命令\n        let command = CreateTransactionCommand {\n            idempotency_key,\n            posting_date: NaiveDate::parse_from_str(&req.posting_date, \"%Y-%m-%d\")\n                .map_err(|_| Status::invalid_argument(\"Invalid posting date format\"))?,\n            document_date: NaiveDate::parse_from_str(&req.document_date, \"%Y-%m-%d\")\n                .map_err(|_| Status::invalid_argument(\"Invalid document date format\"))?,\n            company_code: req.company_code,\n            fiscal_year: req.fiscal_year,\n            journal_entries: req.journal_entries\n                .into_iter()\n                .map(|e| JournalEntry {\n                    account_number: e.account_number,\n                    debit_amount: Decimal::from_f64(e.debit_amount)\n                        .ok_or_else(|| Status::invalid_argument(\"Invalid debit amount\"))?,\n                    credit_amount: Decimal::from_f64(e.credit_amount)\n                        .ok_or_else(|| Status::invalid_argument(\"Invalid credit amount\"))?,\n                    currency: e.currency,\n                    cost_center: e.cost_center,\n                    profit_center: e.profit_center,\n                    text: e.text,\n                })\n                .collect::<Result<Vec<_>, _>>()?,\n        };\n\n        // 执行命令\n        let result = self.command_bus\n            .dispatch(command)\n            .await\n            .map_err(|e| Status::internal(format!(\"Failed to create transaction: {}\", e)))?;\n\n        // 返回响应\n        Ok(Response::new(CreateTransactionResponse {\n            transaction_id: result.transaction_id.to_string(),\n            transaction_number: result.transaction_number,\n            status: result.status.into(),\n            created_at: Some(prost_types::Timestamp {\n                seconds: result.created_at.timestamp(),\n                nanos: result.created_at.timestamp_subsec_nanos() as i32,\n            }),\n        }))\n    }\n\n    async fn get_transaction(\n        &self,\n        request: Request<GetTransactionRequest>,\n    ) -> Result<Response<GetTransactionResponse>, Status> {\n        let req = request.into_inner();\n\n        let transaction_id = Uuid::parse_str(&req.transaction_id)\n            .map_err(|_| Status::invalid_argument(\"Invalid transaction ID\"))?;\n\n        let query = GetTransactionQuery { transaction_id };\n\n        let result = self.query_bus\n            .dispatch(query)\n            .await\n            .map_err(|e| match e {\n                QueryError::NotFound => Status::not_found(\"Transaction not found\"),\n                _ => Status::internal(format!(\"Failed to get transaction: {}\", e)),\n            })?;\n\n        Ok(Response::new(GetTransactionResponse {\n            transaction: Some(result.into()),\n        }))\n    }\n\n    // ... 其他方法实现\n}\n```\n\n#### 1.2.3 gRPC 拦截器（鉴权、日志、追踪）\n\n```rust\n// src/api/grpc/interceptors/auth_interceptor.rs\n\nuse tonic::{Request, Status};\n\npub fn auth_interceptor(mut req: Request<()>) -> Result<Request<()>, Status> {\n    let metadata = req.metadata();\n\n    // 1. 提取JWT Token\n    let token = metadata\n        .get(\"authorization\")\n        .and_then(|v| v.to_str().ok())\n        .and_then(|v| v.strip_prefix(\"Bearer \"))\n        .ok_or_else(|| Status::unauthenticated(\"Missing authorization token\"))?;\n\n    // 2. 验证JWT Token\n    let claims = verify_jwt_token(token)\n        .map_err(|_| Status::unauthenticated(\"Invalid token\"))?;\n\n    // 3. 注入用户信息到扩展\n    req.extensions_mut().insert(AuthenticatedUser {\n        user_id: claims.sub,\n        roles: claims.roles,\n        tenant_id: claims.tenant_id,\n    });\n\n    Ok(req)\n}\n\n// src/api/grpc/interceptors/logging_interceptor.rs\n\npub fn logging_interceptor(req: Request<()>) -> Result<Request<()>, Status> {\n    let metadata = req.metadata();\n    let trace_id = metadata\n        .get(\"x-trace-id\")\n        .and_then(|v| v.to_str().ok())\n        .unwrap_or(\"unknown\");\n\n    tracing::info!(\n        trace_id = trace_id,\n        method = ?req.uri().path(),\n        \"Incoming gRPC request\"\n    );\n\n    Ok(req)\n}\n\n// 服务器启动时注册拦截器\nuse tonic::transport::Server;\n\nServer::builder()\n    .layer(tower::ServiceBuilder::new()\n        .layer(tonic::service::interceptor(auth_interceptor))\n        .layer(tonic::service::interceptor(logging_interceptor))\n        .into_inner())\n    .add_service(TransactionServiceServer::new(transaction_service))\n    .serve(addr)\n    .await?;\n```\n\n---\n\n## 二、数据库设计模式与迁移\n\n### 2.1 数据库设计原则\n\n#### 2.1.1 表命名规范\n\n```sql\n-- 模式命名: {service_name}\nCREATE SCHEMA IF NOT EXISTS financial;\nCREATE SCHEMA IF NOT EXISTS materials;\nCREATE SCHEMA IF NOT EXISTS sales;\n\n-- 表命名: {aggregate_name}_{entity_name}\n-- 聚合根表\nCREATE TABLE financial.transactions (\n    transaction_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    -- ...\n);\n\n-- 子实体表\nCREATE TABLE financial.journal_entries (\n    journal_entry_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    transaction_id UUID NOT NULL REFERENCES financial.transactions(transaction_id),\n    -- ...\n);\n\n-- 值对象表（如果需要单独存储）\nCREATE TABLE financial.money (\n    money_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    amount NUMERIC(19, 4) NOT NULL,\n    currency VARCHAR(3) NOT NULL\n);\n\n-- 历史表（审计/时间旅行）\nCREATE TABLE financial.transactions_history (\n    history_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    transaction_id UUID NOT NULL,\n    valid_from TIMESTAMPTZ NOT NULL,\n    valid_to TIMESTAMPTZ,\n    -- ... 所有字段的快照\n);\n\n-- 事件存储表（Event Sourcing）\nCREATE TABLE shared.event_store (\n    event_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    aggregate_id UUID NOT NULL,\n    aggregate_type VARCHAR(100) NOT NULL,\n    event_type VARCHAR(100) NOT NULL,\n    event_version VARCHAR(20) NOT NULL,\n    event_data JSONB NOT NULL,\n    metadata JSONB NOT NULL,\n    occurred_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n    sequence_number BIGSERIAL NOT NULL,\n    UNIQUE (aggregate_id, sequence_number)\n);\n\n-- 分区索引\nCREATE INDEX idx_event_store_aggregate\nON shared.event_store (aggregate_id, sequence_number);\n\nCREATE INDEX idx_event_store_type_time\nON shared.event_store (aggregate_type, occurred_at);\n```\n\n#### 2.1.2 字段命名规范\n\n```sql\n-- 主键: {table_name}_id\ntransaction_id UUID PRIMARY KEY\n\n-- 外键: {reference_table}_id\naccount_id UUID REFERENCES financial.accounts(account_id)\n\n-- 布尔值: is_{condition} / has_{condition}\nis_active BOOLEAN DEFAULT TRUE\nhas_been_posted BOOLEAN DEFAULT FALSE\n\n-- 日期时间: {action}_at / {action}_date\ncreated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()\nupdated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()\nposting_date DATE NOT NULL\n\n-- 金额: {field}_amount\ndebit_amount NUMERIC(19, 4)\ncredit_amount NUMERIC(19, 4)\n\n-- 审计字段（每张表必须有）\ncreated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),\ncreated_by VARCHAR(255) NOT NULL,\nupdated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),\nupdated_by VARCHAR(255) NOT NULL,\nversion INTEGER NOT NULL DEFAULT 1  -- 乐观锁版本号\n```\n\n### 2.2 完整数据模型示例：财务凭证\n\n```sql\n-- migrations/financial/001_create_transactions_table.sql\n\n-- 启用UUID扩展\nCREATE EXTENSION IF NOT EXISTS \"uuid-ossp\";\nCREATE EXTENSION IF NOT EXISTS \"pgcrypto\";\n\n-- 创建Schema\nCREATE SCHEMA IF NOT EXISTS financial;\n\n-- 枚举类型\nCREATE TYPE financial.transaction_status AS ENUM (\n    'DRAFT',      -- 草稿\n    'POSTED',     -- 已过账\n    'REVERSED'    -- 已冲销\n);\n\n-- 主表：财务凭证\nCREATE TABLE financial.transactions (\n    -- 主键\n    transaction_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n\n    -- 业务字段\n    transaction_number VARCHAR(50) NOT NULL UNIQUE,  -- 凭证编号（业务主键）\n    posting_date DATE NOT NULL,                       -- 过账日期\n    document_date DATE NOT NULL,                      -- 凭证日期\n    company_code VARCHAR(10) NOT NULL,                -- 公司代码\n    fiscal_year INTEGER NOT NULL,                     -- 会计年度\n    fiscal_period INTEGER NOT NULL,                   -- 会计期间\n    status financial.transaction_status NOT NULL DEFAULT 'DRAFT',\n\n    -- 冲销关联\n    reversed_transaction_id UUID REFERENCES financial.transactions(transaction_id),\n    reversal_date DATE,\n    reversal_reason TEXT,\n\n    -- 附加信息\n    document_type VARCHAR(10),                        -- 凭证类型\n    reference VARCHAR(100),                           -- 参考号\n    header_text TEXT,                                 -- 抬头文本\n\n    -- 审计字段\n    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n    created_by VARCHAR(255) NOT NULL,\n    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n    updated_by VARCHAR(255) NOT NULL,\n    version INTEGER NOT NULL DEFAULT 1,\n\n    -- 约束\n    CONSTRAINT check_posting_date CHECK (posting_date <= CURRENT_DATE),\n    CONSTRAINT check_fiscal_period CHECK (fiscal_period BETWEEN 1 AND 16)\n);\n\n-- 子表：分录\nCREATE TABLE financial.journal_entries (\n    journal_entry_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    transaction_id UUID NOT NULL REFERENCES financial.transactions(transaction_id) ON DELETE CASCADE,\n\n    -- 业务字段\n    line_number INTEGER NOT NULL,                     -- 行号\n    account_number VARCHAR(20) NOT NULL,              -- 科目编号\n    debit_amount NUMERIC(19, 4) NOT NULL DEFAULT 0,   -- 借方金额\n    credit_amount NUMERIC(19, 4) NOT NULL DEFAULT 0,  -- 贷方金额\n    currency VARCHAR(3) NOT NULL DEFAULT 'USD',       -- 币种\n\n    -- 本位币金额（如果是外币交易）\n    local_currency VARCHAR(3),\n    exchange_rate NUMERIC(12, 5),\n    local_debit_amount NUMERIC(19, 4),\n    local_credit_amount NUMERIC(19, 4),\n\n    -- 成本对象\n    cost_center VARCHAR(20),                          -- 成本中心\n    profit_center VARCHAR(20),                        -- 利润中心\n    internal_order VARCHAR(20),                       -- 内部订单\n    project_id UUID,                                  -- 项目ID\n\n    -- 业务伙伴\n    business_partner_id UUID,                         -- 业务伙伴ID\n\n    -- 文本\n    line_text TEXT,\n\n    -- 审计字段\n    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n    created_by VARCHAR(255) NOT NULL,\n\n    -- 约束\n    CONSTRAINT check_entry_amount CHECK (\n        (debit_amount > 0 AND credit_amount = 0) OR\n        (debit_amount = 0 AND credit_amount > 0)\n    ),\n    CONSTRAINT unique_transaction_line UNIQUE (transaction_id, line_number)\n);\n\n-- 历史表（SCD Type 2）\nCREATE TABLE financial.transactions_history (\n    history_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    transaction_id UUID NOT NULL,\n\n    -- 所有业务字段的快照\n    transaction_number VARCHAR(50) NOT NULL,\n    posting_date DATE NOT NULL,\n    document_date DATE NOT NULL,\n    company_code VARCHAR(10) NOT NULL,\n    fiscal_year INTEGER NOT NULL,\n    fiscal_period INTEGER NOT NULL,\n    status financial.transaction_status NOT NULL,\n\n    -- 有效期\n    valid_from TIMESTAMPTZ NOT NULL,\n    valid_to TIMESTAMPTZ,                             -- NULL表示当前版本\n\n    -- 变更信息\n    changed_by VARCHAR(255) NOT NULL,\n    change_reason TEXT\n);\n\n-- 索引\nCREATE INDEX idx_transactions_company_year\nON financial.transactions (company_code, fiscal_year);\n\nCREATE INDEX idx_transactions_posting_date\nON financial.transactions (posting_date);\n\nCREATE INDEX idx_transactions_status\nON financial.transactions (status) WHERE status = 'POSTED';\n\nCREATE INDEX idx_journal_entries_transaction\nON financial.journal_entries (transaction_id);\n\nCREATE INDEX idx_journal_entries_account\nON financial.journal_entries (account_number);\n\nCREATE INDEX idx_journal_entries_cost_center\nON financial.journal_entries (cost_center) WHERE cost_center IS NOT NULL;\n\n-- 全文搜索索引\nCREATE INDEX idx_transactions_search\nON financial.transactions USING gin(to_tsvector('english', header_text));\n\n-- 触发器：更新updated_at\nCREATE OR REPLACE FUNCTION financial.update_updated_at_column()\nRETURNS TRIGGER AS $$\nBEGIN\n    NEW.updated_at = NOW();\n    NEW.version = OLD.version + 1;\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trigger_transactions_updated_at\n    BEFORE UPDATE ON financial.transactions\n    FOR EACH ROW\n    EXECUTE FUNCTION financial.update_updated_at_column();\n\n-- 触发器：历史记录\nCREATE OR REPLACE FUNCTION financial.insert_transaction_history()\nRETURNS TRIGGER AS $$\nBEGIN\n    -- 关闭旧版本\n    UPDATE financial.transactions_history\n    SET valid_to = NOW()\n    WHERE transaction_id = OLD.transaction_id AND valid_to IS NULL;\n\n    -- 插入新版本\n    INSERT INTO financial.transactions_history (\n        transaction_id, transaction_number, posting_date, document_date,\n        company_code, fiscal_year, fiscal_period, status,\n        valid_from, changed_by, change_reason\n    ) VALUES (\n        NEW.transaction_id, NEW.transaction_number, NEW.posting_date, NEW.document_date,\n        NEW.company_code, NEW.fiscal_year, NEW.fiscal_period, NEW.status,\n        NOW(), NEW.updated_by, 'Updated transaction'\n    );\n\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trigger_transactions_history\n    AFTER UPDATE ON financial.transactions\n    FOR EACH ROW\n    EXECUTE FUNCTION financial.insert_transaction_history();\n\n-- 约束：借贷平衡检查\nCREATE OR REPLACE FUNCTION financial.check_transaction_balance()\nRETURNS TRIGGER AS $$\nDECLARE\n    total_debit NUMERIC(19, 4);\n    total_credit NUMERIC(19, 4);\nBEGIN\n    SELECT\n        COALESCE(SUM(debit_amount), 0),\n        COALESCE(SUM(credit_amount), 0)\n    INTO total_debit, total_credit\n    FROM financial.journal_entries\n    WHERE transaction_id = NEW.transaction_id;\n\n    IF ABS(total_debit - total_credit) > 0.01 THEN\n        RAISE EXCEPTION 'Transaction % is not balanced: debit=%, credit=%',\n            NEW.transaction_id, total_debit, total_credit;\n    END IF;\n\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\n-- 在凭证状态变更为POSTED时检查借贷平衡\nCREATE TRIGGER trigger_check_balance_before_post\n    BEFORE UPDATE OF status ON financial.transactions\n    FOR EACH ROW\n    WHEN (NEW.status = 'POSTED' AND OLD.status != 'POSTED')\n    EXECUTE FUNCTION financial.check_transaction_balance();\n\n-- 分区表（按年度分区，提升性能）\n-- 注意：仅在数据量巨大时使用\nCREATE TABLE financial.transactions_partitioned (\n    LIKE financial.transactions INCLUDING ALL\n) PARTITION BY RANGE (fiscal_year);\n\nCREATE TABLE financial.transactions_2024 PARTITION OF financial.transactions_partitioned\n    FOR VALUES FROM (2024) TO (2025);\n\nCREATE TABLE financial.transactions_2025 PARTITION OF financial.transactions_partitioned\n    FOR VALUES FROM (2025) TO (2026);\n\n-- 权限设置\nGRANT SELECT, INSERT, UPDATE ON financial.transactions TO financial_service;\nGRANT SELECT, INSERT ON financial.journal_entries TO financial_service;\nGRANT SELECT ON financial.transactions_history TO financial_service;\n\n-- 注释\nCOMMENT ON TABLE financial.transactions IS '财务凭证主表';\nCOMMENT ON COLUMN financial.transactions.transaction_id IS '凭证唯一标识';\nCOMMENT ON COLUMN financial.transactions.transaction_number IS '凭证编号（业务主键）';\nCOMMENT ON COLUMN financial.transactions.posting_date IS '过账日期（影响会计期间）';\n```\n\n### 2.3 数据库迁移管理（SQLx）\n\n#### 2.3.1 迁移脚本结构\n\n```\nmigrations/\n├── financial/\n│   ├── 001_create_transactions_table.sql\n│   ├── 002_create_accounts_table.sql\n│   ├── 003_create_receivables_table.sql\n│   ├── 004_add_transaction_attachments.sql\n│   └── 005_add_transaction_approval_workflow.sql\n├── materials/\n│   ├── 001_create_materials_table.sql\n│   ├── 002_create_purchase_orders_table.sql\n│   └── 003_create_inventory_table.sql\n├── sales/\n│   ├── 001_create_customers_table.sql\n│   └── 002_create_sales_orders_table.sql\n└── shared/\n    ├── 001_create_event_store_table.sql\n    └── 002_create_audit_log_table.sql\n```\n\n#### 2.3.2 迁移脚本模板\n\n```sql\n-- migrations/financial/004_add_transaction_attachments.sql\n-- Description: Add attachments support to transactions\n-- Author: Developer B\n-- Date: 2025-12-22\n\n-- Up Migration\nCREATE TABLE IF NOT EXISTS financial.transaction_attachments (\n    attachment_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    transaction_id UUID NOT NULL REFERENCES financial.transactions(transaction_id) ON DELETE CASCADE,\n\n    filename VARCHAR(255) NOT NULL,\n    content_type VARCHAR(100) NOT NULL,\n    file_size BIGINT NOT NULL,\n    file_path TEXT NOT NULL,  -- S3路径或本地路径\n\n    checksum VARCHAR(64) NOT NULL,  -- SHA-256校验和\n\n    uploaded_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n    uploaded_by VARCHAR(255) NOT NULL\n);\n\nCREATE INDEX idx_attachments_transaction\nON financial.transaction_attachments (transaction_id);\n\n-- Rollback (Down) Migration\n-- DROP TABLE IF EXISTS financial.transaction_attachments CASCADE;\n```\n\n#### 2.3.3 执行迁移（代码）\n\n```rust\n// src/infrastructure/database/migrations.rs\n\nuse sqlx::{PgPool, migrate::MigrateDatabase};\n\npub async fn run_migrations(pool: &PgPool) -> Result<(), sqlx::Error> {\n    tracing::info!(\"Running database migrations...\");\n\n    // SQLx会自动读取migrations目录下的所有.sql文件\n    sqlx::migrate!(\"./migrations\")\n        .run(pool)\n        .await?;\n\n    tracing::info!(\"Database migrations completed successfully\");\n    Ok(())\n}\n\n// 应用启动时执行\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    let database_url = std::env::var(\"DATABASE_URL\")?;\n    let pool = PgPool::connect(&database_url).await?;\n\n    // 运行迁移\n    run_migrations(&pool).await?;\n\n    // 启动服务\n    // ...\n\n    Ok(())\n}\n```\n\n#### 2.3.4 测试环境迁移重置\n\n```bash\n#!/bin/bash\n# scripts/reset_test_database.sh\n\nset -e\n\nDB_NAME=\"erp_test\"\nDB_USER=\"erp_user\"\nDB_PASSWORD=\"erp_pass\"\n\necho \"Dropping test database...\"\npsql -U postgres -c \"DROP DATABASE IF EXISTS $DB_NAME;\"\n\necho \"Creating test database...\"\npsql -U postgres -c \"CREATE DATABASE $DB_NAME OWNER $DB_USER;\"\n\necho \"Running migrations...\"\nDATABASE_URL=\"postgresql://$DB_USER:$DB_PASSWORD@localhost/$DB_NAME\" \\\n    cargo sqlx migrate run\n\necho \"Loading seed data...\"\npsql -U $DB_USER -d $DB_NAME -f scripts/seed_data.sql\n\necho \"Test database reset complete!\"\n```\n\n### 2.4 种子数据（Seed Data）\n\n```sql\n-- scripts/seed_data.sql\n\n-- 主数据：币种\nINSERT INTO mdg.currencies (currency_code, currency_name, symbol, decimal_places) VALUES\n('USD', 'US Dollar', '$', 2),\n('EUR', 'Euro', '€', 2),\n('CNY', 'Chinese Yuan', '¥', 2),\n('JPY', 'Japanese Yen', '¥', 0);\n\n-- 主数据：公司代码\nINSERT INTO mdg.company_codes (company_code, company_name, currency, country) VALUES\n('1000', 'Acme Corporation', 'USD', 'US'),\n('2000', 'Acme Europe GmbH', 'EUR', 'DE'),\n('3000', 'Acme China Ltd', 'CNY', 'CN');\n\n-- 主数据：科目表\nINSERT INTO financial.accounts (account_number, account_name, account_type, company_code) VALUES\n-- 资产类\n('100000', 'Cash', 'ASSET', '1000'),\n('110000', 'Accounts Receivable', 'ASSET', '1000'),\n('120000', 'Inventory', 'ASSET', '1000'),\n('130000', 'Fixed Assets', 'ASSET', '1000'),\n-- 负债类\n('200000', 'Accounts Payable', 'LIABILITY', '1000'),\n('210000', 'Short-term Loans', 'LIABILITY', '1000'),\n-- 权益类\n('300000', 'Share Capital', 'EQUITY', '1000'),\n('310000', 'Retained Earnings', 'EQUITY', '1000'),\n-- 收入类\n('400000', 'Sales Revenue', 'REVENUE', '1000'),\n-- 成本费用类\n('500000', 'Cost of Goods Sold', 'EXPENSE', '1000'),\n('510000', 'Salaries Expense', 'EXPENSE', '1000');\n\n-- 测试用户\nINSERT INTO iam.users (user_id, username, email, password_hash, is_active) VALUES\n('550e8400-e29b-41d4-a716-446655440001', 'admin', 'admin@example.com', '$2b$12$...', TRUE),\n('550e8400-e29b-41d4-a716-446655440002', 'accountant', 'accountant@example.com', '$2b$12$...', TRUE),\n('550e8400-e29b-41d4-a716-446655440003', 'purchaser', 'purchaser@example.com', '$2b$12$...', TRUE);\n\n-- 测试角色\nINSERT INTO iam.roles (role_id, role_name, description) VALUES\n('role-admin', 'Administrator', 'System administrator with full access'),\n('role-accountant', 'Accountant', 'Financial accounting role'),\n('role-purchaser', 'Purchaser', 'Purchasing role');\n\n-- 用户-角色关联\nINSERT INTO iam.user_roles (user_id, role_id) VALUES\n('550e8400-e29b-41d4-a716-446655440001', 'role-admin'),\n('550e8400-e29b-41d4-a716-446655440002', 'role-accountant'),\n('550e8400-e29b-41d4-a716-446655440003', 'role-purchaser');\n```\n\n---\n\n## 三、分布式事务处理（Saga模式）\n\n### 3.1 Saga模式概述\n\n在微服务架构中，跨服务的事务使用**Saga编排模式**（Orchestration）或**Saga协同模式**（Choreography）。\n\n#### 3.1.1 两种模式对比\n\n| 特性 | 编排模式（Orchestration） | 协同模式（Choreography） |\n|-----|-------------------------|------------------------|\n| 协调者 | 中央Saga协调器 | 无中央协调，事件驱动 |\n| 复杂度 | 中等（协调器集中管理） | 高（分布在各服务） |\n| 可观测性 | 好（集中监控） | 差（分散追踪） |\n| 耦合度 | 协调器与服务耦合 | 服务间松耦合 |\n| 适用场景 | 复杂业务流程 | 简单事件链 |\n\n**推荐**：对于ERP系统的复杂业务流程（如O2C、P2P），使用**编排模式**。\n\n### 3.2 Saga编排模式实现\n\n#### 3.2.1 Saga定义：销售订单流程（O2C）\n\n```rust\n// src/sagas/order_to_cash_saga.rs\n\nuse async_trait::async_trait;\nuse serde::{Deserialize, Serialize};\nuse uuid::Uuid;\n\n/// 销售订单到收款Saga\n///\n/// 流程：\n/// 1. 创建销售订单 (Sales Service)\n/// 2. 信用检查 (Credit Management Service)\n/// 3. 预留库存 (Materials Service)\n/// 4. 创建交付单 (Warehouse Service)\n/// 5. 创建发货单 (Transport Service)\n/// 6. 开票 (Sales Service)\n/// 7. 创建应收账款 (Financial Service)\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct OrderToCashSaga {\n    pub saga_id: Uuid,\n    pub order_id: Uuid,\n    pub customer_id: Uuid,\n    pub order_amount: Decimal,\n    pub currency: String,\n    pub status: SagaStatus,\n    pub current_step: SagaStep,\n    pub started_at: DateTime<Utc>,\n    pub completed_at: Option<DateTime<Utc>>,\n\n    // 步骤结果\n    pub steps_completed: Vec<SagaStepResult>,\n    pub compensations_executed: Vec<SagaStepResult>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum SagaStatus {\n    Started,\n    InProgress,\n    Completed,\n    Failed,\n    Compensating,\n    Compensated,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum SagaStep {\n    CreateOrder,\n    CheckCredit,\n    ReserveInventory,\n    CreateDelivery,\n    CreateShipment,\n    CreateInvoice,\n    CreateReceivable,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct SagaStepResult {\n    pub step: SagaStep,\n    pub status: StepStatus,\n    pub result: serde_json::Value,\n    pub executed_at: DateTime<Utc>,\n    pub error: Option<String>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum StepStatus {\n    Pending,\n    Success,\n    Failed,\n    Compensated,\n}\n\n/// Saga协调器\npub struct OrderToCashSagaOrchestrator {\n    sales_client: Arc<SalesServiceClient>,\n    credit_client: Arc<CreditManagementServiceClient>,\n    materials_client: Arc<MaterialsServiceClient>,\n    warehouse_client: Arc<WarehouseServiceClient>,\n    transport_client: Arc<TransportServiceClient>,\n    financial_client: Arc<FinancialServiceClient>,\n    saga_store: Arc<SagaStore>,\n}\n\nimpl OrderToCashSagaOrchestrator {\n    pub async fn execute(&self, saga: OrderToCashSaga) -> Result<OrderToCashSaga, SagaError> {\n        let mut current_saga = saga.clone();\n        current_saga.status = SagaStatus::InProgress;\n\n        // 持久化Saga状态\n        self.saga_store.save(&current_saga).await?;\n\n        // 执行步骤\n        let result = self.execute_steps(&mut current_saga).await;\n\n        match result {\n            Ok(_) => {\n                current_saga.status = SagaStatus::Completed;\n                current_saga.completed_at = Some(Utc::now());\n                self.saga_store.save(&current_saga).await?;\n                Ok(current_saga)\n            }\n            Err(e) => {\n                // 执行补偿\n                current_saga.status = SagaStatus::Compensating;\n                self.saga_store.save(&current_saga).await?;\n\n                self.compensate(&mut current_saga).await?;\n\n                current_saga.status = SagaStatus::Compensated;\n                self.saga_store.save(&current_saga).await?;\n\n                Err(e)\n            }\n        }\n    }\n\n    async fn execute_steps(&self, saga: &mut OrderToCashSaga) -> Result<(), SagaError> {\n        // Step 1: 创建销售订单\n        let order_result = self.create_order(saga).await?;\n        saga.record_step_success(SagaStep::CreateOrder, order_result);\n\n        // Step 2: 信用检查\n        let credit_result = self.check_credit(saga).await?;\n        saga.record_step_success(SagaStep::CheckCredit, credit_result);\n\n        // Step 3: 预留库存\n        let reserve_result = self.reserve_inventory(saga).await?;\n        saga.record_step_success(SagaStep::ReserveInventory, reserve_result);\n\n        // Step 4: 创建交付单\n        let delivery_result = self.create_delivery(saga).await?;\n        saga.record_step_success(SagaStep::CreateDelivery, delivery_result);\n\n        // Step 5: 创建发货单\n        let shipment_result = self.create_shipment(saga).await?;\n        saga.record_step_success(SagaStep::CreateShipment, shipment_result);\n\n        // Step 6: 开票\n        let invoice_result = self.create_invoice(saga).await?;\n        saga.record_step_success(SagaStep::CreateInvoice, invoice_result);\n\n        // Step 7: 创建应收账款\n        let receivable_result = self.create_receivable(saga).await?;\n        saga.record_step_success(SagaStep::CreateReceivable, receivable_result);\n\n        Ok(())\n    }\n\n    async fn compensate(&self, saga: &mut OrderToCashSaga) -> Result<(), SagaError> {\n        // 逆序执行补偿\n        for step_result in saga.steps_completed.iter().rev() {\n            if step_result.status == StepStatus::Success {\n                match step_result.step {\n                    SagaStep::CreateOrder => self.compensate_create_order(saga).await?,\n                    SagaStep::CheckCredit => self.compensate_check_credit(saga).await?,\n                    SagaStep::ReserveInventory => self.compensate_reserve_inventory(saga).await?,\n                    SagaStep::CreateDelivery => self.compensate_create_delivery(saga).await?,\n                    SagaStep::CreateShipment => self.compensate_create_shipment(saga).await?,\n                    SagaStep::CreateInvoice => self.compensate_create_invoice(saga).await?,\n                    SagaStep::CreateReceivable => self.compensate_create_receivable(saga).await?,\n                }\n                saga.record_compensation_success(step_result.step.clone());\n            }\n        }\n        Ok(())\n    }\n\n    // 前进步骤实现\n    async fn create_order(&self, saga: &OrderToCashSaga) -> Result<serde_json::Value, SagaError> {\n        let request = CreateSalesOrderRequest {\n            idempotency_key: saga.saga_id,  // 使用Saga ID作为幂等键\n            customer_id: saga.customer_id,\n            order_amount: saga.order_amount,\n            currency: saga.currency.clone(),\n        };\n\n        let response = self.sales_client\n            .create_order(request)\n            .await\n            .map_err(|e| SagaError::StepFailed(SagaStep::CreateOrder, e.to_string()))?;\n\n        Ok(serde_json::to_value(response)?)\n    }\n\n    async fn check_credit(&self, saga: &OrderToCashSaga) -> Result<serde_json::Value, SagaError> {\n        let request = CheckCreditRequest {\n            customer_id: saga.customer_id,\n            order_amount: saga.order_amount,\n            currency: saga.currency.clone(),\n        };\n\n        let response = self.credit_client\n            .check_credit(request)\n            .await\n            .map_err(|e| SagaError::StepFailed(SagaStep::CheckCredit, e.to_string()))?;\n\n        // 如果信用检查失败，抛出错误触发补偿\n        if !response.approved {\n            return Err(SagaError::StepFailed(\n                SagaStep::CheckCredit,\n                format!(\"Credit limit exceeded: available={}, requested={}\",\n                    response.available_credit, saga.order_amount)\n            ));\n        }\n\n        Ok(serde_json::to_value(response)?)\n    }\n\n    async fn reserve_inventory(&self, saga: &OrderToCashSaga) -> Result<serde_json::Value, SagaError> {\n        // 从订单结果中提取订单行项目\n        let order_result = saga.get_step_result(SagaStep::CreateOrder)\n            .ok_or_else(|| SagaError::StepFailed(SagaStep::ReserveInventory, \"Order not created\".to_string()))?;\n\n        let order: SalesOrderResponse = serde_json::from_value(order_result.result.clone())?;\n\n        let request = ReserveInventoryRequest {\n            idempotency_key: saga.saga_id,\n            order_id: order.order_id,\n            items: order.items.iter().map(|item| ReserveInventoryItem {\n                material_id: item.material_id,\n                quantity: item.quantity,\n                plant: item.plant.clone(),\n            }).collect(),\n        };\n\n        let response = self.materials_client\n            .reserve_inventory(request)\n            .await\n            .map_err(|e| SagaError::StepFailed(SagaStep::ReserveInventory, e.to_string()))?;\n\n        Ok(serde_json::to_value(response)?)\n    }\n\n    // ... 其他步骤实现\n\n    // 补偿步骤实现\n    async fn compensate_create_order(&self, saga: &OrderToCashSaga) -> Result<(), SagaError> {\n        let order_result = saga.get_step_result(SagaStep::CreateOrder)\n            .ok_or_else(|| SagaError::CompensationFailed(SagaStep::CreateOrder, \"Order not found\".to_string()))?;\n\n        let order: SalesOrderResponse = serde_json::from_value(order_result.result.clone())?;\n\n        let request = CancelSalesOrderRequest {\n            order_id: order.order_id,\n            reason: format!(\"Saga compensation: {}\", saga.saga_id),\n        };\n\n        self.sales_client\n            .cancel_order(request)\n            .await\n            .map_err(|e| SagaError::CompensationFailed(SagaStep::CreateOrder, e.to_string()))?;\n\n        Ok(())\n    }\n\n    async fn compensate_check_credit(&self, saga: &OrderToCashSaga) -> Result<(), SagaError> {\n        // 信用检查通常不需要补偿（只是检查，未修改状态）\n        // 但如果信用检查时锁定了额度，需要在这里释放\n\n        let credit_result = saga.get_step_result(SagaStep::CheckCredit)\n            .ok_or_else(|| SagaError::CompensationFailed(SagaStep::CheckCredit, \"Credit check not found\".to_string()))?;\n\n        let credit: CreditCheckResponse = serde_json::from_value(credit_result.result.clone())?;\n\n        if let Some(hold_id) = credit.credit_hold_id {\n            let request = ReleaseCreditHoldRequest {\n                hold_id,\n                reason: format!(\"Saga compensation: {}\", saga.saga_id),\n            };\n\n            self.credit_client\n                .release_credit_hold(request)\n                .await\n                .map_err(|e| SagaError::CompensationFailed(SagaStep::CheckCredit, e.to_string()))?;\n        }\n\n        Ok(())\n    }\n\n    async fn compensate_reserve_inventory(&self, saga: &OrderToCashSaga) -> Result<(), SagaError> {\n        let reserve_result = saga.get_step_result(SagaStep::ReserveInventory)\n            .ok_or_else(|| SagaError::CompensationFailed(SagaStep::ReserveInventory, \"Reservation not found\".to_string()))?;\n\n        let reservation: ReserveInventoryResponse = serde_json::from_value(reserve_result.result.clone())?;\n\n        let request = CancelInventoryReservationRequest {\n            reservation_id: reservation.reservation_id,\n            reason: format!(\"Saga compensation: {}\", saga.saga_id),\n        };\n\n        self.materials_client\n            .cancel_reservation(request)\n            .await\n            .map_err(|e| SagaError::CompensationFailed(SagaStep::ReserveInventory, e.to_string()))?;\n\n        Ok(())\n    }\n\n    // ... 其他补偿步骤实现\n}\n\nimpl OrderToCashSaga {\n    fn record_step_success(&mut self, step: SagaStep, result: serde_json::Value) {\n        self.steps_completed.push(SagaStepResult {\n            step: step.clone(),\n            status: StepStatus::Success,\n            result,\n            executed_at: Utc::now(),\n            error: None,\n        });\n        self.current_step = step;\n    }\n\n    fn record_compensation_success(&mut self, step: SagaStep) {\n        self.compensations_executed.push(SagaStepResult {\n            step,\n            status: StepStatus::Compensated,\n            result: serde_json::Value::Null,\n            executed_at: Utc::now(),\n            error: None,\n        });\n    }\n\n    fn get_step_result(&self, step: SagaStep) -> Option<&SagaStepResult> {\n        self.steps_completed.iter().find(|r| r.step == step)\n    }\n}\n\n#[derive(Debug, thiserror::Error)]\npub enum SagaError {\n    #[error(\"Saga step {0:?} failed: {1}\")]\n    StepFailed(SagaStep, String),\n\n    #[error(\"Saga compensation for step {0:?} failed: {1}\")]\n    CompensationFailed(SagaStep, String),\n\n    #[error(\"Saga persistence failed: {0}\")]\n    PersistenceFailed(String),\n}\n```\n\n#### 3.2.2 Saga状态持久化\n\n```rust\n// src/sagas/saga_store.rs\n\nuse sqlx::PgPool;\n\npub struct SagaStore {\n    pool: PgPool,\n}\n\nimpl SagaStore {\n    pub async fn save(&self, saga: &OrderToCashSaga) -> Result<(), SagaError> {\n        sqlx::query!(\n            r#\"\n            INSERT INTO shared.saga_instances (\n                saga_id, saga_type, status, current_step, payload, started_at, completed_at\n            ) VALUES ($1, $2, $3, $4, $5, $6, $7)\n            ON CONFLICT (saga_id) DO UPDATE SET\n                status = EXCLUDED.status,\n                current_step = EXCLUDED.current_step,\n                payload = EXCLUDED.payload,\n                completed_at = EXCLUDED.completed_at,\n                updated_at = NOW()\n            \"#,\n            saga.saga_id,\n            \"OrderToCash\",\n            serde_json::to_value(&saga.status)?,\n            serde_json::to_value(&saga.current_step)?,\n            serde_json::to_value(saga)?,\n            saga.started_at,\n            saga.completed_at,\n        )\n        .execute(&self.pool)\n        .await\n        .map_err(|e| SagaError::PersistenceFailed(e.to_string()))?;\n\n        Ok(())\n    }\n\n    pub async fn load(&self, saga_id: Uuid) -> Result<OrderToCashSaga, SagaError> {\n        let row = sqlx::query!(\n            r#\"\n            SELECT payload FROM shared.saga_instances WHERE saga_id = $1\n            \"#,\n            saga_id\n        )\n        .fetch_one(&self.pool)\n        .await\n        .map_err(|e| SagaError::PersistenceFailed(e.to_string()))?;\n\n        let saga: OrderToCashSaga = serde_json::from_value(row.payload)?;\n        Ok(saga)\n    }\n\n    pub async fn list_pending_sagas(&self) -> Result<Vec<OrderToCashSaga>, SagaError> {\n        let rows = sqlx::query!(\n            r#\"\n            SELECT payload FROM shared.saga_instances\n            WHERE status IN ('Started', 'InProgress', 'Compensating')\n            AND started_at < NOW() - INTERVAL '5 minutes'\n            \"#\n        )\n        .fetch_all(&self.pool)\n        .await\n        .map_err(|e| SagaError::PersistenceFailed(e.to_string()))?;\n\n        let sagas = rows.into_iter()\n            .filter_map(|row| serde_json::from_value(row.payload).ok())\n            .collect();\n\n        Ok(sagas)\n    }\n}\n\n// 数据库表\nCREATE TABLE IF NOT EXISTS shared.saga_instances (\n    saga_id UUID PRIMARY KEY,\n    saga_type VARCHAR(100) NOT NULL,\n    status JSONB NOT NULL,\n    current_step JSONB NOT NULL,\n    payload JSONB NOT NULL,\n    started_at TIMESTAMPTZ NOT NULL,\n    completed_at TIMESTAMPTZ,\n    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),\n\n    INDEX idx_saga_status (saga_type, status, started_at)\n);\n```\n\n#### 3.2.3 Saga恢复机制（处理崩溃）\n\n```rust\n// src/sagas/saga_recovery.rs\n\n/// Saga恢复服务\n/// 定期扫描未完成的Saga并恢复执行\npub struct SagaRecoveryService {\n    saga_store: Arc<SagaStore>,\n    orchestrator: Arc<OrderToCashSagaOrchestrator>,\n}\n\nimpl SagaRecoveryService {\n    pub async fn start(&self) {\n        let mut interval = tokio::time::interval(Duration::from_secs(60));\n\n        loop {\n            interval.tick().await;\n\n            if let Err(e) = self.recover_pending_sagas().await {\n                tracing::error!(\"Failed to recover pending sagas: {}\", e);\n            }\n        }\n    }\n\n    async fn recover_pending_sagas(&self) -> Result<(), SagaError> {\n        let pending_sagas = self.saga_store.list_pending_sagas().await?;\n\n        tracing::info!(\"Found {} pending sagas to recover\", pending_sagas.len());\n\n        for saga in pending_sagas {\n            tracing::info!(\"Recovering saga {}\", saga.saga_id);\n\n            match saga.status {\n                SagaStatus::Started | SagaStatus::InProgress => {\n                    // 继续执行\n                    if let Err(e) = self.orchestrator.execute(saga.clone()).await {\n                        tracing::error!(\"Failed to recover saga {}: {}\", saga.saga_id, e);\n                    }\n                }\n                SagaStatus::Compensating => {\n                    // 继续补偿\n                    let mut saga_mut = saga.clone();\n                    if let Err(e) = self.orchestrator.compensate(&mut saga_mut).await {\n                        tracing::error!(\"Failed to compensate saga {}: {}\", saga.saga_id, e);\n                    } else {\n                        saga_mut.status = SagaStatus::Compensated;\n                        self.saga_store.save(&saga_mut).await?;\n                    }\n                }\n                _ => {}\n            }\n        }\n\n        Ok(())\n    }\n}\n```\n\n### 3.3 Saga超时与重试策略\n\n```rust\n// src/sagas/saga_config.rs\n\npub struct SagaConfig {\n    /// 单个步骤超时时间\n    pub step_timeout: Duration,\n\n    /// 重试次数\n    pub max_retries: u32,\n\n    /// 重试退避策略\n    pub retry_backoff: RetryBackoff,\n\n    /// Saga整体超时时间\n    pub saga_timeout: Duration,\n}\n\nimpl Default for SagaConfig {\n    fn default() -> Self {\n        Self {\n            step_timeout: Duration::from_secs(30),\n            max_retries: 3,\n            retry_backoff: RetryBackoff::Exponential {\n                initial_delay: Duration::from_secs(1),\n                max_delay: Duration::from_secs(60),\n                multiplier: 2.0,\n            },\n            saga_timeout: Duration::from_secs(300),  // 5分钟\n        }\n    }\n}\n\npub enum RetryBackoff {\n    Fixed(Duration),\n    Exponential {\n        initial_delay: Duration,\n        max_delay: Duration,\n        multiplier: f64,\n    },\n}\n\n// 在协调器中应用重试\nimpl OrderToCashSagaOrchestrator {\n    async fn execute_with_retry<F, T>(\n        &self,\n        step: SagaStep,\n        f: F,\n    ) -> Result<T, SagaError>\n    where\n        F: Fn() -> BoxFuture<'static, Result<T, SagaError>>,\n    {\n        let mut retries = 0;\n        let mut backoff = self.config.retry_backoff.initial_delay();\n\n        loop {\n            match tokio::time::timeout(self.config.step_timeout, f()).await {\n                Ok(Ok(result)) => return Ok(result),\n                Ok(Err(e)) if retries < self.config.max_retries => {\n                    tracing::warn!(\n                        \"Saga step {:?} failed (attempt {}/{}): {}. Retrying in {:?}\",\n                        step, retries + 1, self.config.max_retries, e, backoff\n                    );\n\n                    tokio::time::sleep(backoff).await;\n\n                    retries += 1;\n                    backoff = self.config.retry_backoff.next_delay(backoff);\n                }\n                Ok(Err(e)) => {\n                    tracing::error!(\"Saga step {:?} failed after {} retries: {}\", step, retries, e);\n                    return Err(e);\n                }\n                Err(_) => {\n                    tracing::error!(\"Saga step {:?} timed out after {:?}\", step, self.config.step_timeout);\n                    return Err(SagaError::StepFailed(step, \"Timeout\".to_string()));\n                }\n            }\n        }\n    }\n}\n```\n\n---\n\n## 四、安全加固详细方案\n\n### 4.1 身份认证与授权\n\n#### 4.1.1 JWT Token 实现\n\n```rust\n// src/infrastructure/auth/jwt.rs\n\nuse jsonwebtoken::{decode, encode, DecodingKey, EncodingKey, Header, Validation};\nuse serde::{Deserialize, Serialize};\nuse chrono::{Duration, Utc};\n\n#[derive(Debug, Serialize, Deserialize)]\npub struct Claims {\n    /// Subject (用户ID)\n    pub sub: String,\n\n    /// Issued at (签发时间)\n    pub iat: i64,\n\n    /// Expiration time (过期时间)\n    pub exp: i64,\n\n    /// Issuer (签发者)\n    pub iss: String,\n\n    /// Audience (受众)\n    pub aud: String,\n\n    /// 用户角色\n    pub roles: Vec<String>,\n\n    /// 租户ID（多租户）\n    pub tenant_id: Option<String>,\n\n    /// 额外声明\n    pub permissions: Vec<String>,\n}\n\npub struct JwtManager {\n    encoding_key: EncodingKey,\n    decoding_key: DecodingKey,\n    issuer: String,\n    audience: String,\n    access_token_expiry: Duration,\n    refresh_token_expiry: Duration,\n}\n\nimpl JwtManager {\n    pub fn new(secret: &str, issuer: String, audience: String) -> Self {\n        Self {\n            encoding_key: EncodingKey::from_secret(secret.as_bytes()),\n            decoding_key: DecodingKey::from_secret(secret.as_bytes()),\n            issuer,\n            audience,\n            access_token_expiry: Duration::minutes(15),  // Access Token 15分钟\n            refresh_token_expiry: Duration::days(7),     // Refresh Token 7天\n        }\n    }\n\n    /// 生成 Access Token\n    pub fn generate_access_token(&self, user_id: &str, roles: Vec<String>, tenant_id: Option<String>) -> Result<String, AuthError> {\n        let now = Utc::now();\n        let claims = Claims {\n            sub: user_id.to_string(),\n            iat: now.timestamp(),\n            exp: (now + self.access_token_expiry).timestamp(),\n            iss: self.issuer.clone(),\n            aud: self.audience.clone(),\n            roles,\n            tenant_id,\n            permissions: vec![],  // 可从数据库加载\n        };\n\n        encode(&Header::default(), &claims, &self.encoding_key)\n            .map_err(|e| AuthError::TokenGenerationFailed(e.to_string()))\n    }\n\n    /// 生成 Refresh Token\n    pub fn generate_refresh_token(&self, user_id: &str) -> Result<String, AuthError> {\n        let now = Utc::now();\n        let claims = Claims {\n            sub: user_id.to_string(),\n            iat: now.timestamp(),\n            exp: (now + self.refresh_token_expiry).timestamp(),\n            iss: self.issuer.clone(),\n            aud: format!(\"{}-refresh\", self.audience),\n            roles: vec![],\n            tenant_id: None,\n            permissions: vec![],\n        };\n\n        encode(&Header::default(), &claims, &self.encoding_key)\n            .map_err(|e| AuthError::TokenGenerationFailed(e.to_string()))\n    }\n\n    /// 验证 Token\n    pub fn validate_token(&self, token: &str) -> Result<Claims, AuthError> {\n        let validation = Validation::default();\n\n        decode::<Claims>(token, &self.decoding_key, &validation)\n            .map(|data| data.claims)\n            .map_err(|e| AuthError::InvalidToken(e.to_string()))\n    }\n}\n\n#[derive(Debug, thiserror::Error)]\npub enum AuthError {\n    #[error(\"Token generation failed: {0}\")]\n    TokenGenerationFailed(String),\n\n    #[error(\"Invalid token: {0}\")]\n    InvalidToken(String),\n\n    #[error(\"Unauthorized\")]\n    Unauthorized,\n\n    #[error(\"Forbidden\")]\n    Forbidden,\n}\n```\n\n#### 4.1.2 RBAC 授权中间件\n\n```rust\n// src/api/http/middleware/auth_middleware.rs\n\nuse axum::{\n    extract::{Request, State},\n    http::{HeaderMap, StatusCode},\n    middleware::Next,\n    response::Response,\n};\n\npub async fn auth_middleware(\n    State(state): State<AppState>,\n    headers: HeaderMap,\n    mut request: Request,\n    next: Next,\n) -> Result<Response, StatusCode> {\n    // 1. 提取 Token\n    let token = headers\n        .get(\"Authorization\")\n        .and_then(|v| v.to_str().ok())\n        .and_then(|v| v.strip_prefix(\"Bearer \"))\n        .ok_or(StatusCode::UNAUTHORIZED)?;\n\n    // 2. 验证 Token\n    let claims = state.jwt_manager\n        .validate_token(token)\n        .map_err(|_| StatusCode::UNAUTHORIZED)?;\n\n    // 3. 检查 Token 是否在黑名单中（Redis）\n    let is_blacklisted = state.redis\n        .exists::<bool>(&format!(\"token:blacklist:{}\", token))\n        .await\n        .unwrap_or(false);\n\n    if is_blacklisted {\n        return Err(StatusCode::UNAUTHORIZED);\n    }\n\n    // 4. 将用户信息注入到请求扩展中\n    request.extensions_mut().insert(AuthenticatedUser {\n        user_id: claims.sub,\n        roles: claims.roles,\n        tenant_id: claims.tenant_id,\n        permissions: claims.permissions,\n    });\n\n    Ok(next.run(request).await)\n}\n\n/// 权限检查中间件（装饰器模式）\npub fn require_permission(permission: &'static str) -> impl Fn(Request, Next) -> BoxFuture<'static, Result<Response, StatusCode>> + Clone {\n    move |request: Request, next: Next| {\n        Box::pin(async move {\n            let user = request\n                .extensions()\n                .get::<AuthenticatedUser>()\n                .ok_or(StatusCode::UNAUTHORIZED)?;\n\n            if !user.has_permission(permission) {\n                return Err(StatusCode::FORBIDDEN);\n            }\n\n            Ok(next.run(request).await)\n        })\n    }\n}\n\n#[derive(Clone, Debug)]\npub struct AuthenticatedUser {\n    pub user_id: String,\n    pub roles: Vec<String>,\n    pub tenant_id: Option<String>,\n    pub permissions: Vec<String>,\n}\n\nimpl AuthenticatedUser {\n    pub fn has_role(&self, role: &str) -> bool {\n        self.roles.iter().any(|r| r == role)\n    }\n\n    pub fn has_permission(&self, permission: &str) -> bool {\n        self.permissions.iter().any(|p| p == permission)\n    }\n\n    pub fn has_any_permission(&self, permissions: &[&str]) -> bool {\n        permissions.iter().any(|p| self.has_permission(p))\n    }\n}\n\n// 使用示例\nuse axum::Router;\n\nlet app = Router::new()\n    .route(\"/api/v1/financial/transactions\", post(create_transaction))\n    .layer(axum::middleware::from_fn_with_state(\n        state.clone(),\n        auth_middleware,\n    ))\n    .layer(axum::middleware::from_fn(\n        require_permission(\"financial:transaction:create\"),\n    ));\n```\n\n#### 4.1.3 职责分离（SoD）检查\n\n```rust\n// src/domain/services/sod_check_service.rs\n\n/// 职责分离规则\n#[derive(Debug, Clone)]\npub struct SoDRule {\n    pub rule_id: String,\n    pub name: String,\n    pub conflicting_permissions: Vec<String>,\n    pub severity: SoDSeverity,\n}\n\n#[derive(Debug, Clone)]\npub enum SoDSeverity {\n    Critical,  // 严重冲突，禁止\n    High,      // 高风险，需要审批\n    Medium,    // 中风险，记录告警\n}\n\npub struct SoDCheckService {\n    rules: Vec<SoDRule>,\n}\n\nimpl SoDCheckService {\n    pub fn new() -> Self {\n        Self {\n            rules: vec![\n                // 财务职责分离规则\n                SoDRule {\n                    rule_id: \"FIN-SOD-001\".to_string(),\n                    name: \"采购订单创建者不能审批\".to_string(),\n                    conflicting_permissions: vec![\n                        \"purchasing:po:create\".to_string(),\n                        \"purchasing:po:approve\".to_string(),\n                    ],\n                    severity: SoDSeverity::Critical,\n                },\n                SoDRule {\n                    rule_id: \"FIN-SOD-002\".to_string(),\n                    name: \"出纳不能记账\".to_string(),\n                    conflicting_permissions: vec![\n                        \"financial:payment:execute\".to_string(),\n                        \"financial:transaction:post\".to_string(),\n                    ],\n                    severity: SoDSeverity::Critical,\n                },\n                SoDRule {\n                    rule_id: \"FIN-SOD-003\".to_string(),\n                    name: \"主数据创建者不能审批\".to_string(),\n                    conflicting_permissions: vec![\n                        \"mdg:vendor:create\".to_string(),\n                        \"mdg:vendor:approve\".to_string(),\n                    ],\n                    severity: SoDSeverity::Critical,\n                },\n                // 库存职责分离规则\n                SoDRule {\n                    rule_id: \"INV-SOD-001\".to_string(),\n                    name: \"收货人不能进行发票校验\".to_string(),\n                    conflicting_permissions: vec![\n                        \"materials:goods_receipt:post\".to_string(),\n                        \"materials:invoice:verify\".to_string(),\n                    ],\n                    severity: SoDSeverity::High,\n                },\n            ],\n        }\n    }\n\n    /// 检查用户权限是否违反 SoD 规则\n    pub fn check_user_permissions(&self, permissions: &[String]) -> Vec<SoDViolation> {\n        let mut violations = Vec::new();\n\n        for rule in &self.rules {\n            let has_conflicts: Vec<_> = rule.conflicting_permissions\n                .iter()\n                .filter(|p| permissions.contains(p))\n                .collect();\n\n            if has_conflicts.len() > 1 {\n                violations.push(SoDViolation {\n                    rule_id: rule.rule_id.clone(),\n                    rule_name: rule.name.clone(),\n                    conflicting_permissions: has_conflicts.into_iter().cloned().collect(),\n                    severity: rule.severity.clone(),\n                });\n            }\n        }\n\n        violations\n    }\n\n    /// 检查角色分配是否违反 SoD 规则\n    pub async fn check_role_assignment(\n        &self,\n        user_id: &str,\n        new_role: &str,\n        existing_roles: &[String],\n    ) -> Result<(), SoDViolation> {\n        // 获取新角色的权限\n        let new_permissions = self.get_role_permissions(new_role).await?;\n\n        // 获取现有角色的权限\n        let mut all_permissions: Vec<String> = Vec::new();\n        for role in existing_roles {\n            let perms = self.get_role_permissions(role).await?;\n            all_permissions.extend(perms);\n        }\n        all_permissions.extend(new_permissions);\n\n        // 检查冲突\n        let violations = self.check_user_permissions(&all_permissions);\n\n        if let Some(critical) = violations.iter().find(|v| matches!(v.severity, SoDSeverity::Critical)) {\n            return Err(critical.clone());\n        }\n\n        Ok(())\n    }\n\n    async fn get_role_permissions(&self, role: &str) -> Result<Vec<String>, SoDError> {\n        // 从数据库查询角色权限\n        // 这里简化处理\n        Ok(vec![])\n    }\n}\n\n#[derive(Debug, Clone)]\npub struct SoDViolation {\n    pub rule_id: String,\n    pub rule_name: String,\n    pub conflicting_permissions: Vec<String>,\n    pub severity: SoDSeverity,\n}\n```\n\n### 4.2 数据加密\n\n#### 4.2.1 字段级加密（敏感数据）\n\n```rust\n// src/infrastructure/encryption/field_encryption.rs\n\nuse aes_gcm::{\n    aead::{Aead, KeyInit, OsRng},\n    Aes256Gcm, Nonce,\n};\nuse base64::{Engine as _, engine::general_purpose};\n\npub struct FieldEncryption {\n    cipher: Aes256Gcm,\n}\n\nimpl FieldEncryption {\n    pub fn new(key: &[u8; 32]) -> Self {\n        let cipher = Aes256Gcm::new(key.into());\n        Self { cipher }\n    }\n\n    /// 加密字段\n    pub fn encrypt(&self, plaintext: &str) -> Result<String, EncryptionError> {\n        let nonce = Nonce::from_slice(b\"unique nonce\");  // 实际应用中应使用随机nonce\n\n        let ciphertext = self.cipher\n            .encrypt(nonce, plaintext.as_bytes())\n            .map_err(|e| EncryptionError::EncryptionFailed(e.to_string()))?;\n\n        // Base64编码\n        Ok(general_purpose::STANDARD.encode(ciphertext))\n    }\n\n    /// 解密字段\n    pub fn decrypt(&self, ciphertext: &str) -> Result<String, EncryptionError> {\n        let nonce = Nonce::from_slice(b\"unique nonce\");\n\n        // Base64解码\n        let ciphertext_bytes = general_purpose::STANDARD\n            .decode(ciphertext)\n            .map_err(|e| EncryptionError::DecryptionFailed(e.to_string()))?;\n\n        let plaintext = self.cipher\n            .decrypt(nonce, ciphertext_bytes.as_ref())\n            .map_err(|e| EncryptionError::DecryptionFailed(e.to_string()))?;\n\n        String::from_utf8(plaintext)\n            .map_err(|e| EncryptionError::DecryptionFailed(e.to_string()))\n    }\n}\n\n// 数据库存储示例\n#[derive(Debug)]\npub struct Employee {\n    pub employee_id: Uuid,\n    pub name: String,\n    pub email: String,\n\n    // 敏感字段（加密存储）\n    pub ssn: String,              // 社会保障号（加密）\n    pub bank_account: String,     // 银行账号（加密）\n    pub salary: Decimal,          // 薪资（加密）\n}\n\nimpl Employee {\n    pub fn encrypt_sensitive_fields(&mut self, encryption: &FieldEncryption) -> Result<(), EncryptionError> {\n        self.ssn = encryption.encrypt(&self.ssn)?;\n        self.bank_account = encryption.encrypt(&self.bank_account)?;\n        self.salary = encryption.encrypt(&self.salary.to_string())?.parse().unwrap();\n        Ok(())\n    }\n\n    pub fn decrypt_sensitive_fields(&mut self, encryption: &FieldEncryption) -> Result<(), EncryptionError> {\n        self.ssn = encryption.decrypt(&self.ssn)?;\n        self.bank_account = encryption.decrypt(&self.bank_account)?;\n        self.salary = encryption.decrypt(&self.salary.to_string())?.parse().unwrap();\n        Ok(())\n    }\n}\n```\n\n#### 4.2.2 密钥管理（HashiCorp Vault 集成）\n\n```rust\n// src/infrastructure/vault/vault_client.rs\n\nuse vaultrs::{client::VaultClient, kv2};\n\npub struct VaultManager {\n    client: VaultClient,\n    mount: String,\n}\n\nimpl VaultManager {\n    pub async fn new(vault_addr: &str, token: &str, mount: String) -> Result<Self, VaultError> {\n        let client = VaultClient::new(\n            VaultClientSettingsBuilder::default()\n                .address(vault_addr)\n                .token(token)\n                .build()?,\n        )?;\n\n        Ok(Self { client, mount })\n    }\n\n    /// 获取加密密钥\n    pub async fn get_encryption_key(&self, key_name: &str) -> Result<Vec<u8>, VaultError> {\n        let secret: HashMap<String, String> = kv2::read(&self.client, &self.mount, key_name).await?;\n\n        let key_base64 = secret\n            .get(\"key\")\n            .ok_or_else(|| VaultError::KeyNotFound(key_name.to_string()))?;\n\n        general_purpose::STANDARD\n            .decode(key_base64)\n            .map_err(|e| VaultError::InvalidKey(e.to_string()))\n    }\n\n    /// 获取数据库凭证\n    pub async fn get_database_credentials(&self, db_name: &str) -> Result<DatabaseCredentials, VaultError> {\n        let secret: HashMap<String, String> = kv2::read(&self.client, &self.mount, &format!(\"database/{}\", db_name)).await?;\n\n        Ok(DatabaseCredentials {\n            username: secret.get(\"username\").cloned().ok_or_else(|| VaultError::MissingField(\"username\"))?,\n            password: secret.get(\"password\").cloned().ok_or_else(|| VaultError::MissingField(\"password\"))?,\n            host: secret.get(\"host\").cloned().ok_or_else(|| VaultError::MissingField(\"host\"))?,\n            port: secret.get(\"port\").and_then(|p| p.parse().ok()).ok_or_else(|| VaultError::MissingField(\"port\"))?,\n        })\n    }\n\n    /// 轮换密钥\n    pub async fn rotate_encryption_key(&self, key_name: &str) -> Result<Vec<u8>, VaultError> {\n        // 生成新密钥\n        let new_key = Self::generate_random_key();\n\n        // 存储到 Vault\n        let mut data = HashMap::new();\n        data.insert(\"key\", general_purpose::STANDARD.encode(&new_key));\n\n        kv2::set(&self.client, &self.mount, key_name, &data).await?;\n\n        Ok(new_key)\n    }\n\n    fn generate_random_key() -> Vec<u8> {\n        use rand::RngCore;\n        let mut key = vec![0u8; 32];\n        rand::thread_rng().fill_bytes(&mut key);\n        key\n    }\n}\n\npub struct DatabaseCredentials {\n    pub username: String,\n    pub password: String,\n    pub host: String,\n    pub port: u16,\n}\n```\n\n### 4.3 API 安全\n\n#### 4.3.1 限流（Rate Limiting）\n\n```rust\n// src/api/http/middleware/rate_limit_middleware.rs\n\nuse governor::{Quota, RateLimiter, clock::DefaultClock, state::keyed::DashMapStateStore};\nuse std::num::NonZeroU32;\n\npub struct RateLimitMiddleware {\n    limiter: RateLimiter<String, DashMapStateStore<String>, DefaultClock>,\n}\n\nimpl RateLimitMiddleware {\n    pub fn new(requests_per_minute: u32) -> Self {\n        let quota = Quota::per_minute(NonZeroU32::new(requests_per_minute).unwrap());\n        let limiter = RateLimiter::keyed(quota);\n\n        Self { limiter }\n    }\n\n    pub async fn check(&self, key: &str) -> Result<(), RateLimitError> {\n        self.limiter\n            .check_key(&key.to_string())\n            .map_err(|_| RateLimitError::TooManyRequests)?;\n\n        Ok(())\n    }\n}\n\n// Axum 中间件\npub async fn rate_limit_middleware(\n    State(limiter): State<Arc<RateLimitMiddleware>>,\n    request: Request,\n    next: Next,\n) -> Result<Response, StatusCode> {\n    // 从请求中提取限流键（用户ID、IP地址等）\n    let user = request.extensions().get::<AuthenticatedUser>();\n    let key = user\n        .map(|u| u.user_id.clone())\n        .unwrap_or_else(|| {\n            // 未认证用户使用IP地址\n            request\n                .headers()\n                .get(\"x-forwarded-for\")\n                .and_then(|v| v.to_str().ok())\n                .unwrap_or(\"unknown\")\n                .to_string()\n        });\n\n    limiter\n        .check(&key)\n        .await\n        .map_err(|_| StatusCode::TOO_MANY_REQUESTS)?;\n\n    Ok(next.run(request).await)\n}\n\n// 分层限流策略\npub struct TieredRateLimiter {\n    anonymous: RateLimitMiddleware,      // 匿名用户：10 req/min\n    authenticated: RateLimitMiddleware,  // 认证用户：100 req/min\n    premium: RateLimitMiddleware,        // 高级用户：1000 req/min\n}\n\nimpl TieredRateLimiter {\n    pub fn new() -> Self {\n        Self {\n            anonymous: RateLimitMiddleware::new(10),\n            authenticated: RateLimitMiddleware::new(100),\n            premium: RateLimitMiddleware::new(1000),\n        }\n    }\n\n    pub async fn check(&self, user: Option<&AuthenticatedUser>, key: &str) -> Result<(), RateLimitError> {\n        match user {\n            None => self.anonymous.check(key).await,\n            Some(u) if u.has_role(\"premium\") => self.premium.check(key).await,\n            Some(_) => self.authenticated.check(key).await,\n        }\n    }\n}\n```\n\n#### 4.3.2 CSRF 防护\n\n```rust\n// src/api/http/middleware/csrf_middleware.rs\n\nuse axum::http::header::SET_COOKIE;\n\npub struct CsrfMiddleware {\n    secret: String,\n}\n\nimpl CsrfMiddleware {\n    pub fn new(secret: String) -> Self {\n        Self { secret }\n    }\n\n    /// 生成 CSRF Token\n    pub fn generate_token(&self, session_id: &str) -> String {\n        use hmac::{Hmac, Mac};\n        use sha2::Sha256;\n\n        type HmacSha256 = Hmac<Sha256>;\n\n        let mut mac = HmacSha256::new_from_slice(self.secret.as_bytes())\n            .expect(\"HMAC can take key of any size\");\n        mac.update(session_id.as_bytes());\n\n        let result = mac.finalize();\n        general_purpose::STANDARD.encode(result.into_bytes())\n    }\n\n    /// 验证 CSRF Token\n    pub fn validate_token(&self, session_id: &str, token: &str) -> bool {\n        let expected = self.generate_token(session_id);\n        // 常量时间比较，防止时序攻击\n        expected == token\n    }\n}\n\npub async fn csrf_middleware(\n    State(csrf): State<Arc<CsrfMiddleware>>,\n    headers: HeaderMap,\n    request: Request,\n    next: Next,\n) -> Result<Response, StatusCode> {\n    // 对于非GET/HEAD/OPTIONS请求，验证CSRF Token\n    if !matches!(request.method(), &Method::GET | &Method::HEAD | &Method::OPTIONS) {\n        let token = headers\n            .get(\"X-CSRF-Token\")\n            .and_then(|v| v.to_str().ok())\n            .ok_or(StatusCode::FORBIDDEN)?;\n\n        let session_id = request\n            .extensions()\n            .get::<AuthenticatedUser>()\n            .map(|u| u.user_id.clone())\n            .ok_or(StatusCode::UNAUTHORIZED)?;\n\n        if !csrf.validate_token(&session_id, token) {\n            return Err(StatusCode::FORBIDDEN);\n        }\n    }\n\n    Ok(next.run(request).await)\n}\n```\n\n#### 4.3.3 SQL 注入防护\n\n所有数据库操作使用 **参数化查询**，永不拼接 SQL：\n\n```rust\n// ❌ 错误示例（SQL注入风险）\nlet sql = format!(\"SELECT * FROM users WHERE username = '{}'\", username);\n\n// ✅ 正确示例（参数化查询）\nsqlx::query_as!(\n    User,\n    \"SELECT * FROM users WHERE username = $1\",\n    username\n)\n.fetch_one(&pool)\n.await?;\n```\n\n#### 4.3.4 XSS 防护\n\n```rust\n// 输出编码（使用 askama 模板引擎自动转义）\n// templates/invoice.html\n<div>\n    <p>Customer Name: {{ customer_name }}</p>  <!-- 自动HTML转义 -->\n</div>\n\n// API 响应设置安全头\npub async fn security_headers_middleware(\n    request: Request,\n    next: Next,\n) -> Response {\n    let mut response = next.run(request).await;\n\n    response.headers_mut().insert(\n        \"X-Content-Type-Options\",\n        \"nosniff\".parse().unwrap(),\n    );\n    response.headers_mut().insert(\n        \"X-Frame-Options\",\n        \"DENY\".parse().unwrap(),\n    );\n    response.headers_mut().insert(\n        \"X-XSS-Protection\",\n        \"1; mode=block\".parse().unwrap(),\n    );\n    response.headers_mut().insert(\n        \"Content-Security-Policy\",\n        \"default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'\".parse().unwrap(),\n    );\n\n    response\n}\n```\n\n### 4.4 审计日志\n\n#### 4.4.1 审计日志记录\n\n```rust\n// src/infrastructure/audit/audit_logger.rs\n\n#[derive(Debug, Serialize)]\npub struct AuditLog {\n    pub audit_id: Uuid,\n    pub timestamp: DateTime<Utc>,\n    pub user_id: String,\n    pub tenant_id: Option<String>,\n    pub action: AuditAction,\n    pub resource_type: String,\n    pub resource_id: String,\n    pub before_state: Option<serde_json::Value>,\n    pub after_state: Option<serde_json::Value>,\n    pub ip_address: Option<String>,\n    pub user_agent: Option<String>,\n    pub result: AuditResult,\n    pub error_message: Option<String>,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"UPPERCASE\")]\npub enum AuditAction {\n    Create,\n    Read,\n    Update,\n    Delete,\n    Approve,\n    Reject,\n    Login,\n    Logout,\n}\n\n#[derive(Debug, Serialize)]\n#[serde(rename_all = \"UPPERCASE\")]\npub enum AuditResult {\n    Success,\n    Failure,\n}\n\npub struct AuditLogger {\n    pool: PgPool,\n}\n\nimpl AuditLogger {\n    pub async fn log(&self, log: AuditLog) -> Result<(), AuditError> {\n        sqlx::query!(\n            r#\"\n            INSERT INTO shared.audit_logs (\n                audit_id, timestamp, user_id, tenant_id, action, resource_type, resource_id,\n                before_state, after_state, ip_address, user_agent, result, error_message\n            ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)\n            \"#,\n            log.audit_id,\n            log.timestamp,\n            log.user_id,\n            log.tenant_id,\n            serde_json::to_value(&log.action)?,\n            log.resource_type,\n            log.resource_id,\n            log.before_state,\n            log.after_state,\n            log.ip_address,\n            log.user_agent,\n            serde_json::to_value(&log.result)?,\n            log.error_message,\n        )\n        .execute(&self.pool)\n        .await?;\n\n        Ok(())\n    }\n}\n\n// 审计日志表\nCREATE TABLE shared.audit_logs (\n    audit_id UUID PRIMARY KEY,\n    timestamp TIMESTAMPTZ NOT NULL,\n    user_id VARCHAR(255) NOT NULL,\n    tenant_id VARCHAR(255),\n    action JSONB NOT NULL,\n    resource_type VARCHAR(100) NOT NULL,\n    resource_id VARCHAR(255) NOT NULL,\n    before_state JSONB,\n    after_state JSONB,\n    ip_address VARCHAR(45),\n    user_agent TEXT,\n    result JSONB NOT NULL,\n    error_message TEXT\n) PARTITION BY RANGE (timestamp);\n\n-- 按月分区\nCREATE TABLE shared.audit_logs_2025_01 PARTITION OF shared.audit_logs\n    FOR VALUES FROM ('2025-01-01') TO ('2025-02-01');\n\n-- 索引\nCREATE INDEX idx_audit_logs_user ON shared.audit_logs (user_id, timestamp);\nCREATE INDEX idx_audit_logs_resource ON shared.audit_logs (resource_type, resource_id);\n```\n\n---\n\n## 五、监控告警详细配置\n\n### 5.1 Prometheus 指标暴露\n\n#### 5.1.1 业务指标定义\n\n```rust\n// src/infrastructure/observability/metrics.rs\n\nuse prometheus::{\n    Counter, Histogram, HistogramOpts, IntCounter, IntGauge, Opts, Registry,\n    labels, histogram_opts, register_counter, register_histogram, register_int_counter, register_int_gauge,\n};\nuse once_cell::sync::Lazy;\n\n// 全局 Registry\npub static REGISTRY: Lazy<Registry> = Lazy::new(Registry::new);\n\n// HTTP 请求指标\npub static HTTP_REQUESTS_TOTAL: Lazy<Counter> = Lazy::new(|| {\n    let opts = Opts::new(\"http_requests_total\", \"Total number of HTTP requests\")\n        .namespace(\"erp\")\n        .subsystem(\"api\");\n    register_counter!(opts, REGISTRY).unwrap()\n});\n\npub static HTTP_REQUEST_DURATION_SECONDS: Lazy<Histogram> = Lazy::new(|| {\n    let opts = histogram_opts!(\n        \"http_request_duration_seconds\",\n        \"HTTP request latency in seconds\",\n        vec![0.001, 0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1.0, 2.5, 5.0, 10.0]\n    )\n    .namespace(\"erp\")\n    .subsystem(\"api\");\n    register_histogram!(opts, REGISTRY).unwrap()\n});\n\n// 业务指标\npub static TRANSACTIONS_POSTED_TOTAL: Lazy<IntCounter> = Lazy::new(|| {\n    let opts = Opts::new(\"transactions_posted_total\", \"Total number of posted transactions\")\n        .namespace(\"erp\")\n        .subsystem(\"financial\");\n    register_int_counter!(opts, REGISTRY).unwrap()\n});\n\npub static SALES_ORDERS_CREATED_TOTAL: Lazy<IntCounter> = Lazy::new(|| {\n    let opts = Opts::new(\"sales_orders_created_total\", \"Total number of sales orders created\")\n        .namespace(\"erp\")\n        .subsystem(\"sales\");\n    register_int_counter!(opts, REGISTRY).unwrap()\n});\n\npub static INVENTORY_LEVEL: Lazy<IntGauge> = Lazy::new(|| {\n    let opts = Opts::new(\"inventory_level\", \"Current inventory level\")\n        .namespace(\"erp\")\n        .subsystem(\"materials\");\n    register_int_gauge!(opts, REGISTRY).unwrap()\n});\n\n// Kafka 消费指标\npub static KAFKA_MESSAGES_CONSUMED_TOTAL: Lazy<Counter> = Lazy::new(|| {\n    let opts = Opts::new(\"kafka_messages_consumed_total\", \"Total number of Kafka messages consumed\")\n        .namespace(\"erp\")\n        .subsystem(\"messaging\");\n    register_counter!(opts, REGISTRY).unwrap()\n});\n\npub static KAFKA_CONSUMER_LAG: Lazy<IntGauge> = Lazy::new(|| {\n    let opts = Opts::new(\"kafka_consumer_lag\", \"Kafka consumer lag\")\n        .namespace(\"erp\")\n        .subsystem(\"messaging\");\n    register_int_gauge!(opts, REGISTRY).unwrap()\n});\n\n// 数据库连接池指标\npub static DB_CONNECTIONS_ACTIVE: Lazy<IntGauge> = Lazy::new(|| {\n    let opts = Opts::new(\"db_connections_active\", \"Number of active database connections\")\n        .namespace(\"erp\")\n        .subsystem(\"database\");\n    register_int_gauge!(opts, REGISTRY).unwrap()\n});\n\npub static DB_QUERY_DURATION_SECONDS: Lazy<Histogram> = Lazy::new(|| {\n    let opts = histogram_opts!(\n        \"db_query_duration_seconds\",\n        \"Database query latency in seconds\",\n        vec![0.001, 0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1.0]\n    )\n    .namespace(\"erp\")\n    .subsystem(\"database\");\n    register_histogram!(opts, REGISTRY).unwrap()\n});\n\n// Saga 指标\npub static SAGA_EXECUTIONS_TOTAL: Lazy<Counter> = Lazy::new(|| {\n    let opts = Opts::new(\"saga_executions_total\", \"Total number of saga executions\")\n        .namespace(\"erp\")\n        .subsystem(\"saga\");\n    register_counter!(opts, REGISTRY).unwrap()\n});\n\npub static SAGA_COMPENSATIONS_TOTAL: Lazy<Counter> = Lazy::new(|| {\n    let opts = Opts::new(\"saga_compensations_total\", \"Total number of saga compensations\")\n        .namespace(\"erp\")\n        .subsystem(\"saga\");\n    register_counter!(opts, REGISTRY).unwrap()\n});\n```\n\n#### 5.1.2 指标收集中间件\n\n```rust\n// src/api/http/middleware/metrics_middleware.rs\n\npub async fn metrics_middleware(\n    request: Request,\n    next: Next,\n) -> Response {\n    let start = std::time::Instant::now();\n    let method = request.method().clone();\n    let path = request.uri().path().to_string();\n\n    // 增加请求计数\n    HTTP_REQUESTS_TOTAL.inc();\n\n    // 执行请求\n    let response = next.run(request).await;\n\n    // 记录延迟\n    let duration = start.elapsed().as_secs_f64();\n    HTTP_REQUEST_DURATION_SECONDS\n        .with_label_values(&[method.as_str(), &path, response.status().as_str()])\n        .observe(duration);\n\n    response\n}\n\n// 暴露 Prometheus 指标端点\npub async fn metrics_handler() -> impl IntoResponse {\n    use prometheus::Encoder;\n\n    let encoder = prometheus::TextEncoder::new();\n    let metric_families = REGISTRY.gather();\n\n    let mut buffer = Vec::new();\n    encoder.encode(&metric_families, &mut buffer).unwrap();\n\n    Response::builder()\n        .status(StatusCode::OK)\n        .header(\"Content-Type\", encoder.format_type())\n        .body(buffer.into())\n        .unwrap()\n}\n\n// 路由注册\nlet app = Router::new()\n    .route(\"/metrics\", get(metrics_handler))\n    .layer(axum::middleware::from_fn(metrics_middleware));\n```\n\n### 5.2 Grafana Dashboard 配置\n\n#### 5.2.1 财务服务 Dashboard（JSON）\n\n```json\n{\n  \"dashboard\": {\n    \"title\": \"Financial Service Dashboard\",\n    \"panels\": [\n      {\n        \"title\": \"Transaction Posting Rate\",\n        \"targets\": [\n          {\n            \"expr\": \"rate(erp_financial_transactions_posted_total[5m])\",\n            \"legendFormat\": \"Transactions/sec\"\n          }\n        ],\n        \"type\": \"graph\"\n      },\n      {\n        \"title\": \"API Latency (P99)\",\n        \"targets\": [\n          {\n            \"expr\": \"histogram_quantile(0.99, rate(erp_api_http_request_duration_seconds_bucket{job=\\\"financial-service\\\"}[5m]))\",\n            \"legendFormat\": \"P99 Latency\"\n          }\n        ],\n        \"type\": \"graph\"\n      },\n      {\n        \"title\": \"Error Rate\",\n        \"targets\": [\n          {\n            \"expr\": \"rate(erp_api_http_requests_total{status=~\\\"5..\\\"}[5m])\",\n            \"legendFormat\": \"5xx Errors/sec\"\n          }\n        ],\n        \"type\": \"graph\"\n      }\n    ]\n  }\n}\n```\n\n### 5.3 告警规则配置\n\n#### 5.3.1 Prometheus 告警规则\n\n```yaml\n# prometheus/alerts/financial-service.yml\n\ngroups:\n  - name: financial_service_alerts\n    interval: 30s\n    rules:\n      # API 延迟告警\n      - alert: HighAPILatency\n        expr: histogram_quantile(0.99, rate(erp_api_http_request_duration_seconds_bucket{job=\"financial-service\"}[5m])) > 0.5\n        for: 5m\n        labels:\n          severity: warning\n          service: financial-service\n        annotations:\n          summary: \"High API latency on {{ $labels.instance }}\"\n          description: \"P99 latency is {{ $value }}s (threshold: 0.5s)\"\n\n      # 错误率告警\n      - alert: HighErrorRate\n        expr: rate(erp_api_http_requests_total{status=~\"5..\",job=\"financial-service\"}[5m]) > 0.01\n        for: 2m\n        labels:\n          severity: critical\n          service: financial-service\n        annotations:\n          summary: \"High error rate on {{ $labels.instance }}\"\n          description: \"Error rate is {{ $value }} req/s\"\n\n      # 数据库连接池耗尽\n      - alert: DatabaseConnectionPoolExhausted\n        expr: erp_database_db_connections_active / erp_database_db_connections_max > 0.9\n        for: 1m\n        labels:\n          severity: warning\n          service: financial-service\n        annotations:\n          summary: \"Database connection pool nearly exhausted\"\n          description: \"{{ $value | humanizePercentage }} of connections in use\"\n\n      # Kafka 消费延迟\n      - alert: KafkaConsumerLag\n        expr: erp_messaging_kafka_consumer_lag > 1000\n        for: 5m\n        labels:\n          severity: warning\n          service: financial-service\n        annotations:\n          summary: \"Kafka consumer lag is high\"\n          description: \"Lag is {{ $value }} messages\"\n\n      # Saga 补偿率过高\n      - alert: HighSagaCompensationRate\n        expr: rate(erp_saga_saga_compensations_total[5m]) / rate(erp_saga_saga_executions_total[5m]) > 0.1\n        for: 10m\n        labels:\n          severity: critical\n          service: financial-service\n        annotations:\n          summary: \"High saga compensation rate\"\n          description: \"{{ $value | humanizePercentage }} of sagas are being compensated\"\n```\n\n#### 5.3.2 AlertManager 配置\n\n```yaml\n# alertmanager/config.yml\n\nglobal:\n  resolve_timeout: 5m\n  slack_api_url: 'https://hooks.slack.com/services/xxx'\n\nroute:\n  group_by: ['alertname', 'service']\n  group_wait: 10s\n  group_interval: 10s\n  repeat_interval: 12h\n  receiver: 'default'\n\n  routes:\n    # 严重告警发送到 PagerDuty\n    - match:\n        severity: critical\n      receiver: 'pagerduty'\n      continue: true\n\n    # 所有告警发送到 Slack\n    - receiver: 'slack'\n\nreceivers:\n  - name: 'default'\n    slack_configs:\n      - channel: '#erp-alerts'\n        title: 'ERP Alert'\n        text: '{{ range .Alerts }}{{ .Annotations.summary }}\\n{{ .Annotations.description }}\\n{{ end }}'\n\n  - name: 'pagerduty'\n    pagerduty_configs:\n      - service_key: 'xxx'\n        description: '{{ .CommonAnnotations.summary }}'\n\n  - name: 'slack'\n    slack_configs:\n      - channel: '#erp-alerts'\n        title: '{{ .GroupLabels.alertname }}'\n        text: '{{ range .Alerts }}{{ .Annotations.description }}\\n{{ end }}'\n        color: '{{ if eq .Status \"firing\" }}danger{{ else }}good{{ end }}'\n```\n\n### 5.4 分布式追踪（Jaeger）\n\n#### 5.4.1 OpenTelemetry 集成\n\n```rust\n// src/infrastructure/observability/tracing.rs\n\nuse opentelemetry::{\n    global,\n    sdk::{\n        export::trace::stdout,\n        propagation::TraceContextPropagator,\n        trace::{self, RandomIdGenerator, Sampler},\n        Resource,\n    },\n    KeyValue,\n};\nuse opentelemetry_jaeger::new_agent_pipeline;\nuse tracing_subscriber::{layer::SubscriberExt, Registry};\n\npub fn init_tracing(service_name: &str) -> Result<(), Box<dyn std::error::Error>> {\n    global::set_text_map_propagator(TraceContextPropagator::new());\n\n    let tracer = new_agent_pipeline()\n        .with_service_name(service_name)\n        .with_auto_split_batch(true)\n        .with_max_packet_size(65000)\n        .install_batch(opentelemetry::runtime::Tokio)?;\n\n    let telemetry = tracing_opentelemetry::layer().with_tracer(tracer);\n\n    let subscriber = Registry::default()\n        .with(telemetry)\n        .with(tracing_subscriber::fmt::layer());\n\n    tracing::subscriber::set_global_default(subscriber)?;\n\n    Ok(())\n}\n\n// 在服务启动时初始化\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    init_tracing(\"financial-service\")?;\n\n    // ... 启动服务\n\n    Ok(())\n}\n```\n\n#### 5.4.2 自定义 Span\n\n```rust\nuse tracing::{info, instrument, Span};\n\n#[instrument(skip(pool))]\npub async fn create_transaction(\n    pool: &PgPool,\n    command: CreateTransactionCommand,\n) -> Result<Transaction, DomainError> {\n    let span = Span::current();\n\n    span.record(\"transaction.company_code\", &command.company_code.as_str());\n    span.record(\"transaction.fiscal_year\", &command.fiscal_year);\n\n    info!(\"Creating transaction\");\n\n    // 业务逻辑\n    let transaction = Transaction::create(command)?;\n\n    // 持久化\n    let saved = save_transaction(pool, &transaction).await?;\n\n    span.record(\"transaction.id\", &saved.id.to_string().as_str());\n    info!(\"Transaction created successfully\");\n\n    Ok(saved)\n}\n```\n\n---\n\n## 六、测试策略详细方案\n\n### 6.1 单元测试\n\n#### 6.1.1 领域层单元测试示例\n\n```rust\n// src/domain/aggregates/transaction.rs\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use chrono::NaiveDate;\n    use rust_decimal_macros::dec;\n\n    #[test]\n    fn test_create_transaction_success() {\n        // Arrange\n        let command = CreateTransactionCommand {\n            idempotency_key: Uuid::new_v4(),\n            posting_date: NaiveDate::from_ymd_opt(2025, 12, 22).unwrap(),\n            document_date: NaiveDate::from_ymd_opt(2025, 12, 20).unwrap(),\n            company_code: \"1000\".to_string(),\n            fiscal_year: 2025,\n            journal_entries: vec![\n                JournalEntry {\n                    account_number: \"100000\".to_string(),\n                    debit_amount: dec!(10000.00),\n                    credit_amount: dec!(0.00),\n                    currency: \"USD\".to_string(),\n                    cost_center: None,\n                    profit_center: None,\n                },\n                JournalEntry {\n                    account_number: \"200000\".to_string(),\n                    debit_amount: dec!(0.00),\n                    credit_amount: dec!(10000.00),\n                    currency: \"USD\".to_string(),\n                    cost_center: None,\n                    profit_center: None,\n                },\n            ],\n        };\n\n        // Act\n        let result = Transaction::create(command);\n\n        // Assert\n        assert!(result.is_ok());\n        let transaction = result.unwrap();\n        assert_eq!(transaction.status, TransactionStatus::Draft);\n        assert_eq!(transaction.journal_entries.len(), 2);\n    }\n\n    #[test]\n    fn test_create_transaction_unbalanced_fails() {\n        // Arrange\n        let command = CreateTransactionCommand {\n            idempotency_key: Uuid::new_v4(),\n            posting_date: NaiveDate::from_ymd_opt(2025, 12, 22).unwrap(),\n            document_date: NaiveDate::from_ymd_opt(2025, 12, 20).unwrap(),\n            company_code: \"1000\".to_string(),\n            fiscal_year: 2025,\n            journal_entries: vec![\n                JournalEntry {\n                    account_number: \"100000\".to_string(),\n                    debit_amount: dec!(10000.00),\n                    credit_amount: dec!(0.00),\n                    currency: \"USD\".to_string(),\n                    cost_center: None,\n                    profit_center: None,\n                },\n                JournalEntry {\n                    account_number: \"200000\".to_string(),\n                    debit_amount: dec!(0.00),\n                    credit_amount: dec!(5000.00),  // 不平衡!\n                    currency: \"USD\".to_string(),\n                    cost_center: None,\n                    profit_center: None,\n                },\n            ],\n        };\n\n        // Act\n        let result = Transaction::create(command);\n\n        // Assert\n        assert!(result.is_err());\n        assert!(matches!(result.unwrap_err(), DomainError::TransactionUnbalanced { .. }));\n    }\n\n    #[test]\n    fn test_post_transaction_success() {\n        // Arrange\n        let mut transaction = create_test_transaction();\n\n        // Act\n        let result = transaction.post();\n\n        // Assert\n        assert!(result.is_ok());\n        assert_eq!(transaction.status, TransactionStatus::Posted);\n        assert!(transaction.posted_at.is_some());\n    }\n\n    fn create_test_transaction() -> Transaction {\n        Transaction {\n            transaction_id: Uuid::new_v4(),\n            transaction_number: \"FI-2025-0001\".to_string(),\n            posting_date: NaiveDate::from_ymd_opt(2025, 12, 22).unwrap(),\n            document_date: NaiveDate::from_ymd_opt(2025, 12, 20).unwrap(),\n            company_code: \"1000\".to_string(),\n            fiscal_year: 2025,\n            status: TransactionStatus::Draft,\n            journal_entries: vec![\n                JournalEntry {\n                    account_number: \"100000\".to_string(),\n                    debit_amount: dec!(10000.00),\n                    credit_amount: dec!(0.00),\n                    currency: \"USD\".to_string(),\n                    cost_center: None,\n                    profit_center: None,\n                },\n                JournalEntry {\n                    account_number: \"200000\".to_string(),\n                    debit_amount: dec!(0.00),\n                    credit_amount: dec!(10000.00),\n                    currency: \"USD\".to_string(),\n                    cost_center: None,\n                    profit_center: None,\n                },\n            ],\n            created_at: Utc::now(),\n            created_by: \"test_user\".to_string(),\n            posted_at: None,\n        }\n    }\n}\n```\n\n### 6.2 集成测试\n\n#### 6.2.1 数据库集成测试\n\n```rust\n// tests/integration/financial/transaction_repository_test.rs\n\nuse sqlx::PgPool;\nuse testcontainers::*;\n\n#[tokio::test]\nasync fn test_save_and_load_transaction() {\n    // 启动测试容器\n    let docker = clients::Cli::default();\n    let postgres = docker.run(images::postgres::Postgres::default());\n    let connection_string = format!(\n        \"postgresql://postgres:postgres@localhost:{}/postgres\",\n        postgres.get_host_port_ipv4(5432)\n    );\n\n    // 创建连接池\n    let pool = PgPool::connect(&connection_string).await.unwrap();\n\n    // 运行迁移\n    sqlx::migrate!(\"./migrations\")\n        .run(&pool)\n        .await\n        .unwrap();\n\n    // 创建仓储\n    let repo = TransactionRepository::new(pool.clone());\n\n    // 测试数据\n    let transaction = create_test_transaction();\n\n    // Act: 保存\n    repo.save(&transaction).await.unwrap();\n\n    // Act: 加载\n    let loaded = repo.find_by_id(transaction.transaction_id).await.unwrap();\n\n    // Assert\n    assert_eq!(loaded.transaction_number, transaction.transaction_number);\n    assert_eq!(loaded.journal_entries.len(), transaction.journal_entries.len());\n}\n```\n\n### 6.3 契约测试（Pact）\n\n```rust\n// tests/contract/sales_to_materials_contract_test.rs\n\nuse pact_consumer::prelude::*;\nuse pact_consumer::*;\n\n#[tokio::test]\nasync fn test_reserve_inventory_contract() {\n    // 定义契约\n    let pact = PactBuilder::new(\"sales-service\", \"materials-service\")\n        .interaction(\"reserve inventory\", |mut i| {\n            i.request\n                .post()\n                .path(\"/api/v1/materials/reservations\")\n                .header(\"Content-Type\", \"application/json\")\n                .json_body(json_pattern!({\n                    \"idempotency_key\": like!(\"550e8400-e29b-41d4-a716-446655440000\"),\n                    \"order_id\": like!(\"660e8400-e29b-41d4-a716-446655440000\"),\n                    \"items\": each_like!({\n                        \"material_id\": like!(\"770e8400-e29b-41d4-a716-446655440000\"),\n                        \"quantity\": like!(10),\n                        \"plant\": like!(\"1000\")\n                    })\n                }));\n\n            i.response\n                .status(201)\n                .header(\"Content-Type\", \"application/json\")\n                .json_body(json_pattern!({\n                    \"reservation_id\": like!(\"880e8400-e29b-41d4-a716-446655440000\"),\n                    \"status\": like!(\"RESERVED\")\n                }));\n        })\n        .build();\n\n    // 启动 Mock Server\n    let mock_server = pact.start_mock_server(None);\n\n    // 调用客户端\n    let client = MaterialsServiceClient::new(mock_server.url().as_str());\n    let response = client\n        .reserve_inventory(ReserveInventoryRequest {\n            idempotency_key: Uuid::parse_str(\"550e8400-e29b-41d4-a716-446655440000\").unwrap(),\n            order_id: Uuid::parse_str(\"660e8400-e29b-41d4-a716-446655440000\").unwrap(),\n            items: vec![ReserveInventoryItem {\n                material_id: Uuid::parse_str(\"770e8400-e29b-41d4-a716-446655440000\").unwrap(),\n                quantity: 10,\n                plant: \"1000\".to_string(),\n            }],\n        })\n        .await\n        .unwrap();\n\n    // 断言\n    assert_eq!(response.status, \"RESERVED\");\n\n    // 验证契约\n    mock_server.verify().unwrap();\n}\n```\n\n### 6.4 端到端测试\n\n```rust\n// tests/e2e/order_to_cash_e2e_test.rs\n\n#[tokio::test]\nasync fn test_complete_order_to_cash_flow() {\n    // Setup: 启动所有服务（或使用Docker Compose）\n    let services = start_all_services().await;\n\n    // Step 1: 创建销售订单\n    let order_response = services.sales_client\n        .create_order(CreateSalesOrderRequest {\n            customer_id: test_customer_id(),\n            items: vec![\n                OrderItem {\n                    material_id: test_material_id(),\n                    quantity: 10,\n                    unit_price: dec!(100.00),\n                }\n            ],\n        })\n        .await\n        .expect(\"Failed to create sales order\");\n\n    assert_eq!(order_response.status, \"CREATED\");\n\n    // Step 2: 验证信用检查通过\n    tokio::time::sleep(Duration::from_secs(1)).await;  // 等待异步处理\n    let credit_check = services.credit_client\n        .get_credit_check_status(order_response.order_id)\n        .await\n        .expect(\"Failed to get credit check status\");\n\n    assert_eq!(credit_check.status, \"APPROVED\");\n\n    // Step 3: 验证库存预留\n    let reservation = services.materials_client\n        .get_reservation_by_order(order_response.order_id)\n        .await\n        .expect(\"Failed to get reservation\");\n\n    assert_eq!(reservation.status, \"RESERVED\");\n\n    // Step 4: 创建交付\n    let delivery_response = services.warehouse_client\n        .create_delivery(CreateDeliveryRequest {\n            order_id: order_response.order_id,\n        })\n        .await\n        .expect(\"Failed to create delivery\");\n\n    // Step 5: 创建发货\n    let shipment_response = services.transport_client\n        .create_shipment(CreateShipmentRequest {\n            delivery_id: delivery_response.delivery_id,\n        })\n        .await\n        .expect(\"Failed to create shipment\");\n\n    // Step 6: 创建发票\n    let invoice_response = services.sales_client\n        .create_invoice(CreateInvoiceRequest {\n            order_id: order_response.order_id,\n        })\n        .await\n        .expect(\"Failed to create invoice\");\n\n    // Step 7: 验证应收账款创建\n    tokio::time::sleep(Duration::from_secs(1)).await;\n    let receivable = services.financial_client\n        .get_receivable_by_invoice(invoice_response.invoice_id)\n        .await\n        .expect(\"Failed to get receivable\");\n\n    assert_eq!(receivable.status, \"OPEN\");\n    assert_eq!(receivable.amount, dec!(1000.00));  // 10 * 100\n\n    // Cleanup\n    cleanup_test_data().await;\n}\n```\n\n---\n\n继续补充剩余章节（第7-10章）？\n## 七、Kubernetes部署配置\n\n### 7.1 服务 Deployment 配置\n\n#### 7.1.1 Financial Service Deployment\n\n```yaml\n# kubernetes/deployments/financial-service.yaml\n\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: financial-service\n  namespace: erp\n  labels:\n    app: financial-service\n    version: v1.0.0\nspec:\n  replicas: 3\n  revisionHistoryLimit: 10\n  selector:\n    matchLabels:\n      app: financial-service\n  template:\n    metadata:\n      labels:\n        app: financial-service\n        version: v1.0.0\n      annotations:\n        prometheus.io/scrape: \"true\"\n        prometheus.io/port: \"8080\"\n        prometheus.io/path: \"/metrics\"\n    spec:\n      serviceAccountName: financial-service\n      containers:\n      - name: financial-service\n        image: ghcr.io/erp/financial-service:v1.0.0\n        imagePullPolicy: IfNotPresent\n        ports:\n        - name: http\n          containerPort: 8080\n          protocol: TCP\n        - name: grpc\n          containerPort: 50051\n          protocol: TCP\n        env:\n        - name: DATABASE_URL\n          valueFrom:\n            secretKeyRef:\n              name: financial-db-credentials\n              key: connection_string\n        - name: REDIS_URL\n          value: \"redis://redis-cluster:6379\"\n        - name: KAFKA_BROKERS\n          value: \"kafka-0.kafka:9092,kafka-1.kafka:9092,kafka-2.kafka:9092\"\n        - name: RUST_LOG\n          value: \"info,financial_service=debug\"\n        - name: JAEGER_AGENT_HOST\n          value: \"jaeger-agent.observability\"\n        - name: JAEGER_AGENT_PORT\n          value: \"6831\"\n        - name: VAULT_ADDR\n          value: \"http://vault.vault:8200\"\n        - name: VAULT_TOKEN\n          valueFrom:\n            secretKeyRef:\n              name: vault-token\n              key: token\n        resources:\n          requests:\n            memory: \"512Mi\"\n            cpu: \"500m\"\n          limits:\n            memory: \"2Gi\"\n            cpu: \"2000m\"\n        livenessProbe:\n          httpGet:\n            path: /health/live\n            port: 8080\n          initialDelaySeconds: 30\n          periodSeconds: 10\n          timeoutSeconds: 5\n          failureThreshold: 3\n        readinessProbe:\n          httpGet:\n            path: /health/ready\n            port: 8080\n          initialDelaySeconds: 10\n          periodSeconds: 5\n          timeoutSeconds: 3\n          failureThreshold: 3\n        volumeMounts:\n        - name: config\n          mountPath: /etc/config\n          readOnly: true\n      volumes:\n      - name: config\n        configMap:\n          name: financial-service-config\n      affinity:\n        podAntiAffinity:\n          preferredDuringSchedulingIgnoredDuringExecution:\n          - weight: 100\n            podAffinityTerm:\n              labelSelector:\n                matchExpressions:\n                - key: app\n                  operator: In\n                  values:\n                  - financial-service\n              topologyKey: kubernetes.io/hostname\n\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: financial-service\n  namespace: erp\n  labels:\n    app: financial-service\nspec:\n  type: ClusterIP\n  ports:\n  - name: http\n    port: 80\n    targetPort: 8080\n    protocol: TCP\n  - name: grpc\n    port: 50051\n    targetPort: 50051\n    protocol: TCP\n  selector:\n    app: financial-service\n\n---\napiVersion: autoscaling/v2\nkind: HorizontalPodAutoscaler\nmetadata:\n  name: financial-service-hpa\n  namespace: erp\nspec:\n  scaleTargetRef:\n    apiVersion: apps/v1\n    kind: Deployment\n    name: financial-service\n  minReplicas: 3\n  maxReplicas: 10\n  metrics:\n  - type: Resource\n    resource:\n      name: cpu\n      target:\n        type: Utilization\n        averageUtilization: 70\n  - type: Resource\n    resource:\n      name: memory\n      target:\n        type: Utilization\n        averageUtilization: 80\n  behavior:\n    scaleDown:\n      stabilizationWindowSeconds: 300\n      policies:\n      - type: Percent\n        value: 50\n        periodSeconds: 60\n    scaleUp:\n      stabilizationWindowSeconds: 0\n      policies:\n      - type: Percent\n        value: 100\n        periodSeconds: 30\n      - type: Pods\n        value: 2\n        periodSeconds: 30\n      selectPolicy: Max\n```\n\n### 7.2 ConfigMap 和 Secret\n\n#### 7.2.1 ConfigMap\n\n```yaml\n# kubernetes/configmaps/financial-service-config.yaml\n\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: financial-service-config\n  namespace: erp\ndata:\n  config.yaml: |\n    server:\n      host: \"0.0.0.0\"\n      port: 8080\n      grpc_port: 50051\n    \n    database:\n      max_connections: 20\n      min_connections: 5\n      connection_timeout: 30\n    \n    redis:\n      pool_size: 10\n      connection_timeout: 5\n    \n    kafka:\n      consumer_group_id: \"financial-service-consumer\"\n      auto_offset_reset: \"earliest\"\n      enable_auto_commit: false\n    \n    observability:\n      metrics_enabled: true\n      tracing_enabled: true\n      logging_level: \"info\"\n```\n\n#### 7.2.2 Secret\n\n```yaml\n# kubernetes/secrets/financial-db-credentials.yaml\n\napiVersion: v1\nkind: Secret\nmetadata:\n  name: financial-db-credentials\n  namespace: erp\ntype: Opaque\nstringData:\n  connection_string: \"postgresql://erp_user:CHANGE_ME@postgres-primary.database:5432/erp_financial\"\n  username: \"erp_user\"\n  password: \"CHANGE_ME\"\n```\n\n### 7.3 StatefulSet（PostgreSQL、Redis、Kafka）\n\n#### 7.3.1 PostgreSQL StatefulSet\n\n```yaml\n# kubernetes/statefulsets/postgres.yaml\n\napiVersion: apps/v1\nkind: StatefulSet\nmetadata:\n  name: postgres\n  namespace: database\nspec:\n  serviceName: postgres\n  replicas: 3\n  selector:\n    matchLabels:\n      app: postgres\n  template:\n    metadata:\n      labels:\n        app: postgres\n    spec:\n      containers:\n      - name: postgres\n        image: postgres:16\n        env:\n        - name: POSTGRES_USER\n          value: \"postgres\"\n        - name: POSTGRES_PASSWORD\n          valueFrom:\n            secretKeyRef:\n              name: postgres-credentials\n              key: password\n        - name: PGDATA\n          value: \"/var/lib/postgresql/data/pgdata\"\n        ports:\n        - name: postgres\n          containerPort: 5432\n        volumeMounts:\n        - name: postgres-data\n          mountPath: /var/lib/postgresql/data\n        resources:\n          requests:\n            memory: \"1Gi\"\n            cpu: \"500m\"\n          limits:\n            memory: \"4Gi\"\n            cpu: \"2000m\"\n        livenessProbe:\n          exec:\n            command:\n            - pg_isready\n            - -U\n            - postgres\n          initialDelaySeconds: 30\n          periodSeconds: 10\n        readinessProbe:\n          exec:\n            command:\n            - pg_isready\n            - -U\n            - postgres\n          initialDelaySeconds: 5\n          periodSeconds: 5\n  volumeClaimTemplates:\n  - metadata:\n      name: postgres-data\n    spec:\n      accessModes: [\"ReadWriteOnce\"]\n      storageClassName: \"fast-ssd\"\n      resources:\n        requests:\n          storage: 100Gi\n\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: postgres\n  namespace: database\nspec:\n  clusterIP: None\n  ports:\n  - port: 5432\n    targetPort: 5432\n  selector:\n    app: postgres\n\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: postgres-primary\n  namespace: database\nspec:\n  type: ClusterIP\n  ports:\n  - port: 5432\n    targetPort: 5432\n  selector:\n    app: postgres\n    role: primary\n```\n\n### 7.4 Istio 配置（Service Mesh）\n\n#### 7.4.1 VirtualService\n\n```yaml\n# kubernetes/istio/financial-service-virtualservice.yaml\n\napiVersion: networking.istio.io/v1beta1\nkind: VirtualService\nmetadata:\n  name: financial-service\n  namespace: erp\nspec:\n  hosts:\n  - financial-service\n  http:\n  - match:\n    - headers:\n        x-api-version:\n          exact: v2\n    route:\n    - destination:\n        host: financial-service\n        subset: v2\n      weight: 100\n  - route:\n    - destination:\n        host: financial-service\n        subset: v1\n      weight: 90\n    - destination:\n        host: financial-service\n        subset: v2\n      weight: 10\n    retries:\n      attempts: 3\n      perTryTimeout: 2s\n      retryOn: 5xx,reset,connect-failure,refused-stream\n    timeout: 10s\n\n---\napiVersion: networking.istio.io/v1beta1\nkind: DestinationRule\nmetadata:\n  name: financial-service\n  namespace: erp\nspec:\n  host: financial-service\n  trafficPolicy:\n    connectionPool:\n      tcp:\n        maxConnections: 100\n      http:\n        http1MaxPendingRequests: 50\n        http2MaxRequests: 100\n        maxRequestsPerConnection: 2\n    loadBalancer:\n      simple: LEAST_REQUEST\n    outlierDetection:\n      consecutiveErrors: 5\n      interval: 30s\n      baseEjectionTime: 30s\n      maxEjectionPercent: 50\n      minHealthPercent: 40\n  subsets:\n  - name: v1\n    labels:\n      version: v1.0.0\n  - name: v2\n    labels:\n      version: v2.0.0\n```\n\n#### 7.4.2 Circuit Breaker\n\n```yaml\n# kubernetes/istio/financial-service-circuit-breaker.yaml\n\napiVersion: networking.istio.io/v1beta1\nkind: DestinationRule\nmetadata:\n  name: financial-service-circuit-breaker\n  namespace: erp\nspec:\n  host: financial-service\n  trafficPolicy:\n    outlierDetection:\n      consecutiveGatewayErrors: 5\n      consecutive5xxErrors: 5\n      interval: 10s\n      baseEjectionTime: 30s\n      maxEjectionPercent: 50\n```\n\n---\n\n## 八、CI/CD Pipeline详细配置\n\n### 8.1 GitHub Actions Workflow\n\n#### 8.1.1 完整 CI/CD Pipeline\n\n```yaml\n# .github/workflows/ci-cd.yml\n\nname: CI/CD Pipeline\n\non:\n  push:\n    branches:\n      - main\n      - develop\n    tags:\n      - 'v*'\n  pull_request:\n    branches:\n      - main\n      - develop\n\nenv:\n  CARGO_TERM_COLOR: always\n  REGISTRY: ghcr.io\n  IMAGE_NAME: ${{ github.repository }}\n\njobs:\n  lint:\n    name: Lint\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Install Rust\n        uses: dtolnay/rust-toolchain@stable\n        with:\n          components: rustfmt, clippy\n\n      - name: Cache Cargo\n        uses: actions/cache@v3\n        with:\n          path: |\n            ~/.cargo/bin/\n            ~/.cargo/registry/index/\n            ~/.cargo/registry/cache/\n            ~/.cargo/git/db/\n            target/\n          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}\n\n      - name: Format Check\n        run: cargo fmt -- --check\n\n      - name: Clippy\n        run: cargo clippy --all-targets --all-features -- -D warnings\n\n  test:\n    name: Test\n    runs-on: ubuntu-latest\n    services:\n      postgres:\n        image: postgres:16\n        env:\n          POSTGRES_PASSWORD: postgres\n        options: >-\n          --health-cmd pg_isready\n          --health-interval 10s\n          --health-timeout 5s\n          --health-retries 5\n        ports:\n          - 5432:5432\n      redis:\n        image: redis:7\n        options: >-\n          --health-cmd \"redis-cli ping\"\n          --health-interval 10s\n          --health-timeout 5s\n          --health-retries 5\n        ports:\n          - 6379:6379\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Install Rust\n        uses: dtolnay/rust-toolchain@stable\n\n      - name: Cache Cargo\n        uses: actions/cache@v3\n        with:\n          path: |\n            ~/.cargo/bin/\n            ~/.cargo/registry/index/\n            ~/.cargo/registry/cache/\n            ~/.cargo/git/db/\n            target/\n          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}\n\n      - name: Run Database Migrations\n        env:\n          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/postgres\n        run: |\n          cargo install sqlx-cli --no-default-features --features postgres\n          sqlx database create\n          sqlx migrate run\n\n      - name: Run Tests\n        env:\n          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/postgres\n          REDIS_URL: redis://localhost:6379\n        run: cargo test --all-features --workspace\n\n      - name: Code Coverage\n        run: |\n          cargo install cargo-tarpaulin\n          cargo tarpaulin --all-features --workspace --timeout 300 --out Xml\n\n      - name: Upload Coverage to Codecov\n        uses: codecov/codecov-action@v3\n        with:\n          files: ./cobertura.xml\n          fail_ci_if_error: false\n\n  security-audit:\n    name: Security Audit\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Install Rust\n        uses: dtolnay/rust-toolchain@stable\n\n      - name: Cargo Audit\n        run: |\n          cargo install cargo-audit\n          cargo audit\n\n      - name: Dependency Check\n        run: |\n          cargo install cargo-deny\n          cargo deny check\n\n  build:\n    name: Build Docker Image\n    runs-on: ubuntu-latest\n    needs: [lint, test, security-audit]\n    if: github.event_name == 'push'\n    permissions:\n      contents: read\n      packages: write\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Set up Docker Buildx\n        uses: docker/setup-buildx-action@v3\n\n      - name: Log in to Container Registry\n        uses: docker/login-action@v3\n        with:\n          registry: ${{ env.REGISTRY }}\n          username: ${{ github.actor }}\n          password: ${{ secrets.GITHUB_TOKEN }}\n\n      - name: Extract metadata\n        id: meta\n        uses: docker/metadata-action@v5\n        with:\n          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}\n          tags: |\n            type=ref,event=branch\n            type=ref,event=pr\n            type=semver,pattern={{version}}\n            type=semver,pattern={{major}}.{{minor}}\n            type=sha,prefix={{branch}}-\n\n      - name: Build and push Docker image\n        uses: docker/build-push-action@v5\n        with:\n          context: .\n          file: ./services/financial-service/Dockerfile\n          push: true\n          tags: ${{ steps.meta.outputs.tags }}\n          labels: ${{ steps.meta.outputs.labels }}\n          cache-from: type=gha\n          cache-to: type=gha,mode=max\n\n  deploy-staging:\n    name: Deploy to Staging\n    runs-on: ubuntu-latest\n    needs: build\n    if: github.ref == 'refs/heads/develop'\n    environment:\n      name: staging\n      url: https://staging.erp.example.com\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Configure kubectl\n        uses: azure/k8s-set-context@v3\n        with:\n          method: kubeconfig\n          kubeconfig: ${{ secrets.KUBE_CONFIG_STAGING }}\n\n      - name: Deploy to Kubernetes\n        run: |\n          kubectl set image deployment/financial-service \\\n            financial-service=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:develop \\\n            -n erp\n\n          kubectl rollout status deployment/financial-service -n erp --timeout=5m\n\n      - name: Run Smoke Tests\n        run: |\n          kubectl run smoke-test --rm -i --restart=Never --image=curlimages/curl -- \\\n            curl -f http://financial-service.erp/health/ready\n\n  deploy-production:\n    name: Deploy to Production\n    runs-on: ubuntu-latest\n    needs: build\n    if: startsWith(github.ref, 'refs/tags/v')\n    environment:\n      name: production\n      url: https://erp.example.com\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Configure kubectl\n        uses: azure/k8s-set-context@v3\n        with:\n          method: kubeconfig\n          kubeconfig: ${{ secrets.KUBE_CONFIG_PRODUCTION }}\n\n      - name: Blue-Green Deployment\n        run: |\n          # 部署绿色环境\n          kubectl apply -f kubernetes/deployments/financial-service-green.yaml\n\n          # 等待绿色环境就绪\n          kubectl rollout status deployment/financial-service-green -n erp --timeout=10m\n\n          # 切换流量\n          kubectl patch service financial-service -n erp -p \\\n            '{\"spec\":{\"selector\":{\"version\":\"green\"}}}'\n\n          # 等待5分钟观察\n          sleep 300\n\n          # 检查错误率\n          ERROR_RATE=$(kubectl exec -n observability prometheus-0 -- \\\n            promtool query instant 'rate(erp_api_http_requests_total{status=~\"5..\",job=\"financial-service\"}[5m])')\n\n          if (( $(echo \"$ERROR_RATE > 0.01\" | bc -l) )); then\n            echo \"Error rate too high, rolling back...\"\n            kubectl patch service financial-service -n erp -p \\\n              '{\"spec\":{\"selector\":{\"version\":\"blue\"}}}'\n            exit 1\n          fi\n\n          # 删除蓝色环境\n          kubectl delete deployment financial-service-blue -n erp\n```\n\n### 8.2 Multi-stage Dockerfile\n\n```dockerfile\n# services/financial-service/Dockerfile\n\n# Stage 1: Build\nFROM rust:1.75-slim as builder\n\nWORKDIR /app\n\n# Install system dependencies\nRUN apt-get update && apt-get install -y \\\n    pkg-config \\\n    libssl-dev \\\n    protobuf-compiler \\\n    && rm -rf /var/lib/apt/lists/*\n\n# Copy manifests\nCOPY Cargo.toml Cargo.lock ./\nCOPY shared/ ./shared/\nCOPY services/financial-service/ ./services/financial-service/\n\n# Build dependencies (cached layer)\nRUN cargo build --release --package financial-service\n\n# Stage 2: Runtime\nFROM debian:bookworm-slim\n\n# Install runtime dependencies\nRUN apt-get update && apt-get install -y \\\n    ca-certificates \\\n    libssl3 \\\n    && rm -rf /var/lib/apt/lists/*\n\n# Create non-root user\nRUN useradd -m -u 1000 -s /bin/bash appuser\n\nWORKDIR /app\n\n# Copy binary from builder\nCOPY --from=builder /app/target/release/financial-service /app/financial-service\n\n# Copy migrations\nCOPY services/financial-service/migrations ./migrations\n\n# Change ownership\nRUN chown -R appuser:appuser /app\n\nUSER appuser\n\nEXPOSE 8080 50051\n\nHEALTHCHECK --interval=30s --timeout=3s --start-period=40s --retries=3 \\\n  CMD curl -f http://localhost:8080/health/ready || exit 1\n\nCMD [\"./financial-service\"]\n```\n\n### 8.3 Helm Chart\n\n```yaml\n# helm/financial-service/Chart.yaml\n\napiVersion: v2\nname: financial-service\ndescription: Financial Service for ERP System\ntype: application\nversion: 1.0.0\nappVersion: \"1.0.0\"\n```\n\n```yaml\n# helm/financial-service/values.yaml\n\nreplicaCount: 3\n\nimage:\n  repository: ghcr.io/erp/financial-service\n  pullPolicy: IfNotPresent\n  tag: \"v1.0.0\"\n\nservice:\n  type: ClusterIP\n  httpPort: 80\n  grpcPort: 50051\n\nautoscaling:\n  enabled: true\n  minReplicas: 3\n  maxReplicas: 10\n  targetCPUUtilizationPercentage: 70\n  targetMemoryUtilizationPercentage: 80\n\nresources:\n  requests:\n    memory: \"512Mi\"\n    cpu: \"500m\"\n  limits:\n    memory: \"2Gi\"\n    cpu: \"2000m\"\n\nenv:\n  DATABASE_URL: \"postgresql://erp_user:password@postgres:5432/erp_financial\"\n  REDIS_URL: \"redis://redis:6379\"\n  KAFKA_BROKERS: \"kafka-0:9092,kafka-1:9092,kafka-2:9092\"\n  RUST_LOG: \"info\"\n\nconfigMap:\n  data:\n    config.yaml: |\n      server:\n        host: \"0.0.0.0\"\n        port: 8080\n\nistio:\n  enabled: true\n  virtualService:\n    enabled: true\n    gateways: []\n    hosts:\n      - financial-service\n```\n\n---\n\n## 九、运维Runbook模板\n\n### 9.1 故障排查手册\n\n#### 9.1.1 服务不可用\n\n```markdown\n# Runbook: Financial Service 不可用\n\n## 症状\n- 健康检查失败\n- HTTP 503 Service Unavailable\n- Prometheus 告警：HighErrorRate\n\n## 诊断步骤\n\n### 1. 检查 Pod 状态\nkubectl get pods -n erp -l app=financial-service\n\n### 2. 查看 Pod 日志\nkubectl logs -n erp deployment/financial-service --tail=100 --follow\n\n### 3. 检查资源使用\nkubectl top pods -n erp -l app=financial-service\n\n### 4. 检查数据库连接\nkubectl exec -it -n erp deployment/financial-service -- \\\n  psql $DATABASE_URL -c \"SELECT 1\"\n\n### 5. 检查 Kafka 连接\nkubectl exec -it -n erp deployment/financial-service -- \\\n  kafka-console-consumer --bootstrap-server $KAFKA_BROKERS --topic erp.financial.transactions --max-messages 1\n\n## 常见原因与解决方案\n\n### 原因 1: 数据库连接池耗尽\n**症状**: 日志显示 \"connection pool timeout\"\n\n**解决方案**:\n# 临时扩容 Pod\nkubectl scale deployment/financial-service -n erp --replicas=5\n\n# 或增加数据库连接池大小（需要重新部署）\nkubectl set env deployment/financial-service -n erp \\\n  DATABASE_MAX_CONNECTIONS=50\n\n### 原因 2: 内存泄漏\n**症状**: Pod 内存使用持续增长，最终 OOMKilled\n\n**解决方案**:\n# 重启 Pod\nkubectl rollout restart deployment/financial-service -n erp\n\n# 收集堆转储（如果可能）\nkubectl exec -it -n erp deployment/financial-service -- \\\n  kill -USR1 $(pgrep financial-service)\n\n### 原因 3: Kafka 消费者延迟\n**症状**: Kafka 消费者滞后告警\n\n**解决方案**:\n# 检查消费者滞后\nkubectl exec -it -n erp kafka-0 -- \\\n  kafka-consumer-groups --bootstrap-server localhost:9092 \\\n  --group financial-service-consumer --describe\n\n# 临时增加消费者副本\nkubectl scale deployment/financial-service -n erp --replicas=6\n\n## 升级路径\n如果以上步骤无法解决，升级到 L2 支持：\n- Slack: #erp-oncall\n- PagerDuty: Financial Service 组\n- 联系人: 开发者B (财务模块负责人)\n```\n\n### 9.2 数据库维护手册\n\n```markdown\n# Runbook: PostgreSQL 数据库维护\n\n## 定期维护任务\n\n### 每日任务（自动化）\n\n#### 1. 备份数据库\n# 通过 CronJob 自动执行\nkubectl get cronjob -n database postgres-backup\n\n# 手动触发备份\nkubectl create job -n database --from=cronjob/postgres-backup manual-backup-$(date +%s)\n\n#### 2. 检查备份状态\nkubectl logs -n database job/postgres-backup-xxx\n\n### 每周任务\n\n#### 1. VACUUM ANALYZE\nkubectl exec -it -n database postgres-0 -- \\\n  psql -U postgres -d erp_financial -c \"VACUUM ANALYZE;\"\n\n#### 2. 检查慢查询\nkubectl exec -it -n database postgres-0 -- \\\n  psql -U postgres -d erp_financial -c \"\nSELECT \n  query, \n  calls, \n  mean_exec_time, \n  max_exec_time \nFROM pg_stat_statements \nORDER BY mean_exec_time DESC \nLIMIT 10;\"\n\n#### 3. 检查表膨胀\nkubectl exec -it -n database postgres-0 -- \\\n  psql -U postgres -d erp_financial -f /scripts/check_bloat.sql\n\n### 每月任务\n\n#### 1. 分区表维护\n# 创建下月分区\nkubectl exec -it -n database postgres-0 -- \\\n  psql -U postgres -d erp_financial -c \"\nCREATE TABLE financial.transactions_2025_02 \nPARTITION OF financial.transactions \nFOR VALUES FROM ('2025-02-01') TO ('2025-03-01');\"\n\n# 删除过期分区（6个月前）\nkubectl exec -it -n database postgres-0 -- \\\n  psql -U postgres -d erp_financial -c \"\nDROP TABLE IF EXISTS financial.transactions_2024_07;\"\n\n#### 2. 索引维护\n# 重建索引\nkubectl exec -it -n database postgres-0 -- \\\n  psql -U postgres -d erp_financial -c \"REINDEX DATABASE erp_financial;\"\n\n## 应急操作\n\n### 数据库恢复\n# 从备份恢复\nkubectl exec -it -n database postgres-0 -- \\\n  pg_restore -U postgres -d erp_financial /backups/erp_financial_2025-12-22.dump\n\n### 主从切换\n# 提升从库为主库\nkubectl exec -it -n database postgres-1 -- \\\n  pg_ctl promote -D /var/lib/postgresql/data\n\n# 更新服务指向新主库\nkubectl label pod postgres-1 -n database role=primary --overwrite\nkubectl label pod postgres-0 -n database role=replica --overwrite\n```\n\n### 9.3 性能调优手册\n\n```markdown\n# Runbook: 性能调优\n\n## API 延迟优化\n\n### 诊断步骤\n\n#### 1. 确认延迟位置\n# 检查 Jaeger 追踪\nhttps://jaeger.erp.example.com/search?service=financial-service\n\n#### 2. 分析慢查询\nkubectl exec -it -n database postgres-0 -- \\\n  psql -U postgres -d erp_financial -c \"\nSELECT * FROM pg_stat_statements \nWHERE mean_exec_time > 100 \nORDER BY mean_exec_time DESC \nLIMIT 10;\"\n\n#### 3. 检查缓存命中率\n# Redis 缓存命中率\nkubectl exec -it -n erp deployment/financial-service -- \\\n  redis-cli --stat | grep hit_rate\n\n### 优化措施\n\n#### 1. 添加数据库索引\nkubectl exec -it -n database postgres-0 -- \\\n  psql -U postgres -d erp_financial -c \"\nCREATE INDEX CONCURRENTLY idx_transactions_posting_date_company \nON financial.transactions (posting_date, company_code);\"\n\n#### 2. 增加 Redis 缓存 TTL\nkubectl set env deployment/financial-service -n erp \\\n  CACHE_TTL=3600\n\n#### 3. 启用查询缓存\nkubectl set env deployment/financial-service -n erp \\\n  ENABLE_QUERY_CACHE=true\n\n## 吞吐量优化\n\n### 水平扩容\nkubectl scale deployment/financial-service -n erp --replicas=10\n\n### 垂直扩容\nkubectl set resources deployment/financial-service -n erp \\\n  --requests=cpu=1000m,memory=1Gi \\\n  --limits=cpu=4000m,memory=8Gi\n\n### 数据库连接池调优\nkubectl set env deployment/financial-service -n erp \\\n  DATABASE_MAX_CONNECTIONS=50 \\\n  DATABASE_MIN_CONNECTIONS=10\n```\n\n---\n\n## 十、代码规范和最佳实践\n\n### 10.1 Rust 代码规范\n\n#### 10.1.1 命名规范\n\n```rust\n// 类型名称：大驼峰（PascalCase）\npub struct Transaction {}\npub enum TransactionStatus {}\npub trait Repository {}\n\n// 函数和变量：小写下划线（snake_case）\npub fn create_transaction() {}\nlet transaction_id = Uuid::new_v4();\n\n// 常量：大写下划线（SCREAMING_SNAKE_CASE）\nconst MAX_RETRY_ATTEMPTS: u32 = 3;\nconst DEFAULT_PAGE_SIZE: usize = 20;\n\n// 模块：小写下划线（snake_case）\nmod transaction_repository;\nmod value_objects;\n\n// Trait 实现：避免孤儿规则\n// ✅ 好的做法：在本地类型上实现外部 Trait\nimpl Display for Transaction {\n    fn fmt(&self, f: &mut Formatter) -> fmt::Result {\n        write!(f, \"Transaction({})\", self.transaction_number)\n    }\n}\n\n// ❌ 坏的做法：在外部类型上实现外部 Trait（孤儿规则）\n// impl Display for Uuid {}  // 编译错误!\n```\n\n#### 10.1.2 错误处理\n\n```rust\n// 使用 thiserror 定义错误类型\nuse thiserror::Error;\n\n#[derive(Debug, Error)]\npub enum DomainError {\n    #[error(\"Transaction is not balanced: debit={debit}, credit={credit}\")]\n    TransactionUnbalanced {\n        debit: Decimal,\n        credit: Decimal,\n    },\n\n    #[error(\"Account not found: {account_number}\")]\n    AccountNotFound {\n        account_number: String,\n    },\n\n    #[error(\"Invalid fiscal period: {period}\")]\n    InvalidFiscalPeriod {\n        period: i32,\n    },\n\n    #[error(\"Database error: {0}\")]\n    DatabaseError(#[from] sqlx::Error),\n\n    #[error(\"Unexpected error: {0}\")]\n    Unexpected(String),\n}\n\n// 使用 Result 传播错误\npub fn post_transaction(transaction: &mut Transaction) -> Result<(), DomainError> {\n    // 验证业务规则\n    if !transaction.is_balanced() {\n        return Err(DomainError::TransactionUnbalanced {\n            debit: transaction.total_debit(),\n            credit: transaction.total_credit(),\n        });\n    }\n\n    // 更新状态\n    transaction.status = TransactionStatus::Posted;\n    transaction.posted_at = Some(Utc::now());\n\n    Ok(())\n}\n\n// 使用 ? 操作符简化错误传播\npub async fn save_transaction(\n    pool: &PgPool,\n    transaction: &Transaction,\n) -> Result<(), DomainError> {\n    sqlx::query!(\n        \"INSERT INTO transactions (...) VALUES (...)\",\n        // ...\n    )\n    .execute(pool)\n    .await?;  // 自动转换为 DomainError::DatabaseError\n\n    Ok(())\n}\n```\n\n#### 10.1.3 文档注释\n\n```rust\n/// 财务凭证聚合根\n///\n/// 代表一个完整的财务交易，包含多个分录。\n/// 凭证必须满足借贷平衡原则。\n///\n/// # 示例\n///\n/// ```rust\n/// use financial_service::domain::Transaction;\n///\n/// let mut transaction = Transaction::create(command)?;\n/// transaction.post()?;\n/// ```\npub struct Transaction {\n    /// 凭证唯一标识\n    pub transaction_id: Uuid,\n\n    /// 凭证编号（业务主键）\n    ///\n    /// 格式: FI-{年度}-{序号}\n    /// 示例: FI-2025-0001234\n    pub transaction_number: String,\n\n    // ...\n}\n\nimpl Transaction {\n    /// 创建新的财务凭证\n    ///\n    /// # 参数\n    ///\n    /// * `command` - 创建凭证命令\n    ///\n    /// # 返回\n    ///\n    /// * `Ok(Transaction)` - 创建成功\n    /// * `Err(DomainError)` - 创建失败（借贷不平衡、无效数据等）\n    ///\n    /// # 示例\n    ///\n    /// ```rust\n    /// let command = CreateTransactionCommand {\n    ///     posting_date: NaiveDate::from_ymd(2025, 12, 22),\n    ///     // ...\n    /// };\n    /// let transaction = Transaction::create(command)?;\n    /// ```\n    pub fn create(command: CreateTransactionCommand) -> Result<Self, DomainError> {\n        // 实现...\n    }\n}\n```\n\n### 10.2 DDD 最佳实践\n\n#### 10.2.1 聚合根设计\n\n```rust\n// 聚合根：封装业务逻辑，维护不变量\npub struct Transaction {\n    // 私有字段，只能通过方法访问\n    transaction_id: Uuid,\n    transaction_number: String,\n    status: TransactionStatus,\n    journal_entries: Vec<JournalEntry>,\n    // ...\n\n    // 领域事件\n    uncommitted_events: Vec<DomainEvent>,\n}\n\nimpl Transaction {\n    // 工厂方法：创建聚合根\n    pub fn create(command: CreateTransactionCommand) -> Result<Self, DomainError> {\n        // 验证业务规则\n        Self::validate_balance(&command.journal_entries)?;\n\n        let transaction = Self {\n            transaction_id: Uuid::new_v4(),\n            transaction_number: Self::generate_transaction_number(),\n            status: TransactionStatus::Draft,\n            journal_entries: command.journal_entries,\n            uncommitted_events: vec![],\n        };\n\n        // 发布领域事件\n        transaction.add_event(TransactionCreated {\n            transaction_id: transaction.transaction_id,\n            transaction_number: transaction.transaction_number.clone(),\n        });\n\n        Ok(transaction)\n    }\n\n    // 命令方法：改变状态\n    pub fn post(&mut self) -> Result<(), DomainError> {\n        // 验证前置条件\n        if self.status != TransactionStatus::Draft {\n            return Err(DomainError::InvalidStatus);\n        }\n\n        // 再次验证业务规则\n        Self::validate_balance(&self.journal_entries)?;\n\n        // 改变状态\n        self.status = TransactionStatus::Posted;\n        self.posted_at = Some(Utc::now());\n\n        // 发布领域事件\n        self.add_event(TransactionPosted {\n            transaction_id: self.transaction_id,\n        });\n\n        Ok(())\n    }\n\n    // 查询方法：不改变状态\n    pub fn is_balanced(&self) -> bool {\n        let total_debit: Decimal = self.journal_entries.iter()\n            .map(|e| e.debit_amount)\n            .sum();\n        let total_credit: Decimal = self.journal_entries.iter()\n            .map(|e| e.credit_amount)\n            .sum();\n\n        (total_debit - total_credit).abs() < Decimal::new(1, 2)  // 0.01\n    }\n\n    // 私有方法：封装业务规则\n    fn validate_balance(entries: &[JournalEntry]) -> Result<(), DomainError> {\n        // 实现...\n    }\n\n    fn generate_transaction_number() -> String {\n        // 实现...\n    }\n\n    fn add_event(&mut self, event: impl Into<DomainEvent>) {\n        self.uncommitted_events.push(event.into());\n    }\n\n    // 获取未提交的事件（用于事件发布）\n    pub fn take_uncommitted_events(&mut self) -> Vec<DomainEvent> {\n        std::mem::take(&mut self.uncommitted_events)\n    }\n}\n```\n\n#### 10.2.2 值对象设计\n\n```rust\n// 值对象：不可变、无标识、可替换\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct Money {\n    amount: Decimal,\n    currency: String,\n}\n\nimpl Money {\n    // 构造函数：验证不变量\n    pub fn new(amount: Decimal, currency: impl Into<String>) -> Result<Self, DomainError> {\n        let currency = currency.into();\n\n        // 验证货币代码\n        if !Self::is_valid_currency(&currency) {\n            return Err(DomainError::InvalidCurrency { currency });\n        }\n\n        Ok(Self { amount, currency })\n    }\n\n    // 值对象的操作返回新实例（不可变）\n    pub fn add(&self, other: &Money) -> Result<Money, DomainError> {\n        if self.currency != other.currency {\n            return Err(DomainError::CurrencyMismatch {\n                left: self.currency.clone(),\n                right: other.currency.clone(),\n            });\n        }\n\n        Ok(Money {\n            amount: self.amount + other.amount,\n            currency: self.currency.clone(),\n        })\n    }\n\n    pub fn multiply(&self, factor: Decimal) -> Money {\n        Money {\n            amount: self.amount * factor,\n            currency: self.currency.clone(),\n        }\n    }\n\n    // 访问器\n    pub fn amount(&self) -> Decimal {\n        self.amount\n    }\n\n    pub fn currency(&self) -> &str {\n        &self.currency\n    }\n\n    fn is_valid_currency(currency: &str) -> bool {\n        matches!(currency, \"USD\" | \"EUR\" | \"CNY\" | \"JPY\")\n    }\n}\n\n// 实现 Display\nimpl std::fmt::Display for Money {\n    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n        write!(f, \"{} {}\", self.amount, self.currency)\n    }\n}\n```\n\n### 10.3 性能优化技巧\n\n```rust\n// 1. 使用 Cow 避免不必要的克隆\nuse std::borrow::Cow;\n\npub fn process_transaction(data: Cow<str>) -> Result<(), Error> {\n    // 如果 data 不需要修改，不会发生克隆\n    println!(\"Processing: {}\", data);\n    Ok(())\n}\n\n// 调用方\nprocess_transaction(Cow::Borrowed(\"existing_data\"))?;  // 无克隆\nprocess_transaction(Cow::Owned(new_data))?;            // 已拥有\n\n// 2. 使用 Arc 共享不可变数据\nuse std::sync::Arc;\n\n#[derive(Clone)]\npub struct AppState {\n    pub config: Arc<Config>,  // 多个副本共享同一份配置\n    pub pool: PgPool,\n}\n\n// 3. 避免不必要的分配\n// ❌ 差：每次调用都分配\npub fn get_status(&self) -> String {\n    match self.status {\n        TransactionStatus::Draft => \"Draft\".to_string(),\n        TransactionStatus::Posted => \"Posted\".to_string(),\n    }\n}\n\n// ✅ 好：返回引用\npub fn get_status(&self) -> &'static str {\n    match self.status {\n        TransactionStatus::Draft => \"Draft\",\n        TransactionStatus::Posted => \"Posted\",\n    }\n}\n\n// 4. 使用 SmallVec 优化小集合\nuse smallvec::SmallVec;\n\n// 大多数交易少于10个分录，避免堆分配\npub struct Transaction {\n    pub journal_entries: SmallVec<[JournalEntry; 10]>,\n}\n\n// 5. 批量操作\n// ❌ 差：逐个插入\nfor entry in entries {\n    sqlx::query!(\"INSERT INTO ...\").execute(&pool).await?;\n}\n\n// ✅ 好：批量插入\nlet mut query_builder = QueryBuilder::new(\"INSERT INTO journal_entries (...) \");\nquery_builder.push_values(entries, |mut b, entry| {\n    b.push_bind(entry.account_number)\n     .push_bind(entry.debit_amount)\n     .push_bind(entry.credit_amount);\n});\nquery_builder.build().execute(&pool).await?;\n```\n\n---\n\n**文档完成！**\n\n本实施技术指南涵盖了：\n1. API设计规范与示例\n2. 数据库设计模式与迁移\n3. 分布式事务处理（Saga模式）\n4. 安全加固详细方案\n5. 监控告警详细配置\n6. 测试策略详细方案\n7. Kubernetes部署配置\n8. CI/CD Pipeline详细配置\n9. 运维Runbook模板\n10. 代码规范和最佳实践\n\n配合《Rust-Abc-Enhanced.md》使用，提供12个月开发计划的完整技术实施细节。\n\n", "md/Rust-Microservices.md": "# Rust DDD 微服务架构最佳实践\n\n**文档版本**: v1.0\n**创建日期**: 2025-12-21\n**适用场景**: 企业级ERP系统、SaaS平台、高并发业务系统\n**技术栈**: Rust + DDD + Event Sourcing + CQRS + Microservices\n\n---\n\n## 目录\n\n1. [系统架构概览](#系统架构概览)\n2. [DDD领域驱动设计](#ddd领域驱动设计)\n3. [微服务架构设计](#微服务架构设计)\n4. [Rust项目结构](#rust项目结构)\n5. [核心领域实现](#核心领域实现)\n6. [基础设施层](#基础设施层)\n7. [API网关与服务发现](#api网关与服务发现)\n8. [GitHub CI/CD配置](#github-cicd配置)\n9. [容器化与Kubernetes](#容器化与kubernetes)\n10. [可观测性](#可观测性)\n11. [安全最佳实践](#安全最佳实践)\n12. [性能优化](#性能优化)\n13. [测试策略](#测试策略)\n\n---\n\n## 系统架构概览\n\n### 技术栈选型\n\n```\n┌─────────────────────────────────────────────────────────┐\n│                   技术栈矩阵                              │\n├─────────────────────────────────────────────────────────┤\n│ 编程语言        │ Rust 1.75+ (2021 Edition)            │\n│ Web框架         │ Axum 0.7 + Tower                     │\n│ 异步运行时      │ Tokio 1.35                           │\n│ 数据库          │ PostgreSQL 16 + Redis 7              │\n│ ORM/查询构建器  │ SQLx 0.7 (编译时SQL验证)             │\n│ 消息队列        │ Apache Kafka 3.6                     │\n│ 服务网格        │ Istio 1.20                           │\n│ API网关         │ Kong / Traefik                       │\n│ 服务发现        │ Consul / Kubernetes DNS              │\n│ 配置中心        │ Consul KV / Kubernetes ConfigMap     │\n│ 容器编排        │ Kubernetes 1.29                      │\n│ 监控            │ Prometheus + Grafana                 │\n│ 日志            │ Loki + Vector                        │\n│ 链路追踪        │ Jaeger + OpenTelemetry               │\n│ CI/CD           │ GitHub Actions                       │\n│ 镜像仓库        │ GitHub Container Registry            │\n└─────────────────────────────────────────────────────────┘\n```\n\n### 系统架构图\n\n```\n┌────────────────────────────────────────────────────────────────┐\n│                        Client Layer                            │\n│  Web App (React)  │  Mobile App  │  Third-party Integration   │\n└────────────────┬───────────────────────────────────────────────┘\n                 │\n                 ↓\n┌────────────────────────────────────────────────────────────────┐\n│                      API Gateway (Kong)                        │\n│  - Authentication (JWT)                                        │\n│  - Rate Limiting                                               │\n│  - Request Routing                                             │\n└────────────────┬───────────────────────────────────────────────┘\n                 │\n    ┌────────────┼────────────┬────────────┬────────────┐\n    ↓            ↓            ↓            ↓            ↓\n┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐\n│ Order   │ │ Inventory│ │ Payment │ │ Customer│ │ Shipping│\n│ Service │ │ Service  │ │ Service │ │ Service │ │ Service │\n│ (Rust)  │ │ (Rust)   │ │ (Rust)  │ │ (Rust)  │ │ (Rust)  │\n└────┬────┘ └────┬─────┘ └────┬────┘ └────┬────┘ └────┬────┘\n     │           │            │           │           │\n     └───────────┴────────────┴───────────┴───────────┘\n                              │\n                 ┌────────────┼────────────┐\n                 ↓            ↓            ↓\n         ┌──────────┐  ┌──────────┐  ┌──────────┐\n         │ PostgreSQL│  │  Kafka   │  │  Redis   │\n         │ (Primary) │  │ (Events) │  │ (Cache)  │\n         └──────────┘  └──────────┘  └──────────┘\n```\n\n### 架构原则\n\n1. **高内聚低耦合**：每个微服务独立部署、独立数据库\n2. **事件驱动**：通过Kafka实现服务间异步通信\n3. **CQRS模式**：读写分离，提升查询性能\n4. **Event Sourcing**：记录所有状态变更事件\n5. **最终一致性**：通过Saga模式处理分布式事务\n6. **容错设计**：Circuit Breaker、Retry、Timeout\n7. **零信任安全**：所有服务间通信mTLS加密\n\n---\n\n## DDD领域驱动设计\n\n### 限界上下文划分\n\n```\nERP系统限界上下文（Bounded Contexts）：\n\n1. 订单上下文 (Order Context)\n   - 核心实体：Order, OrderLine, OrderStatus\n   - 值对象：Money, Quantity, ShippingAddress\n   - 聚合根：Order\n   - 领域服务：OrderPriceCalculator, OrderValidator\n   - 领域事件：OrderCreated, OrderConfirmed, OrderCancelled\n\n2. 库存上下文 (Inventory Context)\n   - 核心实体：Product, StockLevel, Warehouse\n   - 值对象：SKU, Location\n   - 聚合根：Product\n   - 领域服务：StockAllocator, ReorderService\n   - 领域事件：StockReserved, StockReleased, LowStockWarning\n\n3. 支付上下文 (Payment Context)\n   - 核心实体：Payment, Transaction, Refund\n   - 值对象：PaymentMethod, Amount\n   - 聚合根：Payment\n   - 领域服务：PaymentProcessor, FraudDetection\n   - 领域事件：PaymentAuthorized, PaymentCaptured, PaymentFailed\n\n4. 客户上下文 (Customer Context)\n   - 核心实体：Customer, Account, ContactInfo\n   - 值对象：Email, PhoneNumber, Address\n   - 聚合根：Customer\n   - 领域服务：CustomerScoring, LoyaltyCalculator\n   - 领域事件：CustomerRegistered, CustomerUpdated\n\n5. 物流上下文 (Shipping Context)\n   - 核心实体：Shipment, Carrier, TrackingInfo\n   - 值对象：ShippingMethod, DeliveryWindow\n   - 聚合根：Shipment\n   - 领域服务：RouteOptimizer, ShippingCostCalculator\n   - 领域事件：ShipmentCreated, ShipmentDispatched, ShipmentDelivered\n```\n\n### DDD分层架构\n\n```\n┌─────────────────────────────────────────────────────────┐\n│                   用户接口层 (Presentation)              │\n│  - REST API Controllers (Axum Handlers)                 │\n│  - GraphQL Resolvers                                    │\n│  - gRPC Service Implementations                         │\n│  - DTO (Data Transfer Objects)                          │\n└─────────────────┬───────────────────────────────────────┘\n                  │\n                  ↓\n┌─────────────────────────────────────────────────────────┐\n│                   应用层 (Application)                   │\n│  - Use Cases / Application Services                     │\n│  - Command Handlers                                     │\n│  - Query Handlers (CQRS)                                │\n│  - Event Handlers                                       │\n│  - Application DTOs                                     │\n└─────────────────┬───────────────────────────────────────┘\n                  │\n                  ↓\n┌─────────────────────────────────────────────────────────┐\n│                   领域层 (Domain)                        │\n│  - Entities (聚合根、实体)                               │\n│  - Value Objects (值对象)                                │\n│  - Domain Services                                      │\n│  - Domain Events                                        │\n│  - Repositories (接口定义)                               │\n│  - Specifications (规约模式)                             │\n└─────────────────┬───────────────────────────────────────┘\n                  │\n                  ↓\n┌─────────────────────────────────────────────────────────┐\n│                   基础设施层 (Infrastructure)             │\n│  - Repository Implementations (PostgreSQL)              │\n│  - Event Store (Kafka Producer)                         │\n│  - Cache (Redis)                                        │\n│  - External Service Clients                             │\n│  - Persistence Models                                   │\n└─────────────────────────────────────────────────────────┘\n```\n\n---\n\n## 微服务架构设计\n\n### 服务拆分策略\n\n#### 订单服务 (Order Service)\n\n**职责**：\n- 订单创建、修改、取消\n- 订单状态流转\n- 订单查询（支持复杂过滤）\n\n**技术细节**：\n- 端口：8001\n- 数据库：order_service_db (PostgreSQL)\n- 事件发布：order-events topic (Kafka)\n- 事件订阅：payment-events, inventory-events\n\n**API端点**：\n```\nPOST   /api/v1/orders              - 创建订单\nGET    /api/v1/orders/{id}         - 获取订单详情\nPUT    /api/v1/orders/{id}         - 更新订单\nDELETE /api/v1/orders/{id}         - 取消订单\nGET    /api/v1/orders              - 查询订单列表\nPOST   /api/v1/orders/{id}/confirm - 确认订单\n```\n\n#### 库存服务 (Inventory Service)\n\n**职责**：\n- 库存查询和预留\n- 库存扣减和释放\n- 安全库存告警\n- 库存盘点\n\n**技术细节**：\n- 端口：8002\n- 数据库：inventory_service_db (PostgreSQL)\n- 缓存：Redis (库存快照)\n- 事件发布：inventory-events topic\n\n**核心领域逻辑**：\n```rust\n// 库存预留逻辑（乐观锁）\npub async fn reserve_stock(\n    &self,\n    sku: &SKU,\n    quantity: Quantity,\n    order_id: &OrderId,\n) -> Result<StockReservation, InventoryError> {\n    // 1. 检查可用库存\n    let available = self.get_available_stock(sku).await?;\n\n    if available < quantity {\n        return Err(InventoryError::InsufficientStock {\n            requested: quantity,\n            available,\n        });\n    }\n\n    // 2. 预留库存（使用数据库版本号实现乐观锁）\n    let reservation = self.repository\n        .reserve_with_version_check(sku, quantity, order_id)\n        .await?;\n\n    // 3. 发布库存预留事件\n    self.event_bus\n        .publish(InventoryEvent::StockReserved {\n            sku: sku.clone(),\n            quantity,\n            order_id: order_id.clone(),\n            reservation_id: reservation.id(),\n        })\n        .await?;\n\n    Ok(reservation)\n}\n```\n\n#### 支付服务 (Payment Service)\n\n**职责**：\n- 支付授权和捕获\n- 退款处理\n- 支付方式管理\n- 对账\n\n**技术细节**：\n- 端口：8003\n- 数据库：payment_service_db (PostgreSQL)\n- 外部集成：Stripe API, PayPal API\n- 幂等性：通过幂等性键保证\n\n**支付流程（Saga模式）**：\n```\n订单创建 → 库存预留 → 支付授权 → 支付捕获 → 发货\n    ↓           ↓           ↓           ↓\n  失败      释放库存    取消授权    退款处理\n```\n\n### 服务间通信\n\n#### 同步通信 (gRPC)\n\n适用场景：实时性要求高、需要立即响应\n\n```protobuf\n// inventory_service.proto\nsyntax = \"proto3\";\n\npackage inventory.v1;\n\nservice InventoryService {\n  rpc CheckStock(CheckStockRequest) returns (CheckStockResponse);\n  rpc ReserveStock(ReserveStockRequest) returns (ReserveStockResponse);\n  rpc ReleaseStock(ReleaseStockRequest) returns (ReleaseStockResponse);\n}\n\nmessage CheckStockRequest {\n  string sku = 1;\n  int32 quantity = 2;\n}\n\nmessage CheckStockResponse {\n  bool available = 1;\n  int32 current_stock = 2;\n  int32 reserved_stock = 3;\n}\n\nmessage ReserveStockRequest {\n  string sku = 1;\n  int32 quantity = 2;\n  string order_id = 3;\n  string idempotency_key = 4;\n}\n\nmessage ReserveStockResponse {\n  string reservation_id = 1;\n  google.protobuf.Timestamp expires_at = 2;\n}\n```\n\n#### 异步通信 (Kafka Events)\n\n适用场景：解耦服务、最终一致性\n\n```rust\n// 领域事件定义\nuse serde::{Deserialize, Serialize};\nuse chrono::{DateTime, Utc};\nuse uuid::Uuid;\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(tag = \"type\")]\npub enum OrderEvent {\n    OrderCreated {\n        event_id: Uuid,\n        timestamp: DateTime<Utc>,\n        order_id: Uuid,\n        customer_id: Uuid,\n        items: Vec<OrderItem>,\n        total_amount: Decimal,\n    },\n    OrderConfirmed {\n        event_id: Uuid,\n        timestamp: DateTime<Utc>,\n        order_id: Uuid,\n    },\n    OrderCancelled {\n        event_id: Uuid,\n        timestamp: DateTime<Utc>,\n        order_id: Uuid,\n        reason: String,\n    },\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct OrderItem {\n    pub sku: String,\n    pub quantity: i32,\n    pub unit_price: Decimal,\n}\n\n// Kafka Producer实现\nuse rdkafka::producer::{FutureProducer, FutureRecord};\nuse rdkafka::ClientConfig;\n\npub struct EventPublisher {\n    producer: FutureProducer,\n    topic: String,\n}\n\nimpl EventPublisher {\n    pub fn new(brokers: &str, topic: String) -> Result<Self, KafkaError> {\n        let producer: FutureProducer = ClientConfig::new()\n            .set(\"bootstrap.servers\", brokers)\n            .set(\"message.timeout.ms\", \"5000\")\n            .set(\"compression.type\", \"snappy\")\n            .set(\"acks\", \"all\")  // 确保消息持久化\n            .set(\"enable.idempotence\", \"true\")  // 幂等生产者\n            .create()?;\n\n        Ok(Self { producer, topic })\n    }\n\n    pub async fn publish(&self, event: &OrderEvent) -> Result<(), PublishError> {\n        let event_id = event.event_id().to_string();\n        let payload = serde_json::to_string(event)?;\n\n        let record = FutureRecord::to(&self.topic)\n            .key(&event_id)  // 使用event_id作为key保证顺序\n            .payload(&payload);\n\n        self.producer\n            .send(record, Duration::from_secs(5))\n            .await\n            .map_err(|(err, _)| PublishError::Kafka(err))?;\n\n        tracing::info!(\n            event_id = %event_id,\n            event_type = event.event_type(),\n            \"Event published successfully\"\n        );\n\n        Ok(())\n    }\n}\n```\n\n### 分布式事务处理 (Saga Pattern)\n\n使用Choreography-based Saga（编排式Saga）：\n\n```rust\n// Saga协调器\npub struct OrderSaga {\n    order_service: Arc<OrderService>,\n    inventory_service: Arc<InventoryServiceClient>,\n    payment_service: Arc<PaymentServiceClient>,\n    event_bus: Arc<EventBus>,\n}\n\nimpl OrderSaga {\n    pub async fn create_order(\n        &self,\n        command: CreateOrderCommand,\n    ) -> Result<OrderId, SagaError> {\n        let saga_id = Uuid::new_v4();\n\n        // Step 1: 创建订单（状态：Pending）\n        let order_id = self.order_service\n            .create_order(command.clone())\n            .await?;\n\n        // Step 2: 预留库存\n        let reservation_result = self.inventory_service\n            .reserve_stock(ReserveStockRequest {\n                order_id: order_id.clone(),\n                items: command.items.clone(),\n            })\n            .await;\n\n        match reservation_result {\n            Ok(reservation) => {\n                // Step 3: 授权支付\n                let payment_result = self.payment_service\n                    .authorize_payment(AuthorizePaymentRequest {\n                        order_id: order_id.clone(),\n                        amount: command.total_amount,\n                        payment_method: command.payment_method,\n                    })\n                    .await;\n\n                match payment_result {\n                    Ok(authorization) => {\n                        // 成功：确认订单\n                        self.order_service\n                            .confirm_order(&order_id)\n                            .await?;\n\n                        Ok(order_id)\n                    }\n                    Err(payment_error) => {\n                        // 补偿：释放库存\n                        self.inventory_service\n                            .release_stock(ReleaseStockRequest {\n                                reservation_id: reservation.id,\n                            })\n                            .await?;\n\n                        // 取消订单\n                        self.order_service\n                            .cancel_order(&order_id, \"Payment failed\")\n                            .await?;\n\n                        Err(SagaError::PaymentFailed(payment_error))\n                    }\n                }\n            }\n            Err(inventory_error) => {\n                // 取消订单\n                self.order_service\n                    .cancel_order(&order_id, \"Insufficient stock\")\n                    .await?;\n\n                Err(SagaError::InventoryUnavailable(inventory_error))\n            }\n        }\n    }\n}\n```\n\n---\n\n## Rust项目结构\n\n### Monorepo结构（使用Cargo Workspace）\n\n```\nerp-system/\n├── Cargo.toml                    # Workspace配置\n├── .github/\n│   └── workflows/\n│       ├── ci.yml                # CI/CD工作流\n│       ├── deploy-staging.yml\n│       └── deploy-production.yml\n├── docker/\n│   ├── Dockerfile.service        # 微服务通用Dockerfile\n│   └── docker-compose.yml        # 本地开发环境\n├── k8s/\n│   ├── base/                     # Kustomize基础配置\n│   ├── overlays/\n│   │   ├── staging/\n│   │   └── production/\n│   └── helm/                     # Helm Charts\n├── proto/                        # gRPC Proto定义\n│   ├── order/\n│   │   └── v1/\n│   │       └── order_service.proto\n│   ├── inventory/\n│   └── payment/\n├── shared/                       # 共享库\n│   ├── domain-primitives/        # 领域原语\n│   │   ├── Cargo.toml\n│   │   └── src/\n│   │       ├── lib.rs\n│   │       ├── money.rs\n│   │       ├── email.rs\n│   │       └── uuid_wrapper.rs\n│   ├── event-sourcing/           # Event Sourcing框架\n│   ├── cqrs/                     # CQRS框架\n│   └── observability/            # 可观测性工具\n├── services/\n│   ├── order-service/\n│   │   ├── Cargo.toml\n│   │   ├── src/\n│   │   │   ├── main.rs\n│   │   │   ├── api/              # API层\n│   │   │   │   ├── mod.rs\n│   │   │   │   ├── rest/         # REST API\n│   │   │   │   │   ├── handlers.rs\n│   │   │   │   │   ├── routes.rs\n│   │   │   │   │   └── dto.rs\n│   │   │   │   └── grpc/         # gRPC\n│   │   │   │       └── service.rs\n│   │   │   ├── application/      # 应用层\n│   │   │   │   ├── mod.rs\n│   │   │   │   ├── commands/\n│   │   │   │   │   ├── create_order.rs\n│   │   │   │   │   └── cancel_order.rs\n│   │   │   │   ├── queries/\n│   │   │   │   │   ├── get_order.rs\n│   │   │   │   │   └── list_orders.rs\n│   │   │   │   └── services/\n│   │   │   │       └── order_application_service.rs\n│   │   │   ├── domain/           # 领域层\n│   │   │   │   ├── mod.rs\n│   │   │   │   ├── aggregates/\n│   │   │   │   │   ├── order.rs\n│   │   │   │   │   └── order_line.rs\n│   │   │   │   ├── value_objects/\n│   │   │   │   │   ├── money.rs\n│   │   │   │   │   ├── quantity.rs\n│   │   │   │   │   └── shipping_address.rs\n│   │   │   │   ├── events/\n│   │   │   │   │   └── order_events.rs\n│   │   │   │   ├── services/\n│   │   │   │   │   ├── order_price_calculator.rs\n│   │   │   │   │   └── order_validator.rs\n│   │   │   │   └── repositories/\n│   │   │   │       └── order_repository.rs\n│   │   │   └── infrastructure/   # 基础设施层\n│   │   │       ├── mod.rs\n│   │   │       ├── persistence/\n│   │   │       │   ├── postgres/\n│   │   │       │   │   ├── order_repository_impl.rs\n│   │   │       │   │   └── models.rs\n│   │   │       │   └── redis/\n│   │   │       │       └── order_cache.rs\n│   │   │       ├── messaging/\n│   │   │       │   ├── kafka_producer.rs\n│   │   │       │   └── kafka_consumer.rs\n│   │   │       └── config.rs\n│   │   ├── migrations/           # SQL迁移脚本\n│   │   │   ├── 20250101000000_create_orders_table.sql\n│   │   │   └── 20250102000000_add_order_status_index.sql\n│   │   └── tests/\n│   │       ├── integration/\n│   │       └── unit/\n│   ├── inventory-service/\n│   │   └── ...（类似结构）\n│   ├── payment-service/\n│   ├── customer-service/\n│   └── shipping-service/\n└── tools/\n    ├── migration-tool/\n    └── load-testing/\n```\n\n### Cargo.toml (Workspace配置)\n\n```toml\n[workspace]\nmembers = [\n    \"shared/domain-primitives\",\n    \"shared/event-sourcing\",\n    \"shared/cqrs\",\n    \"shared/observability\",\n    \"services/order-service\",\n    \"services/inventory-service\",\n    \"services/payment-service\",\n    \"services/customer-service\",\n    \"services/shipping-service\",\n]\n\nresolver = \"2\"\n\n[workspace.package]\nversion = \"0.1.0\"\nedition = \"2021\"\nauthors = [\"Your Team <team@example.com>\"]\nlicense = \"MIT\"\n\n[workspace.dependencies]\n# Async Runtime\ntokio = { version = \"1.35\", features = [\"full\"] }\ntokio-util = \"0.7\"\n\n# Web Framework\naxum = { version = \"0.7\", features = [\"macros\"] }\ntower = { version = \"0.4\", features = [\"full\"] }\ntower-http = { version = \"0.5\", features = [\"full\"] }\n\n# Database\nsqlx = { version = \"0.7\", features = [\"runtime-tokio-rustls\", \"postgres\", \"uuid\", \"chrono\", \"json\"] }\nredis = { version = \"0.24\", features = [\"tokio-comp\", \"connection-manager\"] }\n\n# Serialization\nserde = { version = \"1.0\", features = [\"derive\"] }\nserde_json = \"1.0\"\n\n# UUID\nuuid = { version = \"1.6\", features = [\"v4\", \"serde\"] }\n\n# Date/Time\nchrono = { version = \"0.4\", features = [\"serde\"] }\n\n# Error Handling\nanyhow = \"1.0\"\nthiserror = \"1.0\"\n\n# Logging & Tracing\ntracing = \"0.1\"\ntracing-subscriber = { version = \"0.3\", features = [\"env-filter\", \"json\"] }\ntracing-opentelemetry = \"0.22\"\n\n# OpenTelemetry\nopentelemetry = \"0.21\"\nopentelemetry-jaeger = \"0.20\"\n\n# Kafka\nrdkafka = { version = \"0.35\", features = [\"cmake-build\"] }\n\n# gRPC\ntonic = \"0.10\"\nprost = \"0.12\"\n\n# Config\nconfig = \"0.13\"\n\n# Validation\nvalidator = { version = \"0.16\", features = [\"derive\"] }\n\n# Decimal\nrust_decimal = { version = \"1.33\", features = [\"serde-float\"] }\n\n# Testing\nmockall = \"0.12\"\n```\n\n---\n\n## 核心领域实现\n\n### 订单聚合根 (Order Aggregate)\n\n```rust\n// services/order-service/src/domain/aggregates/order.rs\n\nuse chrono::{DateTime, Utc};\nuse rust_decimal::Decimal;\nuse serde::{Deserialize, Serialize};\nuse uuid::Uuid;\nuse validator::Validate;\n\nuse crate::domain::events::OrderEvent;\nuse crate::domain::value_objects::{Money, OrderStatus, ShippingAddress};\nuse shared::domain_primitives::{AggregateRoot, DomainError};\n\n/// 订单聚合根\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Order {\n    // 标识\n    id: OrderId,\n    customer_id: CustomerId,\n\n    // 订单信息\n    order_number: String,\n    status: OrderStatus,\n    items: Vec<OrderLine>,\n\n    // 金额\n    subtotal: Money,\n    tax: Money,\n    shipping_cost: Money,\n    total: Money,\n\n    // 地址\n    shipping_address: ShippingAddress,\n    billing_address: ShippingAddress,\n\n    // 审计字段\n    created_at: DateTime<Utc>,\n    updated_at: DateTime<Utc>,\n    version: i64,  // 用于乐观锁\n\n    // 未提交的领域事件\n    #[serde(skip)]\n    uncommitted_events: Vec<OrderEvent>,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct OrderId(Uuid);\n\nimpl OrderId {\n    pub fn new() -> Self {\n        Self(Uuid::new_v4())\n    }\n\n    pub fn from_uuid(uuid: Uuid) -> Self {\n        Self(uuid)\n    }\n\n    pub fn value(&self) -> Uuid {\n        self.0\n    }\n}\n\nimpl Order {\n    /// 创建新订单（工厂方法）\n    pub fn create(\n        customer_id: CustomerId,\n        items: Vec<OrderLine>,\n        shipping_address: ShippingAddress,\n        billing_address: ShippingAddress,\n    ) -> Result<Self, DomainError> {\n        // 验证订单行至少有一项\n        if items.is_empty() {\n            return Err(DomainError::ValidationError(\n                \"Order must have at least one item\".to_string()\n            ));\n        }\n\n        // 计算金额\n        let subtotal = items.iter()\n            .map(|line| line.total())\n            .sum::<Money>();\n\n        let tax = subtotal * Decimal::from_str(\"0.1\")?;  // 10% 税率\n        let shipping_cost = Money::from_usd(Decimal::from(10));  // 固定运费\n        let total = subtotal + tax + shipping_cost;\n\n        let now = Utc::now();\n        let order_id = OrderId::new();\n\n        let mut order = Self {\n            id: order_id,\n            customer_id,\n            order_number: Self::generate_order_number(),\n            status: OrderStatus::Pending,\n            items,\n            subtotal,\n            tax,\n            shipping_cost,\n            total,\n            shipping_address,\n            billing_address,\n            created_at: now,\n            updated_at: now,\n            version: 1,\n            uncommitted_events: Vec::new(),\n        };\n\n        // 添加领域事件\n        order.add_event(OrderEvent::OrderCreated {\n            event_id: Uuid::new_v4(),\n            timestamp: now,\n            order_id: order_id.value(),\n            customer_id: customer_id.value(),\n            total_amount: total.amount(),\n            items: order.items.iter().map(|line| line.to_event_dto()).collect(),\n        });\n\n        Ok(order)\n    }\n\n    /// 确认订单\n    pub fn confirm(&mut self) -> Result<(), DomainError> {\n        // 业务规则：只有Pending状态的订单可以确认\n        if self.status != OrderStatus::Pending {\n            return Err(DomainError::InvalidStateTransition {\n                from: self.status,\n                to: OrderStatus::Confirmed,\n            });\n        }\n\n        self.status = OrderStatus::Confirmed;\n        self.updated_at = Utc::now();\n\n        self.add_event(OrderEvent::OrderConfirmed {\n            event_id: Uuid::new_v4(),\n            timestamp: Utc::now(),\n            order_id: self.id.value(),\n        });\n\n        Ok(())\n    }\n\n    /// 取消订单\n    pub fn cancel(&mut self, reason: String) -> Result<(), DomainError> {\n        // 业务规则：已完成或已取消的订单不能再取消\n        match self.status {\n            OrderStatus::Completed | OrderStatus::Cancelled => {\n                return Err(DomainError::InvalidStateTransition {\n                    from: self.status,\n                    to: OrderStatus::Cancelled,\n                });\n            }\n            _ => {}\n        }\n\n        self.status = OrderStatus::Cancelled;\n        self.updated_at = Utc::now();\n\n        self.add_event(OrderEvent::OrderCancelled {\n            event_id: Uuid::new_v4(),\n            timestamp: Utc::now(),\n            order_id: self.id.value(),\n            reason,\n        });\n\n        Ok(())\n    }\n\n    /// 添加订单行\n    pub fn add_item(&mut self, item: OrderLine) -> Result<(), DomainError> {\n        // 业务规则：只有Pending状态可以修改\n        if self.status != OrderStatus::Pending {\n            return Err(DomainError::InvalidOperation(\n                \"Cannot modify confirmed order\".to_string()\n            ));\n        }\n\n        self.items.push(item);\n        self.recalculate_totals();\n        self.updated_at = Utc::now();\n\n        Ok(())\n    }\n\n    /// 移除订单行\n    pub fn remove_item(&mut self, sku: &str) -> Result<(), DomainError> {\n        if self.status != OrderStatus::Pending {\n            return Err(DomainError::InvalidOperation(\n                \"Cannot modify confirmed order\".to_string()\n            ));\n        }\n\n        self.items.retain(|item| item.sku() != sku);\n\n        if self.items.is_empty() {\n            return Err(DomainError::ValidationError(\n                \"Cannot remove last item from order\".to_string()\n            ));\n        }\n\n        self.recalculate_totals();\n        self.updated_at = Utc::now();\n\n        Ok(())\n    }\n\n    // 私有辅助方法\n    fn recalculate_totals(&mut self) {\n        self.subtotal = self.items.iter()\n            .map(|line| line.total())\n            .sum();\n        self.tax = self.subtotal * Decimal::from_str(\"0.1\").unwrap();\n        self.total = self.subtotal + self.tax + self.shipping_cost;\n    }\n\n    fn generate_order_number() -> String {\n        format!(\"ORD-{}\", Utc::now().format(\"%Y%m%d-%H%M%S\"))\n    }\n\n    fn add_event(&mut self, event: OrderEvent) {\n        self.uncommitted_events.push(event);\n    }\n\n    // Getters\n    pub fn id(&self) -> &OrderId { &self.id }\n    pub fn status(&self) -> &OrderStatus { &self.status }\n    pub fn total(&self) -> &Money { &self.total }\n    pub fn version(&self) -> i64 { self.version }\n    pub fn uncommitted_events(&self) -> &[OrderEvent] { &self.uncommitted_events }\n\n    pub fn clear_events(&mut self) {\n        self.uncommitted_events.clear();\n    }\n}\n\n/// 订单行实体\n#[derive(Debug, Clone, Serialize, Deserialize, Validate)]\npub struct OrderLine {\n    id: Uuid,\n    sku: String,\n    product_name: String,\n    #[validate(range(min = 1))]\n    quantity: i32,\n    unit_price: Money,\n}\n\nimpl OrderLine {\n    pub fn new(\n        sku: String,\n        product_name: String,\n        quantity: i32,\n        unit_price: Money,\n    ) -> Result<Self, DomainError> {\n        let line = Self {\n            id: Uuid::new_v4(),\n            sku,\n            product_name,\n            quantity,\n            unit_price,\n        };\n\n        line.validate()\n            .map_err(|e| DomainError::ValidationError(e.to_string()))?;\n\n        Ok(line)\n    }\n\n    pub fn total(&self) -> Money {\n        self.unit_price * Decimal::from(self.quantity)\n    }\n\n    pub fn sku(&self) -> &str {\n        &self.sku\n    }\n\n    pub fn to_event_dto(&self) -> OrderItemDto {\n        OrderItemDto {\n            sku: self.sku.clone(),\n            quantity: self.quantity,\n            unit_price: self.unit_price.amount(),\n        }\n    }\n}\n```\n\n### 值对象 (Value Objects)\n\n```rust\n// services/order-service/src/domain/value_objects/money.rs\n\nuse rust_decimal::Decimal;\nuse serde::{Deserialize, Serialize};\nuse std::ops::{Add, Mul};\nuse thiserror::Error;\n\n/// 货币值对象\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]\npub struct Money {\n    amount: Decimal,\n    currency: Currency,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]\npub enum Currency {\n    USD,\n    EUR,\n    CNY,\n}\n\n#[derive(Debug, Error)]\npub enum MoneyError {\n    #[error(\"Cannot perform operation on different currencies\")]\n    CurrencyMismatch,\n\n    #[error(\"Negative amount not allowed\")]\n    NegativeAmount,\n}\n\nimpl Money {\n    pub fn new(amount: Decimal, currency: Currency) -> Result<Self, MoneyError> {\n        if amount < Decimal::ZERO {\n            return Err(MoneyError::NegativeAmount);\n        }\n\n        Ok(Self { amount, currency })\n    }\n\n    pub fn from_usd(amount: Decimal) -> Self {\n        Self {\n            amount,\n            currency: Currency::USD,\n        }\n    }\n\n    pub fn amount(&self) -> Decimal {\n        self.amount\n    }\n\n    pub fn currency(&self) -> Currency {\n        self.currency\n    }\n\n    pub fn zero(currency: Currency) -> Self {\n        Self {\n            amount: Decimal::ZERO,\n            currency,\n        }\n    }\n}\n\n// 实现加法\nimpl Add for Money {\n    type Output = Result<Money, MoneyError>;\n\n    fn add(self, rhs: Self) -> Self::Output {\n        if self.currency != rhs.currency {\n            return Err(MoneyError::CurrencyMismatch);\n        }\n\n        Ok(Money {\n            amount: self.amount + rhs.amount,\n            currency: self.currency,\n        })\n    }\n}\n\n// 实现乘法\nimpl Mul<Decimal> for Money {\n    type Output = Money;\n\n    fn mul(self, rhs: Decimal) -> Self::Output {\n        Money {\n            amount: self.amount * rhs,\n            currency: self.currency,\n        }\n    }\n}\n\n// 实现Sum trait用于迭代器求和\nimpl std::iter::Sum for Money {\n    fn sum<I: Iterator<Item = Self>>(iter: I) -> Self {\n        iter.fold(Money::zero(Currency::USD), |acc, m| {\n            acc.add(m).unwrap_or(acc)\n        })\n    }\n}\n```\n\n### 领域服务 (Domain Service)\n\n```rust\n// services/order-service/src/domain/services/order_price_calculator.rs\n\nuse rust_decimal::Decimal;\nuse crate::domain::aggregates::OrderLine;\nuse crate::domain::value_objects::{Money, Currency};\n\n/// 订单价格计算领域服务\npub struct OrderPriceCalculator;\n\nimpl OrderPriceCalculator {\n    /// 计算折扣\n    pub fn calculate_discount(\n        &self,\n        subtotal: &Money,\n        customer_tier: CustomerTier,\n    ) -> Money {\n        let discount_rate = match customer_tier {\n            CustomerTier::Platinum => Decimal::from_str(\"0.15\").unwrap(),  // 15%\n            CustomerTier::Gold => Decimal::from_str(\"0.10\").unwrap(),      // 10%\n            CustomerTier::Silver => Decimal::from_str(\"0.05\").unwrap(),    // 5%\n            CustomerTier::Bronze => Decimal::ZERO,\n        };\n\n        *subtotal * discount_rate\n    }\n\n    /// 计算运费（基于重量和目的地）\n    pub fn calculate_shipping_cost(\n        &self,\n        items: &[OrderLine],\n        destination: &ShippingAddress,\n    ) -> Money {\n        let total_weight = self.calculate_total_weight(items);\n        let base_rate = Decimal::from(10);  // 基础运费$10\n\n        let weight_surcharge = if total_weight > Decimal::from(50) {\n            (total_weight - Decimal::from(50)) * Decimal::from_str(\"0.5\").unwrap()\n        } else {\n            Decimal::ZERO\n        };\n\n        // 远程地区附加费\n        let remote_surcharge = if self.is_remote_area(&destination.postal_code) {\n            Decimal::from(15)\n        } else {\n            Decimal::ZERO\n        };\n\n        Money::from_usd(base_rate + weight_surcharge + remote_surcharge)\n    }\n\n    fn calculate_total_weight(&self, items: &[OrderLine]) -> Decimal {\n        // 假设每个商品重量从商品服务获取\n        items.iter()\n            .map(|_| Decimal::from(5))  // 简化：每件5kg\n            .sum()\n    }\n\n    fn is_remote_area(&self, postal_code: &str) -> bool {\n        // 简化实现\n        postal_code.starts_with(\"9\")\n    }\n}\n\npub enum CustomerTier {\n    Platinum,\n    Gold,\n    Silver,\n    Bronze,\n}\n```\n\n### 仓储接口 (Repository Interface)\n\n```rust\n// services/order-service/src/domain/repositories/order_repository.rs\n\nuse async_trait::async_trait;\nuse uuid::Uuid;\nuse crate::domain::aggregates::{Order, OrderId};\nuse shared::domain_primitives::{Page, PageRequest, RepositoryError};\n\n/// 订单仓储接口（在领域层定义）\n#[async_trait]\npub trait OrderRepository: Send + Sync {\n    /// 保存订单（新增或更新）\n    async fn save(&self, order: &Order) -> Result<(), RepositoryError>;\n\n    /// 根据ID查找订单\n    async fn find_by_id(&self, id: &OrderId) -> Result<Option<Order>, RepositoryError>;\n\n    /// 根据订单号查找\n    async fn find_by_order_number(&self, order_number: &str) -> Result<Option<Order>, RepositoryError>;\n\n    /// 分页查询订单\n    async fn find_all(&self, page: PageRequest) -> Result<Page<Order>, RepositoryError>;\n\n    /// 根据客户ID查询订单\n    async fn find_by_customer_id(\n        &self,\n        customer_id: &CustomerId,\n        page: PageRequest,\n    ) -> Result<Page<Order>, RepositoryError>;\n\n    /// 删除订单（软删除）\n    async fn delete(&self, id: &OrderId) -> Result<(), RepositoryError>;\n\n    /// 检查订单号是否存在\n    async fn exists_by_order_number(&self, order_number: &str) -> Result<bool, RepositoryError>;\n}\n```\n\n---\n\n## 基础设施层\n\n### PostgreSQL仓储实现\n\n```rust\n// services/order-service/src/infrastructure/persistence/postgres/order_repository_impl.rs\n\nuse async_trait::async_trait;\nuse sqlx::{PgPool, Postgres, Row};\nuse uuid::Uuid;\n\nuse crate::domain::aggregates::{Order, OrderId};\nuse crate::domain::repositories::OrderRepository;\nuse crate::infrastructure::persistence::postgres::models::OrderModel;\nuse shared::domain_primitives::{Page, PageRequest, RepositoryError};\n\npub struct PostgresOrderRepository {\n    pool: PgPool,\n}\n\nimpl PostgresOrderRepository {\n    pub fn new(pool: PgPool) -> Self {\n        Self { pool }\n    }\n}\n\n#[async_trait]\nimpl OrderRepository for PostgresOrderRepository {\n    async fn save(&self, order: &Order) -> Result<(), RepositoryError> {\n        let model = OrderModel::from_domain(order);\n\n        // 使用UPSERT（INSERT ... ON CONFLICT）\n        sqlx::query!(\n            r#\"\n            INSERT INTO orders (\n                id, customer_id, order_number, status, subtotal, tax,\n                shipping_cost, total, shipping_address, billing_address,\n                created_at, updated_at, version\n            )\n            VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)\n            ON CONFLICT (id) DO UPDATE SET\n                status = EXCLUDED.status,\n                subtotal = EXCLUDED.subtotal,\n                tax = EXCLUDED.tax,\n                shipping_cost = EXCLUDED.shipping_cost,\n                total = EXCLUDED.total,\n                updated_at = EXCLUDED.updated_at,\n                version = orders.version + 1\n            WHERE orders.version = $14\n            \"#,\n            model.id,\n            model.customer_id,\n            model.order_number,\n            model.status,\n            model.subtotal,\n            model.tax,\n            model.shipping_cost,\n            model.total,\n            sqlx::types::Json(&model.shipping_address) as _,\n            sqlx::types::Json(&model.billing_address) as _,\n            model.created_at,\n            model.updated_at,\n            model.version,\n            order.version()  // 乐观锁版本检查\n        )\n        .execute(&self.pool)\n        .await\n        .map_err(|e| {\n            if let sqlx::Error::RowNotFound = e {\n                RepositoryError::OptimisticLockError\n            } else {\n                RepositoryError::DatabaseError(e.to_string())\n            }\n        })?;\n\n        // 保存订单行\n        self.save_order_lines(order.id(), &order.items).await?;\n\n        Ok(())\n    }\n\n    async fn find_by_id(&self, id: &OrderId) -> Result<Option<Order>, RepositoryError> {\n        let row = sqlx::query!(\n            r#\"\n            SELECT\n                id, customer_id, order_number, status, subtotal, tax,\n                shipping_cost, total, shipping_address, billing_address,\n                created_at, updated_at, version\n            FROM orders\n            WHERE id = $1 AND deleted_at IS NULL\n            \"#,\n            id.value()\n        )\n        .fetch_optional(&self.pool)\n        .await\n        .map_err(|e| RepositoryError::DatabaseError(e.to_string()))?;\n\n        match row {\n            Some(row) => {\n                let lines = self.fetch_order_lines(id).await?;\n                let model = OrderModel {\n                    id: row.id,\n                    customer_id: row.customer_id,\n                    order_number: row.order_number,\n                    status: row.status,\n                    subtotal: row.subtotal,\n                    tax: row.tax,\n                    shipping_cost: row.shipping_cost,\n                    total: row.total,\n                    shipping_address: row.shipping_address.0,\n                    billing_address: row.billing_address.0,\n                    created_at: row.created_at,\n                    updated_at: row.updated_at,\n                    version: row.version,\n                };\n\n                Ok(Some(model.to_domain(lines)?))\n            }\n            None => Ok(None),\n        }\n    }\n\n    async fn find_all(&self, page: PageRequest) -> Result<Page<Order>, RepositoryError> {\n        let offset = page.offset();\n        let limit = page.limit();\n\n        // 查询总数\n        let total: i64 = sqlx::query_scalar!(\n            \"SELECT COUNT(*) FROM orders WHERE deleted_at IS NULL\"\n        )\n        .fetch_one(&self.pool)\n        .await\n        .map_err(|e| RepositoryError::DatabaseError(e.to_string()))?\n        .unwrap_or(0);\n\n        // 查询数据\n        let rows = sqlx::query!(\n            r#\"\n            SELECT\n                id, customer_id, order_number, status, subtotal, tax,\n                shipping_cost, total, shipping_address, billing_address,\n                created_at, updated_at, version\n            FROM orders\n            WHERE deleted_at IS NULL\n            ORDER BY created_at DESC\n            LIMIT $1 OFFSET $2\n            \"#,\n            limit,\n            offset\n        )\n        .fetch_all(&self.pool)\n        .await\n        .map_err(|e| RepositoryError::DatabaseError(e.to_string()))?;\n\n        let mut orders = Vec::new();\n        for row in rows {\n            let id = OrderId::from_uuid(row.id);\n            let lines = self.fetch_order_lines(&id).await?;\n            let model = OrderModel {\n                id: row.id,\n                customer_id: row.customer_id,\n                order_number: row.order_number,\n                status: row.status,\n                subtotal: row.subtotal,\n                tax: row.tax,\n                shipping_cost: row.shipping_cost,\n                total: row.total,\n                shipping_address: row.shipping_address.0,\n                billing_address: row.billing_address.0,\n                created_at: row.created_at,\n                updated_at: row.updated_at,\n                version: row.version,\n            };\n            orders.push(model.to_domain(lines)?);\n        }\n\n        Ok(Page::new(orders, total as usize, page))\n    }\n\n    async fn delete(&self, id: &OrderId) -> Result<(), RepositoryError> {\n        sqlx::query!(\n            \"UPDATE orders SET deleted_at = NOW() WHERE id = $1\",\n            id.value()\n        )\n        .execute(&self.pool)\n        .await\n        .map_err(|e| RepositoryError::DatabaseError(e.to_string()))?;\n\n        Ok(())\n    }\n\n    async fn exists_by_order_number(&self, order_number: &str) -> Result<bool, RepositoryError> {\n        let exists: bool = sqlx::query_scalar!(\n            \"SELECT EXISTS(SELECT 1 FROM orders WHERE order_number = $1 AND deleted_at IS NULL)\",\n            order_number\n        )\n        .fetch_one(&self.pool)\n        .await\n        .map_err(|e| RepositoryError::DatabaseError(e.to_string()))?\n        .unwrap_or(false);\n\n        Ok(exists)\n    }\n}\n\n// 私有辅助方法\nimpl PostgresOrderRepository {\n    async fn save_order_lines(\n        &self,\n        order_id: &OrderId,\n        lines: &[OrderLine],\n    ) -> Result<(), RepositoryError> {\n        // 先删除旧的订单行\n        sqlx::query!(\n            \"DELETE FROM order_lines WHERE order_id = $1\",\n            order_id.value()\n        )\n        .execute(&self.pool)\n        .await\n        .map_err(|e| RepositoryError::DatabaseError(e.to_string()))?;\n\n        // 批量插入新的订单行\n        for line in lines {\n            sqlx::query!(\n                r#\"\n                INSERT INTO order_lines (id, order_id, sku, product_name, quantity, unit_price)\n                VALUES ($1, $2, $3, $4, $5, $6)\n                \"#,\n                Uuid::new_v4(),\n                order_id.value(),\n                line.sku(),\n                line.product_name(),\n                line.quantity(),\n                line.unit_price().amount()\n            )\n            .execute(&self.pool)\n            .await\n            .map_err(|e| RepositoryError::DatabaseError(e.to_string()))?;\n        }\n\n        Ok(())\n    }\n\n    async fn fetch_order_lines(&self, order_id: &OrderId) -> Result<Vec<OrderLineModel>, RepositoryError> {\n        let lines = sqlx::query_as!(\n            OrderLineModel,\n            r#\"\n            SELECT id, order_id, sku, product_name, quantity, unit_price\n            FROM order_lines\n            WHERE order_id = $1\n            ORDER BY id\n            \"#,\n            order_id.value()\n        )\n        .fetch_all(&self.pool)\n        .await\n        .map_err(|e| RepositoryError::DatabaseError(e.to_string()))?;\n\n        Ok(lines)\n    }\n}\n```\n\n### SQL迁移脚本\n\n```sql\n-- services/order-service/migrations/20250101000000_create_orders_table.sql\n\n-- 订单表\nCREATE TABLE orders (\n    id UUID PRIMARY KEY,\n    customer_id UUID NOT NULL,\n    order_number VARCHAR(50) NOT NULL UNIQUE,\n    status VARCHAR(20) NOT NULL,\n\n    -- 金额字段（使用NUMERIC避免浮点误差）\n    subtotal NUMERIC(15, 2) NOT NULL,\n    tax NUMERIC(15, 2) NOT NULL,\n    shipping_cost NUMERIC(15, 2) NOT NULL,\n    total NUMERIC(15, 2) NOT NULL,\n\n    -- 地址（存储为JSONB）\n    shipping_address JSONB NOT NULL,\n    billing_address JSONB NOT NULL,\n\n    -- 审计字段\n    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),\n    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),\n    deleted_at TIMESTAMP WITH TIME ZONE,\n\n    -- 乐观锁版本号\n    version BIGINT NOT NULL DEFAULT 1\n);\n\n-- 订单行表\nCREATE TABLE order_lines (\n    id UUID PRIMARY KEY,\n    order_id UUID NOT NULL REFERENCES orders(id) ON DELETE CASCADE,\n    sku VARCHAR(100) NOT NULL,\n    product_name VARCHAR(255) NOT NULL,\n    quantity INTEGER NOT NULL CHECK (quantity > 0),\n    unit_price NUMERIC(15, 2) NOT NULL CHECK (unit_price >= 0),\n\n    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW()\n);\n\n-- 索引\nCREATE INDEX idx_orders_customer_id ON orders(customer_id);\nCREATE INDEX idx_orders_status ON orders(status);\nCREATE INDEX idx_orders_created_at ON orders(created_at DESC);\nCREATE INDEX idx_orders_order_number ON orders(order_number);\nCREATE INDEX idx_order_lines_order_id ON order_lines(order_id);\nCREATE INDEX idx_order_lines_sku ON order_lines(sku);\n\n-- 部分索引（只索引未删除的订单）\nCREATE INDEX idx_orders_active ON orders(id) WHERE deleted_at IS NULL;\n\n-- 更新updated_at的触发器\nCREATE OR REPLACE FUNCTION update_updated_at_column()\nRETURNS TRIGGER AS $$\nBEGIN\n    NEW.updated_at = NOW();\n    RETURN NEW;\nEND;\n$$ language 'plpgsql';\n\nCREATE TRIGGER update_orders_updated_at BEFORE UPDATE ON orders\nFOR EACH ROW EXECUTE FUNCTION update_updated_at_column();\n\n-- 订单事件溯源表（Event Sourcing）\nCREATE TABLE order_events (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    aggregate_id UUID NOT NULL,  -- 订单ID\n    event_type VARCHAR(100) NOT NULL,\n    event_data JSONB NOT NULL,\n    metadata JSONB,\n    version BIGINT NOT NULL,\n    occurred_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),\n\n    CONSTRAINT unique_version_per_aggregate UNIQUE(aggregate_id, version)\n);\n\nCREATE INDEX idx_order_events_aggregate_id ON order_events(aggregate_id, version);\nCREATE INDEX idx_order_events_event_type ON order_events(event_type);\nCREATE INDEX idx_order_events_occurred_at ON order_events(occurred_at DESC);\n```\n\n---\n\n## API网关与服务发现\n\n### Kong API Gateway配置\n\n```yaml\n# k8s/base/kong-config.yaml\n\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: kong-declarative-config\n  namespace: api-gateway\ndata:\n  kong.yml: |\n    _format_version: \"3.0\"\n\n    # 服务定义\n    services:\n      - name: order-service\n        url: http://order-service.production.svc.cluster.local:8001\n        protocol: http\n        connect_timeout: 60000\n        write_timeout: 60000\n        read_timeout: 60000\n        retries: 3\n\n        # 路由\n        routes:\n          - name: order-api\n            paths:\n              - /api/v1/orders\n            methods:\n              - GET\n              - POST\n              - PUT\n              - DELETE\n            strip_path: false\n\n            # 插件\n            plugins:\n              - name: rate-limiting\n                config:\n                  minute: 100\n                  policy: cluster\n                  fault_tolerant: true\n\n              - name: jwt\n                config:\n                  key_claim_name: kid\n                  secret_is_base64: false\n\n              - name: request-size-limiting\n                config:\n                  allowed_payload_size: 10\n                  size_unit: megabytes\n\n              - name: correlation-id\n                config:\n                  header_name: X-Correlation-ID\n                  generator: uuid\n\n              - name: prometheus\n                config:\n                  per_consumer: true\n\n      - name: inventory-service\n        url: http://inventory-service.production.svc.cluster.local:8002\n        routes:\n          - name: inventory-api\n            paths:\n              - /api/v1/inventory\n\n      - name: payment-service\n        url: http://payment-service.production.svc.cluster.local:8003\n        routes:\n          - name: payment-api\n            paths:\n              - /api/v1/payments\n\n    # 全局插件\n    plugins:\n      - name: cors\n        config:\n          origins:\n            - https://app.example.com\n          methods:\n            - GET\n            - POST\n            - PUT\n            - DELETE\n            - OPTIONS\n          headers:\n            - Accept\n            - Authorization\n            - Content-Type\n            - X-Request-ID\n          exposed_headers:\n            - X-Auth-Token\n          credentials: true\n          max_age: 3600\n\n      - name: request-transformer\n        config:\n          add:\n            headers:\n              - \"X-Gateway-Version:1.0\"\n\n      - name: response-transformer\n        config:\n          remove:\n            headers:\n              - \"X-Internal-Header\"\n```\n\n---\n\n## GitHub CI/CD配置\n\n### CI工作流\n\n```yaml\n# .github/workflows/ci.yml\n\nname: CI\n\non:\n  push:\n    branches: [ main, develop ]\n  pull_request:\n    branches: [ main, develop ]\n\nenv:\n  CARGO_TERM_COLOR: always\n  RUST_VERSION: 1.75.0\n\njobs:\n  # 代码检查\n  lint:\n    name: Lint\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Install Rust\n        uses: actions-rs/toolchain@v1\n        with:\n          profile: minimal\n          toolchain: ${{ env.RUST_VERSION }}\n          components: rustfmt, clippy\n          override: true\n\n      - name: Cache cargo registry\n        uses: actions/cache@v3\n        with:\n          path: ~/.cargo/registry\n          key: ${{ runner.os }}-cargo-registry-${{ hashFiles('**/Cargo.lock') }}\n\n      - name: Cache cargo index\n        uses: actions/cache@v3\n        with:\n          path: ~/.cargo/git\n          key: ${{ runner.os }}-cargo-git-${{ hashFiles('**/Cargo.lock') }}\n\n      - name: Cache target directory\n        uses: actions/cache@v3\n        with:\n          path: target\n          key: ${{ runner.os }}-target-${{ hashFiles('**/Cargo.lock') }}\n\n      - name: Run rustfmt\n        run: cargo fmt --all -- --check\n\n      - name: Run clippy\n        run: cargo clippy --all-targets --all-features -- -D warnings\n\n  # 单元测试\n  test:\n    name: Test\n    runs-on: ubuntu-latest\n    services:\n      postgres:\n        image: postgres:16\n        env:\n          POSTGRES_USER: test\n          POSTGRES_PASSWORD: test\n          POSTGRES_DB: test_db\n        options: >-\n          --health-cmd pg_isready\n          --health-interval 10s\n          --health-timeout 5s\n          --health-retries 5\n        ports:\n          - 5432:5432\n\n      redis:\n        image: redis:7\n        options: >-\n          --health-cmd \"redis-cli ping\"\n          --health-interval 10s\n          --health-timeout 5s\n          --health-retries 5\n        ports:\n          - 6379:6379\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Install Rust\n        uses: actions-rs/toolchain@v1\n        with:\n          profile: minimal\n          toolchain: ${{ env.RUST_VERSION }}\n          override: true\n\n      - name: Cache dependencies\n        uses: actions/cache@v3\n        with:\n          path: |\n            ~/.cargo/registry\n            ~/.cargo/git\n            target\n          key: ${{ runner.os }}-cargo-test-${{ hashFiles('**/Cargo.lock') }}\n\n      - name: Run tests\n        env:\n          DATABASE_URL: postgres://test:test@localhost:5432/test_db\n          REDIS_URL: redis://localhost:6379\n        run: cargo test --all-features --workspace\n\n      - name: Run doc tests\n        run: cargo test --doc --workspace\n\n  # 安全审计\n  security-audit:\n    name: Security Audit\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Install cargo-audit\n        run: cargo install cargo-audit\n\n      - name: Run cargo audit\n        run: cargo audit\n\n  # 代码覆盖率\n  coverage:\n    name: Code Coverage\n    runs-on: ubuntu-latest\n    services:\n      postgres:\n        image: postgres:16\n        env:\n          POSTGRES_USER: test\n          POSTGRES_PASSWORD: test\n          POSTGRES_DB: test_db\n        ports:\n          - 5432:5432\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Install Rust\n        uses: actions-rs/toolchain@v1\n        with:\n          profile: minimal\n          toolchain: ${{ env.RUST_VERSION }}\n          override: true\n\n      - name: Install tarpaulin\n        run: cargo install cargo-tarpaulin\n\n      - name: Generate coverage\n        env:\n          DATABASE_URL: postgres://test:test@localhost:5432/test_db\n        run: cargo tarpaulin --out Xml --workspace\n\n      - name: Upload to codecov.io\n        uses: codecov/codecov-action@v3\n        with:\n          token: ${{ secrets.CODECOV_TOKEN }}\n          fail_ci_if_error: true\n\n  # 构建Docker镜像\n  build:\n    name: Build Docker Images\n    runs-on: ubuntu-latest\n    needs: [lint, test]\n    strategy:\n      matrix:\n        service: [order-service, inventory-service, payment-service]\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Set up Docker Buildx\n        uses: docker/setup-buildx-action@v3\n\n      - name: Login to GitHub Container Registry\n        uses: docker/login-action@v3\n        with:\n          registry: ghcr.io\n          username: ${{ github.actor }}\n          password: ${{ secrets.GITHUB_TOKEN }}\n\n      - name: Extract metadata\n        id: meta\n        uses: docker/metadata-action@v5\n        with:\n          images: ghcr.io/${{ github.repository }}/${{ matrix.service }}\n          tags: |\n            type=ref,event=branch\n            type=ref,event=pr\n            type=semver,pattern={{version}}\n            type=semver,pattern={{major}}.{{minor}}\n            type=sha\n\n      - name: Build and push\n        uses: docker/build-push-action@v5\n        with:\n          context: .\n          file: ./docker/Dockerfile.service\n          build-args: |\n            SERVICE_NAME=${{ matrix.service }}\n          push: true\n          tags: ${{ steps.meta.outputs.tags }}\n          labels: ${{ steps.meta.outputs.labels }}\n          cache-from: type=gha\n          cache-to: type=gha,mode=max\n```\n\n### CD工作流（生产部署）\n\n```yaml\n# .github/workflows/deploy-production.yml\n\nname: Deploy to Production\n\non:\n  push:\n    tags:\n      - 'v*.*.*'\n\njobs:\n  deploy:\n    name: Deploy to Production\n    runs-on: ubuntu-latest\n    environment: production\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Configure AWS credentials\n        uses: aws-actions/configure-aws-credentials@v4\n        with:\n          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}\n          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}\n          aws-region: us-east-1\n\n      - name: Login to Amazon ECR\n        id: login-ecr\n        uses: aws-actions/amazon-ecr-login@v2\n\n      - name: Install kubectl\n        uses: azure/setup-kubectl@v3\n        with:\n          version: 'v1.29.0'\n\n      - name: Configure kubectl\n        run: |\n          aws eks update-kubeconfig --name production-cluster --region us-east-1\n\n      - name: Deploy with Helm\n        run: |\n          helm upgrade --install erp-system ./k8s/helm/erp-system \\\n            --namespace production \\\n            --create-namespace \\\n            --set image.tag=${{ github.ref_name }} \\\n            --set environment=production \\\n            --values ./k8s/helm/erp-system/values-production.yaml \\\n            --wait \\\n            --timeout 10m\n\n      - name: Verify deployment\n        run: |\n          kubectl rollout status deployment/order-service -n production\n          kubectl rollout status deployment/inventory-service -n production\n          kubectl rollout status deployment/payment-service -n production\n\n      - name: Run smoke tests\n        run: |\n          kubectl run smoke-test --rm -i --restart=Never \\\n            --image=curlimages/curl:latest \\\n            -- curl -f http://api-gateway.production.svc.cluster.local/health || exit 1\n\n      - name: Notify Slack\n        if: always()\n        uses: 8398a7/action-slack@v3\n        with:\n          status: ${{ job.status }}\n          text: 'Production deployment ${{ job.status }}'\n          webhook_url: ${{ secrets.SLACK_WEBHOOK }}\n```\n\n---\n\n## 容器化与Kubernetes\n\n### Multi-stage Dockerfile\n\n```dockerfile\n# docker/Dockerfile.service\n\n# ============================================\n# Stage 1: Builder\n# ============================================\nFROM rust:1.75-slim-bookworm AS builder\n\nARG SERVICE_NAME\nENV SERVICE_NAME=${SERVICE_NAME}\n\nWORKDIR /build\n\n# 安装依赖\nRUN apt-get update && apt-get install -y \\\n    pkg-config \\\n    libssl-dev \\\n    protobuf-compiler \\\n    && rm -rf /var/lib/apt/lists/*\n\n# 复制依赖文件\nCOPY Cargo.toml Cargo.lock ./\nCOPY shared/ ./shared/\nCOPY services/${SERVICE_NAME}/ ./services/${SERVICE_NAME}/\n\n# 构建依赖（利用Docker缓存）\nRUN mkdir -p services/${SERVICE_NAME}/src && \\\n    echo \"fn main() {}\" > services/${SERVICE_NAME}/src/main.rs && \\\n    cargo build --release --bin ${SERVICE_NAME} && \\\n    rm -rf services/${SERVICE_NAME}/src\n\n# 构建实际应用\nCOPY services/${SERVICE_NAME}/src ./services/${SERVICE_NAME}/src\nRUN touch services/${SERVICE_NAME}/src/main.rs && \\\n    cargo build --release --bin ${SERVICE_NAME}\n\n# ============================================\n# Stage 2: Runtime\n# ============================================\nFROM debian:bookworm-slim\n\nARG SERVICE_NAME\nENV SERVICE_NAME=${SERVICE_NAME}\n\n# 安装运行时依赖\nRUN apt-get update && apt-get install -y \\\n    ca-certificates \\\n    libssl3 \\\n    && rm -rf /var/lib/apt/lists/*\n\n# 创建非root用户\nRUN useradd -m -u 1000 appuser\n\nWORKDIR /app\n\n# 复制编译后的二进制文件\nCOPY --from=builder /build/target/release/${SERVICE_NAME} /app/service\nCOPY services/${SERVICE_NAME}/migrations /app/migrations\n\n# 更改所有权\nRUN chown -R appuser:appuser /app\n\nUSER appuser\n\nEXPOSE 8080\n\nHEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \\\n  CMD curl -f http://localhost:8080/health || exit 1\n\nCMD [\"/app/service\"]\n```\n\n### Kubernetes Deployment\n\n```yaml\n# k8s/base/order-service/deployment.yaml\n\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: order-service\n  namespace: production\n  labels:\n    app: order-service\n    version: v1.0.0\nspec:\n  replicas: 3\n  strategy:\n    type: RollingUpdate\n    rollingUpdate:\n      maxSurge: 1\n      maxUnavailable: 0\n  selector:\n    matchLabels:\n      app: order-service\n  template:\n    metadata:\n      labels:\n        app: order-service\n        version: v1.0.0\n      annotations:\n        prometheus.io/scrape: \"true\"\n        prometheus.io/port: \"9090\"\n        prometheus.io/path: \"/metrics\"\n    spec:\n      serviceAccountName: order-service\n\n      # 初始化容器（运行数据库迁移）\n      initContainers:\n        - name: db-migration\n          image: ghcr.io/your-org/order-service:latest\n          command: ['sqlx', 'migrate', 'run']\n          env:\n            - name: DATABASE_URL\n              valueFrom:\n                secretKeyRef:\n                  name: order-service-secrets\n                  key: database-url\n\n      containers:\n        - name: order-service\n          image: ghcr.io/your-org/order-service:latest\n          imagePullPolicy: Always\n          ports:\n            - name: http\n              containerPort: 8080\n              protocol: TCP\n            - name: grpc\n              containerPort: 9000\n              protocol: TCP\n            - name: metrics\n              containerPort: 9090\n              protocol: TCP\n\n          env:\n            - name: RUST_LOG\n              value: \"info,order_service=debug\"\n            - name: SERVICE_NAME\n              value: \"order-service\"\n            - name: SERVICE_PORT\n              value: \"8080\"\n\n            # 从ConfigMap加载\n            - name: KAFKA_BROKERS\n              valueFrom:\n                configMapKeyRef:\n                  name: app-config\n                  key: kafka-brokers\n\n            # 从Secret加载\n            - name: DATABASE_URL\n              valueFrom:\n                secretKeyRef:\n                  name: order-service-secrets\n                  key: database-url\n\n            - name: REDIS_URL\n              valueFrom:\n                secretKeyRef:\n                  name: order-service-secrets\n                  key: redis-url\n\n            - name: JWT_SECRET\n              valueFrom:\n                secretKeyRef:\n                  name: order-service-secrets\n                  key: jwt-secret\n\n          resources:\n            requests:\n              memory: \"256Mi\"\n              cpu: \"250m\"\n            limits:\n              memory: \"512Mi\"\n              cpu: \"500m\"\n\n          livenessProbe:\n            httpGet:\n              path: /health/live\n              port: 8080\n            initialDelaySeconds: 10\n            periodSeconds: 10\n            timeoutSeconds: 3\n            failureThreshold: 3\n\n          readinessProbe:\n            httpGet:\n              path: /health/ready\n              port: 8080\n            initialDelaySeconds: 5\n            periodSeconds: 5\n            timeoutSeconds: 2\n            failureThreshold: 3\n\n          securityContext:\n            runAsNonRoot: true\n            runAsUser: 1000\n            allowPrivilegeEscalation: false\n            readOnlyRootFilesystem: true\n            capabilities:\n              drop:\n                - ALL\n\n          volumeMounts:\n            - name: tmp\n              mountPath: /tmp\n            - name: cache\n              mountPath: /app/cache\n\n      volumes:\n        - name: tmp\n          emptyDir: {}\n        - name: cache\n          emptyDir: {}\n\n      # Pod反亲和性（避免同一节点部署多个副本）\n      affinity:\n        podAntiAffinity:\n          preferredDuringSchedulingIgnoredDuringExecution:\n            - weight: 100\n              podAffinityTerm:\n                labelSelector:\n                  matchExpressions:\n                    - key: app\n                      operator: In\n                      values:\n                        - order-service\n                topologyKey: kubernetes.io/hostname\n\n      # Pod中断预算\n      terminationGracePeriodSeconds: 30\n\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: order-service\n  namespace: production\n  labels:\n    app: order-service\nspec:\n  type: ClusterIP\n  selector:\n    app: order-service\n  ports:\n    - name: http\n      port: 80\n      targetPort: 8080\n      protocol: TCP\n    - name: grpc\n      port: 9000\n      targetPort: 9000\n      protocol: TCP\n    - name: metrics\n      port: 9090\n      targetPort: 9090\n      protocol: TCP\n  sessionAffinity: None\n\n---\napiVersion: autoscaling/v2\nkind: HorizontalPodAutoscaler\nmetadata:\n  name: order-service-hpa\n  namespace: production\nspec:\n  scaleTargetRef:\n    apiVersion: apps/v1\n    kind: Deployment\n    name: order-service\n  minReplicas: 3\n  maxReplicas: 10\n  metrics:\n    - type: Resource\n      resource:\n        name: cpu\n        target:\n          type: Utilization\n          averageUtilization: 70\n    - type: Resource\n      resource:\n        name: memory\n        target:\n          type: Utilization\n          averageUtilization: 80\n  behavior:\n    scaleDown:\n      stabilizationWindowSeconds: 300\n      policies:\n        - type: Percent\n          value: 50\n          periodSeconds: 60\n    scaleUp:\n      stabilizationWindowSeconds: 0\n      policies:\n        - type: Percent\n          value: 100\n          periodSeconds: 15\n        - type: Pods\n          value: 2\n          periodSeconds: 15\n      selectPolicy: Max\n```\n\n---\n\n**（文档继续...）**\n\n由于篇幅限制，完整文档还包含以下章节：\n\n10. **可观测性** - Prometheus指标、Grafana仪表盘、Loki日志聚合、Jaeger分布式追踪\n11. **安全最佳实践** - mTLS、RBAC、密钥管理、漏洞扫描\n12. **性能优化** - 连接池、异步I/O、零拷贝、SIMD优化\n13. **测试策略** - 单元测试、集成测试、Contract Testing、性能测试\n\n---\n\n**© 2025 Rust DDD微服务架构最佳实践**\n**版本**: v1.0\n**维护者**: 架构团队\n**许可证**: MIT\n", "md/Rust-Open-Check.md": "# Rust ERP 系统 - 上线运维与演进计划补充文档\n\n**文档类型**: 上线运维与长期演进计划\n**关联文档**:\n- Rust-ERP系统-5人团队12个月开发计划.md\n- Rust-ERP系统-项目管理与协作补充文档.md\n**文档版本**: v1.0\n**创建日期**: 2025-12-21\n\n---\n\n## 目录\n\n9. [上线检查清单](#九上线检查清单)\n10. [应急响应预案](#十应急响应预案)\n11. [运维交接计划](#十一运维交接计划)\n12. [长期演进路线图](#十二长期演进路线图)\n13. [附录](#十三附录)\n\n---\n\n## 九、上线检查清单\n\n### 9.1 上线前检查（Go-Live Checklist）\n\n#### 上线前 4 周：环境准备检查\n\n**基础设施检查**:\n- [ ] 生产 Kubernetes 集群就绪（多可用区部署）\n- [ ] 节点数量满足负载要求（至少 10 个节点）\n- [ ] 资源配额配置正确（CPU、内存、存储）\n- [ ] 网络策略配置完成（Pod 间通信、出入站规则）\n- [ ] Ingress Controller 部署并测试\n- [ ] 证书配置完成（HTTPS、内部 mTLS）\n\n**数据库检查**:\n- [ ] PostgreSQL 主从复制配置完成\n- [ ] 复制延迟 < 1 秒\n- [ ] 自动故障转移测试通过（Patroni/Stolon）\n- [ ] 数据库备份策略就绪（每日全量 + 每小时增量）\n- [ ] 备份恢复测试通过（RTO < 5 分钟，RPO < 1 分钟）\n- [ ] 连接池配置优化（PgBouncer）\n- [ ] 数据库监控配置完成\n\n**消息队列检查**:\n- [ ] Kafka 集群部署（3 个 Broker，副本因子=3）\n- [ ] 主题创建并配置（分区数、副本数、保留策略）\n- [ ] 消费者组配置正确\n- [ ] Kafka 监控就绪（Lag、吞吐量、错误率）\n- [ ] 消息积压告警配置\n\n**缓存检查**:\n- [ ] Redis 集群部署（主从 + 哨兵）\n- [ ] 持久化策略配置（AOF + RDB）\n- [ ] 内存淘汰策略配置（LRU）\n- [ ] Redis 监控配置\n\n**存储检查**:\n- [ ] 对象存储 Bucket 创建（公开、私有）\n- [ ] 访问权限配置（IAM 角色）\n- [ ] CDN 加速配置\n- [ ] 跨区域复制配置（灾备）\n\n#### 上线前 2 周：应用部署检查\n\n**微服务部署**:\n- [ ] 所有微服务部署到生产环境\n- [ ] 副本数满足高可用要求（每服务至少 3 个副本）\n- [ ] 资源限制配置（requests 和 limits）\n- [ ] 健康检查探针配置（liveness、readiness）\n- [ ] 滚动更新策略配置（maxSurge、maxUnavailable）\n- [ ] 服务网格配置（Istio mTLS、流量策略）\n\n**配置管理**:\n- [ ] ConfigMap 和 Secret 创建\n- [ ] 环境变量正确配置\n- [ ] 敏感信息加密存储（Sealed Secrets / Vault）\n- [ ] 配置版本控制（Git 管理）\n- [ ] 配置更新流程测试（热更新 vs 重启）\n\n**网络与安全**:\n- [ ] API Gateway 配置完成（Kong/Nginx）\n- [ ] 认证中间件部署（JWT 验证）\n- [ ] 限流策略配置（每用户、每 IP）\n- [ ] CORS 策略配置\n- [ ] WAF 规则配置（防 SQL 注入、XSS）\n- [ ] DDoS 防护启用\n\n**监控告警**:\n- [ ] Prometheus 指标采集正常\n- [ ] Grafana Dashboard 创建（系统、业务、数据库）\n- [ ] 告警规则配置（CPU、内存、错误率、延迟）\n- [ ] 告警通道配置（邮件、短信、电话、Slack）\n- [ ] 值班排班配置（PagerDuty）\n\n**日志与追踪**:\n- [ ] 日志聚合配置（Loki/ELK）\n- [ ] 日志保留策略配置（30 天在线，90 天归档）\n- [ ] 分布式追踪配置（Jaeger）\n- [ ] 链路追踪采样率配置（生产环境 1%）\n\n#### 上线前 1 周：数据与业务检查\n\n**数据迁移验证**:\n- [ ] 主数据迁移完成并验证（100% 准确）\n- [ ] 交易数据迁移完成并验证\n- [ ] 数据完整性检查通过（外键关联、必填字段）\n- [ ] 数据一致性检查通过（金额汇总、账户余额）\n- [ ] 历史数据归档完成\n- [ ] 数据字典更新\n\n**业务流程测试**:\n- [ ] 端到端业务流程测试通过（P2P、O2C、P2M）\n- [ ] 用户验收测试（UAT）通过\n- [ ] 并发性能测试通过（1000 TPS，P99 < 200ms）\n- [ ] 压力测试通过（峰值负载 2 倍）\n- [ ] 故障注入测试通过（Chaos Engineering）\n\n**用户培训**:\n- [ ] 系统管理员培训完成（100% 通过考核）\n- [ ] 核心用户培训完成（100% 通过考核）\n- [ ] 普通用户培训完成（80% 参与）\n- [ ] 培训材料发布（用户手册、视频、FAQ）\n- [ ] 帮助中心上线\n\n**安全审计**:\n- [ ] 渗透测试完成（无高危漏洞）\n- [ ] 代码安全扫描完成（SAST/DAST）\n- [ ] 依赖漏洞扫描完成（cargo audit）\n- [ ] 容器镜像扫描完成（Trivy）\n- [ ] 权限配置审计（最小权限原则）\n- [ ] 合规检查（GDPR、等保三级）\n\n#### 上线前 3 天：最后准备\n\n**文档准备**:\n- [ ] 上线方案文档完成（详细步骤、时间表）\n- [ ] 回滚方案文档完成（触发条件、回滚步骤）\n- [ ] 应急响应手册更新\n- [ ] 运维操作手册更新\n- [ ] 值班联系人清单更新\n\n**团队准备**:\n- [ ] 上线团队成员确认（开发、运维、业务、管理）\n- [ ] 值班排班确认（上线当天 + 后续 7 天）\n- [ ] 通讯渠道测试（电话、视频会议、应急群）\n- [ ] 应急演练完成（模拟故障响应）\n\n**外部沟通**:\n- [ ] 用户上线通知发出（邮件、公告）\n- [ ] 业务方知晓上线时间和影响\n- [ ] 供应商（云厂商）知晓上线计划\n- [ ] 监管部门（如需要）报备\n\n**备份与回滚准备**:\n- [ ] 旧系统完整备份\n- [ ] 旧系统保持可启动状态（至少 7 天）\n- [ ] 回滚脚本准备并测试\n- [ ] 回滚决策流程明确（谁有权决策回滚）\n\n### 9.2 上线当天执行清单\n\n#### 上线时间窗口：周六凌晨 00:00 - 08:00\n\n**00:00 - 01:00: 系统切换准备**\n- [ ] 00:00 上线指挥部成立（战情室）\n- [ ] 00:05 旧系统停止写入（只读模式）\n- [ ] 00:10 导出旧系统最终数据快照\n- [ ] 00:20 验证旧系统数据完整性\n- [ ] 00:30 旧系统完整备份\n- [ ] 00:45 DNS TTL 调整为 60 秒（准备切换）\n- [ ] 00:55 确认所有检查项通过，获得上线批准\n\n**01:00 - 04:00: 数据迁移**\n- [ ] 01:00 启动数据迁移脚本（增量数据）\n- [ ] 02:00 数据迁移进度检查（预期 30%）\n- [ ] 03:00 数据迁移进度检查（预期 70%）\n- [ ] 03:45 数据迁移完成\n- [ ] 03:50 数据验证脚本运行\n\n**04:00 - 06:00: 数据验证与系统启动**\n- [ ] 04:00 数量验证（记录数对比）\n- [ ] 04:15 完整性验证（外键、必填字段）\n- [ ] 04:30 准确性验证（金额汇总、抽样对比）\n- [ ] 04:45 一致性验证（业务逻辑）\n- [ ] 05:00 所有验证通过，获得系统启动批准\n- [ ] 05:05 启动所有微服务\n- [ ] 05:15 验证所有 Pod 健康（kubectl get pods）\n- [ ] 05:20 验证服务间连通性（gRPC 调用测试）\n- [ ] 05:30 验证数据库连接正常\n- [ ] 05:35 验证 Kafka 消息收发正常\n- [ ] 05:40 验证 Redis 缓存正常\n\n**06:00 - 07:00: 烟雾测试（Smoke Test）**\n- [ ] 06:00 管理员登录测试\n- [ ] 06:05 核心功能测试（财务凭证录入）\n- [ ] 06:10 核心功能测试（采购订单创建）\n- [ ] 06:15 核心功能测试（销售订单创建）\n- [ ] 06:20 核心功能测试（库存查询）\n- [ ] 06:25 核心功能测试（报表查询）\n- [ ] 06:30 监控指标检查（CPU、内存、响应时间）\n- [ ] 06:35 日志检查（无严重错误）\n- [ ] 06:40 告警检查（无异常告警）\n- [ ] 06:45 所有烟雾测试通过，获得流量切换批准\n\n**07:00 - 08:00: 流量切换与验证**\n- [ ] 07:00 DNS 切换（指向新系统）\n- [ ] 07:05 灰度放量（5% 流量）\n- [ ] 07:10 监控观察（5 分钟无异常）\n- [ ] 07:15 灰度放量（20% 流量）\n- [ ] 07:20 监控观察（5 分钟无异常）\n- [ ] 07:25 灰度放量（50% 流量）\n- [ ] 07:30 监控观察（5 分钟无异常）\n- [ ] 07:35 全量流量切换（100%）\n- [ ] 07:40 监控观察（10 分钟）\n- [ ] 07:50 确认所有指标正常\n- [ ] 07:55 上线成功宣布\n\n**08:00 之后: 持续监控**\n- [ ] 08:00 发布上线成功公告\n- [ ] 08:00 - 18:00 现场值守（快速响应用户问题）\n- [ ] 全天 24 小时值班（一周）\n\n### 9.3 上线后检查\n\n#### 上线后第 1 天\n- [ ] 监控所有关键指标（无异常）\n- [ ] 收集用户反馈（问题清单）\n- [ ] 快速修复紧急缺陷（Hotfix）\n- [ ] 数据一致性抽查\n- [ ] 每 2 小时汇报运行状况\n\n#### 上线后第 1 周\n- [ ] 每日监控报告\n- [ ] 用户问题统计和分析\n- [ ] 缺陷修复进度跟踪\n- [ ] 性能调优（根据实际负载）\n- [ ] 补充培训（针对高频问题）\n\n#### 上线后第 1 个月\n- [ ] 用户满意度调查\n- [ ] 系统稳定性评估（可用性、性能）\n- [ ] 上线总结会议（经验教训）\n- [ ] 优化项规划（下个版本）\n- [ ] 取消旧系统（如运行稳定）\n\n---\n\n## 十、应急响应预案\n\n### 10.1 应急响应组织架构\n\n#### 应急指挥体系\n\n```\n应急总指挥（CTO/技术VP）\n    ↓\n应急副总指挥（架构师 - 开发者A）\n    ↓\n├── 技术响应组（开发团队）\n│   ├── 组长：架构师\n│   ├── 成员：开发者 B/C/D/E\n│   └── 职责：问题诊断、代码修复、热修复部署\n│\n├── 运维响应组（DevOps 团队）\n│   ├── 组长：开发者D\n│   ├── 成员：外部运维团队（如有）\n│   └── 职责：基础设施恢复、数据库运维、网络排查\n│\n├── 业务协调组（产品经理 + 业务代表）\n│   ├── 组长：产品经理\n│   ├── 成员：业务部门负责人\n│   └── 职责：用户沟通、业务影响评估、临时解决方案\n│\n└── 公关宣传组（市场部/公关部）\n    ├── 组长：市场总监\n    └── 职责：对外公告、舆情监控、客户安抚\n```\n\n#### 值班制度\n\n**7x24 小时值班**:\n- **上线后第 1 周**: 全员待命\n- **上线后第 2-4 周**: 2 人轮班\n- **稳定运行后**: 1 人值班 + 1 人 Backup\n\n**值班排班表**:\n| 时间段 | 一线值班 | 二线值班 | 三线值班（架构师）|\n|--------|---------|---------|-----------------|\n| 工作日白天 | 开发者E | 开发者D | 开发者A |\n| 工作日夜间 | 开发者B | 开发者C | 开发者A |\n| 周末白天 | 开发者C | 开发者B | 开发者A |\n| 周末夜间 | 开发者D | 开发者E | 开发者A |\n\n**值班职责**:\n- 监控告警响应（15 分钟内）\n- 初步问题诊断\n- 升级严重问题\n- 记录事故日志\n\n### 10.2 故障等级定义\n\n#### P0 - 致命故障（Critical）\n\n**定义**:\n- 系统完全不可用\n- 核心业务功能完全中断\n- 大规模数据丢失\n- 严重安全漏洞被利用\n\n**响应时间**: 立即响应（5 分钟内）\n**解决时间目标**: 1 小时内恢复服务\n\n**示例**:\n- 数据库主库宕机，无法写入\n- API Gateway 宕机，所有请求失败\n- 核心微服务（财务、销售）全部 Pod 崩溃\n- 生产数据被误删除\n- 用户密码泄露\n\n**响应流程**:\n1. 立即拉起应急响应群\n2. 总指挥主持应急会议（5 分钟内）\n3. 技术组立即诊断（并行多人排查）\n4. 运维组准备回滚/故障转移\n5. 业务组评估影响、准备公告\n6. 每 15 分钟汇报进度\n\n#### P1 - 严重故障（High）\n\n**定义**:\n- 关键功能不可用（但系统部分可用）\n- 性能严重下降（响应时间 > 5 秒）\n- 影响大量用户（> 30%）\n\n**响应时间**: 30 分钟内\n**解决时间目标**: 4 小时内\n\n**示例**:\n- 财务模块无法过账凭证\n- 库存查询超时\n- 报表生成失败\n- 数据库从库延迟 > 10 秒\n\n**响应流程**:\n1. 值班人员拉起技术响应组\n2. 30 分钟内完成初步诊断\n3. 1 小时内提供临时解决方案\n4. 4 小时内彻底修复\n\n#### P2 - 一般故障（Medium）\n\n**定义**:\n- 非核心功能不可用\n- 性能轻微下降\n- 影响少量用户（< 10%）\n\n**响应时间**: 2 小时内\n**解决时间目标**: 1 个工作日\n\n**示例**:\n- 某个报表无法导出\n- 搜索功能偶尔超时\n- 个别用户无法登录\n\n**响应流程**:\n1. 值班人员记录问题\n2. 工作时间内处理\n3. 通过 Hotfix 或下个版本修复\n\n#### P3 - 低优先级问题（Low）\n\n**定义**:\n- 不影响功能的 Bug\n- UI 显示问题\n- 性能优化建议\n\n**响应时间**: 1 周内\n**解决时间目标**: 下个迭代\n\n**示例**:\n- 按钮文字错误\n- 页面布局不美观\n- 某个查询可以优化\n\n**响应流程**:\n1. 记录到缺陷跟踪系统\n2. 纳入开发计划\n3. 正常迭代修复\n\n### 10.3 常见故障应急预案\n\n#### 场景 1: 数据库主库宕机\n\n**故障现象**:\n- 所有写入操作失败\n- 大量 500 错误\n- 告警: \"Database connection failed\"\n\n**应急操作步骤**:\n\n**Step 1: 立即止损（5 分钟内）**\n```\n目标：防止数据损坏\n操作：\n1. 切换应用为只读模式（禁用写入 API）\n   kubectl scale deployment <write-services> --replicas=0\n2. 确认从库状态健康\n3. 通知用户：系统维护中\n```\n\n**Step 2: 故障转移（10 分钟内）**\n```\n目标：恢复服务\n操作：\n1. 提升从库为主库\n   pg_ctl promote -D /var/lib/postgresql/data\n2. 验证新主库可写入\n   psql -c \"CREATE TABLE test_write(id int);\"\n3. 更新应用数据库连接配置\n   kubectl set env deployment/<all-services> \\\n     DATABASE_URL=postgresql://new-master:5432/db\n4. 启动写入服务\n   kubectl scale deployment <write-services> --replicas=3\n```\n\n**Step 3: 验证恢复（5 分钟内）**\n```\n验证：\n1. 写入测试数据\n2. 监控错误率（应降至 < 0.1%）\n3. 监控响应时间（应恢复正常）\n```\n\n**Step 4: 根本原因分析**\n```\n事后：\n1. 检查旧主库日志\n2. 分析宕机原因（硬件、软件、配置）\n3. 制定预防措施\n4. 编写 Post-mortem 报告\n```\n\n**预计恢复时间**: 20 分钟\n\n#### 场景 2: Kafka 集群故障\n\n**故障现象**:\n- 事件无法发布\n- 消费者 Lag 持续增长\n- 告警: \"Kafka broker unreachable\"\n\n**应急操作步骤**:\n\n**Step 1: 评估影响（5 分钟）**\n```\n检查：\n1. 哪些 Broker 宕机（1 个 vs 多个）\n2. 哪些 Topic 受影响\n3. 数据是否丢失（副本因子检查）\n```\n\n**Step 2: 降级策略（10 分钟）**\n```\n短期方案：\n1. 如果 Kafka 完全不可用，启用降级模式\n   - 事件暂存到数据库（events 表）\n   - 定时任务补发到 Kafka（恢复后）\n2. 增加事件生产者重试次数\n3. 调整消费者容错策略（跳过错误消息）\n```\n\n**Step 3: 修复 Kafka（30 分钟）**\n```\n操作：\n1. 重启宕机的 Broker\n   kubectl rollout restart statefulset/kafka\n2. 检查副本同步状态\n   kafka-topics.sh --describe --topic <topic-name>\n3. 手动触发 Leader 选举（如需要）\n   kafka-leader-election.sh --all-topic-partitions\n```\n\n**Step 4: 补发事件（按需）**\n```\n恢复后：\n1. 查询暂存的事件\n   SELECT * FROM events WHERE kafka_published = false\n2. 批量重新发布\n3. 标记为已发布\n```\n\n**预计恢复时间**: 45 分钟\n\n#### 场景 3: 内存泄漏导致服务 OOM\n\n**故障现象**:\n- Pod 频繁重启（CrashLoopBackOff）\n- 内存使用率持续上升至 100%\n- 告警: \"Pod OOMKilled\"\n\n**应急操作步骤**:\n\n**Step 1: 快速恢复（5 分钟）**\n```\n临时方案：\n1. 增加内存限制（临时缓解）\n   kubectl set resources deployment/<service> \\\n     --limits=memory=2Gi\n2. 扩容 Pod 副本数（负载分散）\n   kubectl scale deployment/<service> --replicas=6\n```\n\n**Step 2: 问题定位（30 分钟）**\n```\n诊断：\n1. 查看内存快照（如有内存 profiling）\n2. 检查日志中的异常（大对象分配）\n3. 代码审查（查找未释放的资源）\n   - 未关闭的数据库连接\n   - 未释放的缓存\n   - 循环引用\n```\n\n**Step 3: 代码修复（2 小时）**\n```\n修复：\n1. 修复泄漏代码\n2. 本地测试验证（运行压测 24 小时）\n3. 发布 Hotfix 版本\n```\n\n**Step 4: 灰度发布（1 小时）**\n```\n部署：\n1. 先更新 1 个 Pod\n2. 观察内存趋势（1 小时）\n3. 逐步替换所有 Pod\n```\n\n**预计解决时间**: 4 小时\n\n#### 场景 4: DDoS 攻击\n\n**故障现象**:\n- 请求量暴增（10 倍以上）\n- 正常用户无法访问\n- 服务器 CPU/带宽打满\n- 告警: \"Request rate spike\"\n\n**应急操作步骤**:\n\n**Step 1: 确认攻击（5 分钟）**\n```\n分析：\n1. 查看流量来源 IP（是否集中）\n2. 查看请求特征（User-Agent、路径）\n3. 区分真实用户 vs 攻击流量\n```\n\n**Step 2: 黑名单封禁（10 分钟）**\n```\n防御：\n1. 在 API Gateway 层封禁攻击 IP\n   kubectl edit configmap kong-config\n   # 添加 IP 黑名单\n2. 启用严格的限流策略\n   - 每 IP: 10 req/min\n   - 全局: 1000 req/sec\n3. 启用 CAPTCHA（人机验证）\n```\n\n**Step 3: CDN 防护（20 分钟）**\n```\n云服务：\n1. 启用云厂商 DDoS 防护\n2. 配置 WAF 规则（阻止恶意请求）\n3. 启用 JS 挑战（验证浏览器）\n```\n\n**Step 4: 扩容应对（30 分钟）**\n```\n如无法完全阻止：\n1. 紧急扩容（临时应对）\n   kubectl scale deployment --all --replicas=10\n2. 联系云厂商技术支持\n3. 考虑临时切换到维护页面\n```\n\n**预计恢复时间**: 1 小时\n\n### 10.4 应急演练计划\n\n#### 演练目标\n- 验证应急预案可执行性\n- 提升团队应急响应能力\n- 识别流程中的缺陷\n\n#### 演练频率\n- **全员演练**: 每季度一次（3 个月）\n- **小组演练**: 每月一次\n- **新人演练**: 入职第二周\n\n#### 演练场景\n\n**第 1 季度演练: 数据库故障**\n- **时间**: 上线后第 3 个月\n- **场景**: 模拟生产数据库主库宕机\n- **参与人**: 全员\n- **步骤**:\n  1. 随机时间触发（不提前通知）\n  2. 手动停止数据库主库\n  3. 值班人员响应\n  4. 执行故障转移流程\n  5. 验证服务恢复\n  6. 复盘总结\n\n**第 2 季度演练: 微服务级联故障**\n- **场景**: 某个核心服务宕机引发雪崩\n- **重点**: 熔断器、限流、降级策略\n\n**第 3 季度演练: 安全事件响应**\n- **场景**: 发现疑似数据泄露\n- **重点**: 安全事件上报、取证、止损\n\n**第 4 季度演练: 全链路压测 + 故障注入**\n- **场景**: 双十一大促压力测试 + 随机故障注入\n- **重点**: 极限压力下的系统稳定性\n\n#### 演练评估\n\n**评估维度**:\n- ✅ 响应时间（是否满足 SLA）\n- ✅ 操作正确性（是否按预案执行）\n- ✅ 沟通效率（信息传递是否及时）\n- ✅ 问题解决（是否成功恢复服务）\n\n**改进措施**:\n- 更新应急预案\n- 优化监控告警\n- 补充自动化工具\n- 加强人员培训\n\n---\n\n## 十一、运维交接计划\n\n### 11.1 运维能力建设\n\n#### 运维团队组建（如有独立运维团队）\n\n**运维团队结构**:\n```\n运维负责人（1 人）\n    ├── 系统运维工程师（2 人）\n    │   └── 职责：服务器、网络、存储管理\n    ├── 数据库运维工程师（DBA）（1 人）\n    │   └── 职责：数据库优化、备份恢复\n    └── 应用运维工程师（SRE）（2 人）\n        └── 职责：应用部署、监控告警、故障响应\n```\n\n**技能要求**:\n- Kubernetes 运维经验\n- PostgreSQL 管理经验\n- Kafka 运维经验\n- 监控工具使用（Prometheus、Grafana）\n- 脚本编写能力（Bash、Python）\n- 故障排查能力\n\n#### 运维培训计划\n\n**第 11 个月: 提前培训运维团队**\n\n**Week 1-2: 系统架构培训**\n- 整体架构讲解\n- 微服务通信机制\n- 数据流向图\n- 关键技术栈介绍\n\n**Week 3-4: 实操培训**\n- Kubernetes 集群管理\n- 服务部署与升级\n- 配置管理（ConfigMap、Secret）\n- 日志查看与分析\n- 监控告警配置\n\n**第 12 个月: 跟随实习**\n- Week 1-2: 跟随开发团队观察日常运维\n- Week 3: 在开发团队指导下执行运维操作\n- Week 4: 独立执行运维操作（开发团队旁站）\n\n### 11.2 运维交接内容\n\n#### 交接文档清单\n\n**系统文档**:\n- [ ] 系统架构设计文档\n- [ ] 网络拓扑图\n- [ ] 数据流向图\n- [ ] 部署架构图\n- [ ] 服务依赖关系图\n\n**运维手册**:\n- [ ] 日常巡检清单\n- [ ] 常见问题排查手册\n- [ ] 应急响应预案\n- [ ] 备份恢复操作手册\n- [ ] 监控告警手册\n- [ ] 发布操作手册\n- [ ] 数据库运维手册\n- [ ] Kafka 运维手册\n\n**配置清单**:\n- [ ] 服务器清单（IP、角色、配置）\n- [ ] 账号密码清单（加密存储）\n- [ ] 域名与证书清单\n- [ ] 第三方服务清单（账号、API Key）\n- [ ] 监控告警联系人清单\n\n**运维工具**:\n- [ ] 部署脚本（Helm Charts、Kustomize）\n- [ ] 监控 Dashboard 模板\n- [ ] 日常巡检脚本\n- [ ] 备份恢复脚本\n- [ ] 性能测试脚本\n\n#### 运维权限交接\n\n**访问权限**:\n- [ ] Kubernetes 集群管理员权限\n- [ ] 生产数据库管理员权限\n- [ ] 云平台管理控制台权限\n- [ ] 监控系统管理员权限\n- [ ] 代码仓库访问权限（只读）\n- [ ] 文档系统访问权限\n\n**告警通道**:\n- [ ] 告警接收人配置（邮件、短信、电话）\n- [ ] 值班排班系统账号\n- [ ] 应急响应群拉入\n\n### 11.3 双周陪跑期（上线后 2 周）\n\n**目标**: 开发团队和运维团队共同值守，确保平稳过渡\n\n**第 1 周: 开发主导，运维协助**\n- 开发团队处理所有问题\n- 运维团队观察学习\n- 每日复盘会议（30 分钟）\n\n**第 2 周: 运维主导，开发指导**\n- 运维团队处理问题\n- 开发团队提供指导\n- 逐步减少干预\n\n**第 3 周起: 运维独立，开发 Backup**\n- 运维团队独立运维\n- 开发团队保持待命（二线支持）\n\n### 11.4 长期协作机制\n\n#### 定期沟通\n\n**周会**:\n- **时间**: 每周一上午 10:00-11:00\n- **参与人**: 开发负责人 + 运维负责人\n- **议题**:\n  - 上周系统运行情况回顾\n  - 本周发布计划\n  - 问题和需求讨论\n\n**月会**:\n- **时间**: 每月最后一个周五下午\n- **参与人**: 全体开发 + 全体运维\n- **议题**:\n  - 月度运维报告\n  - 系统优化建议\n  - 下月重点工作\n\n#### 协作流程\n\n**发布协作**:\n```\n开发完成 → 提交发布申请（Jira Ticket）→ 运维审核 →\n运维执行部署 → 开发验证 → 发布完成\n```\n\n**故障协作**:\n```\n监控告警 → 运维初步诊断 → 判断是否需要开发介入 →\n（如需要）拉起开发团队 → 共同排查 → 问题解决 → Post-mortem\n```\n\n**优化协作**:\n```\n运维发现性能问题 → 提交优化建议 → 开发评估 →\n纳入开发计划 → 开发优化 → 运维验证\n```\n\n---\n\n## 十二、长期演进路线图\n\n### 12.1 第一阶段（第 13-18 个月）：功能完善与优化\n\n#### 13-15 个月: 用户反馈驱动的优化\n\n**目标**: 根据用户反馈快速迭代，提升用户体验\n\n**功能增强**:\n- **财务模块**:\n  - 支持多账套（Multi-Tenancy）\n  - 高级报表（现金流量表、管理报表）\n  - 预算管理和预算控制\n  - 自动对账功能\n\n- **供应链模块**:\n  - 供应商协同平台（SRM Portal）\n  - 高级排程（APS - Advanced Planning & Scheduling）\n  - 质量追溯（批次号全链路追踪）\n  - VMI（供应商管理库存）\n\n- **HR 模块**:\n  - 绩效管理增强（360 度评估）\n  - 培训管理系统\n  - 招聘门户（Careers Site）\n  - 员工自助 App（移动端）\n\n**性能优化**:\n- 数据库查询优化（慢查询优化）\n- 缓存策略优化（提高命中率）\n- 前端性能优化（懒加载、代码分割）\n- API 响应时间优化（目标 P99 < 100ms）\n\n**用户体验提升**:\n- UI/UX 改版（更现代化的设计）\n- 快捷键支持\n- 批量操作功能\n- 智能搜索（全文搜索 + 模糊匹配）\n\n#### 16-18 个月: 移动化与国际化\n\n**移动端开发**:\n- **技术选型**: React Native / Flutter\n- **功能优先级**:\n  - Phase 1: 移动审批（请假、报销、采购审批）\n  - Phase 2: 移动查询（订单、库存、报表）\n  - Phase 3: 移动录入（简化版数据录入）\n\n**国际化支持**:\n- **多语言**:\n  - 支持中文、英文、日文、德文\n  - 语言包管理\n  - 动态切换语言\n- **多币种**:\n  - 支持 100+ 币种\n  - 实时汇率获取（对接汇率 API）\n  - 多币种报表\n- **多时区**:\n  - 自动时区转换\n  - 时区感知的日期时间处理\n\n### 12.2 第二阶段（第 19-24 个月）：智能化与生态建设\n\n#### 19-21 个月: AI 与大数据分析\n\n**智能推荐**:\n- **采购推荐**:\n  - 基于历史数据预测采购需求\n  - 推荐最优供应商\n  - 价格预警（异常价格检测）\n\n- **库存优化**:\n  - 智能补货建议（基于销售预测）\n  - 安全库存优化\n  - 滞销品预警\n\n- **财务分析**:\n  - 异常交易检测（AI 驱动的审计）\n  - 现金流预测\n  - 成本优化建议\n\n**商业智能增强**:\n- **数据仓库建设**:\n  - 星型模型设计\n  - ETL 流程自动化\n  - 实时数据同步\n\n- **高级分析**:\n  - 自定义 Dashboard\n  - 拖拽式报表设计器\n  - 预测分析（机器学习模型）\n\n**技术栈**:\n- **机器学习**: Rust ML 库（linfa）或 Python（调用 API）\n- **大数据**: ClickHouse（OLAP 数据库）\n- **BI 工具**: Metabase / Superset\n\n#### 22-24 个月: 行业定制与生态集成\n\n**行业化解决方案**:\n- **制造业**:\n  - MES（制造执行系统）集成\n  - 设备物联网（IoT）数据采集\n  - 工业 4.0 功能（数字孪生）\n\n- **零售业**:\n  - POS 系统集成\n  - 会员管理\n  - 全渠道库存（线上线下打通）\n\n- **服务业**:\n  - 项目管理增强\n  - 工时管理\n  - 客户合同管理\n\n**第三方集成**:\n- **电商平台对接**:\n  - 淘宝、京东订单自动同步\n  - 库存实时同步\n  - 物流跟踪\n\n- **支付平台对接**:\n  - 支付宝、微信支付\n  - 银行网关对接\n  - 自动对账\n\n- **办公平台集成**:\n  - 钉钉、企业微信集成\n  - 飞书审批流程\n  - 邮件系统集成\n\n**开放平台建设**:\n- **API 市场**:\n  - 开放 REST API 给第三方\n  - API 文档和 SDK\n  - 开发者门户\n\n- **插件系统**:\n  - 允许第三方开发插件\n  - 插件市场\n  - 插件沙箱机制\n\n### 12.3 第三阶段（第 25-36 个月）：SaaS 化与云原生演进\n\n#### 25-27 个月: 多租户架构改造\n\n**多租户策略**:\n- **数据隔离方案**:\n  - 方案 1: 每租户独立数据库（数据隔离性最强，成本高）\n  - 方案 2: 共享数据库 + Schema 隔离（平衡方案）\n  - 方案 3: 共享 Schema + tenant_id 字段（成本最低，需严格权限控制）\n  - **推荐**: 方案 2（每租户一个 Schema）\n\n**租户管理**:\n- 租户注册、开通、注销\n- 租户配置（功能开关、数据配额）\n- 租户计费（按用户数、按存储、按 API 调用）\n- 租户隔离性验证（跨租户数据泄露测试）\n\n**SaaS 化功能**:\n- 自助开通（在线注册 → 自动开通）\n- 试用期管理（14 天免费试用）\n- 订阅计费（月付、年付）\n- 套餐管理（基础版、专业版、企业版）\n\n#### 28-30 个月: 云原生能力提升\n\n**Serverless 架构探索**:\n- **Function as a Service (FaaS)**:\n  - 使用 AWS Lambda / Knative\n  - 适用场景: 报表生成、批处理任务\n  - 优势: 按需计费、自动扩缩容\n\n**Service Mesh 深化应用**:\n- **Istio 高级功能**:\n  - 流量镜像（Traffic Mirroring）用于灰度测试\n  - 金丝雀发布自动化（基于指标自动推进）\n  - 熔断和重试策略精细化配置\n  - 服务间访问控制（Authorization Policies）\n\n**边缘计算**:\n- **边缘节点部署**:\n  - 在客户本地部署边缘节点（离线可用）\n  - 边缘 - 云端数据同步\n  - 适用: 零售门店、工厂车间\n\n#### 31-36 个月: 生态与商业化\n\n**合作伙伴生态**:\n- **ISV 合作**:\n  - 招募独立软件供应商\n  - 提供 API 和技术支持\n  - 构建应用市场\n\n**行业联盟**:\n- 加入行业标准组织\n- 推动 ERP 标准化\n- 参与开源社区（Rust 生态贡献）\n\n**商业化运营**:\n- **SaaS 定价策略**:\n  - 基础版: 免费（最多 5 用户）\n  - 专业版: 199 元/用户/月\n  - 企业版: 499 元/用户/月 + 定制服务\n- **私有化部署**:\n  - License 销售模式\n  - 技术支持服务（年费）\n- **培训认证**:\n  - 认证课程（用户认证、实施顾问认证）\n  - 培训收入\n\n### 12.4 技术债务管理\n\n**技术债务定期评估**（每季度）:\n- 识别代码中的技术债务（复杂度、重复代码、过时依赖）\n- 优先级排序（根据影响和修复成本）\n- 分配修复资源（每个 Sprint 预留 20% 时间）\n\n**重构计划**:\n- **大规模重构**（每年一次）:\n  - 升级核心依赖（Rust、Tokio、Axum）\n  - 架构优化（微服务拆分或合并）\n  - 数据库 Schema 优化\n\n**技术选型演进**:\n- 持续关注技术趋势\n- 定期评估新技术（每季度技术雷达会议）\n- 小范围试点 → 推广应用\n\n---\n\n## 十三、附录\n\n### 13.1 术语表\n\n| 术语 | 英文 | 解释 |\n|-----|------|------|\n| DDD | Domain-Driven Design | 领域驱动设计，一种软件开发方法论 |\n| CQRS | Command Query Responsibility Segregation | 命令查询职责分离模式 |\n| Event Sourcing | Event Sourcing | 事件溯源，通过事件序列重建状态 |\n| Saga | Saga Pattern | 分布式事务处理模式 |\n| Circuit Breaker | Circuit Breaker | 熔断器，防止级联故障 |\n| Blue-Green Deployment | 蓝绿部署 | 零停机部署策略 |\n| Canary Release | 金丝雀发布 | 灰度发布策略 |\n| Post-mortem | Post-mortem | 事故复盘，无责备文化的故障分析 |\n| SLA | Service Level Agreement | 服务等级协议 |\n| SLO | Service Level Objective | 服务等级目标 |\n| SLI | Service Level Indicator | 服务等级指标 |\n| RTO | Recovery Time Objective | 恢复时间目标 |\n| RPO | Recovery Point Objective | 恢复点目标 |\n| P99 | 99th Percentile | 99 分位数，性能指标 |\n| TPS | Transactions Per Second | 每秒事务数 |\n| QPS | Queries Per Second | 每秒查询数 |\n\n### 13.2 缩写词汇表\n\n| 缩写 | 全称 | 中文 |\n|-----|------|------|\n| API | Application Programming Interface | 应用程序接口 |\n| CI/CD | Continuous Integration / Continuous Deployment | 持续集成/持续部署 |\n| DTO | Data Transfer Object | 数据传输对象 |\n| ORM | Object-Relational Mapping | 对象关系映射 |\n| gRPC | gRPC Remote Procedure Call | 远程过程调用框架 |\n| K8s | Kubernetes | 容器编排平台 |\n| YAML | YAML Ain't Markup Language | 配置文件格式 |\n| JSON | JavaScript Object Notation | 数据交换格式 |\n| SQL | Structured Query Language | 结构化查询语言 |\n| NoSQL | Not Only SQL | 非关系型数据库 |\n| OLTP | Online Transaction Processing | 联机事务处理 |\n| OLAP | Online Analytical Processing | 联机分析处理 |\n| ETL | Extract, Transform, Load | 数据抽取、转换、加载 |\n| BI | Business Intelligence | 商业智能 |\n| MRP | Material Requirements Planning | 物料需求计划 |\n| BOM | Bill of Materials | 物料清单 |\n| WBS | Work Breakdown Structure | 工作分解结构 |\n| SKU | Stock Keeping Unit | 库存单位 |\n| P2P | Procure to Pay | 采购到付款流程 |\n| O2C | Order to Cash | 订单到现金流程 |\n| IoT | Internet of Things | 物联网 |\n| AI | Artificial Intelligence | 人工智能 |\n| ML | Machine Learning | 机器学习 |\n\n### 13.3 关键联系人\n\n| 角色 | 姓名 | 联系方式 | 备注 |\n|-----|------|---------|------|\n| 项目总监 | 待定 | 电话: xxx | 重大决策 |\n| 架构师 | 开发者A | 电话: xxx | 技术问题升级 |\n| 财务模块负责人 | 开发者B | 电话: xxx | 财务相关 |\n| 供应链模块负责人 | 开发者C | 电话: xxx | 供应链相关 |\n| DevOps 负责人 | 开发者D | 电话: xxx | 基础设施问题 |\n| 全栈开发负责人 | 开发者E | 电话: xxx | HR/质量模块 |\n| 运维负责人 | 待定 | 电话: xxx | 日常运维 |\n| 业务方负责人 | 待定 | 电话: xxx | 业务需求 |\n| 云厂商技术支持 | - | 400-xxx-xxxx | 基础设施故障 |\n\n### 13.4 重要日期\n\n| 日期 | 事件 | 责任人 |\n|-----|------|-------|\n| 2025-12-21 | 项目启动 | 架构师 |\n| 2026-02-28 | 第一阶段完成（基础设施） | DevOps 负责人 |\n| 2026-05-31 | 第二阶段完成（财务模块） | 财务模块负责人 |\n| 2026-08-31 | 第三阶段完成（供应链模块） | 供应链模块负责人 |\n| 2026-10-31 | 第四阶段完成（HR/质量模块） | 全栈开发负责人 |\n| 2026-11-30 | 第五阶段完成（集成测试） | 架构师 |\n| 2026-12-21 | 正式上线 | 全体 |\n\n### 13.5 相关文档链接\n\n| 文档名称 | 路径/链接 |\n|---------|---------|\n| 系统架构设计文档 | `/docs/architecture/system-design.md` |\n| API 设计文档 | `/docs/api/api-design.md` |\n| 数据库设计文档 | `/docs/database/schema-design.md` |\n| 开发规范文档 | `/docs/development/coding-standards.md` |\n| 运维操作手册 | `/docs/operations/runbook.md` |\n| 应急响应预案 | `/docs/operations/emergency-response.md` |\n| 用户手册 | `/docs/user-guide/` |\n| 培训材料 | `/docs/training/` |\n\n### 13.6 工具与平台\n\n| 工具类型 | 工具名称 | 访问地址 | 用途 |\n|---------|---------|---------|------|\n| 代码托管 | GitHub | https://github.com/your-org/rust-erp | 代码管理 |\n| 项目管理 | Jira | https://your-org.atlassian.net | 任务跟踪 |\n| 文档管理 | Confluence | https://your-org.atlassian.net/wiki | 知识库 |\n| 监控 | Grafana | https://grafana.your-domain.com | 监控可视化 |\n| 日志 | Loki | https://loki.your-domain.com | 日志查询 |\n| 链路追踪 | Jaeger | https://jaeger.your-domain.com | 分布式追踪 |\n| CI/CD | GitHub Actions | - | 持续集成 |\n| 容器仓库 | GHCR | https://ghcr.io | 镜像存储 |\n\n---\n\n## 结语\n\n本文档为 Rust ERP 系统的上线运维与长期演进提供了全面的指导。成功的关键在于：\n\n1. **充分准备**: 上线前严格执行检查清单，不遗漏任何细节\n2. **快速响应**: 建立完善的应急响应机制，确保故障快速恢复\n3. **平稳交接**: 运维团队提前培训，开发团队陪跑支持\n4. **持续演进**: 根据业务发展和技术趋势，不断优化系统\n\n**项目成功标准**:\n- ✅ 按时交付（12 个月内上线）\n- ✅ 质量达标（可用性 > 99.9%，性能满足 SLA）\n- ✅ 用户满意（用户满意度 > 85%）\n- ✅ 成本可控（预算偏差 < 10%）\n- ✅ 团队成长（团队技能提升，知识沉淀）\n\n---\n\n**文档版本**: v1.0\n**最后更新**: 2025-12-21\n**维护者**: Rust ERP 项目组\n**下次审阅**: 2026-03-21\n\n---\n\n**祝项目圆满成功！**\n", "md/Rust-Open.md": "# Rust ERP 系统开发环境搭建指南\n\n## 1. 环境要求\n\n### 1.1 硬件要求\n\n| 配置项 | 最低要求 | 推荐配置 |\n|-------|---------|---------|\n| CPU | 4核 | 8核及以上 |\n| 内存 | 8GB | 16GB及以上 |\n| 硬盘 | 50GB 可用空间 | 100GB SSD |\n| 操作系统 | macOS 12+, Ubuntu 20.04+, Windows 11 | macOS 13+, Ubuntu 22.04+ |\n\n### 1.2 软件依赖\n\n| 软件 | 版本要求 | 用途 |\n|-----|---------|------|\n| Rust | 1.75+ (Edition 2021) | 主要编程语言 |\n| PostgreSQL | 16+ | 主数据库 |\n| Redis | 7+ | 缓存 |\n| ClickHouse | 23.8+ | 分析服务数据仓库 |\n| Docker | 24+ | 容器化 |\n| Docker Compose | 2.20+ | 本地服务编排 |\n| Kafka | 3.6+ | 消息队列 |\n| Git | 2.40+ | 版本控制 |\n| Node.js | 20+ (可选) | 前端开发 |\n\n---\n\n## 2. 开发工具安装\n\n### 2.1 安装 Rust\n\n#### macOS / Linux\n\n```bash\n# 安装 rustup（Rust 工具链管理器）\ncurl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n\n# 配置环境变量\nsource $HOME/.cargo/env\n\n# 验证安装\nrustc --version\ncargo --version\n\n# 安装 Rust Edition 2021\nrustup default stable\n```\n\n#### Windows\n\n```powershell\n# 下载并运行 rustup-init.exe\n# https://rustup.rs/\n\n# 验证安装\nrustc --version\ncargo --version\n```\n\n### 2.2 安装必要的 Rust 工具\n\n```bash\n# 代码格式化工具\nrustup component add rustfmt\n\n# 静态分析工具（Linter）\nrustup component add clippy\n\n# LLVM 覆盖率工具\nrustup component add llvm-tools-preview\n\n# 安装 cargo-watch（自动重新编译）\ncargo install cargo-watch\n\n# 安装 cargo-tarpaulin（代码覆盖率）\ncargo install cargo-tarpaulin\n\n# 安装 sqlx-cli（数据库迁移工具）\ncargo install sqlx-cli --features postgres\n\n# 安装 cargo-expand（宏展开查看工具）\ncargo install cargo-expand\n\n# 安装 cargo-audit（依赖安全审计）\ncargo install cargo-audit\n```\n\n---\n\n## 3. 数据库环境搭建\n\n### 3.1 使用 Docker Compose 快速启动\n\n项目仓库已经在 `docker/docker-compose.dev.yml` 中预置了开发环境依赖（数据库、缓存、消息队列、监控等），下面截取关键内容，并补充新增的 ClickHouse 服务配置：\n\n```yaml\nversion: '3.9'\n\nservices:\n  # PostgreSQL 数据库\n  postgres:\n    image: postgres:16-alpine\n    container_name: erp-postgres\n    environment:\n      POSTGRES_USER: erp_user\n      POSTGRES_PASSWORD: erp_password_dev\n      POSTGRES_DB: erp_dev\n    ports:\n      - \"5432:5432\"\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n      - ./infrastructure/postgres/init:/docker-entrypoint-initdb.d\n    healthcheck:\n      test: [\"CMD-SHELL\", \"pg_isready -U erp_user -d erp_dev\"]\n      interval: 10s\n      timeout: 5s\n      retries: 5\n\n  # PostgreSQL 管理工具\n  pgadmin:\n    image: dpage/pgadmin4:latest\n    container_name: erp-pgadmin\n    environment:\n      PGADMIN_DEFAULT_EMAIL: admin@erp.local\n      PGADMIN_DEFAULT_PASSWORD: admin\n    ports:\n      - \"5050:80\"\n    depends_on:\n      - postgres\n\n  # ClickHouse 数据仓库\n  clickhouse:\n    image: clickhouse/clickhouse-server:23.8\n    container_name: erp-clickhouse\n    environment:\n      CLICKHOUSE_DB: analytics\n      CLICKHOUSE_USER: analytics_user\n      CLICKHOUSE_PASSWORD: analytics_pass\n      CLICKHOUSE_DEFAULT_ACCESS_MANAGEMENT: \"1\"\n    ports:\n      - \"8123:8123\"   # HTTP 接口\n      - \"9000:9000\"   # Native TCP 接口\n    volumes:\n      - clickhouse_data:/var/lib/clickhouse\n      - ./infrastructure/clickhouse/config.d:/etc/clickhouse-server/config.d\n      - ./infrastructure/clickhouse/users.d:/etc/clickhouse-server/users.d\n    ulimits:\n      nofile:\n        soft: 262144\n        hard: 262144\n\n  # Redis 缓存\n  redis:\n    image: redis:7-alpine\n    container_name: erp-redis\n    command: redis-server --appendonly yes --requirepass redis_dev_password\n    ports:\n      - \"6379:6379\"\n    volumes:\n      - redis_data:/data\n    healthcheck:\n      test: [\"CMD\", \"redis-cli\", \"ping\"]\n      interval: 10s\n      timeout: 5s\n      retries: 5\n\n  # Redis 管理工具\n  redis-commander:\n    image: rediscommander/redis-commander:latest\n    container_name: erp-redis-commander\n    environment:\n      REDIS_HOSTS: local:redis:6379:0:redis_dev_password\n    ports:\n      - \"8081:8081\"\n    depends_on:\n      - redis\n\n  # Kafka 和 Zookeeper\n  zookeeper:\n    image: confluentinc/cp-zookeeper:7.5.0\n    container_name: erp-zookeeper\n    environment:\n      ZOOKEEPER_CLIENT_PORT: 2181\n      ZOOKEEPER_TICK_TIME: 2000\n    ports:\n      - \"2181:2181\"\n    volumes:\n      - zookeeper_data:/var/lib/zookeeper/data\n      - zookeeper_log:/var/lib/zookeeper/log\n\n  kafka:\n    image: confluentinc/cp-kafka:7.5.0\n    container_name: erp-kafka\n    depends_on:\n      - zookeeper\n    ports:\n      - \"9092:9092\"\n      - \"9093:9093\"\n    environment:\n      KAFKA_BROKER_ID: 1\n      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181\n      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://localhost:9092,PLAINTEXT_INTERNAL://kafka:9093\n      KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: PLAINTEXT:PLAINTEXT,PLAINTEXT_INTERNAL:PLAINTEXT\n      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1\n      KAFKA_TRANSACTION_STATE_LOG_MIN_ISR: 1\n      KAFKA_TRANSACTION_STATE_LOG_REPLICATION_FACTOR: 1\n    volumes:\n      - kafka_data:/var/lib/kafka/data\n    healthcheck:\n      test: [\"CMD\", \"kafka-topics\", \"--bootstrap-server\", \"localhost:9092\", \"--list\"]\n      interval: 30s\n      timeout: 10s\n      retries: 5\n\n  # Kafka UI\n  kafka-ui:\n    image: provectuslabs/kafka-ui:latest\n    container_name: erp-kafka-ui\n    depends_on:\n      - kafka\n    ports:\n      - \"8080:8080\"\n    environment:\n      KAFKA_CLUSTERS_0_NAME: local\n      KAFKA_CLUSTERS_0_BOOTSTRAPSERVERS: kafka:9093\n\n  # Jaeger 链路追踪\n  jaeger:\n    image: jaegertracing/all-in-one:1.51\n    container_name: erp-jaeger\n    ports:\n      - \"6831:6831/udp\"  # Jaeger agent\n      - \"16686:16686\"    # Jaeger UI\n      - \"14268:14268\"    # Jaeger collector\n    environment:\n      COLLECTOR_ZIPKIN_HOST_PORT: 9411\n\n  # Prometheus 监控\n  prometheus:\n    image: prom/prometheus:v2.48.0\n    container_name: erp-prometheus\n    ports:\n      - \"9090:9090\"\n    volumes:\n      - ./config/prometheus.yml:/etc/prometheus/prometheus.yml\n      - prometheus_data:/prometheus\n    command:\n      - '--config.file=/etc/prometheus/prometheus.yml'\n      - '--storage.tsdb.path=/prometheus'\n\n  # Grafana 可视化\n  grafana:\n    image: grafana/grafana:10.2.2\n    container_name: erp-grafana\n    ports:\n      - \"3000:3000\"\n    environment:\n      GF_SECURITY_ADMIN_PASSWORD: admin\n      GF_SECURITY_ADMIN_USER: admin\n    volumes:\n      - grafana_data:/var/lib/grafana\n      - ./config/grafana/dashboards:/etc/grafana/provisioning/dashboards\n      - ./config/grafana/datasources:/etc/grafana/provisioning/datasources\n    depends_on:\n      - prometheus\n\nvolumes:\n  postgres_data:\n  redis_data:\n  kafka_data:\n  zookeeper_data:\n  zookeeper_log:\n  prometheus_data:\n  grafana_data:\n  clickhouse_data:\n```\n\n为 ClickHouse 创建配置目录并定义默认用户：\n\n```bash\nmkdir -p infrastructure/clickhouse/{config.d,users.d}\ncat > infrastructure/clickhouse/users.d/analytics-user.xml <<'EOF'\n<?xml version=\"1.0\"?>\n<yandex>\n  <users>\n    <analytics_user>\n      <password>analytics_pass</password>\n      <profile>default</profile>\n      <quota>default</quota>\n      <networks>\n        <ip>::/0</ip>\n      </networks>\n      <access_management>1</access_management>\n      <databases>\n        <analytics>\n          <permissions>ALL</permissions>\n        </analytics>\n      </databases>\n    </analytics_user>\n  </users>\n</yandex>\nEOF\n```\n\n> ⚠️ **安全提示**：示例中使用明文密码便于本地调试，生产环境请改为 `password_sha256_hex` 并限制可信网段。\n\n**启动所有服务**：\n\n```bash\n# 启动所有服务\ndocker compose -f docker/docker-compose.dev.yml up -d\n\n# 查看服务状态\ndocker compose -f docker/docker-compose.dev.yml ps\n\n# 查看日志\ndocker compose -f docker/docker-compose.dev.yml logs -f\n\n# 停止所有服务\ndocker compose -f docker/docker-compose.dev.yml down\n\n# 停止并删除数据\ndocker compose -f docker/docker-compose.dev.yml down -v\n```\n\n---\n\n### 3.2 数据库初始化脚本\n\n在 `infrastructure/postgres/init/01-init.sql` 中定义基础数据库：\n\n```sql\n-- 创建多个数据库实例（每个微服务一个数据库）\nCREATE DATABASE financial_db;\nCREATE DATABASE sales_db;\nCREATE DATABASE materials_db;\nCREATE DATABASE hr_db;\nCREATE DATABASE controlling_db;\nCREATE DATABASE production_db;\n\n-- 创建用户并授权\nCREATE USER financial_user WITH PASSWORD 'financial_pass';\nCREATE USER sales_user WITH PASSWORD 'sales_pass';\nCREATE USER materials_user WITH PASSWORD 'materials_pass';\n\nGRANT ALL PRIVILEGES ON DATABASE financial_db TO financial_user;\nGRANT ALL PRIVILEGES ON DATABASE sales_db TO sales_user;\nGRANT ALL PRIVILEGES ON DATABASE materials_db TO materials_user;\n\n-- 切换到 financial_db 创建扩展\n\\c financial_db;\nCREATE EXTENSION IF NOT EXISTS \"pgcrypto\";\nCREATE EXTENSION IF NOT EXISTS \"uuid-ossp\";\n\n\\c sales_db;\nCREATE EXTENSION IF NOT EXISTS \"pgcrypto\";\nCREATE EXTENSION IF NOT EXISTS \"uuid-ossp\";\n\n\\c materials_db;\nCREATE EXTENSION IF NOT EXISTS \"pgcrypto\";\nCREATE EXTENSION IF NOT EXISTS \"uuid-ossp\";\n```\n\n---\n\n### 3.3 手动安装 PostgreSQL（可选）\n\n#### macOS\n\n```bash\n# 使用 Homebrew 安装\nbrew install postgresql@16\n\n# 启动服务\nbrew services start postgresql@16\n\n# 创建数据库\ncreatedb erp_dev\n\n# 连接数据库\npsql erp_dev\n```\n\n#### Ubuntu\n\n```bash\n# 添加官方源\nsudo sh -c 'echo \"deb http://apt.postgresql.org/pub/repos/apt $(lsb_release -cs)-pgdg main\" > /etc/apt/sources.list.d/pgdg.list'\nwget --quiet -O - https://www.postgresql.org/media/keys/ACCC4CF8.asc | sudo apt-key add -\n\n# 安装\nsudo apt-get update\nsudo apt-get install postgresql-16\n\n# 启动服务\nsudo systemctl start postgresql\nsudo systemctl enable postgresql\n\n# 切换到 postgres 用户\nsudo -u postgres psql\n\n# 创建用户和数据库\nCREATE USER erp_user WITH PASSWORD 'erp_password';\nCREATE DATABASE erp_dev OWNER erp_user;\n```\n\n---\n\n## 4. 项目代码结构初始化\n\n### 4.1 克隆项目（假设项目已初始化）\n\n```bash\n# 克隆代码仓库\ngit clone https://github.com/your-org/rust-erp-system.git\ncd rust-erp-system\n\n# 查看目录结构\ntree -L 3\n```\n\n### 4.2 创建新项目（从零开始）\n\n使用以下脚本可以快速搭建与《Rust-ERP系统项目目录结构.md》一致的骨架：\n\n```bash\n# 创建项目根目录\nmkdir erp-system\ncd erp-system\n\n# 初始化 Cargo Workspace\ncat > Cargo.toml <<'EOF'\n[workspace]\nresolver = \"2\"\n\nmembers = [\n    # 共享库\n    \"shared/domain-primitives\",\n    \"shared/event-sourcing\",\n    \"shared/cqrs\",\n    \"shared/observability\",\n    \"shared/messaging\",\n    \"shared/auth\",\n    \"shared/api-contracts\",\n\n    # 微服务\n    \"services/financial-service\",\n    \"services/controlling-service\",\n    \"services/materials-service\",\n    \"services/sales-service\",\n    \"services/production-service\",\n    \"services/hr-service\",\n    \"services/quality-service\",\n    \"services/maintenance-service\",\n    \"services/crm-service\",\n    \"services/project-service\",\n    \"services/scm-service\",\n    \"services/treasury-service\",\n    \"services/warehouse-service\",\n    \"services/shipping-service\",\n    \"services/analytics-service\",\n    \"services/api-gateway\",\n\n    # 开发工具\n    \"tools/cli\",\n    \"tools/migration-tool\",\n    \"tools/load-testing\"\n]\n\n[workspace.package]\nversion = \"0.1.0\"\nedition = \"2021\"\nauthors = [\"ERP Team <team@erp.example.com>\"]\nlicense = \"MIT\"\n\n[workspace.dependencies]\naxum = \"0.7\"\ntokio = { version = \"1.35\", features = [\"full\"] }\ntower = \"0.4\"\ntower-http = { version = \"0.5\", features = [\"trace\", \"cors\"] }\nsqlx = { version = \"0.7\", features = [\"runtime-tokio-rustls\", \"postgres\", \"uuid\", \"chrono\", \"json\"] }\nserde = { version = \"1.0\", features = [\"derive\"] }\nserde_json = \"1.0\"\nthiserror = \"1.0\"\nanyhow = \"1.0\"\ntracing = \"0.1\"\ntracing-subscriber = { version = \"0.3\", features = [\"env-filter\"] }\nuuid = { version = \"1.6\", features = [\"v4\", \"serde\"] }\nchrono = { version = \"0.4\", features = [\"serde\"] }\nvalidator = { version = \"0.16\", features = [\"derive\"] }\ndotenvy = \"0.15\"\nrdkafka = { version = \"0.36\", features = [\"cmake-build\"] }\nredis = { version = \"0.24\", features = [\"tokio-comp\", \"connection-manager\"] }\ntonic = \"0.11\"\nprost = \"0.12\"\nmockall = \"0.12\"\nEOF\n\n# 创建共享库骨架\nfor lib in domain-primitives event-sourcing cqrs observability messaging auth api-contracts; do\n  mkdir -p shared/$lib/src\n  touch shared/$lib/{Cargo.toml,src/lib.rs}\ndone\n\n# 创建微服务骨架（DDD 分层 + 迁移 + 测试目录）\nservices=(financial-service controlling-service materials-service sales-service production-service hr-service quality-service maintenance-service crm-service project-service scm-service treasury-service warehouse-service shipping-service analytics-service api-gateway)\nfor svc in \"${services[@]}\"; do\n  mkdir -p services/$svc/src/{api/{rest/{handlers,dto},grpc},application/{commands,queries,services},domain/{aggregates,value_objects,events,services,repositories},infrastructure/{persistence/{postgres,redis},messaging,config}}\n  mkdir -p services/$svc/{migrations,tests/{integration,unit}}\n  touch services/$svc/Cargo.toml\n  touch services/$svc/src/main.rs\ndone\n\n# 创建资源目录\nmkdir -p proto/{common,financial,controlling,materials,sales,production,hr,quality,maintenance,crm,project,scm,treasury,warehouse,shipping,analytics}/v1\nmkdir -p docker && touch docker/{Dockerfile.service,docker-compose.yml,docker-compose.dev.yml,docker-compose.prod.yml}\nmkdir -p k8s/{base,overlays/{dev,staging,production},helm/erp-system/templates}\nmkdir -p infrastructure/{kafka,postgres/init,redis,monitoring/{prometheus,grafana/{dashboards,datasources},loki,jaeger},clickhouse/{config.d,users.d},scripts}\nmkdir -p docs/{architecture,deployment,development}\nmkdir -p tools/{cli/src,migration-tool/src,load-testing/scenarios}\n```\n\n---\n\n### 4.3 创建财务服务 Cargo.toml\n\n创建 `services/financial-service/Cargo.toml`：\n\n```toml\n[package]\nname = \"financial-service\"\nversion.workspace = true\nedition.workspace = true\nauthors.workspace = true\n\n[dependencies]\n# Workspace 共享依赖\naxum.workspace = true\ntokio.workspace = true\ntower.workspace = true\ntower-http.workspace = true\nsqlx.workspace = true\nserde.workspace = true\nserde_json.workspace = true\nthiserror.workspace = true\nanyhow.workspace = true\ntracing.workspace = true\ntracing-subscriber.workspace = true\nuuid.workspace = true\nchrono.workspace = true\nvalidator.workspace = true\ndotenvy.workspace = true\nrdkafka.workspace = true\nredis.workspace = true\ntonic.workspace = true\nprost.workspace = true\n\n# 内部依赖（共享库）\ndomain-primitives = { path = \"../../shared/domain-primitives\" }\nevent-sourcing = { path = \"../../shared/event-sourcing\" }\ncqrs = { path = \"../../shared/cqrs\" }\nauth = { path = \"../../shared/auth\" }\nobservability = { path = \"../../shared/observability\" }\nmessaging = { path = \"../../shared/messaging\" }\napi-contracts = { path = \"../../shared/api-contracts\" }\n\n# 其他依赖\nasync-trait = \"0.1\"\nfutures = \"0.3\"\n\n[dev-dependencies]\nmockall.workspace = true\ntokio-test = \"0.4\"\ntestcontainers = \"0.15\"\n\n[[bin]]\nname = \"financial-service\"\npath = \"src/main.rs\"\n```\n\n---\n\n### 4.4 创建环境配置文件\n\n创建 `.env.example`：\n\n```bash\n# 应用配置\nAPP_NAME=financial-service\nAPP_ENV=development\nAPP_HOST=0.0.0.0\nAPP_PORT=8000\nLOG_LEVEL=debug\n\n# 数据库配置\nDATABASE_URL=postgres://financial_user:financial_pass@localhost:5432/financial_db\nDATABASE_MAX_CONNECTIONS=10\nDATABASE_MIN_CONNECTIONS=2\n\n# Redis 配置\nREDIS_URL=redis://:redis_dev_password@localhost:6379/0\nREDIS_MAX_CONNECTIONS=10\n\n# Kafka 配置\nKAFKA_BROKERS=localhost:9092\nKAFKA_GROUP_ID=financial-service-group\nKAFKA_TOPIC_TRANSACTION_POSTED=financial.transaction.posted\nKAFKA_TOPIC_ACCOUNT_CREATED=financial.account.created\n\n# JWT 配置\nJWT_SECRET=your-super-secret-jwt-key-change-in-production\nJWT_EXPIRATION_HOURS=1\n\n# OpenTelemetry 配置\nOTEL_EXPORTER_JAEGER_ENDPOINT=http://localhost:14268/api/traces\nOTEL_SERVICE_NAME=financial-service\n\n# Prometheus 配置\nPROMETHEUS_METRICS_PORT=9091\n```\n\n**复制为实际配置**：\n\n```bash\ncp .env.example .env\n```\n\n---\n\n## 5. 运行数据库迁移\n\n### 5.1 使用 SQLx 创建迁移\n\n```bash\n# 进入财务服务目录\ncd services/financial-service\n\n# 设置数据库 URL 环境变量\nexport DATABASE_URL=\"postgres://financial_user:financial_pass@localhost:5432/financial_db\"\n\n# 创建迁移脚本\nsqlx migrate add init_financial_db\n\n# 编辑迁移文件（自动创建在 migrations/ 目录）\n# 文件名类似：migrations/20251221000000_init_financial_db.sql\n```\n\n编辑 `migrations/20251221000000_init_financial_db.sql`：\n\n```sql\n-- 创建 accounts 表\nCREATE TABLE accounts (\n    account_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    account_number VARCHAR(20) NOT NULL UNIQUE,\n    account_name VARCHAR(200) NOT NULL,\n    account_type VARCHAR(20) NOT NULL CHECK (account_type IN ('ASSET', 'LIABILITY', 'EQUITY', 'REVENUE', 'EXPENSE')),\n    currency VARCHAR(3) NOT NULL DEFAULT 'CNY',\n    balance_type VARCHAR(10) NOT NULL CHECK (balance_type IN ('DEBIT', 'CREDIT')),\n    is_active BOOLEAN NOT NULL DEFAULT TRUE,\n    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    created_by UUID NOT NULL,\n    updated_at TIMESTAMP,\n    updated_by UUID,\n    version INTEGER NOT NULL DEFAULT 1,\n    is_deleted BOOLEAN NOT NULL DEFAULT FALSE\n);\n\nCREATE INDEX idx_accounts_number ON accounts(account_number) WHERE is_deleted = FALSE;\nCREATE INDEX idx_accounts_type ON accounts(account_type) WHERE is_deleted = FALSE;\n\n-- 创建 transactions 表\nCREATE TABLE transactions (\n    transaction_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    document_number VARCHAR(50) NOT NULL UNIQUE,\n    document_type VARCHAR(10) NOT NULL,\n    document_date DATE NOT NULL,\n    posting_date DATE NOT NULL,\n    fiscal_year INTEGER NOT NULL,\n    fiscal_period INTEGER NOT NULL,\n    currency VARCHAR(3) NOT NULL,\n    status VARCHAR(20) NOT NULL DEFAULT 'DRAFT' CHECK (status IN ('DRAFT', 'POSTED', 'REVERSED')),\n    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    created_by UUID NOT NULL,\n    posted_at TIMESTAMP,\n    posted_by UUID,\n    version INTEGER NOT NULL DEFAULT 1,\n    is_deleted BOOLEAN NOT NULL DEFAULT FALSE\n);\n\nCREATE INDEX idx_transactions_number ON transactions(document_number);\nCREATE INDEX idx_transactions_posting_date ON transactions(posting_date DESC);\n\n-- 创建 journal_entries 表\nCREATE TABLE journal_entries (\n    entry_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    transaction_id UUID NOT NULL REFERENCES transactions(transaction_id) ON DELETE CASCADE,\n    account_id UUID NOT NULL REFERENCES accounts(account_id),\n    line_number INTEGER NOT NULL,\n    debit_amount DECIMAL(19,2) NOT NULL DEFAULT 0.00,\n    credit_amount DECIMAL(19,2) NOT NULL DEFAULT 0.00,\n    description TEXT,\n    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    created_by UUID NOT NULL,\n    version INTEGER NOT NULL DEFAULT 1,\n    CONSTRAINT uk_entries_transaction_line UNIQUE (transaction_id, line_number),\n    CONSTRAINT ck_entries_amounts CHECK (\n        (debit_amount >= 0 AND credit_amount >= 0) AND\n        (debit_amount = 0 OR credit_amount = 0)\n    )\n);\n\nCREATE INDEX idx_entries_transaction ON journal_entries(transaction_id);\nCREATE INDEX idx_entries_account ON journal_entries(account_id);\n\n-- 插入初始科目数据\nINSERT INTO accounts (account_number, account_name, account_type, balance_type, currency, created_by)\nVALUES\n    ('1001', '现金', 'ASSET', 'DEBIT', 'CNY', '00000000-0000-0000-0000-000000000001'),\n    ('1002', '银行存款', 'ASSET', 'DEBIT', 'CNY', '00000000-0000-0000-0000-000000000001'),\n    ('2001', '应付账款', 'LIABILITY', 'CREDIT', 'CNY', '00000000-0000-0000-0000-000000000001'),\n    ('4001', '主营业务收入', 'REVENUE', 'CREDIT', 'CNY', '00000000-0000-0000-0000-000000000001'),\n    ('5001', '主营业务成本', 'EXPENSE', 'DEBIT', 'CNY', '00000000-0000-0000-0000-000000000001');\n```\n\n**运行迁移**：\n\n```bash\n# 执行迁移\nsqlx migrate run\n\n# 查看迁移历史\nsqlx migrate info\n\n# 回滚最后一次迁移\nsqlx migrate revert\n```\n\n---\n\n## 6. 代码示例：Hello World 服务\n\n创建 `services/financial-service/src/main.rs`：\n\n```rust\nuse axum::{\n    extract::State,\n    http::StatusCode,\n    response::Json,\n    routing::{get, post},\n    Router,\n};\nuse serde::{Deserialize, Serialize};\nuse sqlx::postgres::PgPoolOptions;\nuse std::net::SocketAddr;\nuse tracing::info;\nuse uuid::Uuid;\n\n#[derive(Clone)]\nstruct AppState {\n    db: sqlx::PgPool,\n}\n\n#[derive(Serialize)]\nstruct HealthResponse {\n    status: String,\n    version: String,\n}\n\n#[derive(Serialize)]\nstruct Account {\n    account_id: Uuid,\n    account_number: String,\n    account_name: String,\n    account_type: String,\n}\n\n#[tokio::main]\nasync fn main() -> anyhow::Result<()> {\n    // 初始化日志\n    tracing_subscriber::fmt()\n        .with_env_filter(tracing_subscriber::EnvFilter::from_default_env())\n        .init();\n\n    // 加载环境变量\n    dotenvy::dotenv().ok();\n\n    // 数据库连接\n    let database_url = std::env::var(\"DATABASE_URL\")\n        .expect(\"DATABASE_URL must be set\");\n\n    let db_pool = PgPoolOptions::new()\n        .max_connections(10)\n        .connect(&database_url)\n        .await?;\n\n    info!(\"Connected to database\");\n\n    // 应用状态\n    let state = AppState { db: db_pool };\n\n    // 路由\n    let app = Router::new()\n        .route(\"/health\", get(health_check))\n        .route(\"/api/v1/accounts\", get(list_accounts))\n        .with_state(state);\n\n    // 启动服务器\n    let addr = SocketAddr::from(([0, 0, 0, 0], 8000));\n    info!(\"Starting server on {}\", addr);\n\n    axum::Server::bind(&addr)\n        .serve(app.into_make_service())\n        .await?;\n\n    Ok(())\n}\n\n// 健康检查接口\nasync fn health_check() -> Json<HealthResponse> {\n    Json(HealthResponse {\n        status: \"ok\".to_string(),\n        version: env!(\"CARGO_PKG_VERSION\").to_string(),\n    })\n}\n\n// 查询科目列表\nasync fn list_accounts(\n    State(state): State<AppState>,\n) -> Result<Json<Vec<Account>>, StatusCode> {\n    let accounts = sqlx::query_as!(\n        Account,\n        r#\"\n        SELECT account_id, account_number, account_name, account_type\n        FROM accounts\n        WHERE is_deleted = FALSE\n        ORDER BY account_number\n        LIMIT 10\n        \"#\n    )\n    .fetch_all(&state.db)\n    .await\n    .map_err(|e| {\n        tracing::error!(\"Database error: {}\", e);\n        StatusCode::INTERNAL_SERVER_ERROR\n    })?;\n\n    Ok(Json(accounts))\n}\n```\n\n---\n\n## 7. 编译和运行\n\n### 7.1 编译项目\n\n```bash\n# 回到项目根目录\ncd /path/to/erp-system\n\n# 检查代码格式\ncargo fmt --all -- --check\n\n# 运行 Clippy 静态分析\ncargo clippy --all-targets --all-features -- -D warnings\n\n# 构建项目（debug 模式）\ncargo build\n\n# 构建项目（release 模式）\ncargo build --release\n\n# 运行测试\ncargo test --all\n\n# 查看依赖树\ncargo tree\n```\n\n### 7.2 运行服务\n\n```bash\n# 运行财务服务\ncd services/financial-service\ncargo run\n\n# 或者使用 cargo-watch 自动重新编译\ncargo watch -x run\n\n# 测试健康检查接口\ncurl http://localhost:8000/health\n\n# 测试查询科目接口\ncurl http://localhost:8000/api/v1/accounts\n```\n\n**预期输出**：\n\n```json\n{\n  \"status\": \"ok\",\n  \"version\": \"0.1.0\"\n}\n```\n\n---\n\n## 8. 开发工具推荐\n\n### 8.1 IDE/编辑器\n\n#### VS Code（推荐）\n\n**必装扩展**：\n\n```json\n{\n  \"recommendations\": [\n    \"rust-lang.rust-analyzer\",      // Rust 语言支持\n    \"serayuzgur.crates\",             // Cargo.toml 依赖管理\n    \"tamasfe.even-better-toml\",      // TOML 语法高亮\n    \"vadimcn.vscode-lldb\",           // 调试器\n    \"ms-azuretools.vscode-docker\",   // Docker 支持\n    \"mtxr.sqltools\",                 // SQL 工具\n    \"mtxr.sqltools-driver-pg\"        // PostgreSQL 驱动\n  ]\n}\n```\n\n**配置文件** (`.vscode/settings.json`):\n\n```json\n{\n  \"rust-analyzer.checkOnSave.command\": \"clippy\",\n  \"rust-analyzer.cargo.features\": \"all\",\n  \"editor.formatOnSave\": true,\n  \"[rust]\": {\n    \"editor.defaultFormatter\": \"rust-lang.rust-analyzer\"\n  },\n  \"files.watcherExclude\": {\n    \"**/target/**\": true\n  }\n}\n```\n\n#### IntelliJ IDEA / CLion\n\n安装 Rust 插件（IntelliJ Rust）\n\n---\n\n### 8.2 调试配置\n\n创建 `.vscode/launch.json`：\n\n```json\n{\n  \"version\": \"0.2.0\",\n  \"configurations\": [\n    {\n      \"type\": \"lldb\",\n      \"request\": \"launch\",\n      \"name\": \"Debug Financial Service\",\n      \"cargo\": {\n        \"args\": [\n          \"build\",\n          \"--bin=financial-service\",\n          \"--package=financial-service\"\n        ],\n        \"filter\": {\n          \"name\": \"financial-service\",\n          \"kind\": \"bin\"\n        }\n      },\n      \"args\": [],\n      \"cwd\": \"${workspaceFolder}/services/financial-service\",\n      \"env\": {\n        \"DATABASE_URL\": \"postgres://financial_user:financial_pass@localhost:5432/financial_db\",\n        \"RUST_LOG\": \"debug\"\n      }\n    }\n  ]\n}\n```\n\n---\n\n### 8.3 数据库管理工具\n\n1. **pgAdmin**（已包含在 `docker/docker-compose.dev.yml`）\n   - 访问：http://localhost:5050\n   - 用户名：admin@erp.local\n   - 密码：admin\n\n2. **DBeaver**（推荐）\n   ```bash\n   # macOS\n   brew install --cask dbeaver-community\n\n   # Ubuntu\n   sudo snap install dbeaver-ce\n   ```\n\n3. **psql 命令行**\n   ```bash\n   # 连接数据库\n   psql -h localhost -U financial_user -d financial_db\n\n   # 查看表结构\n   \\d accounts\n\n   # 查询数据\n   SELECT * FROM accounts;\n   ```\n\n---\n\n## 9. 常见问题排查\n\n### 9.1 数据库连接失败\n\n**错误信息**：\n```\nError: error connecting to server: Connection refused\n```\n\n**解决方案**：\n```bash\n# 检查 PostgreSQL 是否运行\ndocker ps | grep postgres\n\n# 查看日志\ndocker compose -f docker/docker-compose.dev.yml logs postgres\n\n# 重启 PostgreSQL\ndocker compose -f docker/docker-compose.dev.yml restart postgres\n```\n\n---\n\n### 9.2 Rust 编译错误\n\n**错误信息**：\n```\nerror: linking with `cc` failed: exit status: 1\n```\n\n**解决方案**（macOS）：\n```bash\n# 安装 Xcode Command Line Tools\nxcode-select --install\n\n# 安装 CMake（Kafka 依赖需要）\nbrew install cmake\n```\n\n**解决方案**（Ubuntu）：\n```bash\n# 安装构建工具\nsudo apt-get install build-essential cmake libssl-dev pkg-config\n```\n\n---\n\n### 9.3 SQLx 编译时检查失败\n\n**错误信息**：\n```\nerror: error occurred while running `sqlx-data.json`\n```\n\n**解决方案**：\n```bash\n# 方案1：离线模式（不检查 SQL）\nexport SQLX_OFFLINE=true\ncargo build\n\n# 方案2：生成 sqlx-data.json\ncargo sqlx prepare -- --lib\n\n# 方案3：运行迁移后再编译\nsqlx migrate run\ncargo build\n```\n\n---\n\n## 10. 开发流程最佳实践\n\n### 10.1 Git 工作流\n\n```bash\n# 1. 创建功能分支\ngit checkout -b feature/add-account-api\n\n# 2. 开发过程中频繁提交\ngit add .\ngit commit -m \"feat: 添加创建科目 API\"\n\n# 3. 提交前检查\ncargo fmt --all\ncargo clippy --all-targets\ncargo test --all\n\n# 4. 推送到远程\ngit push origin feature/add-account-api\n\n# 5. 创建 Pull Request\n```\n\n---\n\n### 10.2 代码审查检查项\n\n- [ ] 代码通过 `cargo fmt` 格式化\n- [ ] 代码通过 `cargo clippy` 静态检查（无警告）\n- [ ] 所有测试通过 `cargo test`\n- [ ] 新增代码有单元测试（覆盖率 > 70%）\n- [ ] 领域层测试覆盖率 100%\n- [ ] API 接口有集成测试\n- [ ] 敏感配置使用环境变量\n- [ ] 错误处理完善（避免 `unwrap()`）\n- [ ] 文档注释完整\n\n---\n\n### 10.3 测试策略\n\n```bash\n# 运行所有测试\ncargo test --all\n\n# 运行单个服务测试\ncargo test --package financial-service\n\n# 运行单个模块测试\ncargo test --package financial-service domain::aggregates::account\n\n# 生成测试覆盖率报告\ncargo tarpaulin --out Html --output-dir coverage\n\n# 查看覆盖率报告\nopen coverage/index.html\n```\n\n---\n\n## 11. 性能调优\n\n### 11.1 编译优化配置\n\n在 `Cargo.toml` 中添加：\n\n```toml\n[profile.dev]\nopt-level = 0          # 开发模式不优化（编译快）\n\n[profile.release]\nopt-level = 3          # 生产模式最高优化\nlto = true             # 启用链接时优化\ncodegen-units = 1      # 单个代码生成单元（更好的优化）\nstrip = true           # 移除调试符号（减小二进制大小）\n```\n\n### 11.2 数据库连接池调优\n\n```rust\nlet db_pool = PgPoolOptions::new()\n    .max_connections(20)           // 最大连接数\n    .min_connections(5)            // 最小连接数\n    .acquire_timeout(Duration::from_secs(30))  // 获取连接超时\n    .idle_timeout(Duration::from_secs(600))    // 空闲连接超时\n    .max_lifetime(Duration::from_secs(1800))   // 连接最大生命周期\n    .connect(&database_url)\n    .await?;\n```\n\n---\n\n## 12. 下一步\n\n完成环境搭建后，可以进行以下步骤：\n\n1. ✅ 运行 `cargo build` 验证环境\n2. ✅ 运行数据库迁移 `sqlx migrate run`\n3. ✅ 启动服务 `cargo run`\n4. ✅ 测试健康检查接口 `curl http://localhost:8000/health`\n5. ⏳ 阅读《API 设计文档》了解接口规范\n6. ⏳ 阅读《数据库设计文档》了解数据模型\n7. ⏳ 开始实现第一个功能模块（创建会计科目 API）\n\n---\n\n## 附录：快速启动脚本\n\n创建 `infrastructure/scripts/dev-setup.sh`：\n\n```bash\n#!/bin/bash\nset -e\n\necho \"🚀 Starting ERP Development Environment Setup\"\n\n# 1. 检查依赖\necho \"📦 Checking dependencies...\"\ncommand -v docker >/dev/null 2>&1 || { echo \"❌ Docker not found\"; exit 1; }\ndocker compose version >/dev/null 2>&1 || { echo \"❌ Docker Compose plugin not found\"; exit 1; }\ncommand -v cargo >/dev/null 2>&1 || { echo \"❌ Rust not found\"; exit 1; }\n\n# 2. 启动 Docker 服务\necho \"🐳 Starting Docker services...\"\ndocker compose -f docker/docker-compose.dev.yml up -d\n\n# 3. 等待数据库就绪\necho \"⏳ Waiting for PostgreSQL...\"\nuntil docker exec erp-postgres pg_isready -U erp_user -d erp_dev; do\n  sleep 2\ndone\n\n# 4. 运行数据库迁移\necho \"📊 Running database migrations...\"\ncd services/financial-service\nexport DATABASE_URL=\"postgres://financial_user:financial_pass@localhost:5432/financial_db\"\nsqlx migrate run\ncd ../..\n\n# 5. 编译项目\necho \"🔨 Building project...\"\ncargo build\n\necho \"✅ Setup complete!\"\necho \"\"\necho \"📝 Quick Start:\"\necho \"  - Start financial service:  cd services/financial-service && cargo run\"\necho \"  - pgAdmin:                  http://localhost:5050\"\necho \"  - Kafka UI:                 http://localhost:8080\"\necho \"  - Jaeger:                   http://localhost:16686\"\necho \"  - Grafana:                  http://localhost:3000\"\n```\n\n**使用方法**：\n\n```bash\nchmod +x infrastructure/scripts/dev-setup.sh\n./infrastructure/scripts/dev-setup.sh\n```\n\n---\n\n**文档版本**: v1.1\n**最后更新**: 2025-12-23\n**维护者**: ERP 开发团队\n", "md/Rust-Sql.md": "# Rust ERP 系统数据库设计文档\n\n## 1. 数据库设计原则\n\n### 1.1 设计理念\n\n- **微服务独立数据库**：每个微服务拥有独立的数据库实例或 Schema\n- **事件溯源**：所有状态变更通过事件记录，支持审计和回溯\n- **CQRS 读写分离**：写模型标准化，读模型反规范化\n- **数据一致性**：通过领域事件实现最终一致性\n- **版本控制**：使用 Flyway/SQLx 管理数据库迁移脚本\n\n### 1.2 命名规范\n\n| 对象类型 | 命名规范 | 示例 |\n|---------|---------|------|\n| 表名 | snake_case 复数 | accounts, transactions |\n| 列名 | snake_case | account_number, created_at |\n| 主键 | {table}_id | account_id, transaction_id |\n| 外键 | {referenced_table}_id | customer_id, material_id |\n| 索引 | idx_{table}_{columns} | idx_accounts_number |\n| 唯一约束 | uk_{table}_{columns} | uk_accounts_number |\n| 检查约束 | ck_{table}_{condition} | ck_transactions_balance |\n\n### 1.3 通用字段\n\n所有业务表包含以下审计字段：\n\n```sql\n-- 审计字段（所有表必备）\ncreated_at      TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\ncreated_by      UUID NOT NULL,  -- 创建人用户ID\nupdated_at      TIMESTAMP,\nupdated_by      UUID,\nversion         INTEGER NOT NULL DEFAULT 1,  -- 乐观锁版本号\nis_deleted      BOOLEAN NOT NULL DEFAULT FALSE,  -- 软删除标记\ndeleted_at      TIMESTAMP,\ndeleted_by      UUID\n```\n\n### 1.4 数据类型规范\n\n| 数据类型 | 用途 | 示例 |\n|---------|------|------|\n| UUID | 主键、外键 | account_id |\n| VARCHAR(n) | 短文本 | account_number VARCHAR(20) |\n| TEXT | 长文本、JSON | description TEXT |\n| DECIMAL(p,s) | 金额、数量 | amount DECIMAL(19,2) |\n| DATE | 日期 | posting_date DATE |\n| TIMESTAMP | 日期时间 | created_at TIMESTAMP |\n| BOOLEAN | 布尔值 | is_active BOOLEAN |\n| JSONB | 非结构化数据 | metadata JSONB |\n\n---\n\n## 2. 财务服务数据库 (financial_db)\n\n### 2.1 会计科目表 (accounts)\n\n**说明**：存储会计科目主数据（科目表）\n\n```sql\nCREATE TABLE accounts (\n    -- 主键\n    account_id              UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n\n    -- 业务字段\n    account_number          VARCHAR(20) NOT NULL,  -- 科目编号（如 1001）\n    account_name            VARCHAR(200) NOT NULL, -- 科目名称\n    account_type            VARCHAR(20) NOT NULL,  -- 科目类型：ASSET, LIABILITY, EQUITY, REVENUE, EXPENSE\n    account_group           VARCHAR(50),           -- 科目组（如 现金及现金等价物）\n    parent_account_id       UUID,                  -- 上级科目ID（层级结构）\n    is_leaf                 BOOLEAN NOT NULL DEFAULT TRUE,  -- 是否末级科目\n    currency                VARCHAR(3) NOT NULL DEFAULT 'CNY',  -- 币种\n    balance_type            VARCHAR(10) NOT NULL,  -- 余额方向：DEBIT, CREDIT\n\n    -- 控制字段\n    is_active               BOOLEAN NOT NULL DEFAULT TRUE,\n    is_posting_allowed      BOOLEAN NOT NULL DEFAULT TRUE,  -- 是否允许直接过账\n    cost_center_required    BOOLEAN NOT NULL DEFAULT FALSE, -- 是否强制成本中心\n    profit_center_required  BOOLEAN NOT NULL DEFAULT FALSE, -- 是否强制利润中心\n    tax_category            VARCHAR(20),           -- 税务分类\n\n    -- 描述字段\n    description             TEXT,\n\n    -- 审计字段\n    created_at              TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    created_by              UUID NOT NULL,\n    updated_at              TIMESTAMP,\n    updated_by              UUID,\n    version                 INTEGER NOT NULL DEFAULT 1,\n    is_deleted              BOOLEAN NOT NULL DEFAULT FALSE,\n    deleted_at              TIMESTAMP,\n    deleted_by              UUID,\n\n    -- 约束\n    CONSTRAINT uk_accounts_number UNIQUE (account_number),\n    CONSTRAINT ck_accounts_type CHECK (account_type IN ('ASSET', 'LIABILITY', 'EQUITY', 'REVENUE', 'EXPENSE')),\n    CONSTRAINT ck_accounts_balance_type CHECK (balance_type IN ('DEBIT', 'CREDIT')),\n    CONSTRAINT fk_accounts_parent FOREIGN KEY (parent_account_id) REFERENCES accounts(account_id)\n);\n\n-- 索引\nCREATE INDEX idx_accounts_number ON accounts(account_number) WHERE is_deleted = FALSE;\nCREATE INDEX idx_accounts_type ON accounts(account_type) WHERE is_deleted = FALSE;\nCREATE INDEX idx_accounts_parent ON accounts(parent_account_id) WHERE parent_account_id IS NOT NULL;\nCREATE INDEX idx_accounts_active ON accounts(is_active) WHERE is_deleted = FALSE;\n\n-- 注释\nCOMMENT ON TABLE accounts IS '会计科目主数据表';\nCOMMENT ON COLUMN accounts.account_number IS '科目编号，唯一标识';\nCOMMENT ON COLUMN accounts.balance_type IS '余额方向：DEBIT=借方, CREDIT=贷方';\n```\n\n---\n\n### 2.2 财务交易表 (transactions)\n\n**说明**：存储财务凭证头信息\n\n```sql\nCREATE TABLE transactions (\n    -- 主键\n    transaction_id          UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n\n    -- 业务字段\n    document_number         VARCHAR(50) NOT NULL,  -- 凭证号（系统生成，如 FI-2025-000123）\n    document_type           VARCHAR(10) NOT NULL,  -- 凭证类型：JE=日记账, IV=发票, PY=付款\n    document_date           DATE NOT NULL,         -- 凭证日期\n    posting_date            DATE NOT NULL,         -- 过账日期\n    reference_number        VARCHAR(50),           -- 外部参考号\n\n    -- 会计期间\n    fiscal_year             INTEGER NOT NULL,      -- 会计年度\n    fiscal_period           INTEGER NOT NULL,      -- 会计期间（1-12）\n\n    -- 币种与汇率\n    currency                VARCHAR(3) NOT NULL,   -- 凭证币种\n    exchange_rate           DECIMAL(12,6) NOT NULL DEFAULT 1.0,  -- 汇率\n\n    -- 状态\n    status                  VARCHAR(20) NOT NULL DEFAULT 'DRAFT',  -- DRAFT, POSTED, REVERSED\n\n    -- 冲销信息\n    reversal_indicator      BOOLEAN NOT NULL DEFAULT FALSE,  -- 是否冲销凭证\n    reversed_transaction_id UUID,                   -- 被冲销的原凭证ID\n    reversal_date           DATE,                   -- 冲销日期\n    reversal_reason         TEXT,                   -- 冲销原因\n\n    -- 描述字段\n    description             TEXT,\n\n    -- 业务来源\n    source_system           VARCHAR(50),           -- 来源系统（SD, MM, PP等）\n    source_document_type    VARCHAR(50),           -- 来源单据类型\n    source_document_id      UUID,                  -- 来源单据ID\n\n    -- 审计字段\n    created_at              TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    created_by              UUID NOT NULL,\n    updated_at              TIMESTAMP,\n    updated_by              UUID,\n    posted_at               TIMESTAMP,             -- 过账时间\n    posted_by               UUID,                  -- 过账人\n    version                 INTEGER NOT NULL DEFAULT 1,\n    is_deleted              BOOLEAN NOT NULL DEFAULT FALSE,\n    deleted_at              TIMESTAMP,\n    deleted_by              UUID,\n\n    -- 约束\n    CONSTRAINT uk_transactions_document_number UNIQUE (document_number),\n    CONSTRAINT ck_transactions_status CHECK (status IN ('DRAFT', 'POSTED', 'REVERSED')),\n    CONSTRAINT ck_transactions_type CHECK (document_type IN ('JE', 'IV', 'PY', 'RC', 'CN', 'DN')),\n    CONSTRAINT fk_transactions_reversed FOREIGN KEY (reversed_transaction_id) REFERENCES transactions(transaction_id)\n);\n\n-- 索引\nCREATE INDEX idx_transactions_number ON transactions(document_number);\nCREATE INDEX idx_transactions_posting_date ON transactions(posting_date DESC);\nCREATE INDEX idx_transactions_status ON transactions(status);\nCREATE INDEX idx_transactions_fiscal ON transactions(fiscal_year, fiscal_period);\nCREATE INDEX idx_transactions_created_at ON transactions(created_at DESC);\nCREATE INDEX idx_transactions_source ON transactions(source_system, source_document_type, source_document_id);\n\n-- 分区表（按年分区，提高查询性能）\n-- ALTER TABLE transactions PARTITION BY RANGE (fiscal_year);\n-- CREATE TABLE transactions_2025 PARTITION OF transactions FOR VALUES FROM (2025) TO (2026);\n-- CREATE TABLE transactions_2026 PARTITION OF transactions FOR VALUES FROM (2026) TO (2027);\n\nCOMMENT ON TABLE transactions IS '财务凭证头表';\nCOMMENT ON COLUMN transactions.document_number IS '系统自动生成的唯一凭证号';\nCOMMENT ON COLUMN transactions.reversal_indicator IS 'TRUE表示这是一个冲销凭证';\n```\n\n---\n\n### 2.3 会计分录表 (journal_entries)\n\n**说明**：存储财务凭证明细（分录行）\n\n```sql\nCREATE TABLE journal_entries (\n    -- 主键\n    entry_id                UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n\n    -- 外键\n    transaction_id          UUID NOT NULL,         -- 所属凭证ID\n    account_id              UUID NOT NULL,         -- 科目ID\n\n    -- 业务字段\n    line_number             INTEGER NOT NULL,      -- 行号（10, 20, 30...）\n    debit_amount            DECIMAL(19,2) NOT NULL DEFAULT 0.00,  -- 借方金额\n    credit_amount           DECIMAL(19,2) NOT NULL DEFAULT 0.00,  -- 贷方金额\n\n    -- 本位币金额（自动计算）\n    local_currency          VARCHAR(3) NOT NULL DEFAULT 'CNY',\n    local_debit_amount      DECIMAL(19,2) NOT NULL DEFAULT 0.00,\n    local_credit_amount     DECIMAL(19,2) NOT NULL DEFAULT 0.00,\n\n    -- 成本对象\n    cost_center_id          UUID,                  -- 成本中心ID\n    profit_center_id        UUID,                  -- 利润中心ID\n    internal_order_id       UUID,                  -- 内部订单ID\n    project_id              UUID,                  -- 项目ID\n\n    -- 业务伙伴\n    business_partner_id     UUID,                  -- 业务伙伴ID（客户/供应商）\n\n    -- 税务信息\n    tax_code                VARCHAR(10),           -- 税码\n    tax_amount              DECIMAL(19,2),         -- 税额\n\n    -- 描述字段\n    description             TEXT,\n    assignment              VARCHAR(100),          -- 分配（用于对账）\n\n    -- 审计字段\n    created_at              TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    created_by              UUID NOT NULL,\n    version                 INTEGER NOT NULL DEFAULT 1,\n\n    -- 约束\n    CONSTRAINT fk_entries_transaction FOREIGN KEY (transaction_id) REFERENCES transactions(transaction_id) ON DELETE CASCADE,\n    CONSTRAINT fk_entries_account FOREIGN KEY (account_id) REFERENCES accounts(account_id),\n    CONSTRAINT ck_entries_amounts CHECK (\n        (debit_amount >= 0 AND credit_amount >= 0) AND\n        (debit_amount = 0 OR credit_amount = 0)  -- 借贷不能同时有值\n    ),\n    CONSTRAINT uk_entries_transaction_line UNIQUE (transaction_id, line_number)\n);\n\n-- 索引\nCREATE INDEX idx_entries_transaction ON journal_entries(transaction_id);\nCREATE INDEX idx_entries_account ON journal_entries(account_id);\nCREATE INDEX idx_entries_cost_center ON journal_entries(cost_center_id) WHERE cost_center_id IS NOT NULL;\nCREATE INDEX idx_entries_profit_center ON journal_entries(profit_center_id) WHERE profit_center_id IS NOT NULL;\nCREATE INDEX idx_entries_business_partner ON journal_entries(business_partner_id) WHERE business_partner_id IS NOT NULL;\n\nCOMMENT ON TABLE journal_entries IS '会计分录明细表';\nCOMMENT ON COLUMN journal_entries.debit_amount IS '借方金额（原币）';\nCOMMENT ON COLUMN journal_entries.local_debit_amount IS '借方金额（本位币）';\n```\n\n---\n\n### 2.4 科目余额表 (account_balances)\n\n**说明**：存储科目每月余额快照（CQRS 读模型）\n\n```sql\nCREATE TABLE account_balances (\n    -- 主键\n    balance_id              UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n\n    -- 维度字段\n    account_id              UUID NOT NULL,\n    fiscal_year             INTEGER NOT NULL,\n    fiscal_period           INTEGER NOT NULL,\n    currency                VARCHAR(3) NOT NULL,\n    cost_center_id          UUID,\n    profit_center_id        UUID,\n\n    -- 余额字段\n    opening_balance         DECIMAL(19,2) NOT NULL DEFAULT 0.00,  -- 期初余额\n    debit_total             DECIMAL(19,2) NOT NULL DEFAULT 0.00,  -- 借方发生额\n    credit_total            DECIMAL(19,2) NOT NULL DEFAULT 0.00,  -- 贷方发生额\n    closing_balance         DECIMAL(19,2) NOT NULL DEFAULT 0.00,  -- 期末余额\n\n    -- 计算时间\n    calculated_at           TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n\n    -- 约束\n    CONSTRAINT uk_balances_dimension UNIQUE (\n        account_id, fiscal_year, fiscal_period, currency,\n        COALESCE(cost_center_id, '00000000-0000-0000-0000-000000000000'::UUID),\n        COALESCE(profit_center_id, '00000000-0000-0000-0000-000000000000'::UUID)\n    ),\n    CONSTRAINT fk_balances_account FOREIGN KEY (account_id) REFERENCES accounts(account_id)\n);\n\n-- 索引\nCREATE INDEX idx_balances_account ON account_balances(account_id, fiscal_year, fiscal_period);\nCREATE INDEX idx_balances_fiscal ON account_balances(fiscal_year, fiscal_period);\n\nCOMMENT ON TABLE account_balances IS '科目余额快照表（读模型）';\nCOMMENT ON COLUMN account_balances.closing_balance IS '期末余额 = 期初余额 + 借方发生额 - 贷方发生额';\n```\n\n---\n\n### 2.5 会计期间表 (fiscal_periods)\n\n**说明**：会计期间主数据\n\n```sql\nCREATE TABLE fiscal_periods (\n    -- 主键\n    period_id               UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n\n    -- 业务字段\n    fiscal_year             INTEGER NOT NULL,\n    fiscal_period           INTEGER NOT NULL,      -- 1-12（月份）\n    period_name             VARCHAR(50) NOT NULL,  -- 如 \"2025年12月\"\n    start_date              DATE NOT NULL,\n    end_date                DATE NOT NULL,\n\n    -- 状态字段\n    status                  VARCHAR(20) NOT NULL DEFAULT 'OPEN',  -- OPEN, CLOSED, LOCKED\n    is_current              BOOLEAN NOT NULL DEFAULT FALSE,\n\n    -- 关账信息\n    closed_at               TIMESTAMP,\n    closed_by               UUID,\n    closing_notes           TEXT,\n\n    -- 审计字段\n    created_at              TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    created_by              UUID NOT NULL,\n    version                 INTEGER NOT NULL DEFAULT 1,\n\n    -- 约束\n    CONSTRAINT uk_periods_year_period UNIQUE (fiscal_year, fiscal_period),\n    CONSTRAINT ck_periods_status CHECK (status IN ('OPEN', 'CLOSED', 'LOCKED')),\n    CONSTRAINT ck_periods_period_range CHECK (fiscal_period BETWEEN 1 AND 12),\n    CONSTRAINT ck_periods_dates CHECK (end_date > start_date)\n);\n\n-- 索引\nCREATE INDEX idx_periods_year ON fiscal_periods(fiscal_year);\nCREATE INDEX idx_periods_status ON fiscal_periods(status);\nCREATE INDEX idx_periods_current ON fiscal_periods(is_current) WHERE is_current = TRUE;\n\nCOMMENT ON TABLE fiscal_periods IS '会计期间主数据表';\nCOMMENT ON COLUMN fiscal_periods.status IS 'OPEN=开放, CLOSED=关闭, LOCKED=锁定';\n```\n\n---\n\n### 2.6 成本中心表 (cost_centers)\n\n**说明**：成本中心主数据\n\n```sql\nCREATE TABLE cost_centers (\n    -- 主键\n    cost_center_id          UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n\n    -- 业务字段\n    cost_center_code        VARCHAR(20) NOT NULL,  -- 成本中心代码\n    cost_center_name        VARCHAR(200) NOT NULL, -- 成本中心名称\n    cost_center_type        VARCHAR(50),           -- 成本中心类型\n    responsible_person_id   UUID,                  -- 责任人ID\n    parent_cost_center_id   UUID,                  -- 上级成本中心\n\n    -- 有效期\n    valid_from              DATE NOT NULL,\n    valid_to                DATE,\n\n    -- 控制字段\n    is_active               BOOLEAN NOT NULL DEFAULT TRUE,\n\n    -- 描述字段\n    description             TEXT,\n\n    -- 审计字段\n    created_at              TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    created_by              UUID NOT NULL,\n    updated_at              TIMESTAMP,\n    updated_by              UUID,\n    version                 INTEGER NOT NULL DEFAULT 1,\n    is_deleted              BOOLEAN NOT NULL DEFAULT FALSE,\n\n    -- 约束\n    CONSTRAINT uk_cost_centers_code UNIQUE (cost_center_code),\n    CONSTRAINT fk_cost_centers_parent FOREIGN KEY (parent_cost_center_id) REFERENCES cost_centers(cost_center_id)\n);\n\n-- 索引\nCREATE INDEX idx_cost_centers_code ON cost_centers(cost_center_code);\nCREATE INDEX idx_cost_centers_active ON cost_centers(is_active);\n\nCOMMENT ON TABLE cost_centers IS '成本中心主数据表';\n```\n\n---\n\n### 2.7 事件存储表 (events)\n\n**说明**：事件溯源存储（所有服务通用模式）\n\n```sql\nCREATE TABLE events (\n    -- 主键\n    event_id                UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n\n    -- 聚合信息\n    aggregate_type          VARCHAR(100) NOT NULL,  -- 聚合类型：Account, Transaction\n    aggregate_id            VARCHAR(200) NOT NULL,  -- 聚合ID\n    aggregate_version       INTEGER NOT NULL,       -- 聚合版本号\n\n    -- 事件信息\n    event_type              VARCHAR(200) NOT NULL,  -- 事件类型：AccountCreated, TransactionPosted\n    event_version           INTEGER NOT NULL DEFAULT 1,  -- 事件结构版本\n    event_payload           JSONB NOT NULL,         -- 事件数据（JSON）\n\n    -- 元数据\n    event_metadata          JSONB,                  -- 元数据（用户、IP、时间戳等）\n    correlation_id          UUID,                   -- 关联ID（追踪同一业务流程）\n    causation_id            UUID,                   -- 因果ID（触发此事件的事件ID）\n\n    -- 时间字段\n    occurred_at             TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,  -- 事件发生时间\n    recorded_at             TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,  -- 记录时间\n\n    -- 全局顺序号\n    sequence_number         BIGSERIAL NOT NULL,\n\n    -- 约束\n    CONSTRAINT uk_events_aggregate_version UNIQUE (aggregate_type, aggregate_id, aggregate_version)\n);\n\n-- 索引\nCREATE INDEX idx_events_aggregate ON events(aggregate_type, aggregate_id, aggregate_version);\nCREATE INDEX idx_events_type ON events(event_type);\nCREATE INDEX idx_events_occurred_at ON events(occurred_at DESC);\nCREATE INDEX idx_events_sequence ON events(sequence_number);\nCREATE INDEX idx_events_correlation ON events(correlation_id) WHERE correlation_id IS NOT NULL;\n\nCOMMENT ON TABLE events IS '事件存储表（Event Sourcing）';\nCOMMENT ON COLUMN events.aggregate_version IS '聚合根版本号，用于乐观锁';\nCOMMENT ON COLUMN events.sequence_number IS '全局顺序号，保证事件顺序';\n\n-- 示例事件数据\n/*\nINSERT INTO events (aggregate_type, aggregate_id, aggregate_version, event_type, event_payload, event_metadata)\nVALUES (\n    'Transaction',\n    'tx-550e8400-e29b-41d4-a716-446655440000',\n    1,\n    'TransactionPosted',\n    '{\"transaction_id\": \"tx-550e8400-e29b-41d4-a716-446655440000\", \"document_number\": \"FI-2025-000123\", \"total_amount\": 5000.00}'::jsonb,\n    '{\"user_id\": \"user-123\", \"ip_address\": \"192.168.1.100\", \"user_agent\": \"Mozilla/5.0\"}'::jsonb\n);\n*/\n```\n\n---\n\n## 3. 销售服务数据库 (sales_db)\n\n### 3.1 客户主数据表 (customers)\n\n```sql\nCREATE TABLE customers (\n    -- 主键\n    customer_id             UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n\n    -- 业务字段\n    customer_number         VARCHAR(20) NOT NULL,  -- 客户编号\n    customer_name           VARCHAR(200) NOT NULL, -- 客户名称\n    customer_type           VARCHAR(20) NOT NULL,  -- 客户类型：INDIVIDUAL, CORPORATE\n\n    -- 组织数据\n    sales_organization      VARCHAR(20),           -- 销售组织\n    distribution_channel    VARCHAR(20),           -- 分销渠道\n    division                VARCHAR(20),           -- 产品组\n\n    -- 联系信息\n    tax_number              VARCHAR(50),           -- 税号\n    phone                   VARCHAR(50),\n    email                   VARCHAR(100),\n    website                 VARCHAR(200),\n\n    -- 地址信息（JSONB 存储多个地址）\n    addresses               JSONB,                 -- [{\"type\": \"billing\", \"street\": \"...\", \"city\": \"...\"}, ...]\n\n    -- 支付条款\n    payment_terms           VARCHAR(20) DEFAULT 'NET30',  -- 付款条款\n    incoterms               VARCHAR(10),           -- 国际贸易术语\n    currency                VARCHAR(3) NOT NULL DEFAULT 'CNY',\n\n    -- 信用控制\n    credit_limit            DECIMAL(19,2),         -- 信用额度\n    credit_exposure         DECIMAL(19,2) DEFAULT 0.00,  -- 当前风险敞口\n    credit_block            BOOLEAN NOT NULL DEFAULT FALSE,  -- 信用冻结\n\n    -- 状态字段\n    is_active               BOOLEAN NOT NULL DEFAULT TRUE,\n\n    -- 审计字段\n    created_at              TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    created_by              UUID NOT NULL,\n    updated_at              TIMESTAMP,\n    updated_by              UUID,\n    version                 INTEGER NOT NULL DEFAULT 1,\n    is_deleted              BOOLEAN NOT NULL DEFAULT FALSE,\n    deleted_at              TIMESTAMP,\n    deleted_by              UUID,\n\n    -- 约束\n    CONSTRAINT uk_customers_number UNIQUE (customer_number),\n    CONSTRAINT ck_customers_type CHECK (customer_type IN ('INDIVIDUAL', 'CORPORATE')),\n    CONSTRAINT ck_customers_credit CHECK (credit_exposure <= credit_limit OR credit_limit IS NULL)\n);\n\n-- 索引\nCREATE INDEX idx_customers_number ON customers(customer_number);\nCREATE INDEX idx_customers_name ON customers(customer_name);\nCREATE INDEX idx_customers_active ON customers(is_active);\n\nCOMMENT ON TABLE customers IS '客户主数据表';\nCOMMENT ON COLUMN customers.credit_exposure IS '当前风险敞口=未清应收账款';\n```\n\n---\n\n### 3.2 销售订单头表 (sales_orders)\n\n```sql\nCREATE TABLE sales_orders (\n    -- 主键\n    order_id                UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n\n    -- 业务字段\n    order_number            VARCHAR(50) NOT NULL,  -- 订单号（系统生成）\n    customer_id             UUID NOT NULL,         -- 客户ID\n    order_type              VARCHAR(20) NOT NULL,  -- 订单类型：STANDARD, RUSH, CONSIGNMENT\n    order_date              DATE NOT NULL,\n    requested_delivery_date DATE,\n\n    -- 组织数据\n    sales_organization      VARCHAR(20) NOT NULL,\n    distribution_channel    VARCHAR(20) NOT NULL,\n    division                VARCHAR(20),\n    sales_office            VARCHAR(20),\n    sales_group             VARCHAR(20),\n\n    -- 价格与币种\n    currency                VARCHAR(3) NOT NULL,\n    exchange_rate           DECIMAL(12,6) NOT NULL DEFAULT 1.0,\n\n    -- 金额汇总\n    total_net_value         DECIMAL(19,2) NOT NULL DEFAULT 0.00,  -- 净值\n    total_tax               DECIMAL(19,2) NOT NULL DEFAULT 0.00,  -- 税额\n    total_gross_value       DECIMAL(19,2) NOT NULL DEFAULT 0.00,  -- 含税总价\n\n    -- 支付与交付\n    payment_terms           VARCHAR(20),\n    incoterms               VARCHAR(10),\n    shipping_method         VARCHAR(50),\n\n    -- 地址\n    shipping_address        JSONB,                 -- 收货地址\n    billing_address         JSONB,                 -- 开票地址\n\n    -- 状态\n    status                  VARCHAR(20) NOT NULL DEFAULT 'CREATED',  -- CREATED, CONFIRMED, PARTIALLY_DELIVERED, DELIVERED, CANCELLED\n    delivery_status         VARCHAR(20) DEFAULT 'NOT_DELIVERED',\n    billing_status          VARCHAR(20) DEFAULT 'NOT_BILLED',\n\n    -- 审批\n    approval_status         VARCHAR(20) DEFAULT 'PENDING',  -- PENDING, APPROVED, REJECTED\n    approved_at             TIMESTAMP,\n    approved_by             UUID,\n\n    -- 参考信息\n    customer_po_number      VARCHAR(50),           -- 客户采购订单号\n    sales_person_id         UUID,                  -- 销售员\n\n    -- 描述字段\n    notes                   TEXT,\n\n    -- 审计字段\n    created_at              TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    created_by              UUID NOT NULL,\n    updated_at              TIMESTAMP,\n    updated_by              UUID,\n    confirmed_at            TIMESTAMP,\n    confirmed_by            UUID,\n    version                 INTEGER NOT NULL DEFAULT 1,\n    is_deleted              BOOLEAN NOT NULL DEFAULT FALSE,\n\n    -- 约束\n    CONSTRAINT uk_sales_orders_number UNIQUE (order_number),\n    CONSTRAINT fk_sales_orders_customer FOREIGN KEY (customer_id) REFERENCES customers(customer_id),\n    CONSTRAINT ck_sales_orders_status CHECK (status IN ('CREATED', 'CONFIRMED', 'PARTIALLY_DELIVERED', 'DELIVERED', 'CANCELLED')),\n    CONSTRAINT ck_sales_orders_delivery_status CHECK (delivery_status IN ('NOT_DELIVERED', 'PARTIALLY_DELIVERED', 'FULLY_DELIVERED')),\n    CONSTRAINT ck_sales_orders_billing_status CHECK (billing_status IN ('NOT_BILLED', 'PARTIALLY_BILLED', 'FULLY_BILLED'))\n);\n\n-- 索引\nCREATE INDEX idx_sales_orders_number ON sales_orders(order_number);\nCREATE INDEX idx_sales_orders_customer ON sales_orders(customer_id);\nCREATE INDEX idx_sales_orders_status ON sales_orders(status);\nCREATE INDEX idx_sales_orders_date ON sales_orders(order_date DESC);\nCREATE INDEX idx_sales_orders_created_at ON sales_orders(created_at DESC);\n\n-- 分区表（按年分区）\n-- ALTER TABLE sales_orders PARTITION BY RANGE (EXTRACT(YEAR FROM order_date));\n\nCOMMENT ON TABLE sales_orders IS '销售订单头表';\n```\n\n---\n\n### 3.3 销售订单行项目表 (sales_order_items)\n\n```sql\nCREATE TABLE sales_order_items (\n    -- 主键\n    item_id                 UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n\n    -- 外键\n    order_id                UUID NOT NULL,\n\n    -- 业务字段\n    line_number             INTEGER NOT NULL,      -- 行号（10, 20, 30...）\n    material_number         VARCHAR(50) NOT NULL,  -- 物料编号\n    material_description    VARCHAR(200),\n\n    -- 数量与单位\n    quantity                DECIMAL(15,3) NOT NULL,\n    unit                    VARCHAR(10) NOT NULL,  -- 单位：PC, KG, L\n\n    -- 价格\n    unit_price              DECIMAL(19,2) NOT NULL,\n    discount_percent        DECIMAL(5,2) DEFAULT 0.00,\n    net_price               DECIMAL(19,2) NOT NULL,  -- 单价 * (1 - 折扣%)\n\n    -- 金额\n    net_value               DECIMAL(19,2) NOT NULL,  -- 数量 * 净价\n    tax_code                VARCHAR(10),\n    tax_rate                DECIMAL(5,2),\n    tax_amount              DECIMAL(19,2),\n    gross_value             DECIMAL(19,2) NOT NULL,  -- 净值 + 税额\n\n    -- 交付信息\n    requested_delivery_date DATE,\n    confirmed_delivery_date DATE,\n    plant                   VARCHAR(20),           -- 工厂\n    storage_location        VARCHAR(20),           -- 库位\n\n    -- 状态\n    item_category           VARCHAR(20),           -- 项目类别\n    delivery_status         VARCHAR(20) DEFAULT 'NOT_DELIVERED',\n    billing_status          VARCHAR(20) DEFAULT 'NOT_BILLED',\n\n    -- 数量跟踪\n    delivered_quantity      DECIMAL(15,3) DEFAULT 0.00,\n    billed_quantity         DECIMAL(15,3) DEFAULT 0.00,\n    open_quantity           DECIMAL(15,3),         -- 未交货数量\n\n    -- 描述字段\n    notes                   TEXT,\n\n    -- 审计字段\n    created_at              TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    created_by              UUID NOT NULL,\n    updated_at              TIMESTAMP,\n    updated_by              UUID,\n    version                 INTEGER NOT NULL DEFAULT 1,\n\n    -- 约束\n    CONSTRAINT fk_order_items_order FOREIGN KEY (order_id) REFERENCES sales_orders(order_id) ON DELETE CASCADE,\n    CONSTRAINT uk_order_items_line UNIQUE (order_id, line_number),\n    CONSTRAINT ck_order_items_quantity CHECK (quantity > 0),\n    CONSTRAINT ck_order_items_open_qty CHECK (open_quantity >= 0)\n);\n\n-- 索引\nCREATE INDEX idx_order_items_order ON sales_order_items(order_id);\nCREATE INDEX idx_order_items_material ON sales_order_items(material_number);\nCREATE INDEX idx_order_items_delivery_date ON sales_order_items(confirmed_delivery_date);\n\n-- 触发器：自动计算 open_quantity\nCREATE OR REPLACE FUNCTION update_open_quantity()\nRETURNS TRIGGER AS $$\nBEGIN\n    NEW.open_quantity := NEW.quantity - NEW.delivered_quantity;\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_open_quantity\nBEFORE INSERT OR UPDATE ON sales_order_items\nFOR EACH ROW\nEXECUTE FUNCTION update_open_quantity();\n\nCOMMENT ON TABLE sales_order_items IS '销售订单行项目表';\n```\n\n---\n\n### 3.4 发货单表 (deliveries)\n\n```sql\nCREATE TABLE deliveries (\n    -- 主键\n    delivery_id             UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n\n    -- 业务字段\n    delivery_number         VARCHAR(50) NOT NULL,\n    order_id                UUID NOT NULL,         -- 关联销售订单\n    customer_id             UUID NOT NULL,\n\n    -- 日期\n    delivery_date           DATE NOT NULL,\n    planned_goods_issue_date DATE,\n    actual_goods_issue_date DATE,\n\n    -- 物流信息\n    carrier                 VARCHAR(100),          -- 承运商\n    tracking_number         VARCHAR(100),          -- 运单号\n    shipping_method         VARCHAR(50),\n\n    -- 地址\n    shipping_address        JSONB,\n\n    -- 状态\n    status                  VARCHAR(20) NOT NULL DEFAULT 'CREATED',  -- CREATED, PICKED, PACKED, SHIPPED, DELIVERED\n    goods_issue_posted      BOOLEAN NOT NULL DEFAULT FALSE,  -- 是否已过账（库存扣减）\n\n    -- 过账信息\n    material_document       VARCHAR(50),           -- 物料凭证号\n    accounting_document     VARCHAR(50),           -- 财务凭证号\n    goods_issue_date        DATE,\n\n    -- 审计字段\n    created_at              TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    created_by              UUID NOT NULL,\n    updated_at              TIMESTAMP,\n    updated_by              UUID,\n    posted_at               TIMESTAMP,\n    posted_by               UUID,\n    version                 INTEGER NOT NULL DEFAULT 1,\n    is_deleted              BOOLEAN NOT NULL DEFAULT FALSE,\n\n    -- 约束\n    CONSTRAINT uk_deliveries_number UNIQUE (delivery_number),\n    CONSTRAINT fk_deliveries_order FOREIGN KEY (order_id) REFERENCES sales_orders(order_id),\n    CONSTRAINT fk_deliveries_customer FOREIGN KEY (customer_id) REFERENCES customers(customer_id),\n    CONSTRAINT ck_deliveries_status CHECK (status IN ('CREATED', 'PICKED', 'PACKED', 'SHIPPED', 'DELIVERED'))\n);\n\n-- 索引\nCREATE INDEX idx_deliveries_number ON deliveries(delivery_number);\nCREATE INDEX idx_deliveries_order ON deliveries(order_id);\nCREATE INDEX idx_deliveries_date ON deliveries(delivery_date DESC);\nCREATE INDEX idx_deliveries_status ON deliveries(status);\n\nCOMMENT ON TABLE deliveries IS '发货单表';\n```\n\n---\n\n### 3.5 发票表 (invoices)\n\n```sql\nCREATE TABLE invoices (\n    -- 主键\n    invoice_id              UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n\n    -- 业务字段\n    invoice_number          VARCHAR(50) NOT NULL,\n    invoice_type            VARCHAR(20) NOT NULL,  -- STANDARD, CREDIT_MEMO, DEBIT_MEMO\n    order_id                UUID,\n    delivery_id             UUID,\n    customer_id             UUID NOT NULL,\n\n    -- 日期\n    invoice_date            DATE NOT NULL,\n    due_date                DATE NOT NULL,\n\n    -- 金额\n    currency                VARCHAR(3) NOT NULL,\n    total_net_value         DECIMAL(19,2) NOT NULL,\n    total_tax               DECIMAL(19,2) NOT NULL,\n    total_gross_value       DECIMAL(19,2) NOT NULL,\n\n    -- 支付信息\n    payment_terms           VARCHAR(20),\n    payment_status          VARCHAR(20) DEFAULT 'UNPAID',  -- UNPAID, PARTIALLY_PAID, PAID\n    paid_amount             DECIMAL(19,2) DEFAULT 0.00,\n    outstanding_amount      DECIMAL(19,2),\n\n    -- 状态\n    status                  VARCHAR(20) NOT NULL DEFAULT 'DRAFT',  -- DRAFT, POSTED, CANCELLED\n\n    -- 会计凭证\n    accounting_document     VARCHAR(50),\n\n    -- PDF文件\n    pdf_url                 VARCHAR(500),\n\n    -- 审计字段\n    created_at              TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    created_by              UUID NOT NULL,\n    updated_at              TIMESTAMP,\n    updated_by              UUID,\n    posted_at               TIMESTAMP,\n    posted_by               UUID,\n    version                 INTEGER NOT NULL DEFAULT 1,\n    is_deleted              BOOLEAN NOT NULL DEFAULT FALSE,\n\n    -- 约束\n    CONSTRAINT uk_invoices_number UNIQUE (invoice_number),\n    CONSTRAINT fk_invoices_order FOREIGN KEY (order_id) REFERENCES sales_orders(order_id),\n    CONSTRAINT fk_invoices_delivery FOREIGN KEY (delivery_id) REFERENCES deliveries(delivery_id),\n    CONSTRAINT fk_invoices_customer FOREIGN KEY (customer_id) REFERENCES customers(customer_id),\n    CONSTRAINT ck_invoices_type CHECK (invoice_type IN ('STANDARD', 'CREDIT_MEMO', 'DEBIT_MEMO')),\n    CONSTRAINT ck_invoices_payment_status CHECK (payment_status IN ('UNPAID', 'PARTIALLY_PAID', 'PAID'))\n);\n\n-- 索引\nCREATE INDEX idx_invoices_number ON invoices(invoice_number);\nCREATE INDEX idx_invoices_customer ON invoices(customer_id);\nCREATE INDEX idx_invoices_date ON invoices(invoice_date DESC);\nCREATE INDEX idx_invoices_due_date ON invoices(due_date);\nCREATE INDEX idx_invoices_payment_status ON invoices(payment_status);\n\n-- 触发器：自动计算未清金额\nCREATE OR REPLACE FUNCTION update_outstanding_amount()\nRETURNS TRIGGER AS $$\nBEGIN\n    NEW.outstanding_amount := NEW.total_gross_value - NEW.paid_amount;\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_outstanding_amount\nBEFORE INSERT OR UPDATE ON invoices\nFOR EACH ROW\nEXECUTE FUNCTION update_outstanding_amount();\n\nCOMMENT ON TABLE invoices IS '发票表';\n```\n\n---\n\n## 4. 物料服务数据库 (materials_db)\n\n### 4.1 物料主数据表 (materials)\n\n```sql\nCREATE TABLE materials (\n    -- 主键\n    material_id             UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n\n    -- 基本数据\n    material_number         VARCHAR(50) NOT NULL,\n    material_type           VARCHAR(20) NOT NULL,  -- ROH=原料, HALB=半成品, FERT=成品\n    industry_sector         VARCHAR(10),           -- M=机械, C=化工\n    description             VARCHAR(200) NOT NULL,\n    long_description        TEXT,\n\n    -- 单位\n    base_unit_of_measure    VARCHAR(10) NOT NULL,  -- 基本单位\n    weight_unit             VARCHAR(10),\n    volume_unit             VARCHAR(10),\n\n    -- 物理属性\n    gross_weight            DECIMAL(15,3),\n    net_weight              DECIMAL(15,3),\n    volume                  DECIMAL(15,3),\n\n    -- 分类\n    material_group          VARCHAR(50),\n    division                VARCHAR(20),\n\n    -- 状态\n    is_active               BOOLEAN NOT NULL DEFAULT TRUE,\n\n    -- 审计字段\n    created_at              TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    created_by              UUID NOT NULL,\n    updated_at              TIMESTAMP,\n    updated_by              UUID,\n    version                 INTEGER NOT NULL DEFAULT 1,\n    is_deleted              BOOLEAN NOT NULL DEFAULT FALSE,\n\n    -- 约束\n    CONSTRAINT uk_materials_number UNIQUE (material_number),\n    CONSTRAINT ck_materials_type CHECK (material_type IN ('ROH', 'HALB', 'FERT', 'HAWA', 'VERP'))\n);\n\n-- 索引\nCREATE INDEX idx_materials_number ON materials(material_number);\nCREATE INDEX idx_materials_type ON materials(material_type);\nCREATE INDEX idx_materials_group ON materials(material_group);\n\nCOMMENT ON TABLE materials IS '物料主数据表';\nCOMMENT ON COLUMN materials.material_type IS 'ROH=原料,HALB=半成品,FERT=成品,HAWA=贸易商品,VERP=包装';\n```\n\n---\n\n### 4.2 库存表 (inventory)\n\n```sql\nCREATE TABLE inventory (\n    -- 主键\n    inventory_id            UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n\n    -- 维度\n    material_id             UUID NOT NULL,\n    plant                   VARCHAR(20) NOT NULL,  -- 工厂\n    storage_location        VARCHAR(20) NOT NULL,  -- 库位\n    batch                   VARCHAR(50),           -- 批次号（可选）\n    special_stock_type      VARCHAR(10),           -- 特殊库存类型\n\n    -- 库存数量\n    unrestricted_stock      DECIMAL(15,3) NOT NULL DEFAULT 0.00,  -- 非限制使用库存\n    quality_inspection_stock DECIMAL(15,3) NOT NULL DEFAULT 0.00, -- 质检库存\n    blocked_stock           DECIMAL(15,3) NOT NULL DEFAULT 0.00,  -- 冻结库存\n    total_stock             DECIMAL(15,3) GENERATED ALWAYS AS (\n        unrestricted_stock + quality_inspection_stock + blocked_stock\n    ) STORED,\n\n    -- 单位与价值\n    unit                    VARCHAR(10) NOT NULL,\n    unit_price              DECIMAL(19,2),         -- 单价\n    total_value             DECIMAL(19,2),         -- 库存价值\n    currency                VARCHAR(3) DEFAULT 'CNY',\n\n    -- 时间戳\n    last_goods_receipt_date DATE,\n    last_goods_issue_date   DATE,\n    last_updated            TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n\n    -- 约束\n    CONSTRAINT uk_inventory_dimension UNIQUE (\n        material_id, plant, storage_location,\n        COALESCE(batch, ''),\n        COALESCE(special_stock_type, '')\n    ),\n    CONSTRAINT fk_inventory_material FOREIGN KEY (material_id) REFERENCES materials(material_id),\n    CONSTRAINT ck_inventory_quantities CHECK (\n        unrestricted_stock >= 0 AND\n        quality_inspection_stock >= 0 AND\n        blocked_stock >= 0\n    )\n);\n\n-- 索引\nCREATE INDEX idx_inventory_material ON inventory(material_id);\nCREATE INDEX idx_inventory_plant ON inventory(plant, storage_location);\nCREATE INDEX idx_inventory_batch ON inventory(batch) WHERE batch IS NOT NULL;\n\n-- 触发器：自动计算库存价值\nCREATE OR REPLACE FUNCTION update_inventory_value()\nRETURNS TRIGGER AS $$\nBEGIN\n    NEW.total_value := NEW.total_stock * COALESCE(NEW.unit_price, 0);\n    NEW.last_updated := CURRENT_TIMESTAMP;\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql;\n\nCREATE TRIGGER trg_update_inventory_value\nBEFORE INSERT OR UPDATE ON inventory\nFOR EACH ROW\nEXECUTE FUNCTION update_inventory_value();\n\nCOMMENT ON TABLE inventory IS '库存表';\nCOMMENT ON COLUMN inventory.unrestricted_stock IS '可用库存';\n```\n\n---\n\n### 4.3 物料凭证表 (material_documents)\n\n```sql\nCREATE TABLE material_documents (\n    -- 主键\n    document_id             UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n\n    -- 业务字段\n    material_document       VARCHAR(50) NOT NULL,  -- 物料凭证号\n    document_date           DATE NOT NULL,\n    posting_date            DATE NOT NULL,\n    movement_type           VARCHAR(10) NOT NULL,  -- 101=采购入库, 601=销售出库\n\n    -- 参考凭证\n    reference_document_type VARCHAR(20),           -- PO=采购订单, SO=销售订单\n    reference_document_id   UUID,\n\n    -- 业务伙伴\n    vendor_id               UUID,\n    customer_id             UUID,\n\n    -- 会计凭证\n    accounting_document     VARCHAR(50),\n\n    -- 状态\n    status                  VARCHAR(20) NOT NULL DEFAULT 'POSTED',\n    is_reversed             BOOLEAN NOT NULL DEFAULT FALSE,\n    reversal_document       VARCHAR(50),\n\n    -- 描述\n    header_text             TEXT,\n\n    -- 审计字段\n    created_at              TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    created_by              UUID NOT NULL,\n    posted_at               TIMESTAMP,\n    posted_by               UUID,\n    version                 INTEGER NOT NULL DEFAULT 1,\n\n    -- 约束\n    CONSTRAINT uk_material_documents_number UNIQUE (material_document),\n    CONSTRAINT ck_material_documents_movement_type CHECK (movement_type ~ '^\\d{3}$')  -- 3位数字\n);\n\n-- 索引\nCREATE INDEX idx_material_documents_number ON material_documents(material_document);\nCREATE INDEX idx_material_documents_posting_date ON material_documents(posting_date DESC);\nCREATE INDEX idx_material_documents_movement_type ON material_documents(movement_type);\n\nCOMMENT ON TABLE material_documents IS '物料凭证头表';\nCOMMENT ON COLUMN material_documents.movement_type IS '101=PO收货,261=生产领料,601=销售发货';\n```\n\n---\n\n### 4.4 物料凭证行项目表 (material_document_items)\n\n```sql\nCREATE TABLE material_document_items (\n    -- 主键\n    item_id                 UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n\n    -- 外键\n    document_id             UUID NOT NULL,\n\n    -- 业务字段\n    line_number             INTEGER NOT NULL,\n    material_id             UUID NOT NULL,\n\n    -- 数量与单位\n    quantity                DECIMAL(15,3) NOT NULL,\n    unit                    VARCHAR(10) NOT NULL,\n\n    -- 地点信息\n    plant                   VARCHAR(20) NOT NULL,\n    storage_location        VARCHAR(20) NOT NULL,\n    batch                   VARCHAR(50),\n\n    -- 库存类型\n    stock_type              VARCHAR(20) NOT NULL DEFAULT 'UNRESTRICTED',  -- UNRESTRICTED, QUALITY, BLOCKED\n\n    -- 金额\n    amount                  DECIMAL(19,2),\n    currency                VARCHAR(3),\n\n    -- 参考\n    purchase_order          VARCHAR(50),\n    po_item_number          INTEGER,\n    sales_order             VARCHAR(50),\n    so_item_number          INTEGER,\n\n    -- 成本中心\n    cost_center             VARCHAR(20),\n\n    -- 描述\n    item_text               TEXT,\n\n    -- 审计字段\n    created_at              TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    created_by              UUID NOT NULL,\n\n    -- 约束\n    CONSTRAINT fk_material_doc_items_doc FOREIGN KEY (document_id) REFERENCES material_documents(document_id) ON DELETE CASCADE,\n    CONSTRAINT fk_material_doc_items_material FOREIGN KEY (material_id) REFERENCES materials(material_id),\n    CONSTRAINT uk_material_doc_items_line UNIQUE (document_id, line_number),\n    CONSTRAINT ck_material_doc_items_stock_type CHECK (stock_type IN ('UNRESTRICTED', 'QUALITY', 'BLOCKED'))\n);\n\n-- 索引\nCREATE INDEX idx_material_doc_items_doc ON material_document_items(document_id);\nCREATE INDEX idx_material_doc_items_material ON material_document_items(material_id);\nCREATE INDEX idx_material_doc_items_plant ON material_document_items(plant, storage_location);\n\nCOMMENT ON TABLE material_document_items IS '物料凭证行项目表';\n```\n\n---\n\n## 5. 人力资源服务数据库 (hr_db)\n\n### 5.1 员工表 (employees)\n\n```sql\nCREATE TABLE employees (\n    -- 主键\n    employee_id             UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n\n    -- 基本信息\n    employee_number         VARCHAR(20) NOT NULL,\n    first_name              VARCHAR(100) NOT NULL,\n    last_name               VARCHAR(100) NOT NULL,\n    full_name               VARCHAR(200) GENERATED ALWAYS AS (last_name || ' ' || first_name) STORED,\n    gender                  VARCHAR(10),           -- MALE, FEMALE, OTHER\n    date_of_birth           DATE,\n    nationality             VARCHAR(50),\n\n    -- 联系信息\n    email                   VARCHAR(100),\n    phone                   VARCHAR(50),\n    personal_email          VARCHAR(100),\n    address                 JSONB,\n\n    -- 身份信息\n    id_card_number          VARCHAR(50),           -- 身份证号\n    passport_number         VARCHAR(50),\n    social_security_number  VARCHAR(50),           -- 社保号\n\n    -- 组织信息\n    company_code            VARCHAR(20) NOT NULL,\n    personnel_area          VARCHAR(20),           -- 人事范围\n    personnel_subarea       VARCHAR(20),           -- 人事子范围\n    department_id           UUID,                  -- 部门ID\n    cost_center             VARCHAR(20),           -- 成本中心\n    position_id             UUID,                  -- 职位ID\n\n    -- 雇佣信息\n    hire_date               DATE NOT NULL,\n    employment_type         VARCHAR(20),           -- FULL_TIME, PART_TIME, CONTRACT\n    employment_status       VARCHAR(20) NOT NULL DEFAULT 'ACTIVE',  -- ACTIVE, ON_LEAVE, TERMINATED\n    termination_date        DATE,\n\n    -- 报告关系\n    manager_id              UUID,                  -- 直接上级\n\n    -- 薪资信息（加密存储）\n    salary_encrypted        BYTEA,                 -- AES加密薪资\n    salary_currency         VARCHAR(3),\n\n    -- 审计字段\n    created_at              TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,\n    created_by              UUID NOT NULL,\n    updated_at              TIMESTAMP,\n    updated_by              UUID,\n    version                 INTEGER NOT NULL DEFAULT 1,\n    is_deleted              BOOLEAN NOT NULL DEFAULT FALSE,\n\n    -- 约束\n    CONSTRAINT uk_employees_number UNIQUE (employee_number),\n    CONSTRAINT uk_employees_email UNIQUE (email),\n    CONSTRAINT ck_employees_gender CHECK (gender IN ('MALE', 'FEMALE', 'OTHER')),\n    CONSTRAINT ck_employees_employment_type CHECK (employment_type IN ('FULL_TIME', 'PART_TIME', 'CONTRACT', 'INTERN')),\n    CONSTRAINT ck_employees_status CHECK (employment_status IN ('ACTIVE', 'ON_LEAVE', 'TERMINATED')),\n    CONSTRAINT fk_employees_manager FOREIGN KEY (manager_id) REFERENCES employees(employee_id)\n);\n\n-- 索引\nCREATE INDEX idx_employees_number ON employees(employee_number);\nCREATE INDEX idx_employees_email ON employees(email);\nCREATE INDEX idx_employees_department ON employees(department_id);\nCREATE INDEX idx_employees_manager ON employees(manager_id);\nCREATE INDEX idx_employees_status ON employees(employment_status);\n\nCOMMENT ON TABLE employees IS '员工主数据表';\nCOMMENT ON COLUMN employees.salary_encrypted IS 'AES-256-GCM 加密存储';\n```\n\n---\n\n## 6. 视图与物化视图\n\n### 6.1 科目余额视图 (v_account_balances)\n\n```sql\n-- 实时余额视图（从事务表实时计算）\nCREATE OR REPLACE VIEW v_account_balances AS\nSELECT\n    a.account_id,\n    a.account_number,\n    a.account_name,\n    a.currency,\n    t.fiscal_year,\n    t.fiscal_period,\n    COALESCE(SUM(je.debit_amount), 0) AS total_debit,\n    COALESCE(SUM(je.credit_amount), 0) AS total_credit,\n    COALESCE(SUM(je.debit_amount), 0) - COALESCE(SUM(je.credit_amount), 0) AS balance,\n    MAX(t.posting_date) AS last_posting_date,\n    COUNT(DISTINCT t.transaction_id) AS transaction_count\nFROM accounts a\nLEFT JOIN journal_entries je ON a.account_id = je.account_id\nLEFT JOIN transactions t ON je.transaction_id = t.transaction_id AND t.status = 'POSTED'\nWHERE a.is_deleted = FALSE\nGROUP BY a.account_id, a.account_number, a.account_name, a.currency, t.fiscal_year, t.fiscal_period;\n\nCOMMENT ON VIEW v_account_balances IS '科目余额实时视图';\n```\n\n---\n\n### 6.2 订单履行状态视图 (v_order_fulfillment)\n\n```sql\nCREATE OR REPLACE VIEW v_order_fulfillment AS\nSELECT\n    so.order_id,\n    so.order_number,\n    so.customer_id,\n    c.customer_name,\n    so.order_date,\n    so.status AS order_status,\n    so.total_gross_value,\n    so.currency,\n    COUNT(soi.item_id) AS total_items,\n    COALESCE(SUM(soi.quantity), 0) AS total_ordered_qty,\n    COALESCE(SUM(soi.delivered_quantity), 0) AS total_delivered_qty,\n    COALESCE(SUM(soi.open_quantity), 0) AS total_open_qty,\n    CASE\n        WHEN COALESCE(SUM(soi.open_quantity), 0) = 0 THEN 'FULLY_DELIVERED'\n        WHEN COALESCE(SUM(soi.delivered_quantity), 0) > 0 THEN 'PARTIALLY_DELIVERED'\n        ELSE 'NOT_DELIVERED'\n    END AS delivery_status_calculated\nFROM sales_orders so\nJOIN customers c ON so.customer_id = c.customer_id\nLEFT JOIN sales_order_items soi ON so.order_id = soi.order_id\nWHERE so.is_deleted = FALSE\nGROUP BY so.order_id, so.order_number, so.customer_id, c.customer_name,\n         so.order_date, so.status, so.total_gross_value, so.currency;\n\nCOMMENT ON VIEW v_order_fulfillment IS '订单履行状态视图';\n```\n\n---\n\n## 7. 数据库迁移脚本示例\n\n### 7.1 初始化脚本 (001_init_financial.sql)\n\n```sql\n-- Migration: 001_init_financial\n-- Description: 初始化财务服务数据库\n-- Date: 2025-12-21\n\n-- 创建 UUID 扩展\nCREATE EXTENSION IF NOT EXISTS \"pgcrypto\";\n\n-- 创建 accounts 表\n-- （见上文 2.1）\n\n-- 创建 transactions 表\n-- （见上文 2.2）\n\n-- 创建 journal_entries 表\n-- （见上文 2.3）\n\n-- 插入初始数据：科目表\nINSERT INTO accounts (account_number, account_name, account_type, balance_type, currency, created_by)\nVALUES\n    ('1001', '现金', 'ASSET', 'DEBIT', 'CNY', '00000000-0000-0000-0000-000000000001'),\n    ('1002', '银行存款', 'ASSET', 'DEBIT', 'CNY', '00000000-0000-0000-0000-000000000001'),\n    ('2001', '应付账款', 'LIABILITY', 'CREDIT', 'CNY', '00000000-0000-0000-0000-000000000001'),\n    ('4001', '主营业务收入', 'REVENUE', 'CREDIT', 'CNY', '00000000-0000-0000-0000-000000000001'),\n    ('5001', '主营业务成本', 'EXPENSE', 'DEBIT', 'CNY', '00000000-0000-0000-0000-000000000001');\n\n-- 插入会计期间\nINSERT INTO fiscal_periods (fiscal_year, fiscal_period, period_name, start_date, end_date, status, created_by)\nSELECT\n    2025,\n    month_num,\n    '2025年' || month_num || '月',\n    ('2025-' || LPAD(month_num::text, 2, '0') || '-01')::DATE,\n    (DATE_TRUNC('month', ('2025-' || LPAD(month_num::text, 2, '0') || '-01')::DATE) + INTERVAL '1 month' - INTERVAL '1 day')::DATE,\n    CASE WHEN month_num < 12 THEN 'OPEN' ELSE 'OPEN' END,\n    '00000000-0000-0000-0000-000000000001'\nFROM generate_series(1, 12) AS month_num;\n```\n\n---\n\n## 8. 性能优化建议\n\n### 8.1 分区策略\n\n```sql\n-- 按年分区交易表\nCREATE TABLE transactions_partitioned (\n    -- 所有字段同 transactions 表\n) PARTITION BY RANGE (fiscal_year);\n\nCREATE TABLE transactions_2024 PARTITION OF transactions_partitioned\n    FOR VALUES FROM (2024) TO (2025);\n\nCREATE TABLE transactions_2025 PARTITION OF transactions_partitioned\n    FOR VALUES FROM (2025) TO (2026);\n\nCREATE TABLE transactions_2026 PARTITION OF transactions_partitioned\n    FOR VALUES FROM (2026) TO (2027);\n```\n\n### 8.2 索引优化\n\n```sql\n-- 复合索引（覆盖查询）\nCREATE INDEX idx_journal_entries_account_posting_date\n    ON journal_entries(account_id, transaction_id)\n    INCLUDE (debit_amount, credit_amount);\n\n-- 部分索引（仅索引活跃数据）\nCREATE INDEX idx_orders_active_status\n    ON sales_orders(status, order_date DESC)\n    WHERE status IN ('CREATED', 'CONFIRMED') AND is_deleted = FALSE;\n```\n\n### 8.3 物化视图定时刷新\n\n```sql\n-- 创建物化视图\nCREATE MATERIALIZED VIEW mv_monthly_sales_summary AS\nSELECT\n    DATE_TRUNC('month', so.order_date) AS month,\n    c.customer_id,\n    c.customer_name,\n    COUNT(so.order_id) AS order_count,\n    SUM(so.total_net_value) AS total_net_value,\n    SUM(so.total_gross_value) AS total_gross_value\nFROM sales_orders so\nJOIN customers c ON so.customer_id = c.customer_id\nWHERE so.status != 'CANCELLED'\nGROUP BY DATE_TRUNC('month', so.order_date), c.customer_id, c.customer_name;\n\n-- 创建唯一索引\nCREATE UNIQUE INDEX idx_mv_monthly_sales_pk\n    ON mv_monthly_sales_summary(month, customer_id);\n\n-- 定时刷新（使用 pg_cron 或应用层调度）\nREFRESH MATERIALIZED VIEW CONCURRENTLY mv_monthly_sales_summary;\n```\n\n---\n\n## 9. 备份与恢复\n\n### 9.1 备份策略\n\n```bash\n# 全量备份\npg_dump -h localhost -U erp_user -d financial_db -F c -f /backup/financial_db_20251221.dump\n\n# 仅数据备份（排除大表）\npg_dump -h localhost -U erp_user -d financial_db \\\n    --exclude-table=events \\\n    -F c -f /backup/financial_db_no_events_20251221.dump\n\n# 恢复\npg_restore -h localhost -U erp_user -d financial_db_new /backup/financial_db_20251221.dump\n```\n\n---\n\n**文档版本**: v1.0\n**最后更新**: 2025-12-21\n**维护者**: ERP 开发团队\n", "md/rust-Modules.md": "# KILLER 模块完整列表\n\n## 一、功能模块（Functional Modules）\n\n### 财务管理模块\n- **FI (Financial Accounting)** - 财务会计：管理所有财务运营\n  - **FI-GL (General Ledger)** - 总账：集中所有财务交易，便于合规的财务报告\n  - **FI-AP (Accounts Payable)** - 应付账款：管理供应商发票、付款和贷项\n  - **FI-AR (Accounts Receivable)** - 应收账款：处理客户发票、催款和付款计划\n  - **FI-AA (Asset Accounting)** - 资产会计：管理固定资产和折旧\n  - **FI-BL (Bank Ledger)** - 银行分类账：集中银行交易和现金管理\n  - **FI-TV (Travel Management)** - 差旅管理：员工差旅费用管理\n  - **FI-LC (Consolidation)** - 合并：财务合并和企业集团报告\n- **CO (Controlling)** - 管理会计：提供费用和成本的当前信息，用于内部报告\n  - **CO-OM (Overhead Management)** - 间接费用管理：管理间接费用和成本中心会计\n    - **CO-OM-CCA (Cost Center Accounting)** - 成本中心会计：分析企业成本中心的费用\n    - **CO-OM-OPA (Internal Orders)** - 内部订单：跟踪特定任务或项目的成本\n    - **CO-OM-ABC (Activity-Based Costing)** - 作业成本法：基于活动的成本分配\n  - **CO-PC (Product Cost Controlling)** - 产品成本控制：跟踪产品成本，提供实际成本与计划成本对比\n    - **CO-PC-PCP (Product Cost Planning)** - 产品成本计划：制定标准成本\n    - **CO-PC-OBJ (Cost Object Controlling)** - 成本对象控制：跟踪订单和项目实际成本\n    - **CO-PC-ACT (Actual Costing/Material Ledger)** - 实际成本法/物料分类账：多币种和多估价视图\n  - **CO-PA (Profitability Analysis)** - 盈利能力分析：按市场细分、产品、客户或地理区域分析公司盈利能力\n- **EC (Enterprise Controlling)** - 企业控制：合并会计和利润中心会计\n  - **EC-PCA (Profit Center Accounting)** - 利润中心会计：评估组织内部的利润中心\n  - **EC-CS (Consolidation)** - 合并：财务合并和集团报告\n- **IM (Investment Management)** - 投资管理：资本投资项目的规划、预算和监控\n  - **IM-FA (Appropriation Requests)** - 拨款申请：投资项目审批流程\n  - **IM-BG (Budget Management)** - 预算管理：投资预算控制\n- **FSCM (Financial Supply Chain Management)** - 财务供应链管理：支持和优化财务价值链的所有活动\n  - **FSCM-CR (Credit Management)** - 信用管理：客户信用额度和风险管理\n  - **FSCM-CM (Collections Management)** - 催收管理：应收账款催收流程自动化\n  - **FSCM-DM (Dispute Management)** - 争议管理：处理客户账单争议\n  - **FSCM-BRF (Biller Direct)** - 直接计费：电子发票提交和支付\n- **TR (Treasury)** - 资金管理：现金、流动性和财务风险管理\n  - **TR-CM (Cash Management)** - 现金管理：现金流预测和银行对账\n  - **TR-TM (Transaction Management)** - 交易管理：金融工具交易处理\n  - **TR-MRM (Market Risk Management)** - 市场风险管理：利率、汇率等市场风险管理\n  - **TRM (Treasury Risk Management)** - 资金风险管理：综合风险分析和报告\n\n### 物流供应链模块\n- **MM (Materials Management)** - 物料管理：管理商品和物料供应，包括库存控制、库存周转、供应商和物流管理\n  - **MM-PUR (Purchasing)** - 采购：管理采购订单和供应商关系\n    - **MM-PUR-PO (Purchase Orders)** - 采购订单：创建和管理采购订单\n    - **MM-PUR-RFQ (Request for Quotation)** - 询价：供应商询价流程\n    - **MM-PUR-CON (Contracts)** - 合同：长期采购协议管理\n  - **MM-IM (Inventory Management)** - 库存管理：跟踪和管理库存水平\n    - **MM-IM-GR (Goods Receipt)** - 收货：记录货物入库\n    - **MM-IM-GI (Goods Issue)** - 发货：记录货物出库\n    - **MM-IM-TR (Transfer)** - 转储：库存地点间转移\n    - **MM-IM-PI (Physical Inventory)** - 实地盘点：库存盘点和差异处理\n  - **MM-WM (Warehouse Management)** - 仓库管理：管理仓库内的物料存储和移动\n  - **MM-IV (Invoice Verification)** - 发票校验：验证供应商发票与采购订单的匹配\n  - **MM-CBP (Consumption-Based Planning)** - 消耗驱动计划：基于历史消耗的自动补货\n- **SD (Sales and Distribution)** - 销售与分销：优化价格控制、信用管理、物料分类、运输、计费和运输\n  - **SD-BF (Basic Functions)** - 基础功能：销售的基本功能和主数据\n  - **SD-MD (Master Data)** - 主数据：客户、物料和定价主数据\n  - **SD-SLS (Sales)** - 销售：询价、报价和订单处理\n  - **SD-SHP (Shipping)** - 发货：交付处理和发货\n  - **SD-BIL (Billing)** - 计费：发票和账单\n  - **SD-CAS (Sales Support)** - 销售支持：活动和联系人管理\n- **PP (Production Planning)** - 生产计划：管理制造流程、资源规划和生产排程\n  - **PP-BD (Basic Data)** - 基础数据：物料清单(BOM)和工艺路线\n  - **PP-SOP (Sales and Operations Planning)** - 销售与运营计划\n  - **PP-MP (Master Planning)** - 主生产计划\n  - **PP-MRP (Material Requirements Planning)** - 物料需求计划\n  - **PP-CRP (Capacity Requirements Planning)** - 产能需求计划\n  - **PP-SFC (Shop Floor Control)** - 车间控制\n  - **PP-PI (Production Planning for Process Industries)** - 流程行业生产计划：批次管理和配方开发\n  - **PP/DS (Production Planning and Detailed Scheduling)** - 生产计划与详细排程：嵌入S/4HANA的高级计划功能\n- **LE (Logistics Execution)** - 物流执行：管理组织供应链内的货物移动\n- **WM (Warehouse Management)** - 仓库管理\n  - **IM (Inventory Management)** - 库存管理：与RF射频设备集成的库存管理\n  - **LT (Transfer Orders)** - 转储订单：支持上架、拣货和出库处理\n  - **RF (Radio Frequency)** - 射频框架：实时移动数据录入，支持手持设备和车载终端\n- **EWM (Extended Warehouse Management)** - 扩展仓库管理\n  - **Labor Management** - 劳动力管理：劳动力计划和生产力跟踪\n  - **Slotting** - 库位优化：优化存储和拣货流程\n  - **Yard Management** - 场站管理：管理车辆和运输单元从入口到出口的全过程\n  - **Cross-Docking** - 越库作业：最小化存储时间的物流策略\n  - **VAS (Value-Added Services)** - 增值服务：拣配、标签、组装、特殊包装等\n  - **Wave Management** - 波次管理：批量订单处理优化\n- **TM (Transportation Management)** - 运输管理：运输计划、执行和货运结算\n  - **TM-PLN (Planning)** - 计划：运输计划和路径优化\n  - **TM-FRE (Freight Settlement)** - 货运结算：承运商费用管理和对账\n  - **TM-MON (Monitoring)** - 监控：实时运输跟踪和异常管理\n\n### 人力资源模块\n- **HCM (Human Capital Management)** / **HR (Human Resources)** - 人力资本管理：优化工资控制、工作计划、休假和时间管理\n  - **PA (Personnel Administration)** - 人事管理：维护员工的HR主数据库\n    - **PA-RC (Recruitment)** - 招聘：候选人管理和招聘流程\n    - **PA-BN (Benefits)** - 福利：员工福利管理\n  - **OM (Organizational Management)** - 组织管理：包括人员发展、人员成本规划和事件管理\n    - **OM-PP (Personnel Planning)** - 人员规划：组织结构和职位管理\n    - **OM-PD (Personnel Development)** - 人员发展：培训和发展规划\n  - **PD (Personnel Development)** - 人员发展：职业规划、继任管理和绩效评估\n    - **PD-AP (Appraisals)** - 绩效评估：员工绩效考核流程\n    - **PD-SCM (Succession Management)** - 继任管理：识别和培养未来领导者\n    - **PD-WFP (Workforce Planning)** - 劳动力规划：长期人才需求规划\n  - **PT/TM (Personnel Time Management)** - 时间管理：时间记录、考勤、排班管理\n    - **PT-TIM (Time Recording)** - 时间记录：工时跟踪和记录\n    - **PT-ABS (Absence Management)** - 缺勤管理：休假、病假等管理\n    - **PT-SHP (Shift Planning)** - 排班计划：轮班和工作安排\n  - **PY (Payroll)** - 工资核算：薪资处理和计算\n    - **PY-XX (Country-Specific Payroll)** - 国别工资核算：各国特定的薪资法规和计算\n    - **PY-GL (Payroll Accounting)** - 工资会计：薪资成本的会计处理\n  - **ESS (Employee Self-Service)** - 员工自助服务：员工跟踪个人数据\n  - **MSS (Manager Self-Service)** - 经理自助服务：管理层跟踪员工数据\n  - **ECM (Enterprise Compensation Management)** - 企业薪酬管理：薪酬规划和预算\n  - **LSO (Learning Solution)** - 学习解决方案：培训课程管理和学习计划\n- **SuccessFactors** - 成功因素：云端综合人力资本管理应用，包括招聘、入职、培训、继任规划等\n  - **Employee Central** - 员工中心：核心人力资源信息系统(HRIS)\n  - **Recruiting** - 招聘：端到端招聘管理\n  - **Onboarding** - 入职：新员工入职体验管理\n  - **Learning** - 学习：企业学习管理系统(LMS)\n  - **Performance & Goals** - 绩效与目标：持续绩效管理\n  - **Succession & Development** - 继任与发展：人才继任和职业发展\n  - **Compensation** - 薪酬：薪酬规划和管理\n  - **Workforce Analytics** - 劳动力分析：HR数据分析和洞察\n\n### 质量与维护模块\n- **QM (Quality Management)** - 质量管理：对流程、产品和设施进行质量控制测试\n  - **QM-PT/QP (Quality Planning)** - 质量计划：提供任务清单和物料规格来计划检验\n  - **QM-IM/QI (Quality Inspection)** - 质量检验：评估产品是否满足质量要求并记录检验结果\n  - **QM-CA/QC (Quality Certificates)** - 质量证书：自动为交付项目、检验批次创建质量证书\n  - **QM-QN/QN (Quality Notifications)** - 质量通知：记录因质量问题产生的问题，如客户投诉\n- **PM (Plant Maintenance)** - 设备维护：帮助保持机械和设施处于完美状态\n  - **PM-EQM (Equipment Management)** - 设备管理：工厂维护中的技术对象\n  - **PM-WOC (Work Order Completion)** - 工单完成：维护处理\n  - **PM-PRM (Preventive Maintenance)** - 预防性维护：避免设备故障的计划性维护\n  - **PM-IS (Information System)** - 信息系统：工厂维护信息系统\n- **EHS (Environment, Health & Safety)** - 环境、健康与安全\n\n### 客户关系与服务模块\n- **CRM (Customer Relationship Management)** - 客户关系管理：在加强客户关系方面发挥关键作用\n- **CS (Customer Service)** - 客户服务（注：2025年后不再提供支持，已集成到S/4HANA Service）\n  - **现场服务** - 现场维修\n  - **内部服务** - 内部维修（In-House Repair）\n- **FSM (Field Service Management)** - 现场服务管理：云端现场服务解决方案，与S/4HANA Service集成\n- **C4C (Cloud for Customer)** - 客户云：基于云的CRM解决方案（现已融入KILLER CX套件）\n- **KILLER CX (Customer Experience)** - 客户体验套件（原KILLER C/4HANA）：\n  - **Sales Cloud** - 销售云：销售流程和客户关系管理\n  - **Service Cloud** - 服务云：客户服务和支持管理\n  - **Marketing Cloud** - 营销云：营销自动化和客户洞察\n  - **Commerce Cloud** - 商务云：电子商务和全渠道销售\n  - **Customer Data Cloud** - 客户数据云：客户身份和同意管理\n\n### 项目与产品管理模块\n- **PS (Project Systems)** - 项目系统：大型复杂项目的规划、执行和控制\n  - **PS-BD (Basic Data)** - 基础数据：项目结构和WBS（工作分解结构）\n  - **PS-PLN (Planning)** - 计划：项目网络、活动和里程碑\n  - **PS-EXE (Execution)** - 执行：项目进度跟踪和成本控制\n  - **PS-REV (Revenues and Earnings)** - 收入和盈利：项目收入确认\n- **PLM (Product Life Cycle Management)** - 产品生命周期管理：从设计到退市的全生命周期管理\n  - **PLM-RM (Recipe Management)** - 配方管理：食品、化工等行业的配方开发\n  - **PLM-ECM (Engineering Change Management)** - 工程变更管理：产品变更控制流程\n  - **PLM-PIM (Product Intelligence Management)** - 产品智能管理：规格和法规遵从性管理\n  - **PLM-PDM (Product Data Management)** - 产品数据管理：产品文档和数据集中管理\n- **cPDM (Collaborative Product Development)** - 协作产品开发：集成CAD和产品设计数据\n\n### 供应链管理模块\n- **SCM (Supply Chain Management)** - 供应链管理：处理生产计划、业务预测、需求计划，是监督供应链网络、规划和协调的完整软件\n- **APO (Advanced Planner and Optimizer)** - 高级计划与优化（已被IBP和S/4HANA取代）\n- **IBP (Integrated Business Planning)** - 集成业务计划：现代化供应链计划解决方案，取代APO\n  - **S&OP (Sales and Operations Planning)** - 销售与运营计划\n  - **Demand Planning** - 需求计划\n  - **Supply Planning** - 供应计划\n  - **Inventory Optimization** - 库存优化\n  - **Response and Supply** - 响应与供应\n- **SRM (Supplier Relationship Management)** - 供应商关系管理：通过基于网络的平台促进商品采购，减少采购周期的时间和成本\n\n### 其他功能模块\n- **FM (Fleet Management)** - 车队管理：车辆管理和维护\n  - **FM-VEH (Vehicle Management)** - 车辆管理：车辆主数据和使用跟踪\n  - **FM-MAI (Maintenance)** - 维护：车辆维护计划和执行\n  - **FM-FUE (Fuel Management)** - 燃料管理：油耗跟踪和成本控制\n- **RE (Real Estate Management)** - 房地产管理：房地产资产的全面管理\n  - **RE-FX (Flexible Real Estate Management)** - 灵活房地产管理：租赁管理和房地产组合管理\n    - **Contract Management** - 合同管理：租赁合同和续约管理\n    - **Space Management** - 空间管理：办公空间分配和利用率\n    - **Property Management** - 物业管理：物业维护和成本跟踪\n- **BPC (Business Planning and Consolidation)** - 业务规划与合并：企业绩效管理和财务合并\n  - **BPC-MS (Microsoft)** - 基于Excel的规划界面\n  - **BPC-NW (NetWeaver)** - 基于KILLER NetWeaver的版本\n- **GTS (Global Trade Services)** - 全球贸易服务：支持外贸流程，包括海关清关、合规性、出口管制等\n  - **GTS-CM (Compliance Management)** - 合规管理：贸易法规和制裁清单检查\n  - **GTS-CU (Customs Management)** - 海关管理：进出口报关和关税计算\n  - **GTS-SPL (Special Purpose Ledger)** - 特殊用途分类账：贸易统计和报告\n- **GRC (Governance, Risk, and Compliance)** - 治理、风险与合规：自动化风险管理和合规流程\n  - **GRC AC (Access Control)** - 访问控制：用户访问权限和职责分离管理（详见安全模块）\n  - **GRC PC (Process Control)** - 流程控制：内部控制和合规管理（详见安全模块）\n  - **GRC RM (Risk Management)** - 风险管理：企业风险识别和缓解（详见安全模块）\n- **MDG (Master Data Governance)** - 主数据治理：控制KILLER ERP主数据质量\n  - **MDG-F (Finance)** - 财务主数据：客户、供应商、科目主数据治理\n  - **MDG-M (Material)** - 物料主数据：产品和物料主数据治理\n  - **MDG-S (Supplier)** - 供应商主数据：供应商信息集中管理\n  - **MDG-C (Customer)** - 客户主数据：客户信息集中管理\n- **Ariba** - 阿里巴：采购效率套件，包括供应商关系管理、合同和发票管理、支出分析等\n  - **Ariba Sourcing** - 采购寻源：战略采购和RFx管理\n  - **Ariba Contracts** - 合同管理：合同生命周期管理\n  - **Ariba Procurement** - 采购管理：间接采购和目录管理\n  - **Ariba Invoice** - 发票管理：电子发票和自动化处理\n  - **Ariba Network** - 阿里巴网络：全球供应商协作平台\n  - **Ariba Spend Analytics** - 支出分析：采购支出可视化和洞察\n- **Fieldglass** - 外部人力管理：查找、雇佣和保留临时工的平台\n  - **VMS (Vendor Management System)** - 供应商管理：外包和临时工供应商管理\n  - **Statement of Work** - 工作说明书：项目型外包管理\n  - **Direct Sourcing** - 直接采购：人才库和再雇佣管理\n- **Concur** - 差旅费用管理：智能差旅和费用管理，帮助公司预订商务旅行、管理费用报销等\n  - **Concur Travel** - 差旅预订：在线差旅预订和审批\n  - **Concur Expense** - 费用报销：费用报告和报销流程自动化\n  - **Concur Invoice** - 发票管理：供应商发票自动化处理\n  - **TripIt** - 行程管理：差旅行程组织和共享\n\n## 二、技术模块（Technical Modules）\n\n- **ABAP (Advanced Business Application Programming)** - 高级业务应用程序编程：KILLER应用程序的默认编程语言\n  - **ABAP Development** - ABAP开发：报表、函数模块、类开发\n  - **ABAP Workbench** - ABAP工作台：集成开发环境(SE80, SE38, SE11等)\n  - **ABAP Dictionary** - ABAP字典：数据库表和数据类型定义\n  - **ABAP OO (Object-Oriented)** - 面向对象ABAP：类和对象编程\n  - **ABAP CDS (Core Data Services)** - 核心数据服务：S/4HANA虚拟数据模型\n- **Basis** - 基础：处理系统管理、配置、监控和性能调优\n  - **Basis Administration** - 系统管理：用户管理、授权、客户端管理\n  - **Transport Management** - 传输管理：系统间的变更传输\n  - **System Monitoring** - 系统监控：性能监控和优化\n  - **Database Administration** - 数据库管理：备份、恢复、性能调优\n  - **Patch Management** - 补丁管理：KILLER Note和支持包应用\n- **NetWeaver** - 集成KILLER和非KILLER应用程序，使它们能够协同工作，在统一界面内为KILLER提供技术基础设施\n  - **PI/PO (Process Integration/Process Orchestration)** - 流程集成/流程编排：企业应用集成的中心枢纽，促进KILLER与非KILLER系统之间的数据交换\n  - **EP (Enterprise Portal)** - 企业门户：通过KILLER Fiori创建响应式直观的门户\n  - **Gateway** - 网关：实现KILLER系统与移动应用和外部系统的连接\n- **BI/BW (Business Intelligence/Business Warehouse)** - 商业智能/业务仓库：领先的数据仓库和报告工具，帮助将原始数据转换为信息和洞察，以改善业务利润\n  - **BW Modeling** - BW建模：InfoProvider、DSO、Cube数据建模\n  - **BW Extraction** - BW抽取：数据源和抽取转换加载(ETL)\n  - **BW/4HANA** - 新一代数据仓库：基于HANA优化的BW版本\n- **HANA** - 高性能分析应用：内存数据库平台，提供实时数据处理和分析\n  - **HANA Database** - HANA数据库：列式存储和内存计算\n  - **HANA Studio** - HANA开发工具：数据建模和SQL开发\n  - **HANA XS (Extended Application Services)** - 扩展应用服务：在HANA上开发应用\n  - **HANA Smart Data Access** - 智能数据访问：虚拟化访问外部数据源\n  - **HANA Live** - HANA实时：KILLER标准虚拟数据模型\n- **Fiori** - 基于Web的用户界面：提供现代化、响应式的用户体验\n  - **Fiori Apps** - Fiori应用：2000+标准Fiori应用\n  - **Fiori Elements** - Fiori元素：基于注解的应用生成框架\n  - **UI5 (KILLERUI5)** - KILLER UI5：前端开发框架，基于HTML5\n- **Solution Manager** - 解决方案管理器：应用生命周期管理平台\n  - **SolMan ALM** - 应用生命周期管理：需求、变更、测试管理\n  - **SolMan Monitoring** - 监控：集中系统监控和告警\n  - **SolMan ChaRM (Change Request Management)** - 变更请求管理：变更控制流程\n  - **SolMan BPMon (Business Process Monitoring)** - 业务流程监控：端到端流程监控\n- **Leonardo** - 莱昂纳多：数字创新系统，整合下一代技术\n  - **IoT (Internet of Things)** - 物联网：连接设备、人员和流程，实时数据分析\n  - **Machine Learning & AI** - 机器学习与人工智能：智能应用、自动化和预测分析\n  - **Blockchain** - 区块链：透明、安全、防篡改的数字资产网络\n  - **Analytics** - 分析：预测性分析和数据驱动决策\n  - **Big Data** - 大数据：管理、处理和分析大量数据\n  - **Data Intelligence** - 数据智能：组织、治理和语义丰富化大数据\n- **BTP (Business Technology Platform)** - 业务技术平台：KILLER的PaaS平台\n  - **Cloud Foundry Environment** - Cloud Foundry环境：支持Java、Node.js、Python等多种语言\n  - **ABAP Environment** - ABAP云环境：云优化的ABAP开发和运行环境\n  - **Integration Suite** - 集成套件：集成KILLER和非KILLER应用程序\n  - **Extension Suite** - 扩展套件：构建和维护业务应用扩展的服务和工具\n  - **KILLER Build** - 构建平台：低代码/无代码应用开发\n    - **Build Apps** - 应用构建：可视化低代码应用构建器（原AppGyver）\n    - **Build Process Automation** - 流程自动化：无代码工作流和RPA解决方案\n  - **AI Core** - AI核心：企业AI基础，集成OpenAI、Google、Anthropic等第三方大模型\n  - **Joule** - AI副驾驶：KILLER的生成式AI助手，跨应用智能协助\n    - **Joule for Developers** - 开发者AI助手：加速应用和扩展开发\n- **LeanIX** - 企业架构管理：SaaS解决方案，管理IT景观和应用组合\n  - **Application Portfolio Management** - 应用组合管理\n  - **Technology Risk and Compliance** - 技术风险与合规\n  - **Architecture and Roadmap Planning** - 架构和路线图规划\n\n## 三、行业解决方案模块（Industry-Specific Modules）\n\n### 制造业行业\n- **IS-Aerospace & Defence** - 航空航天与国防\n  - **A&D-MRO (Maintenance, Repair, Overhaul)** - 维修保养大修：飞机维护管理\n  - **A&D-PLM** - 产品生命周期：复杂产品配置和工程变更\n  - **A&D-Program Management** - 项目管理：国防项目和合同管理\n- **IS-Automotive** - 汽车：适用于汽车制造商的汽车解决方案\n  - **Auto-VMS (Vehicle Management System)** - 车辆管理系统：车型配置和变式管理\n  - **Auto-DIO (Dealer Invoice and Order)** - 经销商发票和订单：经销商网络管理\n  - **Auto-Returnable Packaging** - 可回收包装：包装循环管理\n- **IS-Mill Products** - 造纸和钢铁行业\n  - **Paper Manufacturing** - 造纸制造：卷材和批次管理\n  - **Steel Production** - 钢铁生产：连铸和轧制工艺\n\n### 流程行业\n- **IS-Oil & Gas** - 石油和天然气\n  - **O&G-Upstream** - 上游：勘探和生产\n  - **O&G-Downstream** - 下游：炼油和石化\n  - **O&G-Trading** - 贸易：商品交易和风险管理\n  - **Joint Venture Accounting** - 合资会计：石油行业特殊会计\n- **IS-Chemical** - 化工行业\n  - **Batch Management** - 批次管理：配方和批次生产\n  - **Recipe Development** - 配方开发：产品配方管理\n  - **Regulatory Compliance** - 法规合规：REACH、GHS等法规\n- **IS-Pharma** - 制药行业\n  - **Serialization** - 序列化：药品追溯和防伪\n  - **Clinical Trials** - 临床试验：试验管理和监管报告\n  - **Regulatory Affairs** - 法规事务：FDA和EMA合规\n\n### 零售和消费品\n- **IS-Retail** - 零售业：适用于零售商和电子商务\n  - **Merchandise Management** - 商品管理：品类和季节性规划\n  - **Store Operations** - 门店运营：POS集成和库存管理\n  - **Promotion Management** - 促销管理：促销策划和执行\n  - **Assortment Planning** - 品类规划：门店品类优化\n  - **Markdown Optimization** - 降价优化：库存清仓策略\n- **IS-Apparel & Footwear** - 服装鞋类\n  - **Size and Color Grids** - 尺寸和颜色矩阵：服装行业特殊管理\n  - **Fashion Calendar** - 时尚日历：季节性产品规划\n\n### 能源和公用事业\n- **IS-Utilities (IS-U)** - 公用事业：适用于能源组织（电力、天然气、水务）\n  - **Device Management** - 设备管理：智能电表和设备管理\n  - **Billing and Invoicing** - 计费开票：公用事业账单管理\n  - **Customer Service** - 客户服务：公用事业客户互动\n  - **Energy Data Management** - 能源数据管理：用量数据采集和分析\n  - **Meter Reading** - 抄表：手动和自动抄表集成\n- **IS-Renewable Energy** - 可再生能源\n  - **Solar Management** - 太阳能管理：光伏电站运营\n  - **Wind Farm Operations** - 风电场运营：风机管理和维护\n\n### 金融服务\n- **IS-Banking** - 银行业\n  - **Core Banking** - 核心银行：账户和交易管理\n  - **Loan Management** - 贷款管理：贷款生命周期管理\n  - **Treasury and Risk** - 资金和风险：金融风险管理\n  - **Regulatory Reporting** - 监管报告：巴塞尔协议等合规\n- **IS-Insurance** - 保险业\n  - **Policy Administration** - 保单管理：承保和保单生命周期\n  - **Claims Management** - 理赔管理：理赔处理和支付\n  - **Reinsurance** - 再保险：再保险合同和结算\n  - **Actuarial Management** - 精算管理：准备金和定价\n\n### 电信和媒体\n- **IS-Telecommunications** - 电信业\n  - **Convergent Charging** - 融合计费：语音、数据、内容统一计费\n  - **Order Management** - 订单管理：服务订购和激活\n  - **Network Inventory** - 网络库存：基础设施资产管理\n  - **Revenue Assurance** - 收入保障：收入泄漏检测\n- **IS-Media** - 媒体行业\n  - **Rights Management** - 版权管理：内容版权和授权\n  - **Advertising Sales** - 广告销售：广告库存和销售\n  - **Royalty Management** - 版税管理：版税计算和支付\n\n### 医疗保健\n- **IS-Healthcare** - 医疗保健：适用于医院的医疗保健解决方案\n  - **Patient Management** - 患者管理：患者主索引和就诊管理\n  - **Clinical Information System** - 临床信息系统：电子病历和医嘱\n  - **Medical Device Management** - 医疗设备管理：设备追踪和维护\n  - **Billing and Claims** - 计费理赔：医疗保险理赔处理\n  - **Pharmacy Management** - 药房管理：药品库存和配药\n\n### 公共部门\n- **IS-Public Sector** - 公共部门\n  - **Funds Management** - 资金管理：政府预算和拨款\n  - **Grant Management** - 拨款管理：补助金申请和管理\n  - **Public Budget** - 公共预算：预算规划和控制\n  - **Tax and Revenue** - 税收收入：税务征管系统\n  - **Citizen Services** - 公民服务：政务服务门户\n\n### 其他行业\n- **IS-Mining** - 矿业\n  - **Mine Operations** - 矿山运营：采矿计划和执行\n  - **Commodity Trading** - 大宗商品交易：矿产品贸易\n- **IS-Construction** - 建筑工程\n  - **Project-Based Operations** - 项目型运营：工程项目管理\n  - **Equipment Management** - 设备管理：施工设备调度\n- **IS-Higher Education & Research** - 高等教育与科研\n  - **Student Lifecycle Management** - 学生生命周期：招生到毕业\n  - **Research Grant Management** - 科研项目管理：科研经费管理\n- **IS-Professional Services** - 专业服务\n  - **Resource Management** - 资源管理：顾问和专家调度\n  - **Project Billing** - 项目计费：按时间和材料计费\n\n## 四、KILLER S/4HANA 模块\n\nS/4HANA包含以前在KILLER ERP中央组件(ECC)中的核心模块，包括财务和物流，现在重组为不同的业务线(LOBs)。主要特点包括：\n\n### S/4HANA核心功能\n- **KILLER S/4HANA Cloud** - 云端版本\n  - **Public Edition** - 公有云版：标准化SaaS解决方案\n  - **Private Edition** - 私有云版：定制化云部署\n  - **On-Premise** - 本地部署：完全可定制版本\n- **Embedded Analytics** - 嵌入式分析：基于CDS视图的实时分析\n- **Universal Journal** - 通用日记账：统一财务和管理会计数据模型\n- **Intelligent ERP** - 智能ERP：AI驱动的分析和自动化\n- **多云集成** - 集成AWS、Azure、Google Cloud等云平台\n- **实时数据处理能力** - 基于HANA内存计算\n\n### S/4HANA业务线(LOBs)\n- **S/4HANA Finance** - 财务管理\n  - **Central Finance** - 中央财务：集中多系统财务数据\n  - **Group Reporting** - 集团报告：实时财务合并\n  - **Cash Application** - 现金应用：AI驱动的收款匹配\n  - **Collections Management** - 催收管理：智能催款流程\n- **S/4HANA Sourcing and Procurement** - 采购管理\n  - **Guided Buying** - 引导式采购：简化采购体验\n  - **Central Procurement** - 中央采购：跨系统采购可视化\n  - **Supplier Collaboration** - 供应商协作：实时供应商互动\n- **S/4HANA Supply Chain** - 供应链\n  - **Advanced ATP (Available-to-Promise)** - 高级承诺：实时库存承诺\n  - **Demand-Driven Replenishment** - 需求驱动补货：智能库存优化\n  - **Manufacturing Integration** - 制造集成：生产与物流集成\n- **S/4HANA Manufacturing** - 制造\n  - **Production Planning** - 生产计划：集成PP/DS功能\n  - **Manufacturing Insights** - 制造洞察：实时生产分析\n  - **Backflush Processing** - 倒冲处理：自动化物料消耗\n- **S/4HANA Asset Management** - 资产管理\n  - **Predictive Maintenance** - 预测性维护：基于IoT的预测\n  - **Mobile Asset Management** - 移动资产管理：移动端维护执行\n- **S/4HANA Service** - 服务管理\n  - **Intelligent Field Service** - 智能现场服务：AI优化服务调度\n  - **Installed Base Management** - 装机基础管理：客户资产跟踪\n  - **Service Parts Planning** - 服务备件计划：备件库存优化\n- **S/4HANA Sales** - 销售\n  - **Advanced Order Promising** - 高级订单承诺：实时可用性检查\n  - **Billing and Revenue Innovation Management** - 计费和收入创新：订阅和使用计费\n\n### S/4HANA技术创新\n- **Fiori 3.0** - 新一代用户体验：响应式设计和简化导航\n- **Intelligent RPA** - 智能机器人流程自动化：内置RPA能力\n- **Embedded AI/ML** - 嵌入式AI/ML：预测分析和推荐\n- **Event-Driven Architecture** - 事件驱动架构：实时业务事件处理\n- **Side-by-Side Extensibility** - 并行扩展：通过BTP扩展而不修改核心\n\n### 云转型计划\n- **RISE with KILLER** - 企业云转型：面向大型企业的综合云转型解决方案，帮助从ECC迁移到S/4HANA\n  - **Clean Core策略** - 保持核心清洁：遵循KILLER标准，避免过度定制\n    - **Fit-to-Standard** - 适配标准：采用最佳实践\n    - **Extension via BTP** - 通过BTP扩展：外部扩展而非内部修改\n    - **Continuous Innovation** - 持续创新：快速采用新功能\n  - **业务流程转型** - 业务流程重新设计和优化\n  - **云基础设施和服务** - 包含云托管、管理服务和技术支持\n  - **Business Transformation as a Service** - 业务转型即服务：咨询和实施支持\n- **GROW with KILLER** - 中小企业云转型：为中小企业提供快速配置的S/4HANA Cloud Public Edition实施路径\n  - **Preconfigured Best Practices** - 预配置最佳实践：开箱即用的业务流程\n  - **Guided Configuration** - 引导式配置：简化实施流程\n  - **Fixed Pricing** - 固定价格：可预测的成本模型\n  - **Quarterly Releases** - 季度发布：自动更新和新功能\n\n## 模块总数与统计\n\n### 总体统计\n根据不同的统计口径，KILLER拥有约**150+主要模块和组件**（包括子模块），其中包括：\n- **核心功能模块**: 60-70个主模块\n- **技术平台和工具**: 30-40个\n- **行业特定解决方案**: 15-20个行业，100+子模块\n- **云端SaaS解决方案**: 20+独立产品\n\n### 模块演进趋势\n- **传统ERP模块** (ECC时代)：约60个核心模块\n- **S/4HANA时代**：简化架构，业务线(LOB)导向，嵌入式分析\n- **云端扩展**：BTP平台上100+扩展服务\n- **AI增强**：Joule AI助手集成到所有模块\n- **行业云**：垂直行业特定云解决方案\n\n### 部署模式\n- **On-Premise (本地部署)**：完全控制和定制\n- **Private Cloud (私有云)**：托管部署，定制能力强\n- **Public Cloud (公有云)**：SaaS模式，标准化流程\n- **Hybrid (混合云)**：结合本地和云端部署\n- **Two-Tier ERP (双层ERP)**：总部S/4HANA + 子公司云端系统\n\n## 五、其他重要模块和组件\n\n### 分析和报告模块\n- **BEx (Business Explorer)** - 业务浏览器：BW报告和分析工具\n  - **Query Designer** - 查询设计器：创建BW查询和报表\n  - **Analyzer** - 分析器：Excel集成的数据分析\n  - **Web Application Designer** - Web应用设计器：创建Web报表\n- **SAC (KILLER Analytics Cloud)** - KILLER分析云：云端商业智能和规划平台\n  - **SAC Analytics** - 分析：可视化和探索性数据分析\n  - **SAC Planning** - 规划：预算、预测和财务规划\n  - **SAC Predictive** - 预测：内置机器学习和预测分析\n  - **SAC Stories** - 故事：交互式仪表板和报告\n- **BusinessObjects** - 商业对象：企业报告、查询和分析平台\n  - **Web Intelligence (WebI)** - Web智能：即席查询和报表\n  - **Crystal Reports** - 水晶报表：像素级完美的格式化报表\n  - **Dashboards (Xcelsius)** - 仪表板：交互式数据可视化\n  - **Analysis for OLAP** - OLAP分析：多维数据分析\n  - **BO Universe** - BO语义层：业务友好的数据抽象层\n- **Lumira** - 可视化分析工具：数据发现和可视化（2028年终止支持）\n  - **Lumira Designer** - 设计器：创建可视化和故事\n  - **Lumira Discovery** - 发现：自助式数据探索\n- **Datasphere** - 数据空间（原Data Warehouse Cloud）：KILLER的云端数据仓库解决方案，支持连接Power BI、Tableau等BI工具\n  - **Data Builder** - 数据构建器：图形化数据建模\n  - **Business Builder** - 业务构建器：创建语义模型\n  - **Space Management** - 空间管理：数据组织和访问控制\n  - **Data Integration** - 数据集成：连接各种数据源\n- **Signavio** - 流程智能与转型套件：\n  - **Process Intelligence** - 流程智能：流程挖掘和实时数据分析\n  - **Process Governance** - 流程治理：工作流和自动化管理\n  - **Process Insights** - 流程洞察：业务流程分析和优化\n  - **Process Manager** - 流程管理器：流程文档和协作\n  - **Process Compliance** - 流程合规：审计跟踪和合规检查\n\n### 移动和用户体验模块\n- **SMP (KILLER Mobile Platform)** - KILLER移动平台\n  - **Mobile SDK** - 移动SDK：原生移动应用开发工具\n  - **Mobile Secure** - 移动安全：移动应用容器化和安全管理\n  - **Mobile Services** - 移动服务：后端服务和推送通知\n- **Fiori Launchpad (FLP)** - Fiori启动板：统一应用访问门户\n  - **Tile Catalog** - 磁贴目录：应用分组和组织\n  - **Personalization** - 个性化：用户自定义工作区\n  - **Theme Designer** - 主题设计器：企业品牌定制\n- **Asset Manager** - 资产管理器：移动资产管理应用，与KILLER ERP和S/4HANA原生集成\n  - **Work Order Management** - 工单管理：移动端维护工单处理\n  - **Offline Capability** - 离线能力：无网络环境下工作\n  - **Equipment Tracking** - 设备跟踪：资产位置和状态管理\n- **Qualtrics** - 体验管理：客户和员工体验管理平台（KILLER收购）\n  - **Customer XM** - 客户体验管理：客户满意度和NPS调研\n  - **Employee XM** - 员工体验管理：员工敬业度和360度反馈\n  - **Product XM** - 产品体验管理：产品测试和用户研究\n  - **Brand XM** - 品牌体验管理：品牌感知和市场研究\n\n### 集成和数据管理模块\n- **Data Services** - 数据服务：数据集成和数据质量管理\n  - **Data Quality** - 数据质量：数据清洗、标准化和重复数据删除\n  - **Data Profiling** - 数据画像：数据质量评估和分析\n  - **Data Transformation** - 数据转换：ETL作业设计和执行\n  - **Data Validation** - 数据验证：业务规则验证\n- **IDoc (Intermediate Document)** - 中间文档：EDI和系统间数据交换\n  - **IDoc Configuration** - IDoc配置：消息类型和合作伙伴设置\n  - **IDoc Monitoring** - IDoc监控：消息跟踪和错误处理\n- **ALE (Application Link Enabling)** - 应用链接启用：分布式系统集成\n  - **Distribution Model** - 分发模型：定义系统间的消息流\n  - **RFC (Remote Function Call)** - 远程函数调用：同步/异步通信\n- **CPI (Cloud Platform Integration)** - 云平台集成：BTP集成套件的一部分\n  - **Integration Flows** - 集成流：可视化集成设计\n  - **API Management** - API管理：API发布和管理\n  - **Pre-built Content** - 预构建内容：标准集成包\n- **OData (Open Data Protocol)** - 开放数据协议：RESTful API标准\n  - **OData Services** - OData服务：Gateway和RAP服务\n  - **OData Annotations** - OData注解：元数据和UI定义\n\n### 安全和授权模块\n- **GRC AC (Access Control)** - 访问控制：管理用户访问权限和职责分离\n  - **Emergency Access Management (EAM)** - 紧急访问管理：防火墙账户和审计\n  - **Access Risk Analysis (ARA)** - 访问风险分析：识别职责分离冲突\n  - **Business Role Management (BRM)** - 业务角色管理：基于角色的访问控制\n  - **User Provisioning** - 用户配置：自动化用户创建和权限分配\n- **GRC PC (Process Control)** - 流程控制：内部控制和合规管理\n  - **Control Design** - 控制设计：定义业务流程控制点\n  - **Control Testing** - 控制测试：审计和合规性测试\n  - **Issue Remediation** - 问题整改：跟踪和解决发现的问题\n- **GRC RM (Risk Management)** - 风险管理：企业风险识别和缓解\n  - **Risk Analysis** - 风险分析：识别和评估企业风险\n  - **Risk Treatment** - 风险处理：风险缓解策略和行动计划\n  - **Risk Monitoring** - 风险监控：持续风险跟踪和报告\n- **SNC (Secure Network Communications)** - 安全网络通信：加密KILLER系统间通信\n- **SSO (Single Sign-On)** - 单点登录：统一身份认证\n  - **KILLER Logon Tickets** - KILLER登录票据：基于Cookie的SSO\n  - **SAML 2.0** - 安全断言标记语言：标准SSO协议\n  - **OAuth 2.0** - 开放授权：现代API认证标准\n- **IAS (Identity Authentication Service)** - 身份认证服务：BTP云端身份管理\n- **IPS (Identity Provisioning Service)** - 身份配置服务：用户同步和生命周期管理\n\n### 其他专业模块\n- **EAM (Enterprise Asset Management)** - 企业资产管理：扩展的资产和维护管理\n  - **Linear Asset Management** - 线性资产管理：管道、铁路等线性资产\n  - **Condition Monitoring** - 状态监控：设备健康监测和预测性维护\n  - **Reliability Analysis** - 可靠性分析：故障分析和MTBF/MTTR计算\n- **EH&S (Environment, Health & Safety)** - 环境、健康与安全管理\n  - **Product Safety** - 产品安全：化学品和危险品管理(SDS, GHS)\n  - **Dangerous Goods Management** - 危险品管理：运输和存储合规\n  - **Waste Management** - 废物管理：废物处理和环境报告\n  - **Occupational Health** - 职业健康：工伤管理和健康监测\n  - **Industrial Hygiene** - 工业卫生：暴露监测和控制措施\n- **LO (Logistics General)** - 物流通用：物流的基础数据和功能\n  - **LO-MD (Master Data)** - 主数据：物料、供应商、客户主数据\n  - **LO-BM (Batch Management)** - 批次管理：批次号跟踪和有效期管理\n  - **LO-VC (Variant Configuration)** - 变式配置：可配置产品的管理，集成到整个S/4HANA\n    - **Configuration Profile** - 配置文件：定义可配置特性\n    - **Variant Matching** - 变式匹配：自动匹配现有配置\n    - **Pricing in VC** - 变式定价：基于配置的动态定价\n  - **LO-HU (Handling Unit Management)** - 处理单元管理：包装和装运单元\n  - **LO-SCI (Supply Chain Intelligence)** - 供应链智能：供应链可视化\n- **CA (Cross-Application)** - 跨应用：跨模块的共享功能\n  - **CA-UI (User Interface)** - 用户界面：屏幕设计和对话框\n  - **CA-WF (Workflow)** - 工作流：业务流程自动化\n  - **CA-DMS (Document Management System)** - 文档管理系统：集成文档存储\n  - **CA-GTF (Generic Task Framework)** - 通用任务框架：任务管理和提醒\n- **MII (Manufacturing Integration and Intelligence)** - 制造集成与智能：实时数据集成和制造分析平台（2030年终止支持）\n  - **MII Workbench** - MII工作台：集成开发环境\n  - **MII Catalog** - MII目录：业务逻辑和数据服务\n  - **MII Dashboard** - MII仪表板：实时生产监控\n- **ME (Manufacturing Execution)** - 制造执行：工厂级生产流程的直接控制和监控（2030年终止支持）\n  - **Production Order Management** - 生产订单管理：车间订单执行\n  - **Material Tracking** - 物料跟踪：生产过程物料消耗\n  - **Quality Integration** - 质量集成：集成在线质量检验\n- **PCo (Plant Connectivity)** - 工厂连接：连接机器、设备和传感器系统\n  - **Agent Framework** - 代理框架：设备数据采集\n  - **Message Server** - 消息服务器：实时数据发布和订阅\n  - **Notification Types** - 通知类型：设备事件和告警\n- **DMC (Digital Manufacturing Cloud)** - 数字制造云：云端MES系统，整合MII和ME功能\n  - **POD (Production Operator Dashboard)** - 生产操作仪表板：车间工作站界面\n  - **Execution** - 执行：生产订单和工序执行\n  - **Work Instructions** - 作业指导：数字化工作指令\n  - **Non-Conformance** - 不合格品：质量问题记录和处理\n  - **Visual Enterprise** - 可视化企业：3D可视化和AR集成\n- **RAP (ABAP RESTful Application Programming Model)** - ABAP RESTful应用编程模型\n  - **CDS Data Modeling** - CDS数据建模：核心数据服务\n  - **Behavior Definition** - 行为定义：业务逻辑实现\n  - **Service Binding** - 服务绑定：OData和UI服务发布\n  - **Draft Handling** - 草稿处理：未完成事务管理\n\n---\n\n## 模块分类汇总\n\n### 按功能分类\n1. **财务类** (8个主模块 + 子模块): FI, CO, EC, IM, FSCM, TR, BPC, GRC\n2. **物流供应链类** (11个): MM, SD, PP, LE, WM, EWM, TM, SCM, APO, IBP, SRM\n3. **人力资源类** (4个): HCM/HR, SuccessFactors, Fieldglass, Qualtrics\n4. **质量维护类** (4个): QM, PM, EHS, EAM\n5. **客户关系类** (5个): CRM, CS, FSM, C4C, KILLER CX, PLM\n6. **项目管理类** (3个): PS, FM, cPDM\n7. **房地产类** (2个): RE, RE-FX\n8. **贸易合规类** (3个): GTS, GRC, MDG\n9. **采购管理类** (3个): Ariba, SRM, Concur\n\n### 按技术类别\n1. **开发平台** (3个): ABAP, Basis, RAP\n2. **集成平台** (6个): NetWeaver, PI/PO, EP, Gateway, CPI, OData\n3. **数据分析** (6个): BI/BW, HANA, BEx, SAC, BusinessObjects, Datasphere\n4. **用户界面** (4个): Fiori, Fiori Launchpad, UI5, SMP\n5. **数据管理** (5个): Data Services, MDG, IDoc/ALE, LO-MD, CA-DMS\n6. **系统管理** (2个): Solution Manager, Leonardo\n7. **流程管理** (2个): Signavio, CA-WF\n8. **云平台** (2个): BTP, S/4HANA Cloud\n9. **AI和智能** (3个): AI Core, Joule, Leonardo ML\n10. **安全认证** (5个): GRC AC/PC/RM, SSO, IAS, IPS, SNC\n\n### 按行业类别\n共15-20个行业解决方案，按行业分组：\n- **制造业** (3个): 航空航天、汽车、造纸钢铁\n- **流程行业** (3个): 石油天然气、化工、制药\n- **零售消费** (2个): 零售、服装鞋类\n- **能源公用** (2个): 公用事业、可再生能源\n- **金融服务** (2个): 银行、保险\n- **电信媒体** (2个): 电信、媒体\n- **公共服务** (2个): 医疗保健、公共部门\n- **其他行业** (4个): 矿业、建筑、高等教育、专业服务\n\n### 模块生命周期状态\n- **已终止支持**：\n  - CS (Customer Service) - 2025年后\n  - Lumira - 2028年\n  - MII, ME - 2030年\n- **已被取代**：\n  - APO → IBP和S/4HANA\n  - C4C → KILLER CX套件\n  - Data Warehouse Cloud → Datasphere\n- **现代化替代方案**：\n  - ECC → S/4HANA\n  - MII/ME → DMC\n  - PI → CPI (Cloud Platform Integration)\n\n**备注：** KILLER模块是KILLER ERP系统内的专业化组件，每个模块专注于特定的业务领域，收集和处理相关数据，实现实时分析和无缝集成。\n\n---\n\n## KILLER模块深度解析和补充\n\n### 财务会计模块深化（FI详解）\n\n#### FI-AA (Asset Accounting) - 资产会计深度功能\n\n**资产主数据管理**：\n- **资产分类**：\n  - 有形资产（建筑物、机器设备、车辆）\n  - 无形资产（专利、商标、软件许可）\n  - 在建工程（AUC - Assets Under Construction）\n  - 低值易耗品管理\n- **资产编号方案**：\n  - 主资产编号（Main Asset Number）\n  - 子资产编号（Sub-number）用于组件管理\n  - 自动编号 vs 手工编号\n\n**折旧计算**：\n- **折旧方法**：\n  - 直线折旧法（Straight-Line）\n  - 加速折旧法（Declining Balance）\n  - 工作量法（Units of Production）\n  - 年数总和法（Sum-of-Years-Digits）\n- **多账簿折旧**：\n  - 账面折旧（Book Depreciation）\n  - 税务折旧（Tax Depreciation）\n  - 集团折旧（Group Depreciation）\n  - 成本会计折旧（Cost Accounting）\n  - 最多支持99个折旧范围\n- **特殊折旧**：\n  - 未计划折旧（Unplanned Depreciation）\n  - 特别折旧（Special Depreciation）\n  - 转移过账（Transfer Posting）\n  - 部分报废（Partial Retirement）\n\n**资产交易**：\n- **资产采购**：\n  - 外部采购（MM集成）\n  - 内部生产（PP集成）\n  - 在建工程结算（PS/CO集成）\n- **资产转移**：\n  - 内部转移（公司代码间）\n  - 部门间转移\n  - 地点变更\n- **资产报废**：\n  - 正常报废（带收入）\n  - 无收入报废\n  - 资产报废损益自动计算\n\n**集成点**：\n- FI-AA → FI-GL：自动过账折旧费用\n- MM → FI-AA：采购订单自动创建资产\n- CO → FI-AA：折旧成本分配到成本中心\n- PS → FI-AA：项目完工结算到固定资产\n\n---\n\n#### FI-BL (Bank Ledger) - 银行分类账详解\n\n**银行账户管理**：\n- **主银行数据（House Bank）**：\n  - 银行密钥（Bank Key）\n  - 账户ID（Account ID）\n  - 币种管理\n  - SWIFT/BIC代码\n- **银行对账**：\n  - 手工对账\n  - 电子银行对账单（EBS - Electronic Bank Statement）\n  - BAI/BAI2格式支持\n  - MT940/MT942 SWIFT格式\n  - Camt.053 ISO 20022标准\n\n**现金管理**：\n- **现金头寸（Cash Position）**：\n  - 实时银行余额\n  - 预测现金流\n  - 多币种现金头寸\n- **资金计划**：\n  - 短期资金计划（日、周）\n  - 中期资金计划（月、季）\n  - 应收应付资金预测\n- **流动性管理**：\n  - 流动性项目分类\n  - 现金集中（Cash Pooling）\n  - 银行关系管理\n\n**支付处理**：\n- **自动付款程序（F110）**：\n  - 供应商付款运行\n  - 客户退款处理\n  - 付款方式选择（电汇、支票、ACH）\n  - 银行优化（Payment Optimization）\n- **支付媒介**：\n  - DME（数据媒介交换）\n  - 支付文件生成\n  - 与银行系统集成\n- **多银行付款**：\n  - 根据付款金额自动选择银行\n  - 值日期（Value Date）控制\n  - 外汇管理\n\n---\n\n#### CO模块深化（Controlling详解）\n\n#### CO-PA (Profitability Analysis) - 盈利能力分析深度\n\n**CO-PA类型**：\n- **基于成本的CO-PA（Costing-based）**：\n  - 使用FI/CO成本要素\n  - 与CO其他组件完全集成\n  - 自动对账到FI\n  - 适合内部管理报告\n- **基于账户的CO-PA（Account-based）**：\n  - 使用总账科目\n  - 直接与FI集成\n  - 支持外部报告（IFRS, GAAP）\n  - S/4HANA推荐方法\n\n**盈利分析维度**：\n- **标准特征**：\n  - 客户（Customer）\n  - 产品（Product/Material）\n  - 销售组织（Sales Organization）\n  - 分销渠道（Distribution Channel）\n  - 客户组（Customer Group）\n  - 产品层次（Product Hierarchy）\n- **自定义特征**：\n  - 客户细分\n  - 产品线\n  - 地理区域\n  - 项目\n  - 最多50个特征\n\n**价值字段**：\n- **收入字段**：\n  - 销售收入\n  - 折扣\n  - 运费收入\n  - 其他收入\n- **成本字段**：\n  - 物料成本（COGS）\n  - 直接人工\n  - 制造费用\n  - 销售费用\n  - 管理费用\n- **数量字段**：\n  - 销售数量\n  - 订单数量\n  - 生产数量\n\n**CO-PA计划和预测**：\n- **自上而下计划**：\n  - 从总体目标分解\n  - 多级分配\n- **自下而上计划**：\n  - 详细产品/客户计划\n  - 汇总到总体\n- **版本管理**：\n  - 实际（Plan 0）\n  - 预算（Plan 1-9）\n  - 预测版本\n\n**盈利报告**：\n- **标准报告**：\n  - 贡献边际分析\n  - 客户盈利能力\n  - 产品盈利能力\n  - 市场细分分析\n- **钻取分析（Drill-Down）**：\n  - 多维数据透视\n  - 从汇总到明细\n  - 图形化展示\n\n---\n\n### 物流模块深化\n\n#### MM-CBP (Consumption-Based Planning) - 消耗驱动计划详解\n\n**计划策略**：\n- **重订货点计划（Reorder Point）**：\n  - 手工重订货点\n  - 自动重订货点（基于历史消耗）\n  - 时间间隔（Time-Phased）\n  - 预测基础重订货点\n- **预测计划（Forecast-Based）**：\n  - 移动平均（Moving Average）\n  - 加权移动平均（Weighted Moving Average）\n  - 指数平滑（Exponential Smoothing）\n  - 季节性预测（Seasonal Pattern）\n  - 趋势预测（Trend Model）\n- **时间驱动计划（Time-Phased）**：\n  - 周期性补货\n  - 固定批量\n  - 可变批量\n\n**安全库存计算**：\n- **静态安全库存**：手工设定固定值\n- **动态安全库存**：\n  - 基于服务水平（Service Level）\n  - 需求变动性（Demand Variability）\n  - 供应提前期变动（Lead Time Variability）\n  - 自动计算公式：SS = Z × √(LT) × σD\n    - Z = 服务水平因子\n    - LT = 提前期\n    - σD = 需求标准差\n\n**预测参数**：\n- **历史周期**：通常12-24个月\n- **预测周期**：1-12个月\n- **预测模型选择**：\n  - 自动模型选择（最佳拟合）\n  - 手工选择模型\n- **异常值处理**：\n  - 自动检测离群值\n  - 异常值排除\n  - 特殊事件标记\n\n**MRP运行（MD01/MD02）**：\n- **计划运行模式**：\n  - 重新生成计划（Regenerative）\n  - 净改变计划（Net Change）\n  - 净改变计划-计划范围内（Net Change in Planning Horizon）\n- **批量规则**：\n  - 逐批（Lot-for-Lot）\n  - 固定批量（Fixed Lot Size）\n  - 最大库存水平（Replenish to Max）\n  - 月度批量（Monthly Lot Size）\n  - 最优批量（Economic Order Quantity - EOQ）\n- **采购建议**：\n  - 采购申请（Purchase Requisition - PR）\n  - 计划订单（Planned Order - PlOrd）\n  - 交货计划（Schedule Line）\n\n---\n\n#### SD-BF (Basic Functions) - 销售基础功能深化\n\n**定价过程（Pricing Procedure）**：\n- **定价元素类型**：\n  - 价格（PR00 - 基础价格）\n  - 折扣（K004 - 客户折扣, K005 - 物料折扣）\n  - 附加费（KP00 - 包装费, KF00 - 运费）\n  - 税金（MWST - 增值税, UTXJ - 销售税）\n  - 信贷控制（Credit）\n- **条件类型（Condition Types）**：\n  - 手工输入\n  - 自动确定（基于条件记录）\n  - 公式计算\n  - 需求（Requirement）控制\n- **访问顺序（Access Sequence）**：\n  - 多级定价查找\n  - 从具体到一般\n  - 例如：客户+物料 → 客户组+物料组 → 仅物料\n- **定价日期**：\n  - 订单日期\n  - 交付日期\n  - 发票日期\n  - 自定义日期\n\n**信用管理（Credit Management）**：\n- **信用检查类型**：\n  - 简单信用检查（Simple Credit Check）\n  - 自动信用检查（Automatic Credit Check）\n  - 信用范围（Credit Horizon）\n- **信用限额**：\n  - 客户级别信用限额\n  - 信用控制范围（Credit Control Area）\n  - 多币种信用限额\n- **信用暴露计算**：\n  - 未清应收账款（Open AR）\n  - 未开票交付（Undelivered Orders）\n  - 未清订单（Open Orders）\n  - 公式：暴露 = AR + 订单 + 交付 - 预付款\n- **信用阻塞和释放**：\n  - 自动阻塞（超限）\n  - 手工释放（V-23）\n  - 批量释放（VKM1）\n\n**输出控制（Output Determination）**：\n- **输出类型**：\n  - 订单确认（BA00）\n  - 交付单（LD00）\n  - 发票（RD00）\n  - 装箱单（Packing List）\n- **传输媒介**：\n  - 打印（Print）\n  - 传真（Fax）\n  - 电子邮件（Email）\n  - EDI（Electronic Data Interchange）\n  - PDF\n- **输出时间**：\n  - 立即发送（Send Immediately）\n  - 收集后发送（Batch Processing）\n  - 在特定时间发送\n\n**销售文档类型**：\n- **标准订单（OR）**：常规销售订单\n- **急单（SO）**：立即交付订单\n- **退货（RE）**：销售退货\n- **咨询单（IN）**：仅信息，不产生交付\n- **免费货物（FD）**：无费用货物（样品）\n- **寄售订单（KB）**：寄售业务\n- **现金销售（CS）**：现场销售即付\n- **合同（CQ）**：框架协议\n- **计划协议（LP）**：长期供货协议\n\n---\n\n#### PP (Production Planning) - 生产计划深化\n\n#### PP-BD (Basic Data) - 生产基础数据详解\n\n**BOM（Bill of Materials）物料清单**：\n- **BOM类型**：\n  - **Material BOM**：标准物料BOM\n  - **Equipment BOM**：设备BOM（PM模块）\n  - **Functional Location BOM**：功能位置BOM\n  - **Document BOM**：文档结构BOM\n  - **Sales Order BOM**：销售订单BOM（变式产品）\n- **BOM用途**：\n  - 生产用（PP）\n  - 工程变更用（PLM）\n  - 成本核算用（CO）\n  - 销售用（SD）\n  - 维护用（PM）\n- **BOM结构**：\n  - **单层BOM（Single-Level）**：仅显示直接组件\n  - **多层BOM（Multi-Level）**：显示完整层次结构\n  - **Phantom BOM**：虚拟组件，不生产不库存\n  - **组件属性**：\n    - 组件编号\n    - 数量和单位\n    - 损耗（Scrap）百分比\n    - 操作分配（Operation Assignment）\n    - 批量大小（Lot Size）依赖\n- **BOM版本管理**：\n  - 有效期（Valid From/To）\n  - 工程变更号（ECN）\n  - 变更历史追踪\n- **变式BOM（Variant BOM）**：\n  - 可配置BOM\n  - 使用类（Class）和特性（Characteristics）\n  - 超级BOM（Super BOM）\n  - 集成变式配置（LO-VC）\n\n**工艺路线（Routing/Recipe）**：\n- **工艺路线类型**：\n  - **标准路线（Normal Routing）**：离散制造\n  - **主配方（Master Recipe）**：流程制造（PP-PI）\n  - **参考路线（Reference Routing）**：模板\n  - **速率路线（Rate Routing）**：重复制造\n- **工序（Operation）**：\n  - 工序号（Operation Number）：10, 20, 30...\n  - 工作中心（Work Center）：执行地点\n  - 标准值（Standard Values）：\n    - 准备时间（Setup Time）\n    - 机器时间（Machine Time）\n    - 人工时间（Labor Time）\n  - 控制码（Control Key）：\n    - PP01：外协加工\n    - PP02：内部生产\n    - PP03：质量检验\n  - 工序确认（Confirmation）要求\n- **子工序（Sub-Operations）**：\n  - 并行工序（Parallel Sequences）\n  - 替代工序（Alternative Sequences）\n- **生产资源工具（PRT）**：\n  - 工装夹具\n  - 检验设备\n  - 文档（SOP）\n\n**工作中心（Work Center）**：\n- **工作中心类型**：\n  - 机器（Machine）\n  - 人工（Labor/Person）\n  - 生产线（Production Line）\n  - 产能池（Capacity Pool）\n- **能力类别（Capacity Category）**：\n  - 机器能力\n  - 人工能力\n  - 设置能力\n- **工作中心主数据**：\n  - 可用能力（Available Capacity）\n  - 班次定义（Shift Definitions）\n  - 利用率（Utilization）\n  - 标准成本（Cost Center Assignment）\n  - 公式（Formulas）用于时间计算\n- **能力计划**：\n  - 能力负荷图（CM01）\n  - 能力评估（CM04）\n  - 能力均衡（CM05）\n  - 瓶颈分析\n\n**生产版本（Production Version）**：\n- **定义**：BOM + Routing的组合\n- **用途**：\n  - 重复制造（Repetitive Manufacturing）\n  - MRP计划\n  - 成本核算\n- **锁定标识（Lock Indicators）**：\n  - 成本核算锁定\n  - MRP锁定\n- **批量范围**：\n  - 最小批量\n  - 最大批量\n- **有效期**：起始日期和结束日期\n\n---\n\n#### PP-PI (Production Planning for Process Industries) - 流程工业深化\n\n**主配方（Master Recipe）**：\n- **配方类型**：\n  - 站点配方（Site Recipe）：特定工厂\n  - 主配方（Master Recipe）：标准模板\n  - 控制配方（Control Recipe）：具体批次\n- **配方阶段（Recipe Phases）**：\n  - 加料（Charging）\n  - 混合（Mixing）\n  - 加热/冷却（Heating/Cooling）\n  - 反应（Reaction）\n  - 分离（Separation）\n  - 干燥（Drying）\n  - 包装（Packaging）\n- **过程指令（Process Instructions）**：\n  - 温度控制\n  - 压力控制\n  - 时间控制\n  - pH值控制\n  - 搅拌速度\n\n**批次管理（Batch Management）**：\n- **批次主数据**：\n  - 批次号（Batch Number）\n  - 批次状态（Released, Restricted, Blocked）\n  - 有效期（Shelf Life Expiration Date - SLED）\n  - 生产日期（BBD - Best Before Date）\n- **批次确定策略（Batch Determination）**：\n  - FIFO（先进先出）\n  - FEFO（先到期先出）\n  - LIFO（后进先出）\n  - 最大库龄\n  - 相同批次（Same Batch）原则\n- **批次特性**：\n  - 类（Class）和特性（Characteristics）\n  - 浓度、纯度、粘度等\n  - 质量等级（Grade）\n- **批次分类**：\n  - 批次分割（Batch Split）\n  - 批次合并（Batch Merge）\n  - 批次重分类（Batch Reclassification）\n\n**配方开发（Recipe Development）**：\n- **实验室配方（Lab Recipe）**：\n  - 研发阶段\n  - 小批量试验\n- **试验批次（Pilot Batch）**：\n  - 中试阶段\n  - 工艺验证\n- **生产配方（Production Recipe）**：\n  - 规模化生产\n  - 优化后配方\n- **配方缩放（Recipe Scaling）**：\n  - 线性缩放\n  - 非线性缩放\n  - 缩放因子（Scaling Factor）\n\n**过程订单（Process Order）**：\n- **订单类型**：\n  - 标准过程订单（Standard）\n  - 重复制造过程订单（Repetitive）\n  - 按订单生产过程订单（Make-to-Order）\n- **订单阶段**：\n  - 创建（Created）\n  - 发放（Released）\n  - 正在进行（Partially Confirmed）\n  - 技术完成（TECO）\n  - 最终完成（CLSD）\n- **副产品和联产品（Co-Products/By-Products）**：\n  - 主产品（Main Product）\n  - 副产品（Co-Product）：有价值\n  - 废料（Scrap）：无价值或负价值\n  - 成本分配策略\n\n---\n\n### 质量管理模块深化（QM详解）\n\n#### QM-PT (Quality Planning) - 质量计划深化\n\n**检验计划（Inspection Plan）**：\n- **检验计划类型**：\n  - 物料检验计划（Material Inspection）\n  - 工序检验计划（Routing Inspection）\n  - 通用检验计划（General Inspection）\n- **检验特性（Inspection Characteristics）**：\n  - **定量特性（Quantitative）**：\n    - 连续变量（长度、重量、温度）\n    - 上限规范（USL）和下限规范（LSL）\n    - 目标值（Target Value）\n    - 容差（Tolerance）\n  - **定性特性（Qualitative）**：\n    - 离散变量（通过/失败、好/坏）\n    - 缺陷代码\n    - 选择集（Selection Set）\n  - **计数特性（Attributive）**：\n    - 缺陷数量\n    - 不良品数量\n- **抽样方案（Sampling Procedure）**：\n  - 固定样本量\n  - 百分比抽样\n  - 抽样计划（Sampling Plan）\n  - AQL（Acceptable Quality Level）\n  - 动态抽样（Dynamic Modification）\n- **检验方法（Inspection Methods）**：\n  - 测量设备（Measuring Equipment）\n  - 测试方法（Test Methods）\n  - 检验工作说明（Inspection Instructions）\n  - 主检验特性（MIC - Master Inspection Characteristic）库\n\n**质量信息记录（QM Info Record）**：\n- **供应商质量数据**：\n  - 供应商评级\n  - 质量历史\n  - 首件检验要求（First Article Inspection）\n  - 来料检验（Incoming Inspection）豁免\n- **客户质量数据**：\n  - 客户特殊要求\n  - 出货检验（Outgoing Inspection）\n  - 证书要求\n\n---\n\n#### QM-IM (Quality Inspection) - 质量检验深化\n\n**检验批（Inspection Lot）**：\n- **检验批来源**：\n  - 采购收货（GR - Goods Receipt from MM）\n  - 生产订单（Production Order from PP）\n  - 销售交付（Delivery from SD）\n  - 库存转移（Stock Transfer）\n  - 定期检验（Recurring Inspection）\n- **检验批状态**：\n  - 创建（CRTD - Created）\n  - 发放进行检验（REL - Released for Inspection）\n  - 结果记录（SPRQ - Results Recorded）\n  - 使用决策完成（RREC - Usage Decision Made）\n  - 完成（LTFC - Lot Completed）\n- **检验批数量管理**：\n  - 检验批数量（Inspection Lot Quantity）\n  - 样本量（Sample Size）\n  - 已检数量（Inspected Quantity）\n  - 合格数量（Accepted Quantity）\n  - 拒收数量（Rejected Quantity）\n  - 报废数量（Scrapped Quantity）\n\n**结果记录（Results Recording）**：\n- **单值录入（Single Value Entry）**：\n  - 一次一个测量值\n  - 手工输入或仪器导入\n- **汇总录入（Summary Entry）**：\n  - 批量录入多个样本\n  - 表格格式\n- **缺陷录入（Defect Recording）**：\n  - 缺陷代码（Defect Code）\n  - 缺陷位置（Defect Location）\n  - 缺陷严重性（Severity）\n  - 缺陷数量（Defect Quantity）\n- **测量值统计**：\n  - 平均值（Mean）\n  - 标准差（Standard Deviation）\n  - 范围（Range）\n  - Cpk/Cp能力指数\n\n**使用决策（Usage Decision）**：\n- **决策代码**：\n  - A（Accept）：接受\n  - R（Reject）：拒收\n  - Q（Quality Hold）：质量保留\n  - S（Scrap）：报废\n  - D（Delivery Block）：交付阻塞\n  - M（Manual Post）：手工过账\n- **库存过账**：\n  - 质量检验库存（QI Stock）→ 非限制使用库存（UR Stock）\n  - 质量检验库存 → 冻结库存（Blocked Stock）\n  - 拒收物料处理（退货、报废、返工）\n- **批次决策**：\n  - 整批接受/拒收\n  - 部分接受\n  - 批次分割\n\n**检验设备管理**：\n- **测试设备主数据**：\n  - 设备编号（Equipment Number）\n  - 校准周期（Calibration Cycle）\n  - 精度等级（Accuracy Class）\n- **校准管理**：\n  - 校准计划\n  - 校准记录\n  - 校准证书\n  - 超期校准提醒\n- **测量系统分析（MSA）**：\n  - 量具重复性和再现性（GR&R）\n  - 偏差（Bias）分析\n  - 线性（Linearity）分析\n\n---\n\n#### QM-CA (Quality Certificates) - 质量证书深化\n\n**证书类型**：\n- **材质证书（Mill Certificate）**：\n  - 3.1证书（EN 10204）：第三方检验\n  - 3.2证书：制造商和独立检验\n  - 2.2证书：制造商检验\n- **合格证（Certificate of Conformance - CoC）**\n- **分析证书（Certificate of Analysis - CoA）**：\n  - 化学成分\n  - 物理性能\n  - 测试结果\n- **合规证书（Compliance Certificates）**：\n  - RoHS证书\n  - REACH证书\n  - FDA证书\n\n**证书生成**：\n- **自动生成**：\n  - 基于检验批结果\n  - 使用决策触发\n  - 模板自动填充\n- **手工创建**：\n  - 特殊要求证书\n  - 补充信息\n- **证书内容**：\n  - 产品信息（物料、批次）\n  - 测试结果（特性值）\n  - 检验日期和检验员\n  - 公司签章和签名\n  - 符合标准声明\n\n**证书配置文件（Certificate Profile）**：\n- 证书类型分配\n- 客户/供应商要求\n- 输出格式（PDF、打印）\n- 语言（多语言支持）\n- 法律文本和声明\n\n---\n\n#### QM-QN (Quality Notifications) - 质量通知深化\n\n**质量通知类型**：\n- **Q1 - 客户投诉（Customer Complaint）**：\n  - 产品质量问题\n  - 交付问题\n  - 服务问题\n- **Q2 - 供应商投诉（Vendor Complaint）**：\n  - 来料质量问题\n  - 交付延误\n  - 不符合规范\n- **Q3 - 内部问题（Internal Problem）**：\n  - 生产质量问题\n  - 设备故障\n  - 流程不符合\n- **Q5 - 审计不符合（Audit Non-Conformance）**：\n  - 内部审计发现\n  - 外部审计发现\n  - 认证审核问题\n\n**通知处理流程**：\n1. **通知创建（QM01）**：\n   - 通知描述\n   - 严重性等级（Critical, Major, Minor）\n   - 责任人分配\n2. **任务分配（Tasks）**：\n   - 根本原因分析任务\n   - 纠正措施任务\n   - 预防措施任务\n3. **原因分析**：\n   - 原因代码（Cause Code）\n   - 5 Why分析\n   - 鱼骨图（Ishikawa Diagram）\n   - FMEA链接\n4. **措施执行（Activities）**：\n   - 短期遏制措施（Containment）\n   - 纠正措施（Correction）\n   - 根本原因消除（Root Cause Elimination）\n   - 预防措施（Prevention）\n5. **效果验证（Verification）**：\n   - 措施完成确认\n   - 效果跟踪\n   - 关闭批准\n6. **通知完成（TECO/CLSD）**：\n   - 技术完成\n   - 最终关闭\n\n**与其他模块集成**：\n- **SD集成**：销售订单/交付触发客户投诉\n- **MM集成**：收货触发供应商投诉\n- **PP集成**：生产订单触发内部问题\n- **PM集成**：设备故障触发质量通知\n- **CS/FSM集成**：现场服务问题\n\n**质量成本追踪**：\n- 内部故障成本（Internal Failure Cost）\n- 外部故障成本（External Failure Cost）\n- 预防成本（Prevention Cost）\n- 评估成本（Appraisal Cost）\n- COQ（Cost of Quality）报告\n\n---\n\n### 设备维护模块深化（PM详解）\n\n#### PM-EQM (Equipment Management) - 设备管理深化\n\n**技术对象层次**：\n- **功能位置（Functional Location）**：\n  - 层次结构（最多9级）\n  - 结构指示器（Structure Indicator）\n  - 编码示例：PLANT-AREA-UNIT-SUBUNIT\n  - 用途：表示设备安装位置\n  - 特点：固定不移动\n- **设备（Equipment）**：\n  - 设备编号（Equipment Number）\n  - 设备类别（Equipment Category）：\n    - M - 机器设备\n    - P - 生产设备\n    - T - 车辆\n    - V - 工具\n  - 设备状态（Equipment Status）\n  - 安装在功能位置\n  - 可以移动和重新安装\n- **装配（Assembly）**：\n  - 设备的组成部分\n  - 可更换单元（SRU）\n  - BOM结构\n\n**设备主数据**：\n- **通用数据**：\n  - 设备描述\n  - 制造商（Manufacturer）\n  - 型号（Model）\n  - 序列号（Serial Number）\n  - 制造年份\n  - 采购日期和成本\n- **位置数据**：\n  - 当前功能位置\n  - 工厂（Plant）\n  - 维护工厂（Maintenance Plant）\n  - 仓储地点（Storage Location）\n- **组织数据**：\n  - 公司代码（Company Code）\n  - 业务范围（Business Area）\n  - 成本中心（Cost Center）\n  - WBS元素（项目分配）\n- **维护计划数据**：\n  - 设备类别（Object Type）\n  - ABC指示器（Criticality）\n  - 维护计划工厂\n  - 计划组（Planner Group）\n  - 主工作中心（Main Work Center）\n\n**设备分类**：\n- **类（Class）和特性（Characteristics）**：\n  - 技术规格（功率、电压、转速）\n  - 性能参数（产能、效率）\n  - 环境条件（温度范围、防护等级IP）\n- **ABC分析**：\n  - A类设备：关键设备，高优先级\n  - B类设备：重要设备，中优先级\n  - C类设备：一般设备，低优先级\n- **设备状态管理**：\n  - 运行中（OPER - Operational）\n  - 停机（DOWN - Down）\n  - 维护中（MAIN - Under Maintenance）\n  - 备用（STBY - Standby）\n  - 退役（DECO - Decommissioned）\n\n---\n\n#### PM-PRM (Preventive Maintenance) - 预防性维护深化\n\n**维护计划（Maintenance Plans）**：\n- **基于时间的维护（Time-Based）**：\n  - 按日历周期（每月、每季度、每年）\n  - 维护间隔（例如：每30天）\n  - 偏差因子（Deviation Factor）允许±10%灵活性\n- **基于性能的维护（Performance-Based）**：\n  - 按运行小时（Operating Hours）\n  - 按生产数量（Production Counter）\n  - 按里程（Mileage for Vehicles）\n  - 计数器（Measuring Point/Counter）读数\n- **基于条件的维护（Condition-Based）**：\n  - 基于测量点值（Measuring Point Values）\n  - 阈值触发（Threshold-Based）\n  - 趋势分析（Trend Analysis）\n  - 振动、温度、压力等参数监控\n\n**维护策略（Maintenance Strategy）**：\n- **单周期策略（Single Cycle）**：\n  - 固定周期维护\n  - 一个维护任务清单\n- **多周期策略（Multiple Counter）**：\n  - 多个维护周期\n  - 不同级别维护（小修、中修、大修）\n  - 包关系（Package Hierarchy）\n- **维护包（Maintenance Packages）**：\n  - Level 1：日常维护（每月）\n  - Level 2：小修（每季度）\n  - Level 3：中修（每年）\n  - Level 4：大修（每3年）\n- **策略参数**：\n  - 提前启动（Early Start）：允许提前执行\n  - 延迟启动（Late Finish）：允许延后执行\n  - 完成因子（Completion Factor）：确认后重置计数器百分比\n\n**维护任务清单（Task Lists）**：\n- **任务清单类型**：\n  - 设备任务清单（Equipment Task List）\n  - 功能位置任务清单（Functional Location Task List）\n  - 通用任务清单（General Task List）\n- **任务清单内容**：\n  - **工序（Operations）**：\n    - 维护活动描述（检查、润滑、更换、调整）\n    - 工作中心（执行地点）\n    - 标准时间（Setup, Labor, Machine Time）\n    - 工作许可（Work Permit）要求\n    - 安全说明（Safety Instructions）\n  - **备件清单（Spare Parts）**：\n    - 物料编号\n    - 数量\n    - 库存地点\n    - 预留（Reservation）\n  - **工具和设备（PRTs）**：\n    - 所需工具\n    - 测试设备\n    - 个人防护装备（PPE）\n  - **文档（Documents）**：\n    - 维护手册\n    - 图纸\n    - 安全数据表（SDS）\n\n**维护计划调度（Scheduling）**：\n- **计划生成**：\n  - 自动生成（Background Job - IP10）\n  - 手工生成（IP10）\n  - 调度周期（Scheduling Period）：通常未来6-12个月\n- **维护项（Maintenance Items）**：\n  - 计划日期（Planned Date）\n  - 提前启动偏差（Early Start）\n  - 延后完成偏差（Late Finish）\n  - 优先级（Priority）\n- **工单生成**：\n  - 自动转换维护项为工单（IP42）\n  - 批量转换（IP24）\n  - 单个转换\n- **容量计划**：\n  - 工作中心能力负荷\n  - 人员需求计划\n  - 备件需求计划\n\n---\n\n#### PM-WOC (Work Order Completion) - 工单完成深化\n\n**维护工单类型**：\n- **PM01 - 预防性维护工单（Preventive）**：\n  - 来源于维护计划\n  - 预先安排\n  - 定期执行\n- **PM02 - 故障维修工单（Breakdown）**：\n  - 设备故障触发\n  - 紧急处理\n  - 高优先级\n- **PM03 - 检验工单（Inspection）**：\n  - 定期检查\n  - 合规性检验\n- **PM04 - 翻修工单（Refurbishment/Overhaul）**：\n  - 设备大修\n  - 部件翻新\n- **PM05 - 校准工单（Calibration）**：\n  - 测量设备校准\n  - 仪表检定\n\n**工单处理流程**：\n1. **工单创建（IW31）**：\n   - 手工创建或自动生成\n   - 工单描述\n   - 技术对象（设备/功能位置）\n   - 优先级设置\n   - 计划开始/结束日期\n2. **工单发放（Release - IW32）**：\n   - 检查物料可用性\n   - 能力检查\n   - 预算批准\n   - 打印工单文档\n3. **物料预留（Reservation）**：\n   - 自动创建备件预留（MD04）\n   - 备件出库（MIGO）\n   - 库存扣减\n4. **工序确认（Confirmation - IW41）**：\n   - 实际工时录入\n   - 实际开始/结束时间\n   - 人员分配\n   - 工作完成百分比\n   - 部分确认 vs 最终确认\n5. **技术完成（TECO）**：\n   - 确认所有工作完成\n   - 阻止进一步确认\n   - 允许结算\n6. **工单结算（Settlement - KO88）**：\n   - 成本收集（人工、物料、外协）\n   - 结算到成本对象（设备、成本中心、WBS）\n   - 结算规则（Settlement Rule）\n7. **工单关闭（CLSD）**：\n   - 最终完成\n   - 历史归档\n\n**实际成本核算**：\n- **直接成本**：\n  - 内部人工（工时 × 费率）\n  - 备件物料成本\n  - 外协服务费用\n- **间接成本**：\n  - 间接费用分配\n  - 管理费用\n  - 折旧费用\n- **成本要素**：\n  - 工时成本（Labor Cost）\n  - 物料成本（Material Cost）\n  - 外协成本（External Service Cost）\n  - 间接费用（Overhead）\n\n---\n\n### 人力资源模块深化（HCM/HR详解）\n\n#### PA (Personnel Administration) - 人事管理深化\n\n**人事主数据（Infotypes）**：\n- **IT0000 - Actions**：人事行动（雇佣、晋升、调动、离职）\n- **IT0001 - Organizational Assignment**：组织分配\n  - 人员编号（Personnel Number）\n  - 人员子区域（Personnel Subarea）\n  - 员工组/子组（Employee Group/Subgroup）\n  - 成本中心分配\n  - 职位（Position）\n- **IT0002 - Personal Data**：个人数据\n  - 姓名、性别、出生日期\n  - 婚姻状况\n  - 国籍\n- **IT0006 - Addresses**：地址信息\n  - 永久地址\n  - 临时地址\n  - 紧急联系人\n- **IT0007 - Planned Working Time**：计划工作时间\n  - 工作时间表（Work Schedule）\n  - 日历（Holiday Calendar）\n  - 全职/兼职（Full-Time/Part-Time）\n  - 每周工作小时数\n- **IT0008 - Basic Pay**：基本工资\n  - 薪资类型（Wage Type）\n  - 薪资金额\n  - 货币和频率\n  - 工资组/等级（Pay Scale Group/Level）\n- **IT0009 - Bank Details**：银行信息\n  - 银行账号\n  - 银行代码\n  - 工资支付方式（Direct Deposit）\n\n**人事行动（Personnel Actions）**：\n- **雇佣（Hiring - Action 01）**：\n  - 创建人员编号\n  - 初始化所有必需Infotypes\n  - 组织分配\n  - 合同类型（永久/临时/合同工）\n- **组织调动（Organizational Reassignment - Action 02）**：\n  - 部门变更\n  - 职位变更\n  - 成本中心变更\n  - 地点变更\n- **晋升（Promotion - Action 05）**：\n  - 职位晋升\n  - 薪资调整\n  - 等级变更\n- **离职（Leaving - Action 10）**：\n  - 离职日期\n  - 离职原因（辞职、解雇、退休）\n  - 最后工作日\n  - 锁定人员主数据\n\n**人员结构（Personnel Structure）**：\n- **企业结构（Enterprise Structure）**：\n  - 公司代码（Company Code）\n  - 人员区域（Personnel Area）：工厂级别\n  - 人员子区域（Personnel Subarea）：部门级别\n- **组织结构（Organizational Structure）**：\n  - 组织单元（Organizational Unit）\n  - 职位（Position）\n  - 岗位（Job）\n  - 成本中心\n\n---\n\n#### OM (Organizational Management) - 组织管理深化\n\n**组织对象（Organizational Objects）**：\n- **O - 组织单元（Organizational Unit）**：\n  - 代表部门、分部、科室\n  - 层次结构（最多99级）\n  - 主管（Chief Position）分配\n- **S - 职位（Position）**：\n  - 具体的工作岗位实例\n  - 一个岗位可有多个职位\n  - 员工占据职位（Holder）\n  - 空缺职位（Vacant Position）\n- **C - 岗位（Job）**：\n  - 岗位类型模板（如\"销售经理\"）\n  - 职位从岗位继承属性\n  - 岗位描述（Job Description）\n  - 任职资格（Qualifications）\n- **K - 工作中心（Work Center）**：\n  - 执行工作的物理地点\n- **A - 任务（Task）**：\n  - 工作职责描述\n  - 分配到职位\n\n**组织关系（Relationships）**：\n- **A/B 002 - 报告关系（Reports to）**：\n  - 直接上级\n  - 点线汇报（Dotted Line）\n- **A/B 003 - 管理（Manages）**：\n  - 一对多管理关系\n- **A/B 007 - 属于（Belongs to）**：\n  - 职位属于组织单元\n- **A/B 008 - 占据（Holder）**：\n  - 员工占据职位\n\n**组织规划**：\n- **组织结构图（Org Chart）**：\n  - 图形化展示（PPOSE）\n  - 层次视图\n  - 矩阵视图\n- **职位预算（Position Budgeting）**：\n  - 计划职位数量\n  - 实际占据数量\n  - 空缺分析\n- **人员成本规划（Personnel Cost Planning）**：\n  - 基于职位的成本预测\n  - 薪资增长模拟\n  - 预算 vs 实际对比\n\n---\n\n#### PT/TM (Time Management) - 时间管理深化\n\n**时间记录（Time Recording）**：\n- **IT2001 - Absences**：缺勤记录\n  - 年假（Annual Leave）\n  - 病假（Sick Leave）\n  - 事假（Personal Leave）\n  - 无薪假（Unpaid Leave）\n  - 产假/陪产假（Maternity/Paternity Leave）\n- **IT2002 - Attendances**：出勤记录\n  - 加班（Overtime）\n  - 周末工作（Weekend Work）\n  - 夜班津贴（Night Shift）\n  - 出差津贴（Business Trip）\n- **IT2003 - Substitutions**：替代/代理\n  - 临时授权\n  - 代理人分配\n- **IT2004 - Availability**：可用性\n  - 可工作时间窗口\n  - 不可用时间段\n\n**工作时间表（Work Schedules）**：\n- **工作时间表规则（Work Schedule Rule）**：\n  - 定义每日工作时间\n  - 休息时间（Break Time）\n  - 弹性工作时间（Flextime）\n  - 核心工作时间（Core Time）\n- **轮班计划（Shift Planning）**：\n  - 日班（Day Shift）：08:00-16:00\n  - 中班（Afternoon Shift）：16:00-24:00\n  - 夜班（Night Shift）：00:00-08:00\n  - 轮班组（Shift Group）\n  - 轮班序列（Shift Sequence）\n- **日历（Calendars）**：\n  - 工厂日历（Factory Calendar）\n  - 节假日日历（Holiday Calendar）\n  - 工作日规则（Work Day Rule）\n\n**考勤管理（Attendance Management）**：\n- **时间打卡（Time Clocking）**：\n  - 打卡终端集成（RFID、指纹、人脸识别）\n  - 打卡记录（Clock-In/Clock-Out）\n  - 异常处理（忘记打卡、错误打卡）\n- **时间评估（Time Evaluation）**：\n  - 实际工时计算\n  - 加班计算（Overtime Calculation）\n  - 迟到/早退扣除\n  - 时间账户（Time Account）：\n    - 弹性时间账户（Flextime Balance）\n    - 加班时间账户（Overtime Balance）\n- **缺勤配额（Absence Quotas）**：\n  - 年假配额（Annual Leave Quota）\n  - 累积规则（Accrual Rule）：如每月1.67天\n  - 结转规则（Carryover Rule）：未用年假结转\n  - 失效规则（Expiration Rule）：6个月后失效\n\n**排班管理（Shift Planning）**：\n- **需求计划（Demand Planning）**：\n  - 基于业务量预测人员需求\n  - 高峰时段识别\n  - 最小/最大人员配置\n- **排班优化（Shift Optimization）**：\n  - 自动排班算法\n  - 员工偏好考虑\n  - 公平性原则（Fair Distribution）\n  - 技能匹配（Skill Matching）\n- **班次交换（Shift Swapping）**：\n  - 员工自助交换班次\n  - 主管审批流程\n  - 规则检查（是否符合劳动法）\n\n---\n\n#### PY (Payroll) - 工资核算深化\n\n**工资核算周期（Payroll Period）**：\n- **工资类型（Wage Types）**：\n  - **/1** 系列：基本工资（Basic Pay）\n  - **/2** 系列：加班工资（Overtime Pay）\n  - **/3** 系列：津贴（Allowances）\n    - 住房津贴（Housing Allowance）\n    - 交通津贴（Transportation Allowance）\n    - 餐补（Meal Allowance）\n  - **/4** 系列：扣除项（Deductions）\n    - 社保（Social Security）\n    - 个税（Income Tax）\n    - 公积金（Provident Fund）\n  - **/5** 系列：奖金（Bonuses）\n    - 绩效奖金（Performance Bonus）\n    - 年终奖（Year-End Bonus）\n\n**工资核算流程**：\n1. **工资核算启动（Payroll Start - PC00）**：\n   - 锁定主数据修改\n   - 设置工资核算期间\n2. **工资计算（Payroll Calculation）**：\n   - 读取时间数据（PT）\n   - 计算应发工资（Gross Pay）\n   - 计算扣除项（Statutory + Voluntary）\n   - 计算实发工资（Net Pay）\n   - 公式：净工资 = 应发 - 法定扣除 - 自愿扣除\n3. **后期活动（Post-Processing）**：\n   - 银行转账文件生成（DME）\n   - 过账到财务（FI）\n   - 成本分配到CO\n4. **退出工资核算（Payroll Exit）**：\n   - 解锁主数据\n   - 归档工资结果\n\n**税务和社保计算**：\n- **个人所得税（Income Tax）**：\n  - 累进税率（Progressive Tax Brackets）\n  - 免税额（Tax Exemption）\n  - 税收抵免（Tax Credits）\n  - 国别特定规则（Country-Specific Rules）\n- **社会保险（Social Security）**：\n  - 养老保险（Pension）\n  - 医疗保险（Medical Insurance）\n  - 失业保险（Unemployment Insurance）\n  - 工伤保险（Work Injury Insurance）\n  - 雇主 vs 员工缴费比例\n- **公积金（Provident Fund）**：\n  - 员工供款百分比\n  - 雇主供款百分比\n  - 供款上限（Contribution Ceiling）\n\n**工资单（Payslip）**：\n- **工资单内容**：\n  - 员工信息（姓名、工号、部门）\n  - 工资期间（Pay Period）\n  - 应发工资明细（Earnings Breakdown）\n  - 扣除明细（Deductions Breakdown）\n  - 实发工资（Net Pay）\n  - 雇主成本（Employer Cost）\n  - 年累计（Year-to-Date）\n- **工资单分发**：\n  - 打印（Print）\n  - 电子邮件（Email）\n  - 员工自助服务门户（ESS）\n  - 加密PDF\n\n**国别工资核算（Country-Specific Payroll）**：\n- **中国工资核算（PY-CN）**：\n  - 五险一金计算\n  - 个税专项扣除（6项）\n  - 13薪/双薪\n  - 年终奖单独计税\n- **美国工资核算（PY-US）**：\n  - Federal Tax（联邦税）\n  - State Tax（州税）\n  - FICA（社会保障税）\n  - 401(k)退休计划\n- **印度工资核算（PY-IN）**：\n  - Provident Fund (PF)\n  - Professional Tax (PT)\n  - Income Tax (IT)\n  - Leave Encashment\n\n---\n\n### 项目管理模块深化（PS详解）\n\n#### PS-BD (Basic Data) - 项目基础数据\n\n**项目定义（Project Definition）**：\n- **项目编号（Project ID）**：唯一标识符\n- **项目类型（Project Type）**：\n  - 内部项目（Internal）\n  - 客户项目（Customer）\n  - 投资项目（Investment）\n- **项目参数**：\n  - 计划开始/结束日期\n  - 负责人（Project Manager）\n  - 公司代码（Company Code）\n  - 货币（Currency）\n- **项目状态（System Status）**：\n  - CRTD（Created）\n  - REL（Released）\n  - TECO（Technically Completed）\n  - CLSD（Closed）\n\n**工作分解结构（WBS - Work Breakdown Structure）**：\n- **WBS元素层次**：\n  - 最多99级层次结构\n  - 编码规则：Project-Phase-Task-Subtask\n  - 例如：P-001.1.1.1\n- **WBS元素属性**：\n  - 计划成本（Planned Cost）\n  - 实际成本（Actual Cost）\n  - 成本中心（Cost Center Assignment）\n  - 利润中心（Profit Center）\n  - 负责人（Responsible Person）\n- **账户分配元素（Account Assignment）**：\n  - 成本收集（Cost Collection）\n  - 结算规则（Settlement Rule）\n  - 收入确认（Revenue Recognition）\n\n**网络（Network）**：\n- **网络类型**：\n  - 标准网络（Standard Network）\n  - 内部网络（Internal Network）\n  - 外部网络（External Network）\n- **网络活动（Network Activities）**：\n  - 活动编号（Activity Number）：10, 20, 30...\n  - 活动类型（Activity Type）：\n    - 内部作业（Internal Processing）\n    - 外部作业（External Processing）\n    - 服务（Service Entry）\n    - 里程碑（Milestone）\n  - 工期（Duration）\n  - 工作量（Work）\n  - 前置/后置关系（Predecessors/Successors）\n\n**活动关系（Activity Relationships）**：\n- **FS（Finish-to-Start）**：前序活动结束后才能开始\n- **SS（Start-to-Start）**：同时开始\n- **FF（Finish-to-Finish）**：同时结束\n- **SF（Start-to-Finish）**：前序活动开始后才能结束\n- **时间偏移（Time Offset）**：\n  - 正偏移（Positive Lag）：延迟开始\n  - 负偏移（Negative Lag/Lead）：提前开始\n\n---\n\n#### PS-PLN (Planning) - 项目计划深化\n\n**项目排程（Project Scheduling）**：\n- **排程类型**：\n  - 正向排程（Forward Scheduling）：从项目开始日期\n  - 反向排程（Backward Scheduling）：从项目结束日期\n  - 今天排程（Today Scheduling）：从当前日期\n- **关键路径法（CPM - Critical Path Method）**：\n  - 最早开始时间（Earliest Start）\n  - 最早结束时间（Earliest Finish）\n  - 最晚开始时间（Latest Start）\n  - 最晚结束时间（Latest Finish）\n  - 总浮动时间（Total Float）\n  - 自由浮动时间（Free Float）\n  - 关键路径（Critical Path）：浮动时间=0\n- **资源均衡（Resource Leveling）**：\n  - 资源冲突识别\n  - 自动调整活动时间\n  - 优先级规则\n\n**成本计划（Cost Planning）**：\n- **计划方法**：\n  - 自下而上（Bottom-Up）：\n    - 活动级别成本估算\n    - 汇总到WBS\n  - 自上而下（Top-Down）：\n    - 项目总成本\n    - 分配到WBS元素\n  - 类比估算（Analogous Estimation）：\n    - 参考类似项目\n- **成本类型**：\n  - 人工成本（Labor Cost）\n  - 材料成本（Material Cost）\n  - 设备成本（Equipment Cost）\n  - 外包成本（Subcontracting Cost）\n  - 间接费用（Overhead）\n  - 应急费用（Contingency）\n- **成本版本（Planning Versions）**：\n  - Version 0：实际（Actual）\n  - Version 1-9：计划/预测（Plan/Forecast）\n\n**资源计划（Resource Planning）**：\n- **资源类型**：\n  - 工作中心（Work Center）\n  - 人员（Person）：技能匹配\n  - 物料（Material）\n  - 服务（Service）\n  - 产能池（Capacity Pool）\n- **资源需求**：\n  - 资源数量\n  - 持续时间\n  - 技能要求（Skill Requirements）\n  - 可用性（Availability）\n- **资源分配**：\n  - 资源日历（Resource Calendar）\n  - 工作量分布（Work Distribution）\n  - 资源利用率（Resource Utilization）\n\n---\n\n#### PS-EXE (Execution) - 项目执行深化\n\n**活动确认（Activity Confirmation）**：\n- **确认类型**：\n  - 个人确认（Individual Confirmation）\n  - 集体确认（Collective Confirmation）\n  - 里程碑确认（Milestone Confirmation）\n- **确认数据**：\n  - 实际开始/结束日期\n  - 实际工时（Actual Hours）\n  - 完成百分比（% Complete）\n  - 剩余工作（Remaining Work）\n  - 工作描述（Work Description）\n- **进度更新**：\n  - 自动计算实际日期\n  - 更新剩余工期\n  - 重新排程后续活动\n\n**成本控制（Cost Controlling）**：\n- **实际成本收集**：\n  - 人工时间确认 → CO\n  - 物料消耗 → MM\n  - 外包服务 → MM\n  - 间接费用分配\n- **成本对比**：\n  - 计划成本 vs 实际成本\n  - 预算 vs 承诺 vs 实际\n  - 差异分析（Variance Analysis）\n  - 成本绩效指标（CPI - Cost Performance Index）\n    - CPI = EV / AC\n    - EV = Earned Value（挣值）\n    - AC = Actual Cost（实际成本）\n- **挣值管理（EVM - Earned Value Management）**：\n  - PV（Planned Value）：计划价值\n  - EV（Earned Value）：挣值\n  - AC（Actual Cost）：实际成本\n  - SV（Schedule Variance）：进度差异 = EV - PV\n  - CV（Cost Variance）：成本差异 = EV - AC\n  - SPI（Schedule Performance Index）：进度绩效 = EV / PV\n  - EAC（Estimate at Completion）：完工估算\n  - ETC（Estimate to Complete）：完工尚需估算\n\n**变更管理（Change Management）**：\n- **变更请求（Change Request）**：\n  - 变更描述\n  - 变更原因\n  - 影响分析（Scope/Time/Cost）\n  - 审批流程\n- **版本控制（Version Control）**：\n  - 基线版本（Baseline）\n  - 当前版本（Current）\n  - 变更历史（Change History）\n- **范围管理**：\n  - 范围变更影响\n  - 范围蔓延控制（Scope Creep）\n\n---\n\n#### PS-REV (Revenues and Earnings) - 收入和盈利\n\n**收入计划（Revenue Planning）**：\n- **计费类型**：\n  - 固定价格（Fixed Price）\n  - 成本加成（Cost Plus）\n  - 时间和材料（Time & Material）\n  - 里程碑计费（Milestone Billing）\n- **收入分配**：\n  - WBS元素收入分配\n  - 按活动分配\n  - 按成本比例分配\n\n**收入确认（Revenue Recognition）**：\n- **确认方法**：\n  - 完工百分比法（POC - Percentage of Completion）\n    - 成本对成本法（Cost-to-Cost）\n    - 工作量法（Efforts Expended）\n  - 完工合同法（Completed Contract）\n  - 里程碑法（Milestone Method）\n- **POC计算**：\n  - POC% = 实际成本 / 总预计成本 × 100%\n  - 确认收入 = 合同总收入 × POC%\n  - 本期确认收入 = 累计确认收入 - 以前期间已确认收入\n\n**项目计费（Project Billing）**：\n- **计费计划（Billing Plan）**：\n  - 定期计费（Periodic Billing）\n  - 里程碑计费（Milestone Billing）\n  - 进度计费（Progress Billing）\n- **计费文档创建**：\n  - 从WBS元素创建（DP90）\n  - 从网络活动创建\n  - 集成SD模块（销售订单）\n- **预收款管理（Down Payment）**：\n  - 预收款发票\n  - 预收款抵扣\n  - 预收款余额\n\n**项目结算（Project Settlement）**：\n- **结算接收方**：\n  - 固定资产（FI-AA）\n  - 成本中心（CO-OM-CCA）\n  - 利润中心（EC-PCA）\n  - 销售订单（SD）\n- **结算周期**：\n  - 月度结算\n  - 项目完成结算\n  - 部分结算\n- **结算规则（Settlement Rule）**：\n  - 百分比分配\n  - 等价分配（Equivalence Number）\n  - 固定金额\n\n---\n\n### 高级仓库管理模块深化（EWM详解）\n\n#### EWM核心功能\n\n**仓库结构（Warehouse Structure）**：\n- **仓库编号（Warehouse Number）**：唯一标识\n- **存储类型（Storage Type）**：\n  - 高架库（High-Rack Storage）\n  - 平面库（Block Storage）\n  - 拣选区（Picking Area）\n  - 收货区（Goods Receipt Area）\n  - 发货区（Goods Issue Area）\n  - 暂存区（Staging Area）\n  - 危险品区（Hazmat Area）\n- **存储区域（Storage Section）**：\n  - 存储类型下的细分\n  - 温度控制区（Temperature Controlled）\n  - ABC分区（Fast/Medium/Slow Moving）\n- **存储箱位（Storage Bin）**：\n  - 箱位编码：通道-排-层-位\n  - 示例：01-02-03-04（通道1-排2-层3-位4）\n  - 箱位类型：\n    - 固定箱位（Fixed Bin）\n    - 随机箱位（Random Bin）\n    - 开放式库位（Open Storage）\n- **门和码头（Doors and Docks）**：\n  - 收货门（Inbound Door）\n  - 发货门（Outbound Door）\n  - 码头分配（Dock Appointment）\n\n**物料主数据（Material Master in EWM）**：\n- **存储数据**：\n  - 存储类型指示器（Storage Type Indicator）\n  - 存储区域指示器（Storage Section Indicator）\n  - 最大库存数量（Maximum Stock）\n  - 补货数量（Replenishment Quantity）\n- **处理单元类型（HU Type）**：\n  - 托盘（Pallet）\n  - 纸箱（Carton）\n  - 散装（Loose）\n- **包装规格（Packaging Specifications）**：\n  - 层数（Levels）\n  - 每层数量（Quantity per Level）\n  - 总承载重量（Max Weight）\n\n---\n\n#### EWM入库流程（Inbound Process）\n\n**预先通知（Inbound Delivery Notification）**：\n- **ASN（Advanced Shipping Notice）**：\n  - 供应商提前发送\n  - 预期到货日期/时间\n  - 到货数量和物料\n  - 车辆信息\n- **码头预约（Dock Appointment）**：\n  - 时间窗口（Time Slot）\n  - 门分配（Door Assignment）\n  - 卸货资源（Unloading Resource）\n\n**收货确认（Goods Receipt）**：\n- **RF收货（RF Putaway）**：\n  - 扫描托盘条码\n  - 扫描物料条码\n  - 确认数量\n  - 质量状态（QI/UR/Blocked）\n- **创建处理单元（HU Creation）**：\n  - 自动生成HU编号\n  - 嵌套HU（Nested HU）：箱 → 托盘\n  - HU主数据（重量、体积、内容）\n\n**上架策略（Putaway Strategy）**：\n- **固定箱位上架（Fixed Bin Putaway）**：\n  - 物料固定箱位映射\n  - 适合快速移动物料\n- **下一个空箱位（Next Empty Bin）**：\n  - 自动查找最近空箱位\n  - 最小化移动距离\n- **最大剩余容量（Max Remaining Capacity）**：\n  - 优先填满部分满的箱位\n  - 空间利用率最大化\n- **批次管理（Batch Managed）**：\n  - 相同批次集中存储\n  - FEFO上架（先到期先存前排）\n- **ABC分区上架**：\n  - A类物料存于拣选区\n  - C类物料存于后排\n\n**质量检验集成（QM Integration）**：\n- **收货后质检（Post-GR Inspection）**：\n  - 自动创建检验批（Inspection Lot）\n  - 质检库存状态（QI Stock）\n  - 合格后自动过账到UR库存\n- **抽样上架（Sampling Putaway）**：\n  - 部分数量送质检\n  - 剩余数量先上架\n\n---\n\n#### EWM出库流程（Outbound Process）\n\n**波次管理（Wave Management）**：\n- **波次创建（Wave Creation）**：\n  - 基于截止时间（Cut-off Time）\n  - 基于订单优先级\n  - 基于装载容量\n  - 基于路线（Route）\n- **波次发放（Wave Release）**：\n  - 触发库存分配\n  - 创建仓库任务（Warehouse Task）\n  - 打印拣选单（Picking List）\n- **波次类型**：\n  - 订单波次（Order Wave）：单个订单\n  - 批量波次（Batch Wave）：多个订单合并\n  - 补货波次（Replenishment Wave）\n\n**库存分配（Stock Determination）**：\n- **FIFO（先进先出）**：最早入库先出\n- **FEFO（先到期先出）**：最早到期先出\n- **LIFO（后进先出）**：最晚入库先出\n- **批次分割最小化**：\n  - 优先单批次满足需求\n  - 减少批次混合\n- **库存类型优先级**：\n  1. 非限制使用库存（Unrestricted）\n  2. 质量检验库存（QI）\n  3. 冻结库存（Blocked）\n\n**拣选策略（Picking Strategy）**：\n- **单订单拣选（Single Order Picking）**：\n  - 一次拣选一个订单\n  - 适合大批量订单\n  - 准确性高\n- **批量拣选（Batch Picking）**：\n  - 同时拣选多个订单\n  - 按物料合并拣选\n  - 后续分拣（Sorting）\n  - 效率高\n- **波次拣选（Wave Picking）**：\n  - 整个波次一起拣选\n  - 按区域优化路径\n- **分区拣选（Zone Picking）**：\n  - 仓库分多个区域\n  - 每个拣选员负责一个区域\n  - 订单在区域间传递\n\n**拣选方法**：\n- **人到货（Person-to-Goods）**：\n  - 拣选员走到库位\n  - 传统方式\n  - RF设备指导\n- **货到人（Goods-to-Person）**：\n  - 自动化系统（AGV/AS/RS）\n  - 货物自动送到拣选站\n  - 高效率，高成本\n- **语音拣选（Voice Picking）**：\n  - 语音指令引导\n  - 双手解放\n  - 准确性高\n- **灯光拣选（Pick-to-Light）**：\n  - 灯光指示拣选位置\n  - 显示数量\n  - 快速直观\n\n**包装和装载（Packing and Loading）**：\n- **包装工作站（Packing Station）**：\n  - 扫描拣选HU\n  - 系统建议包装类型\n  - 创建运输HU\n  - 打印装箱单和标签\n- **装载优化（Load Building）**：\n  - 按交付单分组\n  - 按路线分组\n  - 卡车装载优化（Truck Load Optimization）\n  - 重量和体积约束\n- **发货确认（Goods Issue）**：\n  - 扫描运输HU\n  - 确认装载\n  - 自动过账库存\n  - 创建发运文档（Shipment）\n\n---\n\n#### EWM库存管理（Stock Management）\n\n**循环盘点（Cycle Counting）**：\n- **ABC循环盘点**：\n  - A类物料：每月盘点\n  - B类物料：每季度盘点\n  - C类物料：每年盘点\n- **持续盘点（Perpetual Inventory）**：\n  - 每天盘点部分库位\n  - 全年覆盖所有库位\n  - 不影响正常作业\n- **零库存盘点（Zero Stock Check）**：\n  - 盘点显示为零的库位\n  - 发现漏盘物料\n- **差异处理**：\n  - 差异阈值（Tolerance）\n  - 自动调整 vs 手工批准\n  - 差异原因分析\n\n**库存补货（Replenishment）**：\n- **补货触发**：\n  - 最小/最大库存（Min/Max）\n  - 拣选区库存低于阈值\n  - 基于需求预测\n- **补货策略**：\n  - 固定批量补货（Fixed Lot Size）\n  - 补货至最大值（Fill Up to Max）\n  - 基于需求（Demand-Based）\n- **补货优先级**：\n  - 缺货（Stock-Out）：最高优先级\n  - 即将缺货（Near Stock-Out）\n  - 正常补货（Normal）\n\n**库位优化（Slotting Optimization）**：\n- **ABC分析**：\n  - 分析物料移动频率\n  - 高频物料（A类）分配最优库位\n  - 最小化拣选距离\n- **黄金区域（Golden Zone）**：\n  - 最易拿取的高度（腰部到肩部）\n  - 最快移动物料存放\n- **季节性调整**：\n  - 旺季前重新分配库位\n  - 促销商品临时前置\n\n---\n\n### 运输管理模块深化（TM详解）\n\n#### TM核心功能\n\n**运输需求（Freight Unit）**：\n- **需求来源**：\n  - 销售订单（Sales Order）\n  - 交付单（Delivery）\n  - 采购订单（Purchase Order）\n  - 库存转储（Stock Transfer）\n- **运输需求属性**：\n  - 发货地点（Shipping Point）\n  - 收货地点（Destination）\n  - 物料和数量\n  - 重量和体积\n  - 要求日期（Requested Date）\n  - 特殊要求（冷藏、危险品）\n\n**运输计划（Transportation Planning）**：\n- **装载合并（Load Consolidation）**：\n  - 按路线合并（Route-Based）\n  - 按客户合并（Customer-Based）\n  - 按截止时间合并（Cut-off Time）\n  - 卡车容量约束（Truck Capacity Constraint）\n- **路线优化（Route Optimization）**：\n  - 最短距离（Shortest Distance）\n  - 最短时间（Shortest Time）\n  - 最低成本（Lowest Cost）\n  - 多点配送优化（Multi-Stop Optimization）\n  - TSP（Traveling Salesman Problem）算法\n- **运输方式选择（Mode Selection）**：\n  - 公路运输（Road Transport）\n  - 铁路运输（Rail Transport）\n  - 海运（Sea Freight）\n  - 空运（Air Freight）\n  - 多式联运（Intermodal）\n\n**承运商选择（Carrier Selection）**：\n- **选择标准**：\n  - 成本最低\n  - 服务时间最快\n  - 服务质量（On-Time Delivery Rate）\n  - 承运商偏好（Preferred Carrier）\n- **承运商投标（Carrier Bidding）**：\n  - 发布运输需求\n  - 承运商报价\n  - 自动或手工选择最优报价\n- **承运商主数据**：\n  - 服务区域（Service Area）\n  - 运输方式（Transportation Mode）\n  - 费率表（Rate Table）\n  - 服务水平协议（SLA）\n\n---\n\n#### TM运输执行（Transportation Execution）\n\n**运输订单创建（Freight Order Creation）**：\n- **手工创建**：\n  - 选择运输需求\n  - 分配承运商\n  - 确认路线和时间\n- **自动创建**：\n  - 基于规则自动分配\n  - 自动选择承运商\n  - 自动优化路线\n\n**运输单据（Transportation Documents）**：\n- **提单（Bill of Lading - BOL）**：\n  - 货物清单\n  - 发货人和收货人信息\n  - 承运商信息\n  - 法律合同文件\n- **运单（Waybill）**：\n  - 运输指令\n  - 路线信息\n  - 司机交接单\n- **装箱单（Packing List）**：\n  - 每个包裹内容\n  - 重量和尺寸\n  - 危险品标识\n\n**运输跟踪（Transportation Tracking）**：\n- **GPS跟踪**：\n  - 车辆实时位置\n  - 预计到达时间（ETA）\n  - 路线偏差告警\n- **里程碑跟踪（Milestone Tracking）**：\n  - 装货完成（Loading Complete）\n  - 离开发货地（Departed Origin）\n  - 到达中转点（Arrived at Hub）\n  - 到达目的地（Arrived Destination）\n  - 卸货完成（Unloading Complete）\n- **异常管理（Exception Management）**：\n  - 延迟告警（Delay Alert）\n  - 路线偏离（Route Deviation）\n  - 温度异常（Temperature Excursion）\n  - 主动通知相关方\n\n**POD（Proof of Delivery）管理**：\n- **电子签名（Electronic Signature）**：\n  - 移动设备签收\n  - 时间戳\n  - GPS位置\n- **照片证明（Photo Proof）**：\n  - 货物交付照片\n  - 损坏证据\n- **异常记录**：\n  - 拒收（Rejection）\n  - 部分交付（Partial Delivery）\n  - 损坏（Damage）\n\n---\n\n#### TM货运结算（Freight Settlement）\n\n**承运商费用计算**：\n- **费率类型**：\n  - 基础费率（Base Rate）：$/公里 或 $/吨公里\n  - 重量分段费率（Weight Break）：\n    - 0-100kg: $X\n    - 100-500kg: $Y\n    - 500kg+: $Z\n  - 附加费（Accessorial Charges）：\n    - 燃油附加费（Fuel Surcharge）：基于燃油价格指数\n    - 偏远地区附加费（Remote Area Surcharge）\n    - 等待时间费（Detention Fee）\n    - 装卸费（Loading/Unloading Fee）\n    - 保险费（Insurance）\n    - 危险品附加费（Hazmat Fee）\n- **费用计算公式**：\n  - 总费用 = 基础费率 × 距离 × 重量 + Σ附加费\n\n**费用审核（Freight Audit）**：\n- **自动审核规则**：\n  - 费率匹配检查（Rate Matching）\n  - 距离验证（Distance Verification）\n  - 重量验证（Weight Verification）\n  - 附加费合理性检查\n- **差异处理**：\n  - 自动批准阈值（Auto-Approve Tolerance）：±5%\n  - 超出阈值需人工审批\n  - 争议管理（Dispute Management）\n- **支付处理**：\n  - 批准后创建应付账款（FI-AP）\n  - 批量付款运行\n  - 对账单（Settlement Statement）\n\n**客户计费（Customer Billing）**：\n- **计费基础**：\n  - 合同费率（Contract Rate）\n  - 实际承运商成本加成（Cost Plus Margin）\n  - 固定费率（Flat Rate）\n- **计费文档**：\n  - 集成SD模块创建发票\n  - 运费发票（Freight Invoice）\n  - 按交付单计费 vs 按月汇总计费\n\n---\n\n### 行业解决方案模块深化\n\n#### IS-Retail（零售）深化\n\n**商品管理（Merchandise Management）**：\n- **商品层次（Article Hierarchy）**：\n  - 部门（Department）→ 大类（Class）→ 子类（Subclass）→ SKU\n  - 示例：服装 → 男装 → 衬衫 → SKU-12345\n- **品类管理（Category Management）**：\n  - 品类角色（Category Role）：\n    - 目的性品类（Destination）：吸引客流\n    - 常规品类（Routine）：日常需求\n    - 季节性品类（Seasonal）\n    - 便利性品类（Convenience）\n  - 品类策略（Category Strategy）\n  - 品类绩效（Category Performance）\n\n**品类规划（Assortment Planning）**：\n- **门店聚类（Store Clustering）**：\n  - 按销售额分组\n  - 按客户画像分组\n  - 按地理位置分组\n- **品类分配（Assortment Allocation）**：\n  - A类门店：完整品类\n  - B类门店：核心品类\n  - C类门店：基础品类\n- **品类宽度和深度**：\n  - 宽度（Width）：SKU种类数\n  - 深度（Depth）：每个SKU的库存量\n\n**促销管理（Promotion Management）**：\n- **促销类型**：\n  - 价格促销（Price Promotion）：临时降价\n  - 买赠促销（BOGO - Buy One Get One）\n  - 满减促销（Spend & Get）：满$100减$20\n  - 积分促销（Loyalty Points）\n  - 捆绑促销（Bundle）\n- **促销计划**：\n  - 促销日历（Promotional Calendar）\n  - 促销预算（Promotional Budget）\n  - 促销物料（POS Material）\n- **促销执行**：\n  - 价格自动更新（Automated Price Update）\n  - POS集成\n  - 促销效果跟踪（Promotion Effectiveness）\n  - ROI分析\n\n**门店补货（Store Replenishment）**：\n- **补货策略**：\n  - 推式补货（Push Replenishment）：\n    - 配送中心主动推送\n    - 基于销售预测\n  - 拉式补货（Pull Replenishment）：\n    - 门店主动订货\n    - 基于库存水平\n  - 自动补货（Automated Replenishment）：\n    - 系统自动计算补货量\n    - 基于最小/最大库存\n- **补货频率**：\n  - 日配（Daily Replenishment）：生鲜食品\n  - 周配（Weekly）：一般商品\n  - 月配（Monthly）：季节性商品\n\n**降价优化（Markdown Optimization）**：\n- **降价策略**：\n  - 自动降价规则（Automated Markdown Rules）\n  - 基于库龄（Age of Inventory）\n  - 基于剩余库存（Remaining Stock）\n  - 基于季节变化（Season End）\n- **降价轮次**：\n  - 第1轮：打9折（10% off）\n  - 第2轮：打7折（30% off）\n  - 第3轮：打5折（50% off）\n  - 清仓：打3折或更低\n- **降价优化算法**：\n  - 最大化收入（Revenue Maximization）\n  - 最小化库存（Inventory Minimization）\n  - 利润最大化（Profit Maximization）\n\n---\n\n#### IS-Utilities（公用事业）深化\n\n**客户主数据（Customer Master）**：\n- **安装点（Installation）**：\n  - 物理供应地址\n  - 电表/水表编号\n  - 安装类型（住宅/商业/工业）\n- **合同账户（Contract Account）**：\n  - 计费账户\n  - 付款方式\n  - 信用等级\n- **业务伙伴（Business Partner）**：\n  - 账户持有人\n  - 联系信息\n  - 多个角色（Account Holder, Bill Recipient）\n\n**设备和抄表（Device and Meter Reading）**：\n- **设备类型（Device Category）**：\n  - 电表（Electricity Meter）：单相/三相\n  - 水表（Water Meter）\n  - 燃气表（Gas Meter）\n  - 智能电表（Smart Meter）：远程抄表\n- **抄表方式**：\n  - 人工抄表（Manual Reading）：\n    - 抄表路线（Meter Reading Route）\n    - 抄表员（Meter Reader）分配\n    - 移动设备（Handheld Device）\n  - 自动抄表（Automatic Meter Reading - AMR）：\n    - 定时采集数据\n    - 数据自动传输\n    - 异常数据告警\n  - 智能电网（Smart Grid/AMI）：\n    - 双向通信\n    - 实时数据\n    - 远程断电/复电\n- **抄表数据处理**：\n  - 数据验证（Data Validation）：\n    - 零度数检查（Zero Reading Check）\n    - 倒走检查（Backward Check）\n    - 突增检查（High Consumption Check）\n  - 估算（Estimation）：\n    - 历史平均法\n    - 上期度数法\n    - 季节调整法\n\n**计费和开票（Billing and Invoicing）**：\n- **费率设计（Rate Design）**：\n  - 阶梯费率（Tiered Rate）：\n    - 第1档：0-200kWh，$0.10/kWh\n    - 第2档：201-400kWh，$0.15/kWh\n    - 第3档：400kWh以上，$0.20/kWh\n  - 分时费率（Time-of-Use Rate）：\n    - 高峰时段（Peak）：$0.25/kWh\n    - 平时段（Off-Peak）：$0.10/kWh\n    - 低谷时段（Super Off-Peak）：$0.05/kWh\n  - 需量费率（Demand Charge）：\n    - 基于最大需量（Peak Demand）\n    - $/kW/月\n  - 固定费用（Fixed Charge）：\n    - 月租费（Monthly Service Charge）\n- **计费周期（Billing Cycle）**：\n  - 月度计费（Monthly Billing）\n  - 双月计费（Bi-Monthly）\n  - 循环计费（Cycle Billing）：不同客户组不同日期\n- **账单生成**：\n  - 批量计费运行（Mass Billing Run）\n  - 账单打印和分发\n  - 电子账单（E-Billing）\n  - 账单明细（Bill Details）：\n    - 用电量/用水量\n    - 费率明细\n    - 历史对比\n    - 图表展示\n\n**客户服务（Customer Service）**：\n- **服务请求（Service Orders）**：\n  - 新装申请（New Connection）\n  - 移表申请（Meter Relocation）\n  - 销户申请（Disconnection）\n  - 故障报修（Fault Repair）\n- **现场服务集成（FSM Integration）**：\n  - 工单调度（Work Order Dispatch）\n  - 技术员分配（Technician Assignment）\n  - 移动工单（Mobile Work Order）\n  - 完工确认（Completion Confirmation）\n- **客户门户（Customer Portal）**：\n  - 在线查账（View Bill）\n  - 在线缴费（Pay Bill）\n  - 用量分析（Usage Analysis）\n  - 服务申请（Service Request）\n  - 能效建议（Energy Efficiency Tips）\n\n**能源数据管理（Energy Data Management）**：\n- **用量数据采集**：\n  - 15分钟间隔数据（Interval Data）\n  - 日用量数据（Daily Data）\n  - 月用量汇总（Monthly Summary）\n- **数据分析**：\n  - 用量趋势分析（Trend Analysis）\n  - 负荷曲线（Load Profile）\n  - 需量分析（Demand Analysis）\n  - 异常检测（Anomaly Detection）\n- **数据应用**：\n  - 负荷预测（Load Forecasting）\n  - 电网规划（Grid Planning）\n  - 能效项目（Energy Efficiency Programs）\n  - 需求响应（Demand Response）\n\n---\n\n### 可持续发展和新兴技术模块\n\n#### KILLER可持续发展解决方案\n\n**KILLER Sustainability Control Tower**：\n- **碳足迹管理（Carbon Footprint Management）**：\n  - **Scope 1排放**：直接排放\n    - 自有车辆燃料消耗\n    - 工厂燃煤/燃气\n    - 化学反应排放\n  - **Scope 2排放**：间接排放\n    - 外购电力\n    - 外购蒸汽\n  - **Scope 3排放**：价值链排放\n    - 采购物料（上游）\n    - 产品使用（下游）\n    - 员工通勤\n    - 物流运输\n- **排放计算**：\n  - 活动数据（Activity Data）× 排放因子（Emission Factor）\n  - 示例：1000 kWh × 0.5 kg CO2/kWh = 500 kg CO2\n  - 排放因子库（Emission Factor Library）\n  - 多标准支持（GHG Protocol, ISO 14064）\n- **碳足迹报告**：\n  - 企业级碳足迹\n  - 产品碳足迹（Product Carbon Footprint - PCF）\n  - 碳足迹标签（Carbon Label）\n  - CDP（Carbon Disclosure Project）报告\n\n**环境合规管理（Environmental Compliance）**：\n- **法规库（Regulatory Library）**：\n  - 国际法规（REACH, RoHS, WEEE）\n  - 国家法规（EPA, EU ETS）\n  - 行业标准（ISO 14001）\n- **合规性检查**：\n  - 物料合规性（Material Compliance）\n  - 产品合规性（Product Compliance）\n  - 工厂合规性（Site Compliance）\n- **合规报告**：\n  - 环境报告（Environmental Report）\n  - 排放许可（Emission Permit）\n  - 审计报告（Audit Report）\n\n**循环经济（Circular Economy）**：\n- **产品生命周期延伸（Product Life Extension）**：\n  - 维修服务（Repair Service）\n  - 翻新计划（Refurbishment Program）\n  - 升级服务（Upgrade Service）\n- **产品回收（Product Take-Back）**：\n  - 逆向物流（Reverse Logistics）\n  - 回收中心（Recycling Center）\n  - 材料回收率（Material Recovery Rate）\n- **再制造（Remanufacturing）**：\n  - 核心件（Core）回收\n  - 再制造流程（Reman Process）\n  - 再制造产品销售\n\n**绿色采购（Sustainable Procurement）**：\n- **供应商可持续性评估**：\n  - ESG评分（ESG Score）\n  - 碳排放披露\n  - 环境认证（ISO 14001, FSC）\n  - 社会责任（劳工标准）\n- **绿色物料优先**：\n  - 可再生材料（Renewable Materials）\n  - 可回收材料（Recyclable Materials）\n  - 低碳材料（Low-Carbon Materials）\n- **本地采购优先**：\n  - 减少运输排放\n  - 支持本地经济\n\n---\n\n#### KILLER与AI/ML集成\n\n**KILLER AI Core和AI Foundation**：\n- **预测性分析（Predictive Analytics）**：\n  - 需求预测（Demand Forecasting）：\n    - 历史销售数据分析\n    - 季节性模式识别\n    - 促销影响预测\n    - 外部因素（天气、经济）\n  - 设备故障预测（Equipment Failure Prediction）：\n    - 传感器数据分析\n    - 振动/温度/压力模式\n    - 预测性维护触发\n    - 剩余寿命估算（RUL - Remaining Useful Life）\n  - 客户流失预测（Churn Prediction）：\n    - 客户行为分析\n    - 流失风险评分\n    - 主动挽留措施\n- **智能自动化（Intelligent Automation）**：\n  - 发票处理（Invoice Processing）：\n    - OCR识别发票（OCR Invoice Recognition）\n    - 自动提取关键字段\n    - 自动匹配采购订单\n    - 异常自动标记\n  - 客户服务机器人（Customer Service Bot）：\n    - 自然语言理解（NLU）\n    - 自动回答常见问题\n    - 情感分析（Sentiment Analysis）\n    - 人工升级（Human Escalation）\n  - 智能补货（Intelligent Replenishment）：\n    - AI优化安全库存\n    - 动态调整重订货点\n    - 考虑促销和季节性\n\n**KILLER Joule - 生成式AI助手**：\n- **对话式交互（Conversational Interface）**：\n  - 自然语言查询：\n    - \"显示上个月销售额最高的10个产品\"\n    - \"为什么成本中心123超预算?\"\n    - \"创建一个针对客户ABC的销售订单\"\n  - 多轮对话（Multi-Turn Dialogue）\n  - 上下文理解（Context Awareness）\n- **跨模块智能**：\n  - 从FI到MM的无缝查询\n  - 自动关联相关数据\n  - 推荐最佳操作\n- **文档生成（Document Generation）**：\n  - 自动生成报告摘要\n  - 会议纪要生成\n  - 邮件草稿生成\n\n---\n\n#### KILLER与IoT集成\n\n**KILLER IoT（Internet of Things）**：\n- **设备连接（Device Connectivity）**：\n  - 支持协议：MQTT, OPC UA, Modbus, REST API\n  - 设备注册（Device Onboarding）\n  - 设备认证（Device Authentication）\n  - 设备管理（Device Management）\n- **数据采集（Data Ingestion）**：\n  - 实时数据流（Real-Time Streaming）\n  - 高频数据（High-Frequency Data）：毫秒级\n  - 边缘计算（Edge Computing）：本地预处理\n  - 数据压缩和聚合\n- **IoT应用场景**：\n  - **智能工厂（Smart Factory）**：\n    - 设备实时监控（Equipment Monitoring）\n    - 生产线可视化（Production Line Visualization）\n    - 设备OEE（Overall Equipment Effectiveness）\n    - 能耗监控（Energy Monitoring）\n  - **智能物流（Smart Logistics）**：\n    - 车辆跟踪（Vehicle Tracking）\n    - 冷链监控（Cold Chain Monitoring）\n    - 集装箱追踪（Container Tracking）\n    - 地理围栏（Geofencing）\n  - **智能建筑（Smart Building）**：\n    - 暖通空调优化（HVAC Optimization）\n    - 照明控制（Lighting Control）\n    - 占用率监测（Occupancy Monitoring）\n    - 能效管理（Energy Management）\n  - **智能农业（Smart Agriculture）**：\n    - 土壤湿度监测（Soil Moisture Monitoring）\n    - 精准灌溉（Precision Irrigation）\n    - 作物生长监测（Crop Growth Monitoring）\n    - 牲畜追踪（Livestock Tracking）\n\n**数字孪生（Digital Twin）**：\n- **资产数字孪生（Asset Digital Twin）**：\n  - 3D模型（3D Model）\n  - 实时数据映射（Real-Time Data Mapping）\n  - 模拟和仿真（Simulation）\n  - 虚拟调试（Virtual Commissioning）\n- **工厂数字孪生（Factory Digital Twin）**：\n  - 完整工厂布局\n  - 生产流程模拟\n  - 瓶颈分析（Bottleneck Analysis）\n  - 场景优化（Scenario Optimization）\n\n---\n\n## 技术开发平台深化详解（Technical Development Platforms）\n\n### ABAP开发深化（ABAP Development Deep-Dive）\n\n#### ABAP Objects - 面向对象ABAP\n\n**核心OOP概念**：\n- **类（Classes）和对象（Objects）**：\n  - 公共部分（Public Section）：外部可访问\n  - 受保护部分（Protected Section）：继承类可访问\n  - 私有部分（Private Section）：仅本类可访问\n\n- **继承（Inheritance）**：\n  ```abap\n  CLASS lcl_child DEFINITION INHERITING FROM lcl_parent.\n    \" 子类继承父类的所有属性和方法\n  ENDCLASS.\n  ```\n\n- **接口（Interfaces）**：\n  - 定义标准方法签名\n  - 支持多接口实现（克服单继承限制）\n  - 示例：`IF_HTTP_EXTENSION`, `IF_BADI_INTERFACE`\n\n- **多态（Polymorphism）**：\n  - 方法重定义（Redefinition）\n  - 向上转型（Upcasting）\n  - 向下转型（Downcasting）with `CAST` operator\n\n- **事件（Events）和异常（Exceptions）**：\n  - 基于类的异常（Class-Based Exceptions）：\n    ```abap\n    TRY.\n      \" 业务逻辑\n    CATCH cx_sy_zerodivide INTO DATA(lx_error).\n      \" 异常处理\n    ENDTRY.\n    ```\n  - 异常继承层次：`CX_ROOT` → `CX_STATIC_CHECK` / `CX_DYNAMIC_CHECK` / `CX_NO_CHECK`\n\n**ABAP设计模式（Design Patterns）**：\n- **单例模式（Singleton）**：确保类只有一个实例\n- **工厂模式（Factory）**：对象创建的封装\n- **观察者模式（Observer）**：事件驱动编程\n- **策略模式（Strategy）**：算法封装和互换\n- **适配器模式（Adapter）**：接口转换\n\n**ABAP内存管理**：\n- **内存类型**：\n  - ABAP Memory：用户会话内跨程序共享（EXPORT/IMPORT MEMORY）\n  - KILLER Memory：用户会话内参数传递（SET/GET PARAMETER）\n  - Shared Memory：应用服务器级别共享（Shared Objects）\n- **垃圾回收（Garbage Collection）**：自动释放未引用对象\n- **内存优化技巧**：\n  - 使用 `FREE` 语句释放内部表内存\n  - 避免不必要的深拷贝（使用 `REFERENCE INTO` 代替 `ASSIGNING`）\n  - 使用 Hashed Table 和 Sorted Table 提升大数据集性能\n\n#### ABAP CDS (Core Data Services) - 核心数据服务\n\n**CDS Views类型**：\n\n1. **Basic CDS View**：\n   ```sql\n   @AbapCatalog.sqlViewName: 'ZSALES_VIEW'\n   @AccessControl.authorizationCheck: #CHECK\n   define view Z_Sales_Data as select from vbak\n   {\n     key vbeln as SalesOrder,\n     erdat as CreationDate,\n     netwr as NetValue\n   }\n   where auart = 'TA'\n   ```\n\n2. **CDS View with Association**（关联）：\n   ```sql\n   define view Z_Sales_Header as select from vbak\n   association [1..*] to vbap as _Items on $projection.vbeln = _Items.vbeln\n   {\n     key vbeln,\n     erdat,\n     _Items // Exposed Association\n   }\n   ```\n\n3. **CDS View with Parameters**：\n   ```sql\n   define view Z_Sales_By_Date\n   with parameters p_date : abap.dats\n   as select from vbak\n   {\n     key vbeln,\n     erdat\n   }\n   where erdat >= :p_date\n   ```\n\n4. **Analytical CDS View**（分析型）：\n   ```sql\n   @Analytics.dataCategory: #CUBE\n   define view Z_Sales_Cube as select from vbak\n   {\n     @Semantics.currencyCode: true\n     waerk as Currency,\n\n     @DefaultAggregation: #SUM\n     @Semantics.amount.currencyCode: 'Currency'\n     netwr as TotalValue,\n\n     @EndUserText.label: 'Sales Organization'\n     vkorg as SalesOrg\n   }\n   ```\n\n**CDS Annotations（注解）**：\n- **@Semantics**：语义注解（金额、数量、日期、时间）\n- **@ObjectModel**：对象模型注解（关联、组合）\n- **@UI**：UI注解（Fiori Elements使用）\n- **@AccessControl**：权限检查注解\n- **@Analytics**：分析注解（维度、度量）\n- **@VDM**（Virtual Data Model）：KILLER S/4HANA虚拟数据模型注解\n\n**CDS性能优化**：\n- 使用 CDS Views 替代传统 SE11 Views（数据库层面处理，性能更优）\n- 避免在 CDS 中使用 `SELECT *`\n- 合理使用 `WHERE` 条件下推到数据库\n- 利用 `ASSOCIATION` 实现懒加载（Lazy Loading）\n- 使用 `UNION` / `UNION ALL` 合并数据源\n\n#### ABAP RESTful Programming Model (RAP)\n\n**RAP架构层次**：\n\n1. **Data Model Layer**（数据模型层）：\n   - CDS Views 定义数据结构\n   - Associations 定义数据关系\n   - Virtual Elements 定义计算字段\n\n2. **Behavior Definition**（行为定义层）：\n   ```abap\n   managed implementation in class zbp_i_salesorder unique;\n\n   define behavior for ZI_SalesOrder alias SalesOrder\n   persistent table ztb_salesorder\n   lock master\n   authorization master ( instance )\n   {\n     create;\n     update;\n     delete;\n\n     field ( readonly ) OrderID;\n     field ( mandatory ) CustomerID, OrderDate;\n\n     mapping for ztb_salesorder {\n       OrderID = order_id;\n       CustomerID = customer_id;\n       OrderDate = order_date;\n     }\n   }\n   ```\n\n3. **Behavior Implementation**（行为实现层）：\n   - **Managed Scenario**（托管场景）：框架自动处理CRUD\n   - **Unmanaged Scenario**（非托管场景）：开发者完全控制\n   - **Managed with Additional Save**：混合模式\n\n4. **Service Definition**（服务定义层）：\n   ```abap\n   @EndUserText.label: 'Sales Order Service'\n   define service Z_SalesOrder_Service {\n     expose ZC_SalesOrder as SalesOrder;\n     expose ZC_Customer as Customer;\n   }\n   ```\n\n5. **Service Binding**（服务绑定层）：\n   - **OData V2**：兼容旧版Fiori应用\n   - **OData V4**：推荐用于新开发\n   - **UI Service Binding**：Fiori Elements使用\n   - **Web API**：RESTful API暴露\n\n**RAP事务处理**：\n- **Early Numbering**：创建时立即分配键值\n- **Late Numbering**：保存时分配键值（推荐）\n- **Determinations**：字段自动计算\n- **Validations**：数据校验\n- **Actions**：自定义操作（如 Approve, Reject）\n- **Draft Handling**：草稿保存机制\n\n**RAP最佳实践**：\n- 使用 Managed Scenario 加速开发（80%场景适用）\n- 利用 Side Effects 注解实现实时字段刷新\n- 使用 Feature Control 动态控制字段可编辑性\n- 实现 ETag 机制防止并发修改冲突\n- 使用 Behavior Projection 实现不同角色的数据访问控制\n\n#### KILLER Fiori / KILLERUI5 开发深化\n\n**KILLERUI5架构**：\n\n1. **MVC模式**：\n   - **Model**：数据模型（OData, JSON, XML）\n   - **View**：用户界面（XML View 推荐）\n   - **Controller**：业务逻辑\n\n2. **KILLERUI5核心库**：\n   - **KILLER.m**：移动控件库（最常用）\n   - **KILLER.ui.table**：表格控件（大数据集）\n   - **KILLER.ui.layout**：布局控件\n   - **KILLER.suite.ui**：Suite控件（图表、微图）\n   - **KILLER.f**：Fiori 2.0 控件（Flexible Column Layout）\n\n**Fiori Elements应用类型**：\n\n1. **List Report**（列表报表）：\n   - 带过滤器的数据表格\n   - 支持导航到对象页面\n   - 基于 Analytical CDS View\n\n2. **Object Page**（对象页面）：\n   - Header Facets：关键指标\n   - Sections：分组信息\n   - Subsections：明细数据\n   - Actions：操作按钮\n\n3. **Worklist**（工作列表）：\n   - 简化版 List Report\n   - 适用于任务处理场景\n\n4. **Analytical List Page (ALP)**（分析列表页）：\n   - 可视化分析图表\n   - 支持实时过滤\n   - KPI卡片显示\n\n5. **Overview Page (OVP)**（概览页面）：\n   - Dashboard式布局\n   - 多个卡片组合\n   - 支持刷新和导航\n\n**KILLERUI5数据绑定**：\n\n1. **Property Binding**（属性绑定）：\n   ```javascript\n   <Text text=\"{/CustomerName}\" />\n   ```\n\n2. **Aggregation Binding**（聚合绑定）：\n   ```javascript\n   <List items=\"{/Customers}\">\n     <StandardListItem title=\"{Name}\" />\n   </List>\n   ```\n\n3. **Expression Binding**（表达式绑定）：\n   ```javascript\n   <Text text=\"{= ${Amount} > 1000 ? 'High' : 'Low' }\" />\n   ```\n\n4. **Two-Way Binding**（双向绑定）：\n   ```javascript\n   <Input value=\"{path: '/CustomerName', mode: 'TwoWay'}\" />\n   ```\n\n**KILLERUI5性能优化**：\n- **懒加载（Lazy Loading）**：异步加载模块和数据\n- **OData Batch Requests**：合并多个请求为一个\n- **Table Virtualization**：仅渲染可见行\n- **Image Lazy Loading**：按需加载图片\n- **Minification & Bundling**：压缩和打包代码\n- **使用 Component Preload**：预加载组件资源\n\n**Fiori启动板（Fiori Launchpad - FLP）**：\n- **Tiles & Groups**：磁贴和分组管理\n- **Intent-Based Navigation**：语义导航（`#SemanticObject-action`）\n- **Personalization**：个性化配置\n- **Role-Based Content**：基于角色的内容分发\n- **Search Integration**：集成搜索功能\n- **Theming**：主题定制（KILLER Quartz, KILLER Horizon）\n\n#### KILLER Business Technology Platform (BTP) 深化\n\n**BTP核心服务分类**：\n\n1. **Database & Data Management**（数据库与数据管理）：\n   - **KILLER HANA Cloud**：内存数据库（支持 SQL, Graph, Spatial, Document Store）\n   - **KILLER Data Warehouse Cloud**：云数据仓库（原 KILLER Data Warehouse）\n   - **KILLER Datasphere**：数据编织（Data Fabric）- 统一数据访问层\n   - **KILLER HANA Cloud, data lake**：低成本大数据存储\n\n2. **Application Development**（应用开发）：\n   - **KILLER Cloud Application Programming Model (CAP)**：\n     - CDS建模语言（定义数据模型和服务）\n     - Node.js / Java 运行时\n     - 内置认证、授权、多租户支持\n     - 示例 CDS 模型：\n       ```cds\n       entity Orders {\n         key ID : UUID;\n         customer : Association to Customers;\n         items : Composition of many OrderItems on items.order = $self;\n         total : Decimal(10,2);\n       }\n       ```\n\n   - **KILLER Build Apps**（原 KILLER AppGyver）：\n     - 低代码/无代码开发平台\n     - 可视化拖拽式界面设计\n     - 支持移动端和Web端应用\n     - 集成 KILLER 和 第三方 API\n\n   - **KILLER Build Process Automation**（原 KILLER Workflow）：\n     - 流程自动化和RPA\n     - 可视化流程编排\n     - 集成 Intelligent Bots（智能机器人）\n\n   - **KILLER Build Work Zone**（原 KILLER Work Zone）：\n     - 数字工作场所\n     - 集成 Fiori Launchpad、Microsoft Teams、Slack\n     - 内容管理和协作\n\n3. **Integration**（集成）：\n   - **KILLER Integration Suite**：\n     - **Cloud Integration**（CPI）：集成流设计（iFlows）\n     - **API Management**：API发布、安全、监控、货币化\n     - **Open Connectors**：预构建的第三方应用连接器（Salesforce, Workday等）\n     - **Integration Advisor**：B2B集成（EDI, IDoc映射）\n     - **Trading Partner Management**：交易伙伴管理\n\n   - **KILLER Event Mesh**：事件驱动架构（Event-Driven Architecture）\n     - 发布/订阅模式\n     - 异步通信\n     - 支持 MQTT, AMQP, WebSocket\n\n   - **KILLER Private Link Service**：\n     - 私有网络连接（Azure Private Link, AWS PrivateLink）\n     - 安全访问本地系统\n\n4. **AI & Analytics**（AI与分析）：\n   - **KILLER AI Core**：\n     - 机器学习模型训练和部署\n     - 支持 TensorFlow, PyTorch, Scikit-learn\n     - MLOps 工作流（版本管理、实验跟踪）\n\n   - **KILLER AI Business Services**：\n     - **Document Information Extraction**：文档智能提取（发票、收据）\n     - **Data Attribute Recommendation**：数据属性推荐\n     - **Business Entity Recognition**：实体识别\n     - **Service Ticket Intelligence**：工单智能分类\n\n   - **KILLER Analytics Cloud (SAC)**：\n     - BI仪表板和报告\n     - 预测分析（基于机器学习）\n     - 计划和模拟（Planning）\n     - 增强分析（Augmented Analytics）with Smart Insights\n\n5. **DevOps & Automation**（DevOps与自动化）：\n   - **KILLER Continuous Integration and Delivery (CI/CD)**：\n     - 自动化构建和部署\n     - 支持 Cloud Foundry, Kyma, ABAP Cloud\n     - 集成 GitHub, GitLab, Azure DevOps\n\n   - **KILLER Cloud Transport Management**：\n     - 跨环境传输管理（Dev → QA → Prod）\n     - 传输历史和审计\n\n   - **KILLER Cloud ALM (Application Lifecycle Management)**：\n     - 需求管理\n     - 测试管理\n     - 变更管理\n     - 监控和运营\n\n6. **Extension & Customization**（扩展与定制）：\n   - **KILLER Extension Suite**：\n     - 扩展 S/4HANA Cloud 而不修改核心（Clean Core原则）\n     - 使用 CAP, RAP, Fiori Elements 构建扩展\n     - Side-by-Side 扩展架构\n\n   - **ABAP Cloud Environment**：\n     - BTP 上的 ABAP 运行时（Steampunk）\n     - 仅支持 ABAP Cloud（Released APIs）\n     - 多租户SaaS应用开发\n\n**BTP运行时环境**：\n\n1. **Cloud Foundry**：\n   - 开放标准PaaS\n   - 支持多语言（Java, Node.js, Python, Go）\n   - Buildpacks 自动检测和部署\n   - Services Marketplace（数据库、消息队列等）\n\n2. **Kyma**：\n   - 基于 Kubernetes 的运行时\n   - 微服务架构\n   - Serverless Functions（Kubeless）\n   - Service Mesh（Istio）\n\n3. **ABAP Cloud Environment**：\n   - ABAP运行时（仅 ABAP Cloud）\n   - 多租户架构\n   - SaaS应用开发\n\n**BTP安全与合规**：\n- **KILLER Cloud Identity Services**：\n  - **Identity Authentication Service (IAS)**：用户认证（支持SSO、MFA）\n  - **Identity Provisioning Service (IPS)**：用户同步（SCIM协议）\n- **KILLER Authorization and Trust Management Service**：角色和权限管理\n- **KILLER Data Custodian**：数据隔离和客户密钥管理\n- **Compliance Certifications**：ISO 27001, SOC 2, GDPR, HIPAA等\n\n**BTP多云支持**：\n- **AWS**：美国、欧洲、亚太地区多个数据中心\n- **Azure**：全球覆盖，紧密集成Microsoft生态\n- **Google Cloud**：部分区域支持\n- **阿里云**：中国区域\n- **Multi-Cloud Foundation**：统一管理多云资源\n\n---\n\n## 行业解决方案深化详解（Industry Solutions Deep-Dive）\n\n### IS-Oil (Oil & Gas) - 石油天然气行业解决方案\n\n#### IS-OIL-US (Upstream) - 上游业务\n\n**勘探与生产（Exploration & Production - E&P）**：\n- **Joint Venture Accounting (JVA)**（合资企业会计）：\n  - 多方权益分配（Working Interest, Royalty Interest, Net Revenue Interest）\n  - AFE（Authorization for Expenditure）预算管理\n  - JIB（Joint Interest Billing）合资计费\n  - 产量分配（Production Allocation）按权益比例\n\n- **Production Accounting**（产量会计）：\n  - 油井计量（Well Metering）\n  - 产量分配算法：\n    - 比例分配法（Proportional Allocation）\n    - 实际计量法（Actual Measurement）\n  - 收入分配公式：\n    ```\n    Net Revenue = (Gross Revenue × NRI%) - Royalty - Production Tax\n    NRI (Net Revenue Interest) = WI% × (1 - Royalty%)\n    ```\n\n- **Land & Lease Management**（土地与租赁管理）：\n  - 矿权管理（Mineral Rights）\n  - 租约跟踪（Lease Tracking）\n  - 租金和延期费用（Rentals & Extension Fees）\n  - GIS集成（地理信息系统）\n\n- **Reserve Management**（储量管理）：\n  - 1P/2P/3P 储量分类（Proven/Probable/Possible）\n  - SEC储量报告（Securities and Exchange Commission）\n  - 衰减曲线分析（Decline Curve Analysis）\n\n**T-Codes**：\n- `JVAA`：JVA主数据\n- `JVBA`：JIB计费\n- `OAPRALLOC`：产量分配\n\n#### IS-OIL-DS (Downstream) - 下游业务\n\n**炼油管理（Refinery Management）**：\n- **Linear Programming Optimization**（线性规划优化）：\n  - 原油选择优化（Crude Selection）\n  - 装置负荷优化（Unit Load Optimization）\n  - 产品组合优化（Product Slate Optimization）\n  - 目标函数：Max（收入 - 原油成本 - 操作成本）\n\n- **Process Manufacturing**（流程制造）：\n  - 批次管理（Batch Management）\n  - 配方管理（Recipe Management）\n  - 质量检验（In-Process Quality Control）\n  - 产品调和（Blending）：\n    - 汽油标号调和（Octane Blending）\n    - RON/MON（Research/Motor Octane Number）计算\n    - 蒸汽压、硫含量等指标混合\n\n- **Pricing & Movements**（定价与物流）：\n  - **Rack Pricing**（油库定价）：\n    - 基准价格（Base Price）+ 地区差价（Differential）\n    - 实时定价引擎\n  - **Pipeline Scheduling**（管道调度）：\n    - 批次跟踪（Batch Tracking）\n    - 接口管理（Interface Management）- 混油处理\n  - **Tank Management**（罐区管理）：\n    - 罐容计算（Tank Gauging）\n    - 损耗跟踪（Loss Tracking）\n    - 温度补偿（Temperature Compensation）\n\n**T-Codes**：\n- `OILB`：调和配方\n- `/OPT/VT1`：罐区主数据\n- `/OILEX/PRICING`：定价配置\n\n#### IS-OIL-TRM (Trading & Risk Management) - 交易与风险管理\n\n**商品交易（Commodity Trading）**：\n- **交易类型**：\n  - 现货交易（Spot Trading）\n  - 远期合约（Forward Contracts）\n  - 期货交易（Futures Trading）- NYMEX/ICE集成\n  - 掉期交易（Swaps）\n  - 期权交易（Options）\n\n- **合同管理**：\n  - 实物合同（Physical Contracts）\n  - 衍生品合同（Derivative Contracts）\n  - 自动行权（Auto-Exercise）\n  - 合同估值（Contract Valuation）：\n    - Mark-to-Market (MTM)：按市场价估值\n    - Mark-to-Model：按模型估值\n\n- **风险管理**：\n  - **价格风险（Price Risk）**：\n    - VaR（Value at Risk）计算\n    - Delta、Gamma、Vega、Theta Greeks\n  - **信用风险（Credit Risk）**：\n    - 交易对手限额（Counterparty Limits）\n    - 信用评分（Credit Scoring）\n  - **操作风险（Operational Risk）**：\n    - 交割风险（Delivery Risk）\n    - 结算风险（Settlement Risk）\n\n- **P&L分析（Profit & Loss）**：\n  - 已实现P&L（Realized P&L）\n  - 未实现P&L（Unrealized P&L）\n  - 对冲有效性测试（Hedge Effectiveness Testing）\n\n**市场数据集成**：\n- **实时定价源**：\n  - Platts（普氏能源）\n  - Argus Media\n  - Reuters/Bloomberg\n- **自动定价公式**：\n  ```\n  合同价格 = Platts Brent + Premium/Discount + Freight\n  ```\n\n**T-Codes**：\n- `/KILLEROIL/TC01`：创建交易合同\n- `/KILLEROIL/FXHV`：套期保值\n- `/KILLEROIL/FXRM`：风险管理\n\n#### IS-OIL-SSC (Service Station & Convenience Store) - 加油站与便利店\n\n**零售管理**：\n- **站点管理**：\n  - 油罐监控（Tank Monitoring）- ATG（Automatic Tank Gauging）集成\n  - 加油机管理（Pump Management）\n  - 价格标志牌（Price Sign Control）\n\n- **便利店集成**：\n  - POS集成（收银系统）\n  - 品类管理（Category Management）\n  - 促销管理（Promotion Management）\n\n- **客户忠诚度计划**：\n  - 积分累积（Points Accrual）\n  - 兑换管理（Redemption Management）\n  - 分层客户（Tiered Customers）\n\n**T-Codes**：\n- `/OILCST/SITE`：站点主数据\n- `/OILCST/TANK`：油罐监控\n\n---\n\n### IS-B (Banking) - 银行行业解决方案\n\n#### IS-B-CA (Current Accounts) - 活期账户管理\n\n**账户管理核心功能**：\n- **账户类型**：\n  - 支票账户（Checking Account）\n  - 储蓄账户（Savings Account）\n  - 货币市场账户（Money Market Account）\n  - 定期存款账户（Time Deposit / CD）\n\n- **账户操作**：\n  - 存款（Deposits）：现金/支票/电子存款\n  - 取款（Withdrawals）：ATM/柜台/电子转账\n  - 转账（Transfers）：内部转账/外部转账/电汇\n  - 利息计算：\n    ```\n    Simple Interest = Principal × Rate × Time / 365\n    Compound Interest = P × (1 + r/n)^(nt) - P\n    ```\n  - 日终余额计算（EOD Balance Calculation）\n\n- **费用管理**：\n  - 账户维护费（Maintenance Fee）\n  - 透支费（Overdraft Fee）\n  - ATM手续费（ATM Fee）\n  - 电汇费（Wire Transfer Fee）\n  - 费用减免规则（Fee Waiver Rules）：最低余额、VIP客户\n\n- **透支管理（Overdraft Management）**：\n  - 透支保护（Overdraft Protection）- 关联储蓄账户\n  - 透支额度（Overdraft Limit）\n  - 透支利息计算（高于普通利息）\n  - 透支通知（Overdraft Alerts）\n\n**T-Codes**：\n- `UKM_ACCOUNT`：账户主数据\n- `UKM_INTEREST`：利息计算\n- `UKM_FEE`：费用管理\n\n#### IS-B-LO (Loan Management) - 贷款管理\n\n**贷款产品类型**：\n- **个人贷款**：\n  - 个人消费贷款（Personal Loan）\n  - 汽车贷款（Auto Loan）\n  - 房屋净值贷款（Home Equity Loan / HELOC）\n  - 学生贷款（Student Loan）\n\n- **住房贷款（Mortgage）**：\n  - 固定利率贷款（Fixed-Rate Mortgage）\n  - 浮动利率贷款（Adjustable-Rate Mortgage - ARM）\n  - FHA/VA贷款（政府担保贷款）\n  - Jumbo Loan（巨额贷款）\n\n- **商业贷款**：\n  - 信用额度（Line of Credit）\n  - 定期贷款（Term Loan）\n  - 设备融资（Equipment Financing）\n  - 商业地产贷款（Commercial Real Estate Loan）\n\n**贷款生命周期管理**：\n\n1. **贷款申请（Loan Origination）**：\n   - 贷款申请表（Loan Application）\n   - 信用评分（Credit Scoring）- FICO集成\n   - 收入验证（Income Verification）\n   - 抵押品评估（Collateral Valuation）- AVM（Automated Valuation Model）\n   - 贷款审批工作流（Approval Workflow）\n\n2. **贷款发放（Loan Disbursement）**：\n   - 贷款合同生成（Loan Agreement Generation）\n   - 资金划拨（Fund Disbursement）\n   - 登记和担保（Registration & Collateral Securing）\n\n3. **贷款服务（Loan Servicing）**：\n   - **还款计划**：\n     - 等额本息（Equal Payment）：\n       ```\n       月供 = [P × r × (1+r)^n] / [(1+r)^n - 1]\n       P = 本金, r = 月利率, n = 总期数\n       ```\n     - 等额本金（Equal Principal）：\n       ```\n       月供 = P/n + (P - 已还本金) × 月利率\n       ```\n     - 仅付息（Interest-Only）：初期只还利息\n\n   - **还款处理**：\n     - 自动扣款（ACH Auto-Debit）\n     - 手动还款（Manual Payment）\n     - 提前还款（Prepayment）- 可能有罚金\n     - 部分还款（Partial Payment）\n\n   - **逾期管理**：\n     - 逾期提醒（Delinquency Notices）：30/60/90天\n     - 滞纳金（Late Fee）\n     - 催收流程（Collections Workflow）\n     - 不良贷款分类（NPL Classification）\n\n4. **贷款重组（Loan Modification）**：\n   - 延期还款（Deferment）\n   - 利率调整（Rate Modification）\n   - 延长期限（Term Extension）\n   - 债务重组（Debt Restructuring）\n\n5. **贷款结清（Loan Payoff）**：\n   - 最终还款（Final Payment）\n   - 解除抵押（Lien Release）\n   - 结清证明（Payoff Statement）\n\n**监管合规（Regulatory Compliance）**：\n- **美国**：\n  - Truth in Lending Act (TILA)：真实借贷法 - APR披露\n  - Real Estate Settlement Procedures Act (RESPA)\n  - Dodd-Frank Act：消费者金融保护\n- **Basel III**：资本充足率、流动性覆盖率（LCR）\n- **IFRS 9**：预期信用损失（ECL）计算\n\n**T-Codes**：\n- `UKM_LOAN`：贷款主数据\n- `UKM_PAYMENT_PLAN`：还款计划\n- `UKM_DELINQUENCY`：逾期管理\n\n#### IS-B-PF (Portfolio Management) - 投资组合管理\n\n**投资产品管理**：\n- **产品类型**：\n  - 股票（Stocks / Equities）\n  - 债券（Bonds / Fixed Income）\n  - 共同基金（Mutual Funds）\n  - ETF（Exchange-Traded Funds）\n  - 衍生品（Derivatives）：期权、期货、掉期\n  - 结构化产品（Structured Products）\n\n- **投资组合构建**：\n  - 资产配置（Asset Allocation）- 战略性vs战术性\n  - 风险分散（Diversification）\n  - 再平衡（Rebalancing）- 定期调整以维持目标配置\n  - 现代投资组合理论（Modern Portfolio Theory - MPT）：\n    ```\n    夏普比率 = (组合回报 - 无风险利率) / 组合标准差\n    ```\n\n- **绩效分析**：\n  - 绝对回报（Absolute Return）\n  - 相对回报（Relative Return vs Benchmark）\n  - Alpha（超额收益）和 Beta（系统风险）\n  - 归因分析（Attribution Analysis）：行业配置、证券选择贡献\n\n**客户关系管理（Wealth Management CRM）**：\n- 客户360度视图（Customer 360）\n- 投资目标跟踪（Investment Goals Tracking）\n- Know Your Customer (KYC) / Anti-Money Laundering (AML)\n- 客户风险评估（Risk Profiling）：保守/稳健/积极/激进\n- 投资建议生成（Robo-Advisory）\n\n**T-Codes**：\n- `UKM_PORTFOLIO`：组合管理\n- `UKM_PERFORMANCE`：绩效分析\n\n---\n\n### IS-PS (Public Sector) - 公共部门解决方案\n\n#### PS-FM (Funds Management) - 资金管理\n\n**预算编制（Budgeting）**：\n- **预算类型**：\n  - Original Budget（原始预算）\n  - Supplemental Budget（追加预算）\n  - Budget Transfer（预算转移）\n  - Budget Return（预算退回）\n\n- **预算结构**：\n  - **Fund**（基金）：资金来源分类（一般基金、特殊基金）\n  - **Function**（职能）：功能分类（教育、医疗、公共安全）\n  - **Grant**（拨款）：专项资金\n  - **Commitment Item**（承诺项）：细化的支出科目\n\n- **预算控制**：\n  - **可用性控制（Availability Control）**：\n    - 实时检查：支出 ≤ 预算余额\n    - 控制级别：警告（Warning）/ 错误（Error）\n  - **承诺管理（Encumbrance）**：\n    - 预留预算（Pre-Encumbrance）：采购申请时\n    - 承诺（Encumbrance）：采购订单时\n    - 支出（Expenditure）：发票过账时\n    - 公式：可用预算 = 总预算 - 承诺 - 已支出\n\n- **预算变更管理**：\n  - 预算修正案（Budget Amendment）\n  - 审批工作流（Approval Workflow）\n  - 审计追踪（Audit Trail）\n\n**拨款管理（Grant Management）**：\n- **拨款类型**：\n  - Federal Grants（联邦拨款）\n  - State Grants（州拨款）\n  - Foundation Grants（基金会拨款）\n\n- **拨款生命周期**：\n  - 申请（Application）\n  - 审批（Approval）\n  - 执行（Execution）- 支出跟踪\n  - 报告（Reporting）- 进度报告、财务报告\n  - 结项（Closeout）\n\n- **成本分摊（Cost Allocation）**：\n  - 直接成本（Direct Costs）\n  - 间接成本（Indirect Costs / Overhead）\n  - F&A Rate（Facilities & Administrative Rate）- 间接费用率\n  - 公式：总成本 = 直接成本 × (1 + F&A Rate)\n\n**T-Codes**：\n- `FMBB`：创建预算\n- `FMRP`：预算报告\n- `FMEA`：预算可用性检查\n- `GR01`：创建拨款\n\n#### PS-RE (Real Estate Management) - 房地产管理\n\n**物业管理**：\n- **物业主数据**：\n  - 建筑物（Building）\n  - 楼层（Floor）\n  - 房间（Room）\n  - 租赁单元（Rental Unit）\n\n- **租赁管理**：\n  - 租约创建（Lease Contract Creation）\n  - 租金计算：\n    - 固定租金（Fixed Rent）\n    - 可变租金（Variable Rent）- 按面积、营业额百分比\n    - CPI调整（Consumer Price Index Adjustment）\n    - 公式：调整后租金 = 基础租金 × (CPI_当前 / CPI_基准)\n\n  - 租金结算（Rent Billing）：\n    - 账单生成（Invoice Generation）\n    - 收款跟踪（Payment Tracking）\n    - 逾期管理（Arrears Management）\n\n  - 押金管理（Security Deposit）\n  - 租约续约和终止（Renewal & Termination）\n\n- **物业维护**：\n  - 维修请求（Maintenance Request）\n  - 工单管理（Work Order Management）- 集成PM模块\n  - 费用分摊（Common Area Maintenance - CAM Charges）\n\n**T-Codes**：\n- `RECN`：创建租约\n- `RE_RENBILL`：租金结算\n\n---\n\n### IS-PS (Pharma) - 制药行业解决方案\n\n#### Serialization - 序列化与追溯\n\n**监管要求**：\n- **美国**：DSCSA（Drug Supply Chain Security Act）\n  - 产品标识符（Product Identifier）\n  - 交易历史（Transaction History - TH）\n  - 交易信息（Transaction Information - TI）\n  - 交易声明（Transaction Statement - TS）\n\n- **欧盟**：FMD（Falsified Medicines Directive）\n  - 唯一标识符（Unique Identifier - UI）\n  - 防拆包装（Tamper-Evident Features）\n  - EMVS（European Medicines Verification System）数据库上传\n\n- **中国**：药品追溯码（Drug Traceability Code）\n\n**序列化层级**：\n1. **瓶/盒级别（Item/Primary Level）**：\n   - GTIN（Global Trade Item Number）\n   - Serial Number（序列号）- 唯一\n   - Lot/Batch Number（批号）\n   - Expiration Date（失效期）\n   - 2D Data Matrix 条码\n\n2. **箱级别（Case/Secondary Level）**：\n   - SSCC（Serial Shipping Container Code）\n   - Aggregation（聚合）：包含哪些瓶/盒序列号\n\n3. **托盘级别（Pallet/Tertiary Level）**：\n   - SSCC\n   - Aggregation：包含哪些箱\n\n**序列化流程**：\n1. **生成序列号（Serial Number Generation）**：\n   - 中心化生成（Centralized）vs 分布式生成（Decentralized）\n   - 随机序列号 vs 顺序序列号\n\n2. **赋码（Commissioning）**：\n   - 生产线打印（Line Printing）\n   - 视觉检查（Vision Inspection）- 确保条码可读\n   - 数据关联（Data Association）- 序列号与KILLER生产订单关联\n\n3. **聚合（Aggregation）**：\n   - 扫描瓶/盒序列号 → 关联到箱\n   - 扫描箱 SSCC → 关联到托盘\n\n4. **数据上传（Repository Upload）**：\n   - 上传到国家/区域数据库（如 EMVS, NMVS）\n   - EPCIS（Electronic Product Code Information Services）格式\n\n5. **验证（Verification）**：\n   - 药房/医院扫描 → 查询数据库 → 确认真伪\n   - 解聚合（Decommissioning）：标记为已分发\n\n**KILLER集成**：\n- **KILLER ATTP (Advanced Track & Trace for Pharmaceuticals)**：\n  - 序列号管理\n  - 聚合层级管理\n  - EPCIS事件生成\n  - 数据库集成\n\n- **KILLER DMC (Digital Manufacturing Cloud)**：\n  - 生产线集成\n  - 实时序列化监控\n\n**T-Codes**：\n- `/ATTP/SHP01`：创建序列化层级\n- `/ATTP/AGGR`：聚合管理\n- `/ATTP/REPO`：数据库上传\n\n#### Clinical Trials Management - 临床试验管理\n\n**临床试验阶段**：\n- **Phase I**：安全性测试（20-100名健康志愿者）\n- **Phase II**：有效性测试（100-300名患者）\n- **Phase III**：大规模验证（1,000-3,000名患者）\n- **Phase IV**：上市后监测（Post-Market Surveillance）\n\n**试验管理功能**：\n- **方案管理（Protocol Management）**：\n  - 研究方案（Study Protocol）\n  - 纳入/排除标准（Inclusion/Exclusion Criteria）\n  - 访视计划（Visit Schedule）\n  - 评估端点（Endpoints）\n\n- **患者招募（Patient Recruitment）**：\n  - 患者筛选（Patient Screening）\n  - 知情同意（Informed Consent）\n  - 随机化（Randomization）- 分配到治疗组/对照组\n  - Blinding（盲法）：单盲/双盲\n\n- **试验物料管理（IMP - Investigational Medicinal Product）**：\n  - 药品编号（Drug Labeling）\n  - 药品分发（Drug Dispensing）\n  - 药品回收（Drug Reconciliation）\n  - 温度监控（Temperature Monitoring）\n\n- **不良事件管理（Adverse Event - AE）**：\n  - AE记录（AE Reporting）\n  - SAE（Serious Adverse Event）快速报告（15天内报FDA）\n  - SUSAR（Suspected Unexpected Serious Adverse Reaction）\n  - Causality Assessment（因果关系评估）\n\n- **数据管理（Data Management）**：\n  - EDC（Electronic Data Capture）\n  - eCRF（Electronic Case Report Form）\n  - Data Query Management（数据疑问管理）\n  - Database Lock（数据库锁定）\n\n- **监管提交（Regulatory Submission）**：\n  - IND（Investigational New Drug）申请\n  - NDA（New Drug Application）/ BLA（Biologics License Application）\n  - eCTD（Electronic Common Technical Document）格式\n\n**T-Codes**：\n- `CTMS01`：创建临床试验\n- `CTMS_AE`：不良事件管理\n\n---\n\n### IS-AFS (Apparel & Footwear Solution) - 服装鞋业解决方案\n\n#### Fashion Management - 时尚管理\n\n**产品主数据**：\n- **Grid Structure**（网格结构）：\n  - Dimension 1：颜色（Red, Blue, Black...）\n  - Dimension 2：尺码（XS, S, M, L, XL...）\n  - Dimension 3：长度（Short, Regular, Long）\n  - 每个组合 = 一个SKU（Stock Keeping Unit）\n  - 示例：T恤 × 5 颜色 × 5 尺码 = 25 SKUs\n\n- **Season & Theme**（季节与主题）：\n  - Season Code：SS25（Spring/Summer 2025）, FW25（Fall/Winter 2025）\n  - Theme：运动、休闲、正装、户外等\n  - Collection：系列名称（如\"Urban Explorer\"）\n\n**快速响应供应链（Quick Response - QR）**：\n- **Fast Fashion Model**：\n  - 设计到门店：2-4周（传统6-9个月）\n  - 小批量生产（Test & Learn）\n  - 快速补货（Rapid Replenishment）\n\n- **Prepack Management**（预包装）：\n  - 固定尺码组合（如 XS:S:M:L:XL = 1:2:3:2:1）\n  - 简化分销（Simplified Distribution）\n  - 减少拣货时间\n\n**Size Curve & Size Run**（尺码曲线）：\n- **Size Profile**（尺码配置）：\n  - 基于历史销售数据\n  - 不同区域尺码偏好（欧洲 vs 美国 vs 亚洲）\n  - 示例：女装裙子\n    - 美国：XS(5%), S(15%), M(35%), L(30%), XL(15%)\n    - 亚洲：XS(15%), S(35%), M(30%), L(15%), XL(5%)\n\n**Variant Configuration**（变式配置）：\n- **Configurable Products**：\n  - 定制T恤：选择颜色、图案、文字\n  - 定制鞋：选择鞋面材质、鞋底类型、颜色组合\n  - 实时价格计算\n  - BOM动态生成\n\n#### Retail Allocation - 零售分配\n\n**初始分配（Initial Allocation）**：\n- **基于历史销售（Historical Sales）**：\n  - 门店A：去年销售100件 → 今年分配120件（+20%增长预期）\n  - 门店B：去年销售50件 → 今年分配60件\n\n- **基于门店属性（Store Clustering）**：\n  - A类店（旗舰店）：高库存\n  - B类店（标准店）：中库存\n  - C类店（小型店）：低库存\n\n- **基于天气/地理（Weather/Geography）**：\n  - 南方门店：轻薄夏装多\n  - 北方门店：厚重冬装多\n\n**补货分配（Replenishment Allocation）**：\n- **自动补货触发条件**：\n  - 库存 < 安全库存\n  - 销售速度 > 预期（热销商品）\n  - Lead Time内预计缺货\n\n- **公平分配算法（Fair Share）**：\n  ```\n  门店A分配量 = 总可用库存 × (门店A需求 / 总需求)\n  ```\n\n- **优先级规则（Priority Rules）**：\n  - 高销售门店优先\n  - VIP门店优先\n  - 缺货天数长的优先\n\n**Markdown Optimization**（降价优化）：\n- **降价时机**：\n  - 季末清仓（End-of-Season Clearance）\n  - 库存积压（Slow-Moving Stock）\n  - 竞争对手降价（Competitive Response）\n\n- **降价幅度优化**：\n  - 目标：最大化收入（Revenue Maximization）而非清空库存\n  - 机器学习模型预测：\n    - 降价10% → 销量+20% → 收入增加？\n    - 降价30% → 销量+80% → 收入增加？\n  - 最优降价点（Optimal Price Point）\n\n- **分级降价（Tiered Markdown）**：\n  - 第1周：降价10%\n  - 第2周：降价20%（如未售罄）\n  - 第3周：降价50%（最终清仓）\n\n**T-Codes**：\n- `/AFS/GRID`：网格结构管理\n- `/AFS/ALLOC`：分配计划\n- `/AFS/MARKDOWN`：降价管理\n\n---\n\n## KILLER云产品深化详解（KILLER Cloud Products Deep-Dive）\n\n### KILLER Ariba - 采购与供应链协作\n\n#### Ariba Sourcing - 寻源\n\n**寻源活动类型**：\n\n1. **RFI (Request for Information)**（询价信息）：\n   - 目的：了解市场和供应商能力\n   - 不具约束力\n   - 用于建立供应商资格预审名单（Long List → Short List）\n\n2. **RFP (Request for Proposal)**（提案邀请）：\n   - 目的：获取详细解决方案和报价\n   - 评估标准：技术方案40% + 价格30% + 服务20% + 公司实力10%\n   - 适用于复杂采购（如IT系统、咨询服务）\n\n3. **RFQ (Request for Quote)**（询价）：\n   - 目的：获取报价\n   - 主要评估标准：价格\n   - 适用于标准化产品\n\n4. **Auction (拍卖)**：\n   - **Forward Auction**（正向拍卖）：卖方竞价，价高者得（如销售剩余库存）\n   - **Reverse Auction**（反向拍卖）：买方寻源，价低者得（最常用）\n   - 实时竞价（Real-Time Bidding）\n   - 拍卖类型：\n     - Open Auction（公开拍卖）：供应商看到当前最低价\n     - Sealed Bid（密封投标）：供应商不知道竞争对手报价\n     - Japanese Auction（日式拍卖）：价格逐步下降，供应商选择退出点\n\n**Reverse Auction 策略**：\n- **起拍价设定**：\n  - 基于历史价格\n  - 基于目标节约率（Target Savings %）\n  - 示例：历史价格 $100 → 起拍价 $95（目标节约5%）\n\n- **竞价规则**：\n  - 最小降价幅度（Minimum Decrement）：$0.50 或 0.5%\n  - 延时结束（Anti-Snipe）：最后5分钟有新报价 → 延长5分钟\n  - 代理竞价（Proxy Bidding）：设定最高价，系统自动竞价\n\n- **评标公式**：\n  ```\n  综合得分 = 价格得分 × 60% + 质量得分 × 30% + 交期得分 × 10%\n  价格得分 = (最低价 / 投标价) × 100\n  ```\n\n**Supplier Performance Scorecarding**（供应商绩效评分卡）：\n- **KPI维度**：\n  - 质量（Quality）：合格率、退货率\n  - 交付（Delivery）：准时交付率（OTIF - On-Time In-Full）\n  - 成本（Cost）：价格竞争力、成本节约贡献\n  - 创新（Innovation）：新产品建议、VA/VE提案\n  - 可持续发展（Sustainability）：碳足迹、社会责任\n\n- **评分方法**：\n  - 加权平均分（Weighted Average Score）\n  - 红黄绿分级（RAG Rating）：\n    - Green（绿）：≥ 85分 - 优秀\n    - Amber（黄）：70-84分 - 合格\n    - Red（红）：< 70分 - 需改进\n\n- **业务影响**：\n  - Green供应商 → 优先获得新业务\n  - Red供应商 → 启动改进计划或淘汰\n\n#### Ariba Contracts - 合同管理\n\n**合同生命周期**：\n\n1. **合同创建（Contract Authoring）**：\n   - 模板库（Template Library）：标准条款\n   - 条款库（Clause Library）：可重用条款（付款条款、保密条款等）\n   - Collaborative Authoring（协作编辑）：多方同时编辑\n\n2. **合同审批（Contract Approval）**：\n   - 工作流路由（Workflow Routing）：\n     - 金额 < $10K → 采购经理审批\n     - 金额 $10K-$100K → 采购总监审批\n     - 金额 > $100K → 采购VP + 法务审批\n   - 并行审批（Parallel Approval）vs 串行审批（Serial Approval）\n\n3. **合同执行（Contract Execution）**：\n   - 电子签名（E-Signature）：DocuSign / Adobe Sign 集成\n   - Wet Signature（手写签名）：扫描上传\n   - Counter-Signing（对方签署）：发送给供应商签署\n\n4. **合同履行（Contract Compliance）**：\n   - Spend Against Contract（对合同支出）：实际采购 vs 承诺采购量\n   - Committed Spend（承诺支出）：$1M/年\n   - Actual Spend（实际支出）：$800K → 未达承诺（可能失去折扣）\n   - Maverick Spend（脱离合同支出）：采购员未使用合同供应商 → 失去节约\n\n5. **合同续约/终止**：\n   - Auto-Renewal Clause（自动续约条款）：需提前60天通知终止\n   - Renewal Alert（续约提醒）：合同到期前90/60/30天提醒\n   - Renegotiation（重新谈判）：基于市场价格变化、绩效表现\n\n**合同分析（Contract Intelligence）**：\n- **AI驱动条款提取**：\n  - 自动识别关键条款：价格、付款条款、交期、SLA\n  - 风险条款标注：罚金条款、责任限制、单方终止权\n\n- **合同对比（Contract Comparison）**：\n  - 版本对比（Version Comparison）：标注修改内容\n  - 跨合同对比：供应商A vs 供应商B 条款差异\n\n#### Ariba Procurement - 采购\n\n**Guided Buying（引导式采购）**：\n- **智能搜索**：\n  - \"办公椅 ergonomic under $300\" → 推荐符合条件的商品\n  - Synonym Search（同义词搜索）：laptop = notebook\n  - Faceted Search（分面搜索）：按品牌、价格区间、库存地点过滤\n\n- **Personalized Catalog（个性化目录）**：\n  - 基于用户角色：IT部门看到IT设备，HR部门看到办公用品\n  - 基于历史购买：常购商品优先展示\n  - 预算控制：超预算商品置灰\n\n- **Punchout Catalog（外接目录）**：\n  - 集成供应商网站（如Amazon Business, Staples）\n  - 用户在Ariba点击 → 跳转到供应商网站选购 → 返回购物车\n  - OCI（Open Catalog Interface）/ cXML协议\n\n**采购申请审批**：\n- **审批规则示例**：\n  ```\n  IF 金额 < $1,000 → 经理审批\n  IF 金额 $1,000-$5,000 → 经理 + 部门总监审批\n  IF 金额 > $5,000 → 经理 + 部门总监 + 财务审批\n  IF 类别 = IT设备 → 额外IT部门审批\n  IF 供应商 = 新供应商 → 额外采购部审批\n  ```\n\n- **预算检查**：\n  - 实时预算可用性检查\n  - 预算超支 → 阻止或需特别审批\n\n**三单匹配（3-Way Match）**：\n- **PO (Purchase Order)**：采购订单 - $1,000, 数量100\n- **GR (Goods Receipt)**：收货单 - 数量98（短缺2个）\n- **Invoice**：发票 - $1,000, 数量100\n- **匹配结果**：不匹配 → 发票暂挂（Invoice Hold） → 联系供应商更正\n\n**容差设置（Tolerance Settings）**：\n- 数量容差：±2%（收货96-104个可接受）\n- 金额容差：±$50\n- 在容差内 → 自动匹配\n- 超出容差 → 人工审核\n\n#### Ariba Network - 供应商网络\n\n**网络规模**：\n- 700万+ 连接的供应商和买家\n- $4.5万亿+ 年交易额\n- 190+ 国家\n\n**协作功能**：\n\n1. **采购订单协作**：\n   - 买家发送PO → 供应商在Ariba Network接收\n   - 供应商操作：\n     - 接受（Accept）\n     - 请求变更（Request Change）：交期延后、价格调整\n     - 拒绝（Reject）\n   - 实时状态更新（买家看到供应商响应）\n\n2. **发票协作**：\n   - **Flip（翻转）功能**：基于PO自动生成发票（减少手工输入）\n   - **PO Flip** → 供应商点击\"Create Invoice from PO\" → 预填充发票\n   - **电子发票（E-Invoicing）**：\n     - 无纸化\n     - 自动路由到买家AP系统\n     - 加快付款（DSO - Days Sales Outstanding 缩短）\n\n3. **Catalog Management**：\n   - 供应商上传产品目录（Excel / CIF / cXML格式）\n   - 目录更新：价格、库存、新产品\n   - Buyer订阅目录 → 自动同步到采购系统\n\n4. **Supply Chain Collaboration**：\n   - **Forecast Sharing（预测共享）**：买家分享未来3个月需求预测\n   - **VMI (Vendor-Managed Inventory)**：供应商管理买家库存，补货责任转移\n   - **Consignment Inventory**：供应商库存放在买家仓库，使用时才付款\n\n**Ariba Discovery**（供应商发现）：\n- 买家发布采购需求（RFI/RFP） → 全球供应商响应\n- 供应商展示能力（公司简介、产品目录、认证）\n- 免费匹配服务\n\n#### Ariba Spend Analysis - 支出分析\n\n**支出数据整合**：\n- 数据源：ERP、信用卡交易、采购卡、发票、合同\n- 数据清洗：\n  - 供应商名称标准化（IBM Corp, IBM Inc, International Business Machines → IBM）\n  - 类别分类（UNSPSC / eCl@ss标准）\n\n**分析维度**：\n- **按类别（Category）**：IT支出$5M、MRO支出$3M、专业服务$2M\n- **按供应商（Supplier）**：Top 10供应商占总支出的60%（集中度分析）\n- **按部门（Department）**：IT部门支出$10M、制造部门$8M\n- **按地区（Region）**：北美$15M、欧洲$10M、亚太$5M\n\n**节约机会识别**：\n\n1. **Spend Consolidation（支出整合）**：\n   - 发现：采购办公用品有20个供应商\n   - 机会：整合到2-3个供应商 → 获取Volume Discount（批量折扣）\n   - 预期节约：10-15%\n\n2. **Maverick Spend Reduction（脱离合同支出减少）**：\n   - 发现：30%支出未使用已签合同供应商\n   - 机会：强制使用合同供应商 → 获取合同价格\n   - 预期节约：5-10%\n\n3. **Demand Management（需求管理）**：\n   - 发现：采购100种不同型号的笔记本电脑\n   - 机会：标准化为3-5种型号 → 简化支持、批量采购\n   - 预期节约：15-20%\n\n4. **Payment Term Optimization（付款条款优化）**：\n   - 发现：平均付款条款Net 30\n   - 机会：谈判Net 60或Net 90 → 改善现金流\n   - 或：Early Payment Discount（提前付款折扣）- 2/10 Net 30（10天内付款享2%折扣）\n\n**Savings Tracking（节约跟踪）**：\n- **Baseline Price（基准价格）**：历史价格或市场价格\n- **Negotiated Price（谈判价格）**：新合同价格\n- **Savings**：(Baseline - Negotiated) × Volume\n- 示例：$10.00 → $9.50, 采购10,000件 = $5,000节约\n\n---\n\n### KILLER Fieldglass - 外部劳动力管理（VMS - Vendor Management System）\n\n#### Contingent Workforce Management - 临时劳动力管理\n\n**劳动力类型**：\n- **Contingent Workers（临时工）**：\n  - Independent Contractors（独立合同工）\n  - Temp Workers（临时工）\n  - Consultants（顾问）\n  - Freelancers（自由职业者）\n\n- **Statement of Work (SOW)**：\n  - 项目型外包（非人员，而是成果）\n  - 示例：网站开发项目、市场调研项目\n\n**用工流程**：\n\n1. **需求提交（Requisition）**：\n   - 职位描述（Job Description）\n   - 技能要求（Skills Required）：Java, AWS, 5年经验\n   - 工作地点（Location）：Remote / Onsite\n   - 合同期限（Duration）：3个月、6个月、1年\n   - 费率预算（Rate Budget）：$80-$100/小时\n\n2. **供应商选择（Vendor Selection）**：\n   - 发送给预审供应商（Preferred Vendor List）\n   - 供应商提交候选人（Candidate Submission）\n   - MSP（Managed Service Provider）模式：单一供应商管理所有临时工\n\n3. **候选人筛选（Candidate Screening）**：\n   - 简历审查（Resume Review）\n   - 面试（Interview）\n   - 背景调查（Background Check）\n\n4. **工单创建（Work Order Creation）**：\n   - 候选人：John Doe\n   - 费率：$90/小时\n   - 供应商加成（Vendor Markup）：$20/小时\n   - 总成本（Total Cost to Company）：$110/小时\n   - 开始日期：2025-01-01\n   - 结束日期：2025-06-30\n\n5. **工时管理（Timesheet Management）**：\n   - 工人提交工时表（周或双周）\n   - 经理审批（Manager Approval）\n   - 加班处理（Overtime）：超过40小时/周 → 1.5倍费率\n   - 节假日（Holiday Pay）：2倍费率\n\n6. **发票处理（Invoice Processing）**：\n   - 基于审批工时自动生成发票\n   - 三单匹配：工单 + 工时表 + 发票\n   - 自动支付（Automated Payment）\n\n**合规管理（Compliance Management）**：\n\n- **Classification Compliance（分类合规）**：\n  - 1099 vs W2（美国）：\n    - 1099：独立合同工（公司不代扣税）\n    - W2：临时雇员（公司代扣税、提供福利）\n  - 误分类风险（Misclassification Risk）：罚款、补缴税款、福利\n  - KILLER Fieldglass Risk Assessment（风险评估问卷）：\n    - 谁控制工作时间？\n    - 谁提供工具？\n    - 工作是否持续性？\n    - 根据答案推荐分类\n\n- **Co-Employment Risk（共同雇佣风险）**：\n  - 临时工为公司工作过长时间 → 被视为实际雇员\n  - 缓解措施：限制合同期限（如最长12个月），强制间隔期（如3个月）\n\n- **Contract Expiration Management**（合同到期管理）：\n  - 到期前30/15/7天提醒\n  - 操作选项：续约（Extend）/ 转正（Convert to FTE）/ 终止（Terminate）\n\n**支出分析（Spend Analytics）**：\n- **按类别分析**：\n  - IT Contractors：$5M\n  - Professional Services：$3M\n  - Admin Support：$1M\n\n- **按供应商分析**：\n  - Vendor A：$4M, 100 workers\n  - Vendor B：$2M, 50 workers\n  - Average Bill Rate（平均费率）：$80/小时\n  - Average Markup（平均加成）：25%\n\n- **节约机会**：\n  - Fee Negotiation（费用谈判）：Markup 25% → 20% = 5%节约\n  - Rate Benchmarking（费率对标）：Java Developer 市场费率$75 vs 当前$90 → 重新谈判\n\n#### Total Talent Management - 全员人才管理\n\n**集成人才视图**：\n- **Employees（正式员工）** from SuccessFactors\n- **Contingent Workers（临时工）** from Fieldglass\n- **Consultants（咨询顾问）** from Fieldglass SOW\n- **Gig Workers（零工）** from Freelancer platforms\n\n**混合团队管理**：\n- 项目团队组成：5 FTE + 3 Contractors + 2 Consultants\n- 统一技能视图（Unified Skills View）：谁具备Python、AWS、Machine Learning技能？\n- 资源调配优化（Optimal Resource Allocation）\n\n**成本对比分析**：\n```\nFTE成本 = Salary + Benefits + Taxes + Overhead\n  = $80,000 + $24,000 + $6,120 + $10,000 = $120,120/年\n  = $57.74/小时（按2,080小时/年）\n\nContingent Worker成本 = $90/小时（全包）\n  = $187,200/年（按2,080小时）\n\n短期项目（<6个月） → Contingent Worker更灵活\n长期需求（>1年） → FTE更经济\n```\n\n---\n\n### KILLER Concur - 差旅与费用管理\n\n#### Concur Travel - 差旅预订\n\n**预订渠道**：\n- **Online Booking Tool (OBT)**：\n  - 集成GDS（全球分销系统）：Amadeus, Sabre, Travelport\n  - 实时航班、酒店、租车搜索\n\n- **Travel Agency Integration**：\n  - VIP员工 / 复杂行程 → 通过旅行社预订\n  - 旅行社使用Concur代为预订 → 数据回流系统\n\n**差旅政策控制**：\n\n1. **机票政策（Flight Policy）**：\n   - 国内航班 < 3小时 → 仅经济舱\n   - 国内航班 ≥ 3小时 → 经济舱优先，商务舱需批准\n   - 国际航班 ≥ 6小时 → 允许商务舱（VP及以上）\n   - Out-of-Policy警告：选择非直飞航班 → 警告\"政策建议直飞\"\n   - Out-of-Policy Block：选择头等舱 → 阻止预订，需获批准\n\n2. **酒店政策（Hotel Policy）**：\n   - 城市分级：\n     - Tier 1（纽约、旧金山、伦敦）：$300/晚\n     - Tier 2（芝加哥、波士顿）：$200/晚\n     - Tier 3（其他城市）：$150/晚\n   - 超标需经理批准\n   - Preferred Hotels（首选酒店）：协议价酒店优先展示\n\n3. **租车政策（Car Rental Policy）**：\n   - 标准车型：Compact / Midsize\n   - 禁止豪华车型：Luxury / Premium SUV\n   - 鼓励使用协议供应商（Hertz, Avis）：享折扣\n\n**出差审批（Trip Approval）**：\n- 预估差旅成本：\n  ```\n  机票：$800\n  酒店：$200 × 3晚 = $600\n  租车：$50 × 3天 = $150\n  餐饮：$75 × 3天 = $225（预估）\n  总计：$1,775\n  ```\n- 审批规则：\n  - 国内出差 < $2,000 → 经理审批\n  - 国内出差 ≥ $2,000 → 经理 + 部门总监审批\n  - 国际出差 → 经理 + 部门总监 + SVP审批\n\n**Unused Ticket Management**（未使用机票管理）：\n- 员工取消出差但机票已出 → 记录在Concur\n- 提醒员工在有效期内使用（通常1年）\n- 避免浪费（Ticket Leakage）\n\n#### Concur Expense - 费用报销\n\n**费用类型**：\n- **Meals（餐饮）**：早餐、午餐、晚餐\n- **Transportation（交通）**：出租车、Uber、地铁、停车费\n- **Lodging（住宿）**：酒店\n- **Airfare（机票）**：从Concur Travel自动导入\n- **Entertainment（招待）**：客户晚餐、活动门票\n- **Miscellaneous（杂项）**：网络费、洗衣费\n\n**报销流程**：\n\n1. **费用录入（Expense Entry）**：\n   - **手动录入**：日期、金额、类别、商家\n   - **OCR自动识别**：拍照收据 → AI提取金额、日期、商家\n   - **信用卡进料（Credit Card Feed）**：\n     - 公司卡交易自动导入Concur\n     - 员工只需匹配收据（Receipt Match）\n   - **Mileage Calculation（里程计算）**：\n     - 输入起点、终点 → Google Maps计算里程\n     - 里程费率：$0.655/英里（2023 IRS标准）\n     - 费用 = 里程 × 费率\n\n2. **费用报告提交（Expense Report Submission）**：\n   - 员工创建报告，添加费用项\n   - 必填字段：Business Purpose（业务目的）、Cost Center（成本中心）\n   - 提交审批\n\n3. **费用审批（Expense Approval）**：\n   - **经理审批**：合理性审查\n     - 单笔餐饮$200 → 合理吗？（可能是团队聚餐）\n     - 需查看收据和业务目的\n   - **财务审核**：政策合规性\n     - 检查是否超政策限额\n     - 检查是否缺失收据（通常$25以上需收据）\n   - **审计标记（Audit Flag）**：\n     - 高风险费用（如娱乐、礼品） → 100%审计\n     - 低风险费用 → 随机抽样审计（如10%）\n\n4. **支付（Payment）**：\n   - 集成KILLER ERP / Oracle Financials → 创建应付账款\n   - 直接存款（Direct Deposit）到员工银行账户\n   - 付款周期：双周（Bi-Weekly）\n\n**费用政策示例**：\n\n- **餐饮标准（Meal Per Diem）**：\n  - 早餐：$15\n  - 午餐：$25\n  - 晚餐：$50\n  - 超标需提供业务理由（如客户晚餐）\n\n- **酒精政策（Alcohol Policy）**：\n  - 个人用餐 → 不报销酒精\n  - 客户招待 → 允许适量酒精\n\n- **收据要求（Receipt Requirement）**：\n  - $25以下 → 无需收据\n  - $25-$75 → 需简化收据（Itemized Receipt）\n  - $75以上 → 需详细收据\n\n**税务合规（Tax Compliance）**：\n- **VAT Reclaim（增值税退税）**：\n  - 欧洲出差 → 酒店含20% VAT\n  - Concur识别VAT金额 → 提交退税申请\n  - 公司回收VAT → 降低差旅成本\n\n- **GST/HST（加拿大）**、**消费税（日本）** 同理\n\n#### Concur Invoice - 发票管理\n\n**供应商发票处理**：\n\n1. **发票接收（Invoice Receipt）**：\n   - **Email Ingestion**：供应商发邮件发票 → Concur自动提取PDF\n   - **Supplier Portal**：供应商登录Concur上传发票\n   - **EDI / XML**：结构化数据传输\n\n2. **OCR & Data Extraction**：\n   - AI提取：发票号、日期、金额、税额、供应商、PO号（如有）\n   - 置信度评分（Confidence Score）：\n     - High（> 95%） → 自动处理\n     - Medium（80-95%） → 人工验证\n     - Low（< 80%） → 完全人工录入\n\n3. **PO Matching（订单匹配）**：\n   - 发票有PO号 → 自动匹配PO\n   - 2-Way Match：PO vs Invoice\n   - 3-Way Match：PO vs GR vs Invoice（集成ERP收货数据）\n   - 匹配成功 → 自动审批\n   - 不匹配 → Exception Queue（异常队列）\n\n4. **Non-PO Invoice Processing**（无订单发票）**：\n   - 例如：水电费、租金、咨询费\n   - 编码（Coding）：分配到Cost Center、GL Account\n   - 路由审批（Routing for Approval）：发送给部门经理\n\n5. **Approval & Payment**：\n   - 审批后 → 发送到ERP系统\n   - ERP创建应付账款并付款\n   - 付款状态回传Concur → 供应商可见\n\n**Early Payment Discounts（提前付款折扣）**：\n- 条款：2/10 Net 30（10天内付款享2%折扣，否则30天付款）\n- Concur自动计算折扣到期日\n- 提醒AP团队抓住折扣机会\n- 年化收益率：2% / 20天 × 365天 = 36.5%（高于借款成本 → 应抓住）\n\n**Duplicate Invoice Detection**（重复发票检测）**：\n- AI检测：相同供应商、相同金额、相似日期 → 标记为可能重复\n- 人工确认后阻止重复支付\n\n---\n\n### KILLER SuccessFactors - 人力资本管理云\n\n#### Employee Central (EC) - 员工核心\n\n**Employee Central功能**：\n- **核心HR主数据**：\n  - Personal Information（个人信息）\n  - Job Information（职位信息）\n  - Compensation（薪酬）\n  - Employment Details（雇佣详情）\n  - Organization Chart（组织架构图）\n\n- **Global Assignment Management**（全球派遣管理）：\n  - 员工从美国派遣到中国工作2年\n  - Home Country（母国）：美国\n  - Host Country（东道国）：中国\n  - 薪酬分割（Split Payroll）：部分美国发放、部分中国发放\n  - Tax Equalization（税务平衡）：确保派遣员工税负不增加\n  - 公式：Net Pay = Gross - Hypothetical Tax（假设母国税）\n\n- **Time Off Management**（休假管理）**：\n  - **休假类型**：\n    - Paid Time Off (PTO)：带薪休假\n    - Sick Leave：病假\n    - Parental Leave：育儿假\n    - Bereavement Leave：丧假\n\n  - **Accrual Rules（累积规则）**：\n    - 每月累积1.67天 PTO（年度20天）\n    - 服务年限影响：\n      - 0-5年：20天/年\n      - 5-10年：25天/年\n      - 10年以上：30天/年\n\n  - **Approval Workflow**：\n    - 员工申请 → 经理审批 → HR通知\n    - 集成Outlook/Google Calendar\n\n- **Employee Self-Service (ESS)**：\n  - 更新个人信息（地址、紧急联系人）\n  - 查看工资单（Payslip）\n  - 下载税表（W-2, T4）\n  - 申请休假\n\n- **Manager Self-Service (MSS)**：\n  - 批准休假\n  - 发起加薪（Compensation Change）\n  - 查看团队组织架构\n  - 查看团队绩效\n\n**Employee Central Payroll (ECP)**：\n- SuccessFactors原生工资核算（基于KILLER Payroll引擎）\n- 支持40+国家本地化\n- 集成Employee Central → 自动获取人员变动\n\n#### Recruiting - 招聘管理\n\n**端到端招聘流程**：\n\n1. **Requisition（招聘需求）**：\n   - Hiring Manager创建职位申请\n   - 职位详情：Title, Department, Location, Salary Range\n   - Headcount Approval（编制审批）：HR审批是否有预算\n\n2. **Job Posting（职位发布）**：\n   - **内部发布（Internal Posting）**：给现有员工内部应聘机会（7天）\n   - **外部发布（External Posting）**：\n     - Career Site（公司招聘网站）\n     - Job Boards：LinkedIn, Indeed, Glassdoor\n     - Social Media：Facebook, Twitter\n   - **Job Description Management**：\n     - 模板库（Template Library）\n     - AI生成职位描述（基于Title和Department）\n\n3. **Candidate Sourcing（候选人寻源）**：\n   - **Talent Pool（人才库）**：\n     - 往期应聘者（Past Applicants）\n     - Referrals（员工推荐）\n     - Silver Medalists（上次面试表现好但未被录用）\n\n   - **LinkedIn Recruiter Integration**：\n     - 直接在SuccessFactors搜索LinkedIn人才\n     - 发送InMail\n     - 候选人响应后自动创建Application\n\n4. **Candidate Screening（候选人筛选）**：\n   - **Resume Parsing（简历解析）**：AI提取技能、经验、教育背景\n   - **Knockout Questions（淘汰问题）**：\n     - \"Do you have 5+ years Java experience?\" → No → 自动拒绝\n   - **Candidate Ranking（候选人排名）**：\n     - AI匹配度评分（Job Requirements vs Resume）\n     - 推荐Top 10候选人给Recruiter审阅\n\n5. **Interview Scheduling（面试安排）**：\n   - **Interview Panel（面试小组）**：\n     - Round 1：Recruiter Phone Screen（30分钟）\n     - Round 2：Hiring Manager Interview（1小时）\n     - Round 3：Technical Interview（2小时）\n     - Round 4：Executive Interview（30分钟）\n\n   - **Calendar Integration**：\n     - 集成Outlook/Google Calendar\n     - 自动查找面试官空闲时间\n     - 发送面试邀请（候选人 + 面试官）\n\n   - **Interview Feedback（面试反馈）**：\n     - 面试官完成后填写评估表：\n       - Technical Skills：1-5分\n       - Communication：1-5分\n       - Culture Fit：1-5分\n       - Overall Recommendation：Strong Yes / Yes / No / Strong No\n\n6. **Offer Management（Offer管理）**：\n   - **Offer Letter Generation**：\n     - 基于模板自动生成\n     - 填充：候选人姓名、职位、薪酬、开始日期\n   - **Offer Approval Workflow**：\n     - 薪酬在Budget内 → Hiring Manager审批\n     - 薪酬超Budget → Hiring Manager + HR Director + Finance审批\n   - **E-Signature**：DocuSign集成 → 候选人电子签署\n   - **Offer Acceptance/Decline**：\n     - 接受 → 触发Onboarding流程\n     - 拒绝 → 返回候选人池，考虑其他候选人\n\n7. **Onboarding（入职）**：\n   - **Pre-Boarding（入职前）**：\n     - 发送Welcome Email\n     - 发送文档（Employee Handbook, Tax Forms）\n     - 分配Buddy（入职伙伴）\n   - **Day 1 Checklist**：\n     - IT setup（电脑、邮箱、系统权限）\n     - 办公位安排（Desk Assignment）\n     - 门禁卡（Badge）\n     - 新员工培训（Orientation）\n   - **30/60/90 Day Check-ins**：\n     - Manager定期与新员工会面\n     - 评估适应情况（Adaptation）\n     - 提供反馈（Feedback）\n\n**Recruitment Analytics（招聘分析）**：\n- **Time to Fill（招聘周期）**：\n  - 平均45天（行业基准30-50天）\n  - 按职位分析：Software Engineer 60天 vs Admin 20天\n\n- **Source Effectiveness（来源有效性）**：\n  - LinkedIn：100 applicants → 10 hires（10%转化率）\n  - Indeed：200 applicants → 5 hires（2.5%转化率）\n  - 结论：优先投资LinkedIn\n\n- **Cost per Hire（每招聘成本）**：\n  ```\n  总成本 = Job Board费用 + Recruiter薪酬 + 面试成本 + Relocation\n  Cost per Hire = 总成本 / Hires\n  示例：$500K / 50 hires = $10K/hire\n  ```\n\n- **Offer Acceptance Rate（Offer接受率）**：\n  - 85%（行业基准80-90%）\n  - 低于80% → 检查薪酬竞争力或Candidate Experience\n\n#### Performance & Goals - 绩效与目标管理\n\n**目标设定（Goal Setting）**：\n\n1. **Cascading Goals（目标分解）**：\n   ```\n   CEO Goal：收入增长20%\n   ├─ Sales VP Goal：新客户增长30%\n   │  ├─ Sales Manager Goal：团队成交$5M\n   │  │  └─ Sales Rep Goal：个人成交$500K\n   └─ Product VP Goal：发布3个新产品\n      └─ Product Manager Goal：按时交付Product A\n   ```\n\n2. **SMART Goals（SMART原则）**：\n   - **Specific**（具体）：将Q1销售额提升到$2M\n   - **Measurable**（可衡量）：$2M（vs \"提升销售\"）\n   - **Achievable**（可实现）：基于历史数据和资源\n   - **Relevant**（相关）：与公司战略一致\n   - **Time-Bound**（有时限）：Q1（3个月）\n\n3. **Goal Types**：\n   - **Metric Goals**（指标型）：销售额、客户满意度评分\n   - **Binary Goals**（二元型）：完成项目（是/否）\n   - **Development Goals**（发展型）：学习Python、考取认证\n\n**绩效评估（Performance Review）**：\n\n1. **Continuous Performance Management（持续绩效管理）**：\n   - 传统：年度评估（Annual Review）\n   - 现代：季度/月度Check-ins + 年度总结\n   - 实时反馈（Real-Time Feedback）\n\n2. **360-Degree Feedback（360度反馈）**：\n   - 评估来源：\n     - 自评（Self-Assessment）\n     - 经理评估（Manager Assessment）\n     - 同事评估（Peer Review）- 2-3人\n     - 下属评估（Subordinate Review）- 如有\n     - 客户评估（Customer Feedback）- 如适用\n   - 匿名vs实名（可配置）\n\n3. **Rating Scales（评分等级）**：\n   - **5-Point Scale**：\n     - 5：Exceptional（杰出）- 超出预期\n     - 4：Exceeds Expectations（超预期）\n     - 3：Meets Expectations（达预期）\n     - 2：Partially Meets（部分达成）\n     - 1：Does Not Meet（未达成）\n\n   - **Forced Distribution（强制分布）**：\n     - Top 10%：Rating 5\n     - Next 20%：Rating 4\n     - Middle 40%：Rating 3\n     - Next 20%：Rating 2\n     - Bottom 10%：Rating 1\n   - 争议：可能不公平，很多公司已废除\n\n4. **Calibration Sessions（评分校准会议）**：\n   - 经理们聚在一起讨论评分\n   - 目的：确保评分一致性（不同经理标准一致）\n   - 避免偏见（Leniency Bias - 评分过松，Severity Bias - 评分过严）\n\n5. **Performance Improvement Plan (PIP)**：\n   - 员工Rating 1或连续Rating 2 → 进入PIP\n   - 30/60/90天改进计划\n   - 明确目标和支持措施\n   - 期末评估：改进成功 → 继续雇佣；未改进 → Termination\n\n**绩效与奖励关联**：\n- **Merit Increase（绩效加薪）**：\n  - Rating 5：8-10%加薪\n  - Rating 4：5-7%\n  - Rating 3：2-4%\n  - Rating 2：0-2%\n  - Rating 1：0%\n\n- **Bonus Pool Distribution（奖金池分配）**：\n  ```\n  奖金池：$1M\n  Rating 5员工：10人 → 分配$400K（平均$40K/人）\n  Rating 4员工：20人 → 分配$400K（平均$20K/人）\n  Rating 3员工：50人 → 分配$200K（平均$4K/人）\n  ```\n\n#### Learning Management - 学习管理\n\n**学习内容类型**：\n- **Curriculum（课程体系）**：\n  - New Manager Curriculum：5门课程（面试技巧、绩效管理、冲突解决等）\n  - Technical Curriculum：Java Developer Path（10门课程，从入门到高级）\n\n- **课程格式**：\n  - **E-Learning**：在线自学课程（SCORM / xAPI格式）\n  - **Instructor-Led Training (ILT)**：课堂培训（需预订时间地点）\n  - **Virtual Instructor-Led Training (VILT)**：在线直播培训（Zoom/Teams集成）\n  - **On-the-Job Training**：实践培训\n  - **External Training**：外部会议、研讨会\n\n**Compliance Training（合规培训）**：\n- **强制性培训**：\n  - Anti-Harassment（反骚扰）：年度必修\n  - Information Security（信息安全）：年度必修\n  - GDPR Compliance（GDPR合规）：欧洲员工必修\n\n- **自动分配**：\n  - 新员工入职 → 自动分配\"新员工培训\"课程\n  - 员工晋升为经理 → 自动分配\"管理者培训\"课程\n  - 到期前提醒（30/15/7天）\n  - 逾期未完成 → 上报给经理和HR\n\n**Learning Analytics（学习分析）**：\n- **完成率（Completion Rate）**：\n  - Information Security培训：95%完成率（目标100%）\n\n- **Learning Hours per Employee**：\n  - 平均每员工每年学习40小时（行业基准30-50小时）\n\n- **Skill Gap Analysis（技能差距分析）**：\n  - 职位\"Data Scientist\"需要技能：Python, ML, SQL\n  - 员工当前技能：Python（精通）, SQL（中级）, ML（初级）\n  - 推荐学习：Machine Learning Advanced Course\n\n**Career Development Planning**（职业发展规划）**：\n- **Career Path（职业路径）**：\n  - Individual Contributor（IC）路径：Junior → Mid-Level → Senior → Principal → Distinguished\n  - Management路径：Manager → Senior Manager → Director → VP → SVP\n\n- **Development Plan（发展计划）**：\n  - 员工目标：2年内晋升为Senior Engineer\n  - 所需技能：System Design, Leadership, Mentoring\n  - 行动计划：\n    - 完成\"System Design\"课程\n    - Lead 2个项目\n    - Mentor 1名Junior Engineer\n  - 经理Review进展（季度Check-in）\n\n---\n\n## 高级主数据和治理解决方案（Master Data & Governance）\n\n### KILLER Master Data Governance (MDG)\n\n#### MDG-F (Financials) - 财务主数据治理\n\n**治理对象**：\n- **G/L Accounts（总账科目）**：\n  - 科目表（Chart of Accounts）\n  - 科目编号规则：1000-1999资产、2000-2999负债、3000-3999权益\n  - 多层级审批：创建新科目需CFO审批\n\n- **Cost Centers（成本中心）**：\n  - 层级结构（Hierarchy）：公司 → 部门 → 团队\n  - 有效期管理（Validity Dates）：临时成本中心（项目）\n  - 变更管理：成本中心负责人变更需审批\n\n- **Profit Centers（利润中心）**：\n  - 按产品线、地区、业务单元划分\n  - 内部定价（Internal Pricing）\n  - P&L报告\n\n**Change Request Workflow**：\n1. Requester提交变更请求（如创建新成本中心）\n2. Data Steward（数据管理员）审查数据质量\n3. Data Owner（数据负责人，如Finance Manager）审批业务合理性\n4. 自动激活（Activation） → 分发到所有连接系统（KILLER ECC, S/4HANA, BW）\n\n**数据质量规则**：\n- **Validation Rules**：\n  - Cost Center名称不能为空\n  - Cost Center编号必须10位数字\n  - 负责人必须是有效员工\n- **Duplicate Check**：\n  - Fuzzy Match检测相似名称（\"IT Department\" vs \"IT Dept\"）\n\n#### MDG-M (Material) - 物料主数据治理\n\n**物料创建流程**：\n\n1. **Request Submission**：\n   - Requester（如采购员）提交新物料申请\n   - 填写基本信息：Material Description, Material Type, Base Unit\n\n2. **Enrichment（数据丰富）**：\n   - **Purchasing Data**（采购数据）：采购组、采购员、默认供应商\n   - **MRP Data**（MRP数据）：MRP类型、批量、安全库存\n   - **Accounting Data**（会计数据）：估价类、价格控制\n   - **Sales Data**（销售数据）：销售组织、配送工厂\n   - **Quality Data**（质量数据）：是否需要QM检验\n   - 不同部门并行填写各自数据（Parallel Workflow）\n\n3. **Validation & Approval**：\n   - 数据完整性检查：所有必填字段已填？\n   - 数据质量检查：物料描述是否规范？\n   - 多层级审批：\n     - 采购经理审批采购数据\n     - 质量经理审批质量数据\n     - 数据管理员最终审批\n\n4. **Activation & Replication**：\n   - MDG中心系统激活物料主数据\n   - 实时复制（Real-Time Replication）到所有ERP系统（通过CIF / ALE）\n   - 所有系统保持一致性（Single Source of Truth）\n\n**物料编号策略**：\n- **Internal Numbering**（内部编号）：\n  - 系统自动分配：100000001, 100000002, ...\n  - 保证唯一性\n\n- **External Numbering**（外部编号）：\n  - 用户输入有意义编号：\n    - RAW-STL-001（原材料-钢材-001）\n    - FG-LAPTOP-DEL-001（成品-笔记本-Dell-001）\n  - 需定义编号规则防止冲突\n\n**Mass Change（批量变更）**：\n- 场景：供应商切换（Vendor Switch）\n  - 500个物料的默认供应商从Vendor A → Vendor B\n  - MDG批量变更工具：\n    - 上传Excel（物料清单 + 新供应商）\n    - 系统生成单一Change Request\n    - 审批后批量激活\n\n**Material Hierarchy（物料层级）**：\n- Level 1：Product Group（产品组）- Electronics\n- Level 2：Product Family（产品系列）- Laptops\n- Level 3：Brand（品牌）- Dell\n- Level 4：Model（型号）- XPS 15\n- 用于报表和分析\n\n#### MDG-S (Supplier) - 供应商主数据治理\n\n**Supplier Onboarding（供应商入驻）**：\n\n1. **Supplier Self-Registration（供应商自注册）**：\n   - 供应商访问门户网站\n   - 填写公司信息：\n     - 基本信息（公司名、地址、联系方式）\n     - 银行信息（Bank Account for Payment）\n     - 税务信息（Tax ID, VAT Number）\n     - 产品/服务类别（Commodity Codes）\n     - 认证证书（ISO 9001, ISO 14001等）\n\n2. **Document Upload**：\n   - 营业执照（Business License）\n   - W-9表格（美国税表）\n   - 保险证明（Insurance Certificate）\n   - 质量体系认证（Quality Certifications）\n\n3. **Risk Assessment（风险评估）**：\n   - **Financial Risk**（财务风险）：\n     - Dun & Bradstreet评分集成\n     - 信用评级：AAA, AA, A, BBB, BB, B, CCC\n     - 财务健康度：Paydex Score（付款及时性）\n\n   - **Compliance Risk**（合规风险）**：\n     - 制裁名单筛查（Denied Party Screening）：OFAC, EU Sanctions\n     - 反洗钱检查（AML）\n     - 反贿赂腐败（Anti-Bribery & Corruption - ABAC）\n\n   - **ESG Risk**（ESG风险）**：\n     - 环境合规\n     - 劳工实践（无童工、公平工资）\n     - 冲突矿产（Conflict Minerals）\n\n4. **On-Site Audit（现场审计）** - 如适用：\n   - 质量审计：检查生产能力、质量体系\n   - 审计报告：Pass / Conditional Pass / Fail\n\n5. **Approval & Activation**：\n   - 采购部门审批：商业条款\n   - 质量部门审批：质量能力\n   - 财务部门审批：付款条款\n   - 法务部门审批：合同条款\n   - 多部门审批完成 → 激活供应商 → 可发送PO\n\n**Supplier Lifecycle Management**：\n- **Periodic Re-Certification**（定期重新认证）：\n  - 每2年重新提交证书\n  - 重新进行风险评估\n  - 逾期未认证 → 供应商Block（阻止新PO）\n\n- **Supplier Segmentation（供应商分类）**：\n  - **Strategic Suppliers**（战略供应商）：高价值、难替代\n    - 年度业务审查（Annual Business Review）\n    - 联合创新（Co-Innovation）\n  - **Preferred Suppliers**（首选供应商）：良好绩效\n    - 优先获得新业务\n  - **Approved Suppliers**（合格供应商）：基本合格\n    - 正常业务往来\n  - **Conditional Suppliers**（有条件供应商）：存在问题\n    - 改进计划（Improvement Plan）\n  - **Blocked Suppliers**（封禁供应商）：严重问题\n    - 禁止新业务\n\n#### MDG-C (Customer) - 客户主数据治理\n\n**Customer Hierarchy（客户层级）**：\n- **Sold-To Party**（售达方）：签订合同方\n- **Ship-To Party**（送达方）：收货方（可能多个）\n- **Bill-To Party**（开票方）：接收发票方\n- **Payer**（付款方）：实际付款方\n\n示例：\n- 跨国公司XYZ Corp：\n  - Sold-To：XYZ Corp HQ（总部签合同）\n  - Ship-To：XYZ Factory 1, XYZ Factory 2, XYZ Office 3（多个收货地址）\n  - Bill-To：XYZ AP Department（应付账款部门统一接收发票）\n  - Payer：XYZ Treasury（财务部统一付款）\n\n**Customer Credit Management**（客户信用管理）**：\n- **Credit Limit Assignment**：\n  - 客户A：信用额度$500K\n  - 客户B：信用额度$100K\n\n- **Credit Check**：\n  - 订单创建时自动检查：\n    ```\n    已用额度 = 未清发票 + 未交付订单 + 当前订单\n    如果 已用额度 > 信用额度 → Block订单 → 需Credit Manager审批\n    ```\n\n- **Credit Scoring（信用评分）**：\n  - Payment History（付款历史）：30%\n  - Financial Strength（财务实力）：30%\n  - Order History（订单历史）：20%\n  - Industry Risk（行业风险）：20%\n  - 综合评分 → 自动推荐信用额度\n\n**Customer Deduplication（客户去重）**：\n- 问题：同一客户多次创建（拼写差异、部门差异）\n  - \"IBM Corporation\"\n  - \"IBM Corp\"\n  - \"International Business Machines\"\n\n- MDG Duplicate Check：\n  - Fuzzy Matching算法（Levenshtein距离）\n  - 匹配规则：公司名 + 地址 + Tax ID\n  - 相似度 > 90% → 提示可能重复 → 人工确认合并\n\n**Golden Record（黄金记录）**：\n- 多个系统中的客户数据整合为单一Golden Record\n- 示例：\n  - ERP系统：Customer #12345\n  - CRM系统：Account #CUST-ABC-001\n  - Billing系统：Customer #99999\n  - MDG Golden Record：统一ID + 主数据 → 同步到所有系统\n\n---\n\n## KILLER治理、风险与合规解决方案（GRC - Governance, Risk & Compliance）\n\n### KILLER GRC Access Control - 访问控制\n\n#### Segregation of Duties (SoD) - 职责分离\n\n**SoD概念**：\n- 防止单一用户执行冲突操作（如创建供应商+支付供应商=欺诈风险）\n- 基于风险矩阵（Risk Matrix）识别冲突\n\n**常见SoD冲突示例**：\n\n1. **采购到付款（Procure-to-Pay - P2P）**：\n   - ❌ 冲突：创建供应商（FK01）+ 创建付款（F-58）\n   - 风险：员工创建虚假供应商并支付给自己\n   - 缓解措施：分离角色或启用缓解控制（Mitigating Controls）\n\n2. **订单到现金（Order-to-Cash - O2C）**：\n   - ❌ 冲突：创建客户（XD01）+ 修改客户信用额度（FD32）+ 创建销售订单（VA01）\n   - 风险：员工提高信用额度批准大订单，导致坏账\n\n3. **财务会计（Financial Accounting）**：\n   - ❌ 冲突：过账凭证（FB01）+ 执行付款运行（F110）\n   - 风险：绕过审批流程直接付款\n\n4. **主数据管理**：\n   - ❌ 冲突：创建物料（MM01）+ 修改物料价格（MR21）\n   - 风险：价格操纵\n\n**风险级别分类**：\n- **High（高）**：直接财务损失风险（如付款冲突）→ 必须缓解\n- **Medium（中）**：间接风险或需配合其他操作 → 建议缓解\n- **Low（低）**：理论风险，实际影响小 → 可接受\n\n**冲突检测和报告**：\n- **实时检测**：角色分配时实时检查 → 发现冲突→ 阻止或警告\n- **定期扫描**：每月/季度运行SoD报告\n- **报告内容**：\n  - User ID: JSMITH\n  - 冲突类型: Create Vendor + Pay Vendor\n  - 风险等级: High\n  - 业务流程: Procure-to-Pay\n  - 缓解措施: None（需立即处理）\n\n#### Mitigating Controls - 缓解控制\n\n**缓解控制类型**：\n\n1. **Preventive（预防性）**：\n   - 自动工作流审批：大额付款需额外审批\n   - 双重授权（Dual Authorization）：两人共同批准\n\n2. **Detective（检测性）**：\n   - 定期审查：每月审查供应商主数据变更\n   - 日志审计：记录所有关键操作\n\n3. **Compensating（补偿性）**：\n   - 管理层审查：VP每周审查异常交易\n   - 外部审计：年度第三方审计\n\n**缓解控制记录示例**：\n```\n冲突: User JSMITH 拥有 \"Create Vendor\" + \"Pay Vendor\"\n缓解控制:\n- 所有新供应商创建需采购经理审批（Preventive）\n- 所有付款>$10K需财务总监审批（Preventive）\n- 每月IT审计团队审查JSMITH的活动日志（Detective）\n风险接受: 业务负责人签字接受残余风险\n有效期: 2025-01-01 至 2025-12-31（年度复审）\n```\n\n#### Access Risk Analysis (ARA) - 访问风险分析\n\n**用户访问认证（User Access Certification）**：\n- **目的**：定期验证用户权限仍然合理（员工换岗但权限未删除）\n- **频率**：季度或半年度\n- **流程**：\n  1. 系统生成报告：用户 + 角色 + 权限清单\n  2. 发送给Manager审查：这些权限还需要吗？\n  3. Manager批准/撤销：\n     - 批准：权限保留\n     - 撤销：IT团队移除权限\n  4. 逾期未审查 → 升级到上级Manager\n\n**关键用户监控**：\n- **Super Users（超级用户）**：拥有KILLER_ALL或调试权限\n- **Firefighter（消防员）**：紧急访问账户\n  - 使用场景：生产系统紧急修复（正常流程太慢）\n  - 控制措施：\n    - 使用前申请（Ticket）说明原因\n    - 时间限制：24小时自动失效\n    - 全程录屏（Session Recording）\n    - 事后审计：48小时内审查所有操作\n\n**KILLER GRC ARA架构**：\n```\nKILLER ECC/S/4HANA → GRC Connector → GRC Access Control\n                                        ↓\n                               Risk Analysis Engine\n                                        ↓\n                      ┌─────────────────┴─────────────────┐\n                      ↓                                   ↓\n               SoD Conflicts                    Risk Reports\n                      ↓                                   ↓\n               Mitigating Controls              User Access Review\n```\n\n#### Emergency Access Management (EAM) - 紧急访问管理\n\n**Firefighter功能**：\n- **场景**：生产系统故障，普通权限无法修复，需临时提权\n- **申请流程**：\n  1. 提交Firefighter申请：\n     - 原因：生产订单无法过账（错误代码XYZ）\n     - 需要权限：调试权限（KILLER_DEBUG）\n     - 持续时间：4小时\n  2. 审批：\n     - 自动审批（非工作时间） or 经理审批（工作时间）\n  3. 授权生效：\n     - 临时角色分配\n     - 短信/邮件通知用户\n  4. 使用：\n     - 登录系统，拥有临时权限\n     - 所有操作记录到日志\n  5. 权限撤销：\n     - 时间到期自动撤销\n     - 用户手动归还（完成修复后）\n  6. 事后审计：\n     - IT审计审查日志：用户只做了申请的操作吗？\n     - 违规 → 上报管理层\n\n**Firefighter日志示例**：\n```\nUser: JDOE\nRequest Time: 2025-12-21 02:30 AM\nReason: Critical production issue - Sales Order stuck\nGranted Role: ZFF_SD_DEBUG\nActivities Performed:\n  - 02:35 - Debugged program KILLERMV45A\n  - 02:40 - Modified Sales Order 123456 (removed block)\n  - 02:45 - Saved and released order\n  - 02:50 - Returned Firefighter access (early)\nAudit Status: Approved - Actions aligned with request\n```\n\n---\n\n### KILLER GRC Process Control - 流程控制\n\n#### Risk and Control Matrix - 风险与控制矩阵\n\n**风险识别**：\n- **财务报告风险（Financial Reporting Risks）**：\n  - 收入确认错误（Revenue Recognition Errors）\n  - 资产高估（Asset Overstatement）\n  - 负债低估（Liability Understatement）\n\n**控制设计**：\n- **Manual Controls（手工控制）**：\n  - 月末对账（Month-End Reconciliation）\n  - 高级管理层审查（Management Review）\n\n- **Automated Controls（自动控制）**：\n  - 系统配置：不允许负库存过账\n  - 编号范围控制（Number Range）：防止重复凭证\n  - 字段强制要求（Mandatory Fields）：成本中心必填\n\n**控制测试**：\n- **频率**：\n  - High Risk控制 → 每月测试\n  - Medium Risk控制 → 每季度测试\n  - Low Risk控制 → 每年测试\n\n- **测试方法**：\n  - Manual Control：抽样检查（Sample Testing）- 25笔交易\n  - Automated Control：配置检查（Configuration Review）- 验证设置未变\n\n**控制有效性评估**：\n```\n控制: 所有采购订单>$50K需副总裁审批\n测试样本: 30笔采购订单（>$50K）\n测试结果:\n  - 28笔：有VP审批 ✅\n  - 2笔：无VP审批 ❌（缺陷Deficiency）\n缺陷原因: 系统工作流配置错误（$50K阈值设置为$500K）\n纠正措施:\n  - 立即修复工作流配置\n  - 追溯审批2笔缺失审批的订单\n  - 重新测试25笔新交易\n控制评级: Ineffective → Operating Effectively（修复后）\n```\n\n#### Continuous Monitoring - 持续监控\n\n**自动监控规则**：\n\n1. **财务异常检测**：\n   - 规则：单笔凭证金额 > $1M\n   - 触发：自动发送警报给CFO\n   - 示例：检测到凭证1234567890，金额$5M，科目1010（现金）\n   - 行动：CFO审查 → 合法（大额客户付款） or 错误（退回重做）\n\n2. **主数据变更监控**：\n   - 规则：供应商银行账户变更\n   - 触发：通知采购经理和AP经理\n   - 风险：欺诈者劫持供应商主数据，将付款转到自己账户\n\n3. **权限滥用检测**：\n   - 规则：用户在非工作时间（凌晨1-5点）执行敏感事务码（F-53付款）\n   - 触发：IT安全团队审查\n   - 示例：User JSMITH在凌晨3点创建付款$100K → 可疑\n\n4. **SoD违规实时监控**：\n   - 规则：用户同时执行\"创建供应商\"和\"付款\"在同一天\n   - 触发：阻止第二个操作 or 发送警报（取决于配置）\n\n**监控仪表板（Monitoring Dashboard）**：\n```\n实时监控状态（2025-12-21）:\n┌──────────────────────────────────────┐\n│ 🚨 High Alerts: 3                    │\n│   - Large JE >$1M: 2                 │\n│   - Vendor Bank Change: 1            │\n│                                       │\n│ ⚠️  Medium Alerts: 12                │\n│   - After-hours access: 8            │\n│   - Failed login attempts: 4         │\n│                                       │\n│ ℹ️  Info: 50                         │\n│   - Routine monitoring events        │\n└──────────────────────────────────────┘\n```\n\n---\n\n### KILLER GRC Risk Management - 风险管理\n\n#### Enterprise Risk Management (ERM)\n\n**风险登记册（Risk Register）**：\n\n| 风险ID | 风险描述 | 类别 | 可能性 | 影响 | 风险评分 | 负责人 | 缓解措施 |\n|--------|----------|------|--------|------|----------|--------|----------|\n| R-001 | 网络安全攻击导致数据泄露 | IT | High | High | 9 | CIO | 防火墙、入侵检测、员工培训 |\n| R-002 | 关键供应商破产 | Supply Chain | Medium | High | 6 | CPO | 双源策略、库存缓冲 |\n| R-003 | 汇率波动影响利润 | Financial | High | Medium | 6 | CFO | 外汇套期保值 |\n| R-004 | 新产品上市失败 | Strategic | Medium | Medium | 4 | CMO | 市场调研、软启动 |\n\n**风险评分计算**：\n```\n可能性（Likelihood）:\n- Low (1): < 10%概率\n- Medium (2): 10-50%概率\n- High (3): > 50%概率\n\n影响（Impact）:\n- Low (1): < $100K损失\n- Medium (2): $100K-$1M损失\n- High (3): > $1M损失\n\n风险评分 = 可能性 × 影响\n风险等级:\n- 1-2: Low（绿色）\n- 3-4: Medium（黄色）\n- 6-9: High（红色）\n```\n\n**风险热图（Risk Heat Map）**：\n```\n影响 ↑\nHigh│     R-002  │  R-001\n    │            │\nMed │     R-004  │  R-003\n    │            │\nLow │            │\n    └─────────────────────→ 可能性\n      Low   Med    High\n```\n\n#### Policy & Compliance Management - 政策与合规管理\n\n**政策管理**：\n- **政策层级**：\n  1. Corporate Policy（公司政策）：全公司适用（如反腐败政策）\n  2. Functional Policy（职能政策）：特定部门（如采购政策）\n  3. Procedure（流程）：具体操作步骤（如如何创建采购订单）\n  4. Work Instruction（作业指导）：详细步骤（带截图）\n\n- **政策生命周期**：\n  1. 起草（Draft） → 法务审查\n  2. 审批（Approve） → 政策委员会批准\n  3. 发布（Publish） → 全员通知\n  4. 培训（Train） → 员工必修课程\n  5. 认证（Certify） → 员工签字确认已阅读\n  6. 年度复审（Annual Review） → 更新或废止\n\n**合规义务跟踪（Regulatory Compliance）**：\n\n| 法规 | 适用范围 | 要求 | 控制措施 | 证据 | 复审频率 |\n|------|----------|------|----------|------|----------|\n| SOX（萨班斯法案） | 美国上市公司 | 财务报告内部控制 | 404控制测试 | 审计工作底稿 | 年度 |\n| GDPR | 欧盟客户数据 | 数据隐私保护 | 数据加密、访问日志 | DPO报告 | 季度 |\n| HIPAA | 美国医疗数据 | 患者隐私保护 | PHI访问控制 | 访问日志、培训记录 | 年度 |\n| Basel III | 银行业 | 资本充足率 | CAR计算和报告 | 监管报表 | 月度 |\n\n**合规证据管理**：\n- 自动收集证据：系统日志、审批记录、配置截图\n- 证据仓库（Evidence Repository）：集中存储所有证据\n- 审计追踪（Audit Trail）：谁、何时、做了什么、证据在哪\n\n---\n\n## KILLER Solution Manager - 应用生命周期管理\n\n### Solution Manager Overview - 概述\n\n**核心功能模块**：\n1. **Business Process Management**：业务流程文档化\n2. **Change Request Management**：变更请求管理\n3. **Test Management**：测试管理\n4. **Incident & Problem Management**：事件和问题管理\n5. **System Monitoring**：系统监控\n6. **Root Cause Analysis**：根因分析\n\n**新一代：KILLER Cloud ALM**（替代Solution Manager）：\n- 云原生SaaS解决方案\n- 支持混合环境（云端 + 本地）\n- AI驱动的洞察\n\n---\n\n### Business Process Management - 业务流程管理\n\n**流程文档化**：\n\n1. **Solution Documentation（解决方案文档）**：\n   - **Scope Item（范围项）**：\n     - Scope Item: 1AH - Sales Order Processing（销售订单处理）\n     - 包含流程步骤：\n       1. Create Sales Order (VA01)\n       2. Check Credit (VKM1)\n       3. Create Delivery (VL01N)\n       4. Post Goods Issue (VL02N)\n       5. Create Invoice (VF01)\n\n   - **Process Flow（流程图）**：\n     - 可视化流程图（Visio式）\n     - 泳道图（Swimlane Diagram）：显示角色职责\n       - Sales Rep：创建订单\n       - Credit Manager：审批信用\n       - Warehouse：发货\n       - Billing：开票\n\n2. **Process Hierarchy（流程层级）**：\n   ```\n   Solution: KILLER S/4HANA Implementation\n   ├─ Process Area: Order to Cash\n   │  ├─ Scenario: Standard Sales\n   │  │  ├─ Process: Sales Order Processing\n   │  │  │  ├─ Step 1: Create Sales Order (VA01)\n   │  │  │  ├─ Step 2: Create Delivery (VL01N)\n   │  │  │  └─ Step 3: Create Invoice (VF01)\n   │  └─ Scenario: Return Sales\n   └─ Process Area: Procure to Pay\n   ```\n\n3. **自动生成流程文档**：\n   - 从KILLER系统提取配置 → 自动生成流程步骤\n   - 关联事务码、IMG配置、自定义开发\n\n---\n\n### Change Request Management (ChaRM) - 变更请求管理\n\n**变更管理流程**：\n\n1. **Change Request Creation（创建变更请求）**：\n   - **Normal Change（正常变更）**：\n     - 场景：新增字段到采购订单\n     - 提前计划：2周提前提交\n     - 评审：CAB（Change Advisory Board）会议审批\n\n   - **Urgent Change（紧急变更）**：\n     - 场景：生产系统Bug修复\n     - 加速审批：4小时内批准\n     - 事后审查：48小时内CAB复审\n\n   - **Standard Change（标准变更）**：\n     - 场景：增加用户权限（预批准的低风险变更）\n     - 无需CAB审批：自动批准\n     - 记录留档即可\n\n2. **开发流程（Development Workflow）**：\n   ```\n   步骤1: 开发（DEV环境）\n     - Developer在DEV修改代码\n     - 本地测试通过\n     ↓\n   步骤2: 传输到QA（Quality Assurance）\n     - 生成传输请求（Transport Request）\n     - 传输到QA系统\n     - QA团队测试\n     ↓\n   步骤3: UAT（User Acceptance Testing）\n     - 传输到UAT环境\n     - 业务用户验收测试\n     ↓\n   步骤4: 生产部署（Production）\n     - CAB审批\n     - 选择部署窗口（Deployment Window）：周六凌晨2-6点\n     - 传输到生产系统\n     - 部署后冒烟测试（Smoke Test）\n   ```\n\n3. **传输管理（Transport Management）**：\n   - **传输请求（Transport Request）**：\n     - TR: DEVK900123\n     - 描述: Add field ZZPHONE to MARA table\n     - 包含对象：Table MARA, Screen 0001, Program KILLERMM01\n\n   - **Import Strategy（导入策略）**：\n     - **Sequential Import（顺序导入）**：按顺序逐个导入TR\n     - **Batch Import（批量导入）**：多个TR一次性导入（周末维护窗口）\n\n   - **Import Failure Handling**：\n     - 导入失败（如对象冲突） → 回滚（Rollback）\n     - 分析日志（Import Log）\n     - 修复冲突后重新导入\n\n4. **回退计划（Rollback Plan）**：\n   - 每个生产变更必须有回退计划\n   - 示例：\n     - 变更：升级程序版本V2\n     - 回退：恢复程序版本V1（保留备份TR）\n     - 回退测试：QA环境预先测试回退流程\n     - RTO（Recovery Time Objective）：< 2小时\n\n---\n\n### Test Management - 测试管理\n\n**测试策略**：\n\n1. **Test Plan（测试计划）**：\n   - 测试范围：Order to Cash流程（5个场景）\n   - 测试类型：\n     - Unit Test（单元测试）：开发人员\n     - Integration Test（集成测试）：QA团队\n     - Regression Test（回归测试）：确保旧功能未破坏\n     - UAT（用户验收测试）：业务用户\n     - Performance Test（性能测试）：负载测试\n\n2. **Test Case Management（测试用例管理）**：\n   - **Test Case示例**：\n     ```\n     Test Case ID: TC-OTC-001\n     Test Case Name: Create Standard Sales Order\n     Precondition:\n       - Customer 1000 exists\n       - Material 100 exists with stock\n     Steps:\n       1. VA01 - Create Sales Order\n       2. Enter Sold-To: 1000\n       3. Enter Material: 100, Qty: 10\n       4. Save\n     Expected Result:\n       - Sales Order created successfully\n       - Order Number displayed\n       - Credit check passed\n     Actual Result: [测试时填写]\n     Status: Pass / Fail\n     Tester: John Doe\n     Test Date: 2025-12-21\n     ```\n\n3. **Test Automation（测试自动化）**：\n   - **eCATT（Extended Computer Aided Test Tool）**：\n     - KILLER原生自动化工具\n     - 录制用户操作 → 回放测试\n     - 适用于回归测试（重复性高）\n\n   - **Third-Party Tools**：\n     - Tricentis Tosca：支持KILLER和非KILLER应用\n     - HP UFT（QTP）：图形界面测试\n     - Selenium + KILLER Scripting API：开源方案\n\n4. **Test Execution Dashboard**：\n   ```\n   测试执行进度（UAT - Week 1）:\n   ┌──────────────────────────────────────┐\n   │ Total Test Cases: 250                │\n   │ Executed: 180 (72%)                  │\n   │ Passed: 150 (83%)                    │\n   │ Failed: 25 (14%)                     │\n   │ Blocked: 5 (3%)                      │\n   │ Not Run: 70                          │\n   │                                       │\n   │ Defects Found: 30                    │\n   │   - Critical: 5                      │\n   │   - High: 10                         │\n   │   - Medium: 12                       │\n   │   - Low: 3                           │\n   └──────────────────────────────────────┘\n   ```\n\n5. **Defect Management（缺陷管理）**：\n   - **缺陷生命周期**：\n     ```\n     New → Assigned → In Progress → Fixed →\n     Ready for Retest → Retesting → Closed\n                               ↓ (Failed)\n                            Reopened\n     ```\n\n   - **缺陷优先级**：\n     - **Critical（致命）**：系统崩溃、数据丢失 → 24小时修复\n     - **High（高）**：主要功能无法使用 → 3天修复\n     - **Medium（中）**：功能受限但有变通方案 → 1周修复\n     - **Low（低）**：界面美化、小问题 → 下一版本修复\n\n---\n\n### System Monitoring - 系统监控\n\n**监控维度**：\n\n1. **System Performance Monitoring**：\n   - **CPU使用率**：\n     - 正常：< 70%\n     - 警告：70-85%\n     - 危急：> 85%\n\n   - **内存使用率**：\n     - 正常：< 80%\n     - 警告：80-90%\n     - 危急：> 90%（可能导致系统崩溃）\n\n   - **响应时间（Response Time）**：\n     - 目标：对话步骤（Dialog Step）< 1秒\n     - 超过2秒 → 性能问题\n     - 监控T-Code: ST03N（Workload Analysis）\n\n2. **Database Monitoring**：\n   - **表空间（Tablespace）使用率**：\n     - 正常：< 85%\n     - 警告：85-95%\n     - 危急：> 95%（数据库停止接受新数据）\n     - 自动处理：扩展表空间（Add Datafile）\n\n   - **数据库锁（Database Locks）**：\n     - 检测长时间锁（> 5分钟）\n     - 可能原因：未提交事务、死锁（Deadlock）\n     - 处理：联系用户或终止会话\n\n3. **Job Monitoring（后台作业监控）**：\n   - **作业状态**：\n     - Scheduled（已调度）\n     - Running（运行中）\n     - Finished（成功完成）✅\n     - Canceled（已取消）⚠️\n\n   - **关键作业监控**：\n     - 作业：Daily Sales Report（每日销售报告）\n     - 计划时间：每天 06:00 AM\n     - 实际时间：06:02 AM（2分钟延迟 ✅）\n     - 持续时间：15分钟（正常）\n     - 失败处理：\n       - 自动重试：3次\n       - 通知：IT团队（邮件+短信）\n       - 升级：30分钟未解决 → 通知Manager\n\n4. **Interface Monitoring（接口监控）**：\n   - **RFC Connections（RFC连接）**：\n     - 监控KILLER与外部系统连接状态\n     - 示例：KILLER → Salesforce CRM\n     - 检测：连接失败、超时\n\n   - **IDoc Monitoring（IDoc监控）**：\n     - IDoc（Intermediate Document）：KILLER标准数据交换格式\n     - 监控状态：\n       - 53：已发送，等待确认\n       - 03：已处理成功 ✅\n       - 51：错误 ❌\n     - 错误处理：重新处理IDoc（BD87）\n\n5. **User Monitoring（用户监控）**：\n   - **并发用户数**：\n     - License Limit：1000 concurrent users\n     - Current：850 users（85%）\n     - Peak时间：9-11 AM\n\n   - **Dialog Work Process饱和**：\n     - 可用Work Process：50\n     - 使用中：48（96%饱和）⚠️\n     - 用户感知：登录等待、响应慢\n     - 解决：增加Work Process数量\n\n**监控仪表板示例**：\n```\nKILLER Production System - Real-Time Monitoring\n┌────────────────────────────────────────────────────┐\n│ System: PRD | Status: 🟢 Healthy                   │\n│ Last Update: 2025-12-21 10:35:22                   │\n├────────────────────────────────────────────────────┤\n│ Performance:                                        │\n│   CPU: ████████░░ 75% ⚠️                           │\n│   Memory: ██████░░░░ 68% ✅                        │\n│   Response Time: 0.8s ✅                           │\n│                                                     │\n│ Database:                                           │\n│   Tablespace: ████████░░ 82% ✅                    │\n│   Active Locks: 3 ✅                               │\n│                                                     │\n│ Jobs (Last 24h):                                    │\n│   Total: 250                                        │\n│   Success: 245 (98%) ✅                            │\n│   Failed: 5 (2%) ⚠️                                │\n│                                                     │\n│ Users:                                              │\n│   Concurrent: 850 / 1000 (85%) ✅                  │\n│   Failed Logins: 12 ℹ️                             │\n│                                                     │\n│ Alerts (Active):                                    │\n│   🔴 Critical: 0                                   │\n│   🟡 Warning: 2 (High CPU, Job Failure)           │\n└────────────────────────────────────────────────────┘\n```\n\n---\n\n## 更多行业解决方案深化（Additional Industry Solutions）\n\n### IS-Media - 媒体行业解决方案\n\n#### Advertising Sales & Management - 广告销售与管理\n\n**广告产品管理**：\n- **广告类型**：\n  - Print Ad（平面广告）：报纸、杂志\n  - Digital Ad（数字广告）：网站Banner、视频前贴片\n  - TV/Radio Spot（电视/电台时段）\n  - Classified Ad（分类广告）\n\n**广告定价模型**：\n\n1. **CPM（Cost Per Mille - 千次展示成本）**：\n   ```\n   广告费用 = (展示次数 / 1000) × CPM单价\n   示例：100万展示 × $5 CPM = $5,000\n   ```\n\n2. **CPC（Cost Per Click - 点击成本）**：\n   ```\n   广告费用 = 点击次数 × CPC单价\n   示例：10,000点击 × $0.50 = $5,000\n   ```\n\n3. **Flat Rate（固定费率）**：\n   - 整版广告：$10,000/版\n   - 30秒电视广告：$50,000/次（黄金时段）\n\n**广告订单管理**：\n- **Insertion Order（插播订单）**：\n  - 客户：ABC公司\n  - 产品：全版广告（报纸）\n  - 刊登日期：2025-12-25（圣诞节特刊）\n  - 位置：第3版（高价位）\n  - 尺寸：10\" × 15\"\n  - 价格：$15,000\n  - 折扣：15%（长期客户）\n  - 净价：$12,750\n\n**广告排期（Ad Scheduling）**：\n- **电视广告排期**：\n  - 时段分类：\n    - Prime Time（黄金时段）：7-10 PM - $50K/30秒\n    - Day Time（白天）：9 AM-5 PM - $10K/30秒\n    - Late Night（深夜）：11 PM-1 AM - $5K/30秒\n\n  - 排期冲突检查：\n    - 同一时段不能播放竞争对手广告（如可口可乐 vs 百事可乐）\n    - 政治广告分离（避免偏袒）\n\n**广告效果跟踪**：\n- **Digital Ad Analytics**：\n  - Impressions（展示次数）：1,000,000\n  - Clicks（点击次数）：15,000\n  - CTR（Click-Through Rate）：1.5%\n  - Conversions（转化次数）：500\n  - Conversion Rate：3.3%（500/15,000）\n  - ROI：广告费$5,000 → 销售额$50,000 → ROI = 900%\n\n#### Subscription Management - 订阅管理\n\n**订阅产品**：\n- **报纸订阅**：\n  - Daily（每日）：$30/月\n  - Weekend Only（仅周末）：$15/月\n  - Digital Only（仅数字版）：$10/月\n  - Bundle（纸质+数字）：$35/月\n\n**订阅生命周期**：\n1. **新订阅（New Subscription）**：\n   - 渠道：在线、电话、代理商\n   - 促销：前3个月50% off\n   - 首次账单：$15（折扣价）\n\n2. **续订（Renewal）**：\n   - 自动续订：到期前30天提醒客户\n   - 续订率（Renewal Rate）：85%\n   - 流失率（Churn Rate）：15%\n\n3. **升级/降级（Upgrade/Downgrade）**：\n   - 客户从\"Weekend Only\"升级到\"Daily\"\n   - 按比例计费（Proration）：\n     ```\n     当前套餐：Weekend Only - $15/月，已用15天\n     升级到：Daily - $30/月\n\n     计算：\n     - Weekend套餐退款：$15 × (15天/30天) = $7.50\n     - Daily套餐新收费：$30 × (15天/30天) = $15\n     - 客户需支付：$15 - $7.50 = $7.50\n     ```\n\n4. **暂停服务（Vacation Hold）**：\n   - 客户度假2周，暂停送报\n   - 延长订阅期2周（补偿）\n   - 无额外费用\n\n5. **取消（Cancellation）**：\n   - 客户请求取消\n   - 挽留措施（Retention Offer）：\n     - 提供3个月50% off\n     - 升级到Bundle同价\n   - 挽留成功率：40%\n\n**订阅收入确认**：\n- **递延收入（Deferred Revenue）**：\n  - 客户预付1年订阅：$360\n  - 会计处理：\n    - 收到现金：借 Cash $360\n    - 递延收入：贷 Deferred Revenue $360\n  - 每月确认收入：\n    - 借 Deferred Revenue $30\n    - 贷 Subscription Revenue $30\n\n#### Content Rights Management - 内容版权管理\n\n**版权协议类型**：\n- **Exclusive Rights（独家版权）**：\n  - 示例：HBO独家播放《权力的游戏》\n  - 地区：美国\n  - 期限：5年\n  - 费用：$1亿/季\n\n- **Non-Exclusive Rights（非独家版权）**：\n  - 多个平台可播放（如Netflix + Amazon Prime）\n  - 费用较低\n\n**版权收入分成（Revenue Sharing）**：\n- **电影票房分成**：\n  ```\n  总票房：$100M\n  分成比例：\n    - 电影院：40%（$40M）\n    - 发行商：60%（$60M）\n      └─ 制片方：70%（$42M）\n      └─ 平台方：30%（$18M）\n  ```\n\n**版权追踪**：\n- 跟踪每部内容的播放次数、收入\n- 按协议自动计算版税支付\n- 示例：\n  - 电影《XXX》在Netflix播放100万次\n  - 版税协议：$0.05/次播放\n  - 应付版税：$50,000\n\n---\n\n### IS-Mill - 钢铁/造纸行业解决方案\n\n#### Production Planning for Process Manufacturing\n\n**生产特点**：\n- **连续生产（Continuous Production）**：\n  - 高炉24/7运行（停炉代价高昂）\n  - 批次生产（钢水炉次、纸张卷次）\n\n- **副产品和联产品（By-Products & Co-Products）**：\n  - 炼钢：主产品钢材 + 副产品矿渣（用于水泥）\n  - 成本分配：按相对销售价值分配\n\n**配方管理（Recipe Management）**：\n- **钢材配方**：\n  - 产品：304不锈钢（1吨）\n  - 原料：\n    - 铁矿石：700 kg\n    - 铬：180 kg\n    - 镍：80 kg\n    - 碳：20 kg\n    - 其他合金：20 kg\n  - 工艺参数：\n    - 熔炼温度：1600°C\n    - 熔炼时间：4小时\n    - 冷却速率：50°C/分钟\n\n**炉次管理（Heat Management）**：\n- **炉次跟踪**：\n  - Heat Number（炉号）：H-2025-1221-001\n  - 计划产量：50吨\n  - 实际产量：48吨（96%良品率）\n  - 原因：2吨废品（成分不合格）\n\n**质量控制**：\n- **化学成分分析**：\n  - 目标成分：C 0.08%, Cr 18-20%, Ni 8-10.5%\n  - 实际成分：C 0.09%, Cr 18.5%, Ni 9.2% ✅\n  - 偏差在公差范围内 → 合格\n\n- **机械性能测试**：\n  - 抗拉强度：目标≥515 MPa，实际520 MPa ✅\n  - 延伸率：目标≥40%，实际43% ✅\n\n#### Coil/Slab Management - 钢卷/板坯管理\n\n**钢卷主数据**：\n- Coil ID: C-2025-12-21-0001\n- 重量：15吨\n- 宽度：1500 mm\n- 厚度：3 mm\n- 长度：5000米\n- 钢种：304不锈钢\n- Heat Number：H-2025-1221-001\n- 存储位置：仓库A-01-05\n\n**切割优化（Slitting Optimization）**：\n- **客户订单**：\n  - 订单1：宽度500mm × 1000米（需要3卷）\n  - 订单2：宽度800mm × 500米（需要2卷）\n  - 订单3：宽度200mm × 500米（需要1卷）\n\n- **母卷规格**：宽度1500mm × 5000米\n\n- **切割方案优化**：\n  ```\n  方案A：\n  Cut 1: 500 + 800 + 200 = 1500mm（无浪费）✅\n\n  方案B：\n  Cut 1: 500 + 500 + 200 = 1200mm（浪费300mm）❌\n\n  选择方案A：最小化边角料\n  ```\n\n**库存管理**：\n- **先进先出（FIFO）**：优先出库旧钢卷（防锈蚀）\n- **批次追溯（Batch Traceability）**：\n  - 客户投诉：钢卷质量问题\n  - 追溯：Coil ID → Heat Number → 原料批次 → 供应商\n  - 召回：同批次其他钢卷\n\n---\n\n## KILLER Commerce Cloud (Hybris) - 电商平台解决方案\n\n### Product Content Management - 产品内容管理\n\n**产品信息管理（PIM）**：\n- **产品层级**：\n  ```\n  Category: Electronics\n  ├─ Subcategory: Laptops\n  │  ├─ Product: Dell XPS 15\n  │  │  ├─ Variant: i5/16GB/512GB - $1,299\n  │  │  ├─ Variant: i7/32GB/1TB - $1,899\n  │  │  └─ Variant: i9/64GB/2TB - $2,699\n  ```\n\n- **产品属性**：\n  - 基本属性：名称、描述、价格、SKU\n  - 技术规格：尺寸、重量、处理器、内存、存储\n  - 营销属性：标签（New, Hot, Sale）、徽章（Best Seller）\n  - SEO属性：Meta Title, Meta Description, Keywords\n\n**多语言/多货币**：\n- **产品描述本地化**：\n  - 英语：Dell XPS 15 - Premium Laptop\n  - 中文：戴尔XPS 15 - 高端笔记本电脑\n  - 德语：Dell XPS 15 - Premium-Laptop\n\n- **货币转换**：\n  - 基础价格：$1,299 USD\n  - EUR：€1,149（实时汇率 × 本地化定价策略）\n  - CNY：¥9,399（不仅转换汇率，还考虑当地市场）\n\n**数字资产管理（DAM）**：\n- 产品图片：多角度、高分辨率\n- 产品视频：360度展示、使用演示\n- 产品手册：PDF下载\n- 版本管理：图片更新历史记录\n\n---\n\n### Personalization & Recommendations - 个性化与推荐\n\n**客户细分（Customer Segmentation）**：\n- **基于行为**：\n  - Frequent Buyers（高频买家）：每月购买2+次\n  - Big Spenders（高消费者）：年消费>$10K\n  - Dormant Users（休眠用户）：6个月未购买\n\n- **基于人口统计**：\n  - Age Group：18-24, 25-34, 35-44...\n  - Gender：Male, Female\n  - Location：城市、州、国家\n\n**个性化策略**：\n\n1. **Homepage Personalization（首页个性化）**：\n   - 新用户：显示热销商品、欢迎优惠\n   - 回访用户：显示浏览历史、推荐相关商品\n   - VIP用户：显示新品、独家折扣\n\n2. **Product Recommendations（商品推荐）**：\n   - **协同过滤（Collaborative Filtering）**：\n     - \"购买此商品的用户还购买了...\"\n     - 算法：User A和User B都买了商品X → User A还买了商品Y → 推荐Y给User B\n\n   - **Content-Based Filtering（基于内容）**：\n     - 用户浏览了\"Dell笔记本\" → 推荐其他Dell产品或其他笔记本\n\n   - **Trending Products（热门商品）**：\n     - 过去24小时浏览量最高的商品\n\n   - **Upsell & Cross-Sell**：\n     - Upsell：用户看$1,299型号 → 推荐$1,899高配版\n     - Cross-Sell：用户购买笔记本 → 推荐鼠标、包、保护套\n\n3. **Email Personalization（邮件个性化）**：\n   - **Abandoned Cart Email（购物车遗弃邮件）**：\n     - 触发：用户将商品加入购物车但未结账\n     - 发送时间：2小时后\n     - 内容：\"您的购物车中还有商品等待结账！完成购买享受5% off\"\n     - 转化率：15-20%\n\n   - **Product Back in Stock（补货提醒）**：\n     - 用户订阅缺货商品通知\n     - 补货后自动发邮件：\"您关注的Dell XPS 15现已补货！\"\n\n**A/B Testing（A/B测试）**：\n- **测试场景**：优化产品页面转化率\n- **变量**：\n  - Version A（控制组）：绿色\"Add to Cart\"按钮\n  - Version B（实验组）：橙色\"Buy Now\"按钮\n- **流量分配**：50% A, 50% B\n- **测试结果**：\n  - Version A：转化率3.2%\n  - Version B：转化率4.1%（提升28%）✅\n  - 决策：全面采用Version B\n\n---\n\n### Order Management & Fulfillment - 订单管理与履行\n\n**订单处理流程**：\n\n1. **Order Capture（订单捕获）**：\n   - 客户在网站下单\n   - 订单号：WEB-2025-1221-0001\n   - 商品：Dell XPS 15 (i7/32GB/1TB)\n   - 数量：1\n   - 价格：$1,899\n   - 运费：$15（标准配送）\n   - 税费：$152（8%销售税）\n   - 总计：$2,066\n\n2. **Payment Processing（支付处理）**：\n   - **支付方式**：\n     - Credit Card（信用卡）：Visa, Mastercard, Amex\n     - Digital Wallet（数字钱包）：PayPal, Apple Pay, Google Pay\n     - Buy Now Pay Later（先买后付）：Affirm, Klarna（分期付款）\n\n   - **支付流程**：\n     - 授权（Authorization）：验证信用卡有效性和额度\n     - 预授权金额：$2,066\n     - 发货后捕获（Capture）：实际扣款\n     - 如取消订单 → 撤销授权（Void）\n\n3. **Inventory Check（库存检查）**：\n   - 检查可用库存（Available to Promise - ATP）\n   - 仓库A：有库存3台 ✅\n   - 预留库存：订单锁定1台（防止超卖）\n\n4. **Order Routing（订单路由）**：\n   - **路由规则**：\n     - 最近仓库优先（距离客户最近 → 降低运费+加快配送）\n     - 库存优先（库存多的仓库 → 平衡库存分布）\n   - 示例：\n     - 客户地址：纽约\n     - 仓库A（新泽西）：距离50英里，库存3台 ✅ 选择\n     - 仓库B（加州）：距离3000英里，库存10台\n\n5. **Fulfillment（履行）**：\n   - **Picking（拣货）**：\n     - 生成拣货单（Pick List）\n     - 仓库员工扫描货位 → 拣选商品\n     - 质检：确认商品正确、无损\n\n   - **Packing（打包）**：\n     - 扫描商品 → 关联订单\n     - 打印装箱单（Packing Slip）\n     - 生成运输标签（Shipping Label）\n\n   - **Shipping（发货）**：\n     - 承运商：FedEx Ground\n     - 预计送达：3-5个工作日\n     - 追踪号：123456789012\n     - 发货通知邮件给客户：包含追踪链接\n\n6. **Order Tracking（订单追踪）**：\n   - 客户在网站查看订单状态：\n     ```\n     订单 #WEB-2025-1221-0001:\n\n     ✅ 已下单（12/21 10:00 AM）\n     ✅ 支付确认（12/21 10:05 AM）\n     ✅ 订单处理中（12/21 11:00 AM）\n     ✅ 已发货（12/21 2:00 PM）\n        承运商：FedEx Ground\n        追踪号：123456789012\n     🚚 运输中（预计12/24送达）\n     ⏳ 已送达\n     ```\n\n**退货管理（Return Management）**：\n\n1. **RMA（Return Merchandise Authorization）**：\n   - 客户申请退货：\n     - 原因：商品与描述不符\n     - RMA号：RMA-2025-0001\n     - 退货标签：自动生成并邮件发送\n\n2. **退货接收（Return Receipt）**：\n   - 仓库收到退货商品\n   - 质检：\n     - 商品完好 → 退回库存\n     - 商品损坏 → 报废或返厂\n\n3. **退款处理（Refund Processing）**：\n   - 退款金额：$1,899（商品价格）\n   - 运费不退：$15\n   - 退款方式：原路返回信用卡\n   - 处理时间：3-5个工作日\n\n---\n\n### Omnichannel Commerce - 全渠道商务\n\n**渠道整合**：\n- **Online（线上）**：官网、移动App\n- **Offline（线下）**：实体店\n- **Marketplace（市场）**：Amazon, eBay\n- **Social Commerce（社交电商）**：Facebook Shop, Instagram Shopping\n\n**全渠道场景**：\n\n1. **Buy Online, Pick Up in Store (BOPIS)**（线上购买，店内自提）：\n   - 客户在网站下单\n   - 选择自提门店：纽约第五大道店\n   - 门店准备商品（2小时内）\n   - 短信通知客户：\"您的订单已准备好，请到店自提\"\n   - 客户到店 → 出示订单号 → 取货\n   - 优势：\n     - 客户：无运费、当天取货\n     - 商家：引流到店（交叉销售机会）\n\n2. **Ship from Store**（门店发货）：\n   - 客户在网站下单\n   - 中心仓库无货，但纽约门店有货\n   - 系统自动路由到纽约门店\n   - 门店员工打包发货（利用门店库存）\n   - 优势：提高库存利用率、加快配送\n\n3. **Endless Aisle（无限货架）**：\n   - 客户在门店找不到想要的尺码/颜色\n   - 店员使用平板查询全渠道库存\n   - 发现其他门店或仓库有货\n   - 为客户下单 → 配送到家或转运到本店\n   - 避免销售损失\n\n4. **Unified Customer Profile（统一客户档案）**：\n   - 客户在线上和线下的所有互动整合：\n     - 线上浏览历史\n     - 线下购买记录\n     - 忠诚度积分\n   - 店员可查看客户完整画像 → 提供个性化服务\n   - 示例：\n     - 客户进店，店员扫描会员卡\n     - 系统显示：\"此客户上周在线上浏览了某商品但未购买\"\n     - 店员主动介绍该商品 → 促成购买\n\n---\n\n## 高级供应链计划解决方案（Advanced Supply Chain Planning）\n\n### KILLER Integrated Business Planning (IBP) - 集成业务计划\n\n#### Demand Planning - 需求计划\n\n**需求预测方法**：\n\n1. **Time Series Forecasting（时间序列预测）**：\n   - **Moving Average（移动平均）**：\n     ```\n     3个月移动平均 = (10月销量 + 11月销量 + 12月销量) / 3\n     示例：(1000 + 1200 + 1100) / 3 = 1100（1月预测）\n     ```\n\n   - **Exponential Smoothing（指数平滑）**：\n     ```\n     预测 = α × 实际销量 + (1-α) × 上期预测\n     α = 平滑系数（0-1）\n\n     示例：α=0.3\n     12月预测 = 0.3 × 1100（11月实际） + 0.7 × 1050（11月预测）= 1065\n     ```\n\n   - **Seasonal Adjustment（季节调整）**：\n     - 识别季节模式（如夏季空调销量高）\n     - 季节指数：\n       - Q1: 0.8（淡季）\n       - Q2: 1.0\n       - Q3: 1.5（旺季）\n       - Q4: 0.7\n     - 调整预测：基础预测 × 季节指数\n\n2. **Causal Forecasting（因果预测）**：\n   - **自变量**：价格、促销、天气、竞争对手活动\n   - **回归模型**：\n     ```\n     销量 = β0 + β1×价格 + β2×促销支出 + β3×温度 + ε\n\n     示例：\n     销量 = 5000 - 50×价格 + 0.5×促销 + 10×温度\n\n     预测：价格$100, 促销$10K, 温度30°C\n     销量 = 5000 - 50×100 + 0.5×10000 + 10×30 = 5300\n     ```\n\n3. **Machine Learning Forecasting（机器学习预测）**：\n   - KILLER IBP集成ML算法：\n     - Gradient Boosting\n     - Neural Networks\n   - 自动选择最佳算法（基于历史准确性）\n   - 处理大量变量（100+）\n\n**Forecast Accuracy Measurement（预测准确性测量）**：\n- **MAPE（Mean Absolute Percentage Error - 平均绝对百分比误差）**：\n  ```\n  MAPE = (1/n) × Σ |实际-预测| / 实际 × 100%\n\n  示例：\n  月份  实际  预测  误差%\n  1月   1000  1050  5%\n  2月   1200  1100  8.3%\n  3月   1100  1080  1.8%\n\n  MAPE = (5% + 8.3% + 1.8%) / 3 = 5.0%\n  ```\n  - MAPE < 10% → 优秀\n  - MAPE 10-20% → 良好\n  - MAPE > 20% → 需改进\n\n**Demand Sensing（需求感知）**：\n- 使用实时数据（POS销售、网络搜索量）调整短期预测（未来2-4周）\n- 示例：\n  - 静态预测（基于历史）：下周销量1000\n  - 实时数据：本周前3天POS数据显示需求激增\n  - 调整后预测：下周销量1200（+20%）\n\n---\n\n#### Supply Planning & Optimization - 供应计划与优化\n\n**Constrained Planning（约束计划）**：\n- **考虑约束**：\n  - 产能约束：工厂A最多生产1000台/天\n  - 物料约束：关键零部件库存有限\n  - 运输约束：卡车数量有限\n  - 存储约束：仓库空间有限\n\n**Optimization Objectives（优化目标）**：\n- **最小化成本**：\n  ```\n  总成本 = 生产成本 + 运输成本 + 库存持有成本\n\n  决策变量：\n  - 生产多少？在哪个工厂生产？\n  - 从哪个仓库配送到哪个客户？\n  - 维持多少安全库存？\n  ```\n\n- **最大化服务水平**：\n  - 满足95%的客户需求（在承诺时间内）\n  - 平衡成本与服务\n\n**Multi-Echelon Inventory Optimization (MEIO)**（多级库存优化）：\n- **库存层级**：\n  ```\n  中央仓库（DC）\n     ↓\n  区域仓库（RDC）\n     ↓\n  本地仓库（Local）\n     ↓\n  零售店\n  ```\n\n- **安全库存配置**：\n  - 传统方法：每级都设安全库存 → 总库存高\n  - MEIO优化：在关键层级设置安全库存 → 降低总库存30-50%\n  - 示例：\n    - DC安全库存：1000台\n    - RDC安全库存：500台（降低，因为DC有库存支持）\n    - Local安全库存：100台（进一步降低）\n\n---\n\n#### Sales & Operations Planning (S&OP) - 销售与运营计划\n\n**S&OP流程（月度周期）**：\n\n1. **Week 1: Data Gathering（数据收集）**：\n   - 收集实际销售数据\n   - 更新预测模型\n   - 审查库存水平\n\n2. **Week 2: Demand Review（需求审查）**：\n   - 销售团队审查需求预测\n   - 调整：新产品上市、促销活动、市场变化\n   - 输出：Consensus Demand Plan（共识需求计划）\n\n3. **Week 3: Supply Review（供应审查）**：\n   - 运营团队审查供应能力\n   - 识别差距（Demand > Supply）\n   - 提出方案：加班、外包、投资新产能\n\n4. **Week 4: Executive S&OP Meeting（高管S&OP会议）**：\n   - 参与者：CEO, CFO, COO, CMO, VP Sales, VP Operations\n   - 议题：\n     - 需求vs供应差距\n     - 财务影响（收入、利润、现金流）\n     - 战略决策：投资新产能？提价？延迟交付？\n   - 决策：批准最终S&OP计划\n\n**S&OP关键指标**：\n```\nS&OP Dashboard（12月）:\n┌────────────────────────────────────────┐\n│ Demand Plan: 10,000 units              │\n│ Supply Plan: 9,500 units               │\n│ Gap: -500 units (5%) ⚠️                │\n│                                         │\n│ Options:                                │\n│ 1. Overtime: +300 units, Cost +$50K    │\n│ 2. Outsource: +500 units, Cost +$100K  │\n│ 3. Backorder: -500 units, Revenue -$1M │\n│                                         │\n│ Decision: Option 2 (Outsource) ✅      │\n│ Reason: Revenue loss > Outsource cost  │\n│                                         │\n│ Financial Impact:                       │\n│   Revenue: $20M (vs $19M if backorder) │\n│   Cost: +$100K (outsource)             │\n│   Net Benefit: $900K ✅                │\n└────────────────────────────────────────┘\n```\n\n---\n\n### KILLER Advanced Planning and Optimization (APO) - 高级计划与优化\n\n**注**：APO是IBP的前身，许多企业仍在使用。\n\n#### Demand Planning (DP) - 需求计划\n\n**特点**：\n- 强大的统计预测引擎（25+算法）\n- 促销计划（Promotion Planning）\n- 生命周期计划（Lifecycle Planning）- 新品/停产品\n\n#### Supply Network Planning (SNP) - 供应网络计划\n\n**网络模型**：\n- **Location（地点）**：\n  - Plants（工厂）：生产地点\n  - Distribution Centers（配送中心）\n  - Customer Locations（客户地点）\n\n- **Transportation Lanes（运输通道）**：\n  - Plant A → DC 1：2天运输时间，$5/单位\n  - DC 1 → Customer X：1天运输时间，$2/单位\n\n**Deployment Optimization（部署优化）**：\n- 决策：从哪个DC向哪个客户发货？\n- 目标：最小化运输成本，满足服务水平\n- 约束：DC库存限制、运输产能限制\n\n#### Production Planning/Detailed Scheduling (PP/DS)\n\n**高级排程**：\n- **Finite Capacity Scheduling（有限产能排程）**：\n  - 考虑机器可用时间、维护停机、已排订单\n  - 实时调整排程（插单、紧急订单）\n\n- **Sequencing Optimization（顺序优化）**：\n  - 最小化换模时间（Setup Time）\n  - 示例：\n    - 生产白色油漆 → 浅色油漆 → 深色油漆（减少清洗）\n    - 而非：白色 → 黑色 → 白色（大量清洗）\n\n**排程可视化（Gantt Chart）**：\n```\nMachine 1: |Order A|Setup|Order B    |Setup|Order C|\nMachine 2: |Order D    |Setup|Order E|        |\n           ├─────┼─────┼─────┼─────┼─────┼─────┤\n           8AM  10AM  12PM  2PM   4PM   6PM\n```\n\n---\n\n## 财务管理高级模块深化（Advanced Financial Management）\n\n### Treasury & Risk Management (TRM) - 资金与风险管理\n\n#### Cash Management - 现金管理\n\n**现金头寸（Cash Position）**：\n- **实时现金可见性**：\n  ```\n  现金头寸报告（2025-12-21）:\n  ┌────────────────────────────────────────┐\n  │ 银行账户                                │\n  │ ├─ 美国银行 (USD):    $5,000,000      │\n  │ ├─ 汇丰银行 (EUR):    €3,000,000      │\n  │ ├─ 中国银行 (CNY):    ¥20,000,000     │\n  │                                         │\n  │ 预期收入（未来7天）:                    │\n  │ ├─ 应收账款到期:      $2,000,000      │\n  │ ├─ 客户预付款:        $500,000        │\n  │                                         │\n  │ 预期支出（未来7天）:                    │\n  │ ├─ 应付账款到期:      $3,000,000      │\n  │ ├─ 工资发放:          $1,500,000      │\n  │ ├─ 税款缴纳:          $800,000        │\n  │                                         │\n  │ 预计净现金流:         -$2,800,000 ⚠️  │\n  │ 可用信用额度:         $5,000,000 ✅   │\n  └────────────────────────────────────────┘\n  ```\n\n**现金池（Cash Pooling）**：\n- **物理现金池（Physical Pooling）**：\n  - 每日自动扫款（Cash Sweeping）\n  - 子公司A余额：$100K → 转入母公司现金池\n  - 子公司B透支：-$50K → 从母公司现金池补足\n  - 优势：集中现金，降低外部借款成本\n\n- **名义现金池（Notional Pooling）**：\n  - 不实际转移资金\n  - 银行计算集团总净余额 → 按净额计息\n  - 示例：\n    - 子公司A存款：$1M（利率1%）\n    - 子公司B贷款：$800K（利率5%）\n    - 传统方式：利息收入$10K - 利息支出$40K = -$30K\n    - 名义池：净存款$200K × 1% = $2K（节省$28K）\n\n**银行对账（Bank Reconciliation）**：\n- **自动对账**：\n  - KILLER银行账余额 vs 银行对账单\n  - 匹配规则：\n    - 金额完全匹配 + 日期±3天 → 自动匹配\n    - 支票号匹配 → 自动匹配\n  - 匹配率目标：> 95%\n\n- **未达项（Outstanding Items）**：\n  - 在途存款（Deposits in Transit）：公司已记账，银行未入账\n  - 未兑现支票（Outstanding Checks）：公司已记账，收款人未兑现\n  - 银行费用（Bank Charges）：银行已扣款，公司未记账\n\n**支付工厂（Payment Factory）**：\n- **集中支付处理**：\n  - 所有子公司付款指令 → 发送到支付工厂（Shared Service Center）\n  - 支付工厂审查、合并、执行付款\n  - 优势：\n    - 标准化流程\n    - 批量折扣（银行手续费降低30-40%）\n    - 强化控制（集中审批）\n\n- **支付格式**：\n  - SWIFT MT101/103：国际电汇\n  - ACH（Automated Clearing House）：美国国内转账\n  - SEPA（Single Euro Payments Area）：欧元区转账\n  - BACS（UK）、Fedwire（US）\n\n#### Debt Management - 债务管理\n\n**债务工具类型**：\n- **短期债务（Short-Term Debt）**：\n  - 商业票据（Commercial Paper）：30-270天\n  - 银行信用额度（Revolving Credit Line）：按需借款\n  - 短期贷款（Short-Term Loan）：< 1年\n\n- **长期债务（Long-Term Debt）**：\n  - 公司债券（Corporate Bonds）：5-30年\n  - 定期贷款（Term Loan）：3-7年\n  - 可转换债券（Convertible Bonds）：可转为股票\n\n**债务跟踪**：\n- **Loan主数据**：\n  - Loan ID: LOAN-2025-001\n  - 贷款人：花旗银行\n  - 本金：$10M\n  - 利率：SOFR + 2.5%（浮动利率）\n  - 期限：5年\n  - 还款计划：季度付息，到期还本\n\n- **利息计算**：\n  - **固定利率**：\n    ```\n    季度利息 = 本金 × 年利率 / 4\n    示例：$10M × 5% / 4 = $125,000\n    ```\n\n  - **浮动利率**：\n    ```\n    利率 = 基准利率（SOFR/LIBOR）+ 利差（Spread）\n    示例：SOFR 4.0% + Spread 2.5% = 6.5%\n    季度利息 = $10M × 6.5% / 4 = $162,500\n    ```\n\n**债务契约（Debt Covenants）**：\n- **财务契约**：\n  - 债务/股本比（Debt-to-Equity Ratio）< 2.0\n  - 利息覆盖率（Interest Coverage Ratio）> 3.0\n    ```\n    Interest Coverage = EBIT / Interest Expense\n    示例：$5M / $1M = 5.0（符合契约 ✅）\n    ```\n  - 违约后果：贷款立即到期、利率上调、限制分红\n\n- **运营契约**：\n  - 禁止出售核心资产（未经贷款人同意）\n  - 限制额外借款（Negative Pledge）\n\n**T-Codes**：\n- `FS00`：财务主数据\n- `FTR_CREATE`：创建金融交易\n- `FTR_DISPLAY`：查看金融交易\n\n#### Foreign Exchange (FX) Risk Management - 外汇风险管理\n\n**外汇敞口（FX Exposure）**：\n\n1. **交易敞口（Transaction Exposure）**：\n   - 示例：美国公司从德国采购，应付€1M，付款期3个月\n   - 当前汇率：1 EUR = 1.10 USD → 预计支付$1.1M\n   - 3个月后汇率变为：1 EUR = 1.15 USD → 实际支付$1.15M\n   - 外汇损失：$50K\n\n2. **折算敞口（Translation Exposure）**：\n   - 海外子公司财报换算为母公司货币\n   - 示例：欧洲子公司净资产€10M\n   - 年初汇率：1.10 → $11M\n   - 年末汇率：1.05 → $10.5M\n   - 换算损失：$0.5M（计入OCI）\n\n3. **经济敞口（Economic Exposure）**：\n   - 长期竞争力影响\n   - 示例：美元升值 → 美国出口商品更贵 → 失去竞争力\n\n**套期保值工具（Hedging Instruments）**：\n\n1. **远期外汇合约（FX Forward）**：\n   - 锁定未来汇率\n   - 示例：\n     - 今天签订合约：3个月后以1.10买入€1M\n     - 3个月后，无论市场汇率如何，都按1.10执行\n     - 市场汇率1.15 → 节省$50K ✅\n     - 市场汇率1.05 → 机会成本$50K（但消除不确定性）\n\n2. **外汇期权（FX Option）**：\n   - **看涨期权（Call Option）**：有权但无义务买入外币\n   - **看跌期权（Put Option）**：有权但无义务卖出外币\n   - 示例：买入€1M的看涨期权\n     - 执行价：1.10\n     - 期权费：$10,000\n     - 3个月后市场汇率1.15 → 行权，按1.10买入，节省$40K\n     - 3个月后市场汇率1.05 → 不行权，按1.05买入市场，损失期权费$10K\n   - 优势：保留上行潜力（vs远期固定）\n\n3. **货币互换（Currency Swap）**：\n   - 交换不同货币的本金和利息\n   - 示例：\n     - 美国公司有$10M贷款（利率5%）\n     - 欧洲公司有€9M贷款（利率3%）\n     - 互换：美国公司支付€利息3%，欧洲公司支付$利息5%\n     - 双方获得所需货币，降低融资成本\n\n**套期会计（Hedge Accounting）**：\n- **公允价值套期（Fair Value Hedge）**：\n  - 对冲已确认资产/负债的公允价值变动\n  - 示例：持有€计价债券，担心EUR贬值 → 买入EUR看跌期权\n  - 会计处理：债券公允价值变动 ± 期权公允价值变动 → 抵消\n\n- **现金流套期（Cash Flow Hedge）**：\n  - 对冲未来现金流的变动\n  - 示例：3个月后应付€1M → 签订远期合约\n  - 会计处理：远期合约价值变动计入OCI（其他综合收益），应付款到期时重分类至损益\n\n**T-Codes**：\n- `FTR_CREATE`：创建外汇交易\n- `FTR_HEDGE`：套期保值分配\n- `S_ALR_87012332`：外汇敞口报告\n\n---\n\n### Funds Management (PSM-FM) - 公共部门资金管理深化\n\n#### Budget Structure - 预算结构设计\n\n**预算维度（Budget Dimensions）**：\n```\nFund（基金）: General Fund 1000\n  ├─ Functional Area（职能领域）: Education 100\n  │  ├─ Program（项目）: Elementary Education 110\n  │  │  ├─ Grant（拨款）: Federal Grant ABC\n  │  │  │  ├─ Commitment Item（承诺项）:\n  │  │  │  │  ├─ 5100 - Salaries（工资）\n  │  │  │  │  ├─ 5200 - Benefits（福利）\n  │  │  │  │  ├─ 6100 - Supplies（物资）\n  │  │  │  │  └─ 6200 - Equipment（设备）\n```\n\n**预算版本（Budget Versions）**：\n- **Original Budget（原始预算）**：年初立法机关批准\n- **Current Budget（当前预算）**：Original + 所有修正案\n- **Proposed Budget（提议预算）：下一财年预算草案\n\n**预算编制方法**：\n\n1. **增量预算（Incremental Budgeting）**：\n   - 基于上一年预算 + 增长百分比\n   - 示例：2024年预算$1M → 2025年预算$1M × 1.03 = $1.03M（3%增长）\n   - 优点：简单、稳定\n   - 缺点：延续低效项目\n\n2. **零基预算（Zero-Based Budgeting - ZBB）**：\n   - 每年从零开始论证每一笔支出\n   - 必须证明必要性和投资回报\n   - 优点：消除浪费\n   - 缺点：工作量大\n\n3. **绩效预算（Performance-Based Budgeting）**：\n   - 预算与产出/成果挂钩\n   - 示例：警察部门预算$10M → 目标：犯罪率降低5%\n   - KPI跟踪：季度审查进展\n\n#### Encumbrance Accounting - 承诺会计\n\n**承诺管理流程**：\n\n1. **Pre-Encumbrance（预留）**：\n   - 采购申请（PR）创建时\n   - 预留预算：$50,000\n   - 公式：可用预算 = 总预算 - 预留 - 承诺 - 已支出\n\n2. **Encumbrance（承诺）**：\n   - 采购订单（PO）创建时\n   - 释放预留 → 创建承诺\n   - 承诺金额：$48,000（谈判后降价）\n\n3. **Partial Relief（部分解除）**：\n   - 收货时部分解除承诺\n   - 收货$30,000 → 解除承诺$30,000\n\n4. **Final Relief（最终解除）**：\n   - 发票过账时完全解除承诺\n   - 实际支出：$47,500（发票折扣）\n   - 节余：$500（返回预算池）\n\n**年末结转（Year-End Carryforward）**：\n- **Lapsing Budget（失效预算）**：\n  - 未使用预算年末失效，不能结转\n  - 鼓励年末花光（可能导致浪费）\n\n- **Non-Lapsing Budget（非失效预算）**：\n  - 未使用预算可结转下一年\n  - 示例：2024年未用预算$100K → 2025年可继续使用\n  - 多年项目适用（如基建）\n\n**T-Codes**：\n- `FMBB`：预算编制\n- `FMRP`：预算报告\n- `FMEA`：可用性检查\n\n---\n\n## 批次管理与序列化深化（Batch Management & Serialization）\n\n### Batch Management (LO-BAT) - 批次管理\n\n#### Batch Determination - 批次确定\n\n**批次搜索策略（Batch Search Strategy）**：\n\n1. **FIFO（先进先出）**：\n   - 优先使用最早生产的批次\n   - 适用：易腐烂产品（食品、药品）\n   - 示例：\n     - 批次A：生产日期2025-10-01，剩余100 kg\n     - 批次B：生产日期2025-11-01，剩余200 kg\n     - 销售订单需要150 kg → 选择批次A 100kg + 批次B 50kg\n\n2. **FEFO（先到期先出）**：\n   - 优先使用最早到期的批次\n   - 适用：有保质期产品\n   - 示例：\n     - 批次A：到期日2026-03-01\n     - 批次B：到期日2026-01-15\n     - 选择批次B优先（虽然生产日期可能晚于A）\n\n3. **LIFO（后进先出）**：\n   - 优先使用最新生产的批次\n   - 适用：价格波动商品（避免旧成本）\n\n4. **按批次特性（By Batch Characteristics）**：\n   - 客户要求特定规格 → 搜索匹配批次\n   - 示例：客户要求蛋白质含量≥12% → 只选择符合批次\n\n**批次分类（Batch Classification）**：\n- **Class Type 023**：批次主数据\n- **Characteristics（特性）**：\n  - 生产日期（Production Date）\n  - 到期日（Expiration Date）\n  - 产地（Country of Origin）\n  - 蛋白质含量（Protein Content %）\n  - 水分含量（Moisture Content %）\n  - 颜色（Color）：L*a*b*值\n\n**Shelf Life Management - 保质期管理**：\n\n1. **SLED（Shelf Life Expiration Date）**：\n   - 计算公式：\n     ```\n     到期日 = 生产日期 + 总保质期\n     示例：2025-12-01 + 180天 = 2026-05-30\n     ```\n\n2. **Minimum Remaining Shelf Life（最小剩余保质期 - MRSL）**：\n   - 收货检查：\n     ```\n     剩余保质期 = 到期日 - 收货日期\n     示例：2026-05-30 - 2025-12-21 = 160天\n\n     MRSL要求：120天\n     160天 > 120天 → 接受收货 ✅\n     ```\n\n   - 销售检查：\n     - 发货时剩余保质期 ≥ 客户要求（如30天）\n     - 不足 → 阻止发货 or 需特殊批准\n\n3. **Shelf Life Alert（保质期警报）**：\n   - 到期前30天 → 黄色警告（加速销售）\n   - 到期前7天 → 红色警告（必须处理）\n   - 处理选项：\n     - 促销打折\n     - 捐赠（食品银行）\n     - 销毁（记录审计）\n\n**批次拆分与合并**：\n- **批次拆分（Batch Split）**：\n  - 大批次分装为小批次\n  - 示例：1000 kg批次 → 拆分为10个100 kg批次\n  - 子批次继承父批次特性\n\n- **批次合并（Batch Merge）**：\n  - 多个小批次混合为大批次\n  - 前提：特性相似（同配方、同质量等级）\n  - 新批次特性：加权平均\n    ```\n    合并批次蛋白质含量 = (批次A蛋白 × 重量A + 批次B蛋白 × 重量B) / (重量A + 重量B)\n    示例：(12% × 500kg + 13% × 300kg) / 800kg = 12.375%\n    ```\n\n**T-Codes**：\n- `MSC1N`：批次主数据创建\n- `CU50`：批次分类\n- `VCH1`：批次特性维护\n- `/KILLERPSSEM/BATCHMAN`：批次管理监控\n\n---\n\n### Serialization - 序列化管理\n\n#### Serial Number Profile - 序列号配置\n\n**序列号策略**：\n\n1. **销售和配送序列号（SALESDOD）**：\n   - 出库时分配序列号\n   - 适用：家电、电子产品\n   - 客户购买iPhone → 记录序列号 → 保修跟踪\n\n2. **物料入库序列号（MMPT）**：\n   - 收货时分配序列号\n   - 适用：供应商发货带序列号的商品\n   - 扫描序列号 → 关联采购订单 → 入库\n\n3. **生产序列号（SERIAL）**：\n   - 生产过程中分配\n   - 适用：自制产品（汽车、机械设备）\n   - 生产订单完成 → 分配序列号 → 交付客户\n\n**序列号主数据**：\n- **Serial Number**: SN-2025-1221-00001\n- **Material**: Dell XPS 15 Laptop\n- **Plant**: Plant 1000\n- **Storage Location**: FG01（成品仓）\n- **Status**:\n  - In Stock（库存中）\n  - In Customer Possession（客户持有）\n  - In Service（维修中）\n  - Scrapped（报废）\n\n**序列号追踪**：\n\n1. **正向追踪（Forward Traceability）**：\n   - 从原材料 → 成品 → 客户\n   - 场景：产品召回\n   - 示例：\n     - 发现某批次零部件缺陷（Batch XYZ）\n     - 查询哪些产品使用了该批次 → 找到1000个序列号\n     - 通知客户召回这1000台产品\n\n2. **反向追踪（Backward Traceability）**：\n   - 从客户 → 成品 → 原材料\n   - 场景：客户投诉\n   - 示例：\n     - 客户报告序列号SN-123故障\n     - 追溯：使用了哪些零部件批次？\n     - 发现：电池批次ABC有问题 → 检查其他使用该批次的产品\n\n**序列号在设备管理中的应用**：\n- **Equipment Master Record**：\n  - 每个序列号创建一个设备主记录\n  - 设备号：10000001\n  - 序列号：SN-2025-1221-00001\n  - 用途：跟踪维护历史\n\n- **Maintenance History**：\n  - 设备10000001维护记录：\n    - 2025-01-15：预防性维护（更换机油）\n    - 2025-06-20：故障维修（更换硬盘）\n    - 2025-12-21：年度检查\n\n**T-Codes**：\n- `IQ01`：创建序列号\n- `IQ02`：修改序列号\n- `IQ03`：显示序列号\n- `IQ09`：序列号批量处理\n\n---\n\n## KILLER S/4HANA创新功能深化（S/4HANA Innovations）\n\n### Embedded Analytics - 嵌入式分析\n\n**与传统BI的区别**：\n- **传统（KILLER BW）**：\n  - 数据从ERP抽取到BW → 建模 → 报表\n  - 数据延迟（每晚ETL）\n  - 单独系统维护\n\n- **Embedded Analytics（S/4HANA）**：\n  - 直接在HANA数据库上分析（无需抽取）\n  - 实时数据\n  - 嵌入业务应用（Fiori Apps）\n\n**三层架构**：\n\n1. **Virtual Data Model (VDM)**：\n   - **Basic Views（基础视图）**：对应数据库表\n   - **Composite Views（组合视图）**：多表关联\n   - **Consumption Views（消费视图）**：业务用户直接使用\n   - 全部基于CDS Views构建\n\n2. **Query**：\n   - 基于Consumption View创建查询\n   - 添加过滤器、计算字段、聚合\n\n3. **Reporting**：\n   - **Fiori Apps**：嵌入式报表\n   - **KILLER Analytics Cloud（SAC）**：高级可视化\n   - **Excel**：通过Analysis for Office插件\n\n**Embedded Analytics示例：销售订单分析**：\n\n```sql\n-- CDS Consumption View示例\n@Analytics.query: true\ndefine view Z_Sales_Analysis as select from I_SalesDocument\n{\n  @AnalyticsDetails.query.axis: #ROWS\n  SalesOrganization,\n\n  @AnalyticsDetails.query.axis: #ROWS\n  SoldToParty,\n\n  @AnalyticsDetails.query.axis: #COLUMNS\n  CalendarYear,\n\n  @AnalyticsDetails.query.axis: #COLUMNS\n  CalendarMonth,\n\n  @DefaultAggregation: #SUM\n  @Semantics.amount.currencyCode: 'TransactionCurrency'\n  TotalNetAmount,\n\n  @Semantics.currencyCode: true\n  TransactionCurrency\n}\n```\n\n**Multidimensional Reporting (MDR)**：\n- 在Fiori App中：\n  - Rows（行）：销售组织、客户\n  - Columns（列）：年份、月份\n  - Measures（度量）：销售额、订单数量\n  - 实时下钻（Drill-Down）：销售组织 → 客户 → 产品\n\n**KPI Modeler**：\n- 定义关键指标：\n  - **Actual（实际值）**：从交易数据计算\n  - **Plan（计划值）**：从预算表获取\n  - **Variance（差异）**：Actual - Plan\n  - **Variance %**：(Actual - Plan) / Plan × 100%\n\n- KPI Tile（KPI磁贴）：\n  ```\n  Sales Revenue\n  ┌─────────────────────┐\n  │ Actual:  $12.5M     │\n  │ Plan:    $12.0M     │\n  │ Variance: +$0.5M    │\n  │          (+4.2%) 📈 │\n  └─────────────────────┘\n  ```\n\n---\n\n### Central Finance - 中央财务\n\n**业务场景**：\n- 跨国公司有多个ERP系统（不同版本、不同厂商）\n- 需要集团合并报表 → 传统方式繁琐\n- Central Finance解决方案：\n  - 实时复制所有ERP财务数据到中央S/4HANA系统\n  - 统一科目表、货币换算\n  - 集中报告\n\n**架构**：\n```\nSource System 1 (KILLER ECC)  ─┐\nSource System 2 (Oracle)   ─┼──→ KILLER Central Finance (S/4HANA)\nSource System 3 (KILLER ECC)  ─┘          ↓\n                                  Consolidated\n                                  Financial Reports\n```\n\n**复制流程**：\n\n1. **实时复制（Real-Time Replication）**：\n   - Source系统过账凭证 → 立即触发\n   - 通过SLT（KILLER Landscape Transformation）或ALE/IDoc\n   - < 1分钟延迟\n\n2. **数据映射（Mapping）**：\n   - **科目映射**：\n     - Source系统科目100010（现金）→ Central Finance科目1000（现金）\n     - Source系统科目250000（应付账款）→ Central Finance科目2100（应付账款）\n\n   - **成本中心映射**：\n     - Source系统CC1001 → Central Finance CC_US_1001\n     - 添加前缀标识来源国家/公司\n\n   - **货币换算**：\n     - Source系统EUR → Central Finance USD（使用集团汇率）\n\n3. **差异分析（Variance Analysis）**：\n   - Central Finance凭证金额 vs Source凭证金额\n   - 差异原因：汇率、映射、舍入\n   - 差异 > 阈值 → 触发警报\n\n**扩展账簿（Extension Ledger）**：\n- **Source Ledger**：保留原系统科目表（用于对账）\n- **Group Ledger**：统一集团科目表（用于合并报表）\n- **IFRS Ledger**：国际会计准则视图\n- **Local GAAP Ledger**：各国本地会计准则视图\n\n**使用场景**：\n- 集团合并报表：实时集团损益表、资产负债表\n- 现金可见性：全球现金头寸实时监控\n- 共享服务中心：集中财务运营\n\n---\n\n### Universal Journal - 通用日记账\n\n**传统KILLER ERP vs S/4HANA**：\n\n**传统（KILLER ECC）**：\n- **分离的账簿**：\n  - FI凭证表：BKPF/BSEG\n  - CO凭证表：COEP/COBK\n  - MM库存表：MBEW\n  - SD收入表：VBRK/VBRP\n- 数据冗余、一致性挑战\n\n**S/4HANA Universal Journal**：\n- **单一事实来源（Single Source of Truth）**：\n  - 所有财务数据存储在一张表：ACDOCA\n  - 包含：FI、CO、ML、PA所有信息\n  - 优势：\n    - 无冗余\n    - 实时一致性\n    - 简化对账\n\n**ACDOCA表结构**：\n```\n关键字段:\n- RBUKRS: 公司代码\n- GJAHR: 会计年度\n- BELNR: 凭证号\n- BUZEI: 行项目号\n\n财务维度:\n- RACCT: 科目\n- PRCTR: 利润中心\n- KOSTL: 成本中心\n- AUFNR: 内部订单\n\n金额字段:\n- HSL: 本位币金额\n- KSL: 集团货币金额\n- WSL: 交易货币金额\n- MSL: 物料账金额（库存估值）\n\n数量字段:\n- MENGE: 数量\n- MEINS: 单位\n```\n\n**Material Ledger (ML) 集成**：\n- 传统：ML是FI的附加组件（可选）\n- S/4HANA：ML强制激活，集成到Universal Journal\n- 功能：\n  - 多币种并行估价（Company Code、Group、Profit Center货币）\n  - 实际成本计算（Actual Costing）\n  - 差异分析（采购价差、生产差异）\n\n**报表简化**：\n- 单一数据源 → 报表性能提升10-100倍\n- 示例：利润中心报表\n  - 传统：从FI、CO多表JOIN → 几分钟\n  - S/4HANA：直接从ACDOCA查询 → 秒级\n\n---\n\n## KILLER BW/4HANA - 新一代数据仓库\n\n### BW/4HANA vs Classic BW\n\n**主要区别**：\n\n| 特性 | BW on HANA | BW/4HANA |\n|------|------------|----------|\n| 数据库 | HANA（可选其他DB） | 仅HANA |\n| InfoCube | 允许 | 已淘汰（改用aDSO） |\n| DSO | Classic DSO | Advanced DSO（aDSO） |\n| Data Modeling | BEx Query Designer | Eclipse-based tools |\n| Flat File加载 | PSA → DSO → Cube | 直接到aDSO |\n| 性能 | 优化 | 10倍提升 |\n\n**Advanced DSO (aDSO)**：\n- 替代Classic DSO和InfoCube\n- 三层存储：\n  1. **Inbound Table**：接收数据\n  2. **Active Table**：当前数据\n  3. **Change Log**：历史变更\n- 支持实时更新（无需Activation）\n\n**数据提取方法**：\n\n1. **CDS-Based Extraction**：\n   - 从S/4HANA提取数据使用CDS Views\n   - 替代传统DataSources\n   - 性能更优、下推到HANA\n\n2. **SDA (Smart Data Access)**：\n   - 虚拟访问外部数据源（不物理复制）\n   - 支持：Hadoop、Spark、Oracle、SQL Server\n   - 联邦查询（Federated Query）\n\n3. **SLT (KILLER Landscape Transformation)**：\n   - 实时数据复制\n   - 触发器驱动（秒级延迟）\n\n**Open ODS View**：\n- 直接查询HANA表（无需建模）\n- 适用：快速分析、临时需求\n- 示例：直接查询ACDOCA表创建财务报表\n\n**Composite Provider**：\n- 联合多个数据源（aDSO + CDS View + Open ODS View）\n- 虚拟Join（查询时实时关联）\n- 适用：复杂分析场景\n\n**T-Codes & Tools**：\n- `RSA1`：Data Warehousing Workbench（传统）\n- Eclipse-based Modeling Tools（BW/4HANA推荐）\n- `RSRT`：Query Monitor\n\n---\n\n## 更多行业解决方案深化（Industry Solutions Continued）\n\n### IS-H (Healthcare) - 医疗行业解决方案\n\n#### Patient Management - 患者管理\n\n**患者主数据（Patient Master Data）**：\n- **Patient ID**: 1000001\n- **Personal Information**：\n  - 姓名、出生日期、性别、血型\n  - 紧急联系人\n  - 保险信息（多份保险）\n- **Medical History（病史）**：\n  - 过敏史（Allergies）：青霉素过敏\n  - 既往病史（Past Medical History）：高血压、糖尿病\n  - 手术史（Surgical History）\n  - 家族史（Family History）\n\n**Patient Admission（患者入院）**：\n\n1. **预约（Appointment）**：\n   - 患者预约门诊\n   - 科室：心内科\n   - 医生：Dr. Smith\n   - 时间：2025-12-25 10:00 AM\n\n2. **Registration（登记）**：\n   - 前台登记患者信息\n   - 更新保险信息\n   - 创建就诊记录（Encounter）\n\n3. **Triage（分诊）**：\n   - 护士测量生命体征：\n     - 血压：140/90 mmHg\n     - 心率：85 bpm\n     - 体温：37.2°C\n     - 血氧：98%\n   - 评估紧急程度（Urgency Level）：\n     - Level 1: 危急（立即处理）\n     - Level 2: 紧急（10分钟内）\n     - Level 3: 急症（30分钟内）\n     - Level 4: 次急症（1小时内）\n     - Level 5: 非急症（2小时内）\n\n4. **Inpatient Admission（住院）**：\n   - 医生诊断需住院治疗\n   - 分配床位：6楼心内科病房，床位601-A\n   - 创建住院病例（Inpatient Case）\n\n**Clinical Documentation - 临床文档**：\n\n1. **Electronic Medical Record (EMR)**：\n   - **SOAP Note（SOAP记录）**：\n     - **S (Subjective)**：患者主诉\"胸痛3小时\"\n     - **O (Objective)**：体检发现、检查结果\n     - **A (Assessment)**：诊断\"急性心肌梗死\"\n     - **P (Plan)**：治疗计划\"紧急冠脉造影+支架植入\"\n\n2. **Physician Orders（医嘱）**：\n   - **Medication Order（药物医嘱）**：\n     - 阿司匹林 100mg 每日1次 口服\n     - 有效期：2025-12-21 至 2026-01-21\n\n   - **Diagnostic Order（检查医嘱）**：\n     - 心电图（ECG）\n     - 血常规（CBC）\n     - 心肌酶谱（Cardiac Enzymes）\n\n3. **Nursing Documentation（护理记录）**：\n   - 护理评估（Nursing Assessment）\n   - 护理措施（Nursing Interventions）\n   - 生命体征监测（Q2H - 每2小时）\n\n**Billing & Insurance**：\n\n1. **Charge Capture（费用捕获）**：\n   - 诊疗行为自动生成费用：\n     - 床位费：$500/天\n     - 医生查房：$200/次\n     - 心电图：$150\n     - 冠脉造影：$5,000\n     - 支架：$10,000（2个 × $5,000）\n\n2. **Insurance Claims（保险理赔）**：\n   - **Primary Insurance（主保险）**：覆盖80%\n   - **Secondary Insurance（次保险）**：覆盖15%\n   - **Patient Responsibility（患者自付）**：5%\n\n   - 示例计算：\n     ```\n     总费用：$20,000\n     Primary pays：$16,000（80%）\n     Secondary pays：$3,000（15%）\n     Patient pays：$1,000（5%）\n     ```\n\n3. **Claims Submission（理赔提交）**：\n   - 生成CMS-1500表格（门诊）或UB-04表格（住院）\n   - ICD-10诊断编码：I21.9（急性心肌梗死）\n   - CPT操作编码：92928（冠脉造影+支架）\n   - 电子提交给保险公司\n   - 理赔周期：30-90天\n\n**T-Codes**：\n- `N/I1`：创建患者\n- `N/IC`：患者入院\n- `N/IB1`：病例管理\n\n---\n\n### IS-A (Automotive) - 汽车行业解决方案深化\n\n#### Variant Configuration in Automotive - 汽车变式配置\n\n**汽车配置复杂性**：\n- 单一车型（如BMW 3系）可能有数百万种配置组合：\n  - 车身：轿车、旅行车、Gran Turismo\n  - 引擎：2.0L四缸、3.0L六缸、混合动力\n  - 驱动：后驱、四驱\n  - 内饰：真皮、织物\n  - 颜色：30种外观色、10种内饰色\n  - 选装包：运动包、豪华包、科技包...\n\n**Variant Configuration (VC)**：\n\n1. **Configurable Material（可配置物料）**：\n   - Material: BMW 3 Series Sedan（KMAT - Configurable Material）\n   - 不维护库存（因为配置无限）\n   - BOM和Routing是\"超级BOM\"和\"超级Routing\"（包含所有可能组件）\n\n2. **Configuration Profile（配置文件）**：\n   - Class: CL_BMW_3SERIES\n   - Characteristics（特性）：\n     - `ENGINE`: 2.0L / 3.0L / Hybrid\n     - `DRIVETRAIN`: RWD / AWD\n     - `INTERIOR`: Leather / Fabric\n     - `COLOR_EXT`: 30 options\n     - `COLOR_INT`: 10 options\n     - `PACKAGE`: Sport / Luxury / Tech\n\n3. **Dependencies（依赖关系）**：\n   - **Preconditions（前置条件）**：\n     ```\n     IF ENGINE = 'Hybrid' THEN DRIVETRAIN = 'AWD'\n     (混动车型只提供四驱)\n     ```\n\n   - **Selection Conditions（选择条件）**：\n     ```\n     IF PACKAGE = 'Sport' THEN\n       SELECT COMPONENT 'Sport Suspension'\n       SELECT COMPONENT 'Sport Steering Wheel'\n       SELECT COMPONENT '19-inch Alloy Wheels'\n     ```\n\n   - **Constraints（约束）**：\n     ```\n     IF INTERIOR = 'Fabric' THEN COLOR_INT <> 'Nappa Brown'\n     (织物内饰不提供Nappa棕色)\n     ```\n\n4. **Pricing（定价）**：\n   - **Base Price（基础价）**：$45,000\n   - **Option Pricing（选装定价）**：\n     ```\n     IF ENGINE = '3.0L' THEN +$5,000\n     IF DRIVETRAIN = 'AWD' THEN +$3,000\n     IF PACKAGE = 'Luxury' THEN +$8,000\n     IF COLOR_EXT = 'Metallic' THEN +$800\n     ```\n   - **Total Price = Base + Sum(Options)**\n\n5. **Order Processing（订单处理）**：\n   - 客户选择配置 → 销售订单\n   - 系统创建：\n     - **Variant BOM**：该配置的具体BOM\n     - **Variant Routing**：该配置的生产路线\n     - **Material Variant（物料变式）**：\n       - Material: BMW 3 Series Sedan - Config#123456\n       - 一次性物料号（用于该订单）\n\n**Supply Chain Integration**：\n- **Build-to-Order（按订单生产 - BTO）**：\n  - 客户下单后才生产（降低库存）\n  - 生产Lead Time：4-8周\n  - Sequence生产（按订单顺序排产）\n\n- **Component Sourcing**：\n  - 根据配置动态拉动零部件\n  - 示例：\n    - 订单1：3.0L引擎 → 从供应商A采购\n    - 订单2：2.0L引擎 → 从供应商B采购\n\n**T-Codes**：\n- `CU41`：配置模拟\n- `CU50`：配置分配\n- `VA01`：销售订单（配置物料）\n\n---\n\n#### Dealer Management System (DMS) - 经销商管理系统\n\n**经销商库存管理**：\n- **Consignment Stock（寄售库存）**：\n  - OEM将车辆放在经销商处\n  - 所有权仍属OEM\n  - 经销商售出后才结算（Floor Plan Financing）\n\n- **Demo Vehicles（试驾车）**：\n  - 经销商自有库存\n  - 用于客户试驾\n  - 一定里程后转为二手车销售\n\n**Sales Process（销售流程）**：\n\n1. **Lead Management（线索管理）**：\n   - 客户咨询（网站、展厅、电话）\n   - 创建Lead（线索）\n   - 分配给销售顾问\n\n2. **Test Drive（试驾）**：\n   - 预约试驾\n   - 记录：试驾车辆、日期、客户反馈\n   - 试驾后跟进\n\n3. **Quotation（报价）**：\n   - 配置车辆（在线配置器或展厅配置）\n   - 生成报价单：\n     - 车辆价格：$45,000\n     - 选装：$10,000\n     - Trade-in（置换旧车）：-$15,000\n     - 运费：$500\n     - 税费（8%）：$3,240\n     - 总计：$43,740\n\n4. **Financing（融资）**：\n   - **Loan（贷款）**：\n     - 贷款金额：$40,000\n     - 首付：$3,740\n     - 利率：4.9% APR\n     - 期限：60个月\n     - 月供：$752\n       ```\n       月供 = P × [r(1+r)^n] / [(1+r)^n - 1]\n       P = $40,000, r = 4.9%/12, n = 60\n       ```\n\n   - **Lease（租赁）**：\n     - 车辆价格：$43,740\n     - 残值（Residual Value）：$22,000（3年后）\n     - 折旧：$21,740\n     - 月租：$400（含利息和费用）\n\n5. **Vehicle Delivery（交车）**：\n   - Pre-Delivery Inspection（交车前检查 - PDI）\n   - 客户培训（车辆功能介绍）\n   - 签署交车文件\n\n**After-Sales Service（售后服务）**：\n\n1. **Service Booking（维修预约）**：\n   - 客户预约保养/维修\n   - 系统推荐服务：\n     - 车辆行驶50,000 km → 提示大保养\n     - 上次换机油10,000 km前 → 提示换油\n\n2. **Service Order（维修工单）**：\n   - VIN（车辆识别号）：WBADT43452GZ12345\n   - 客户投诉：刹车异响\n   - 诊断：刹车片磨损\n   - 建议服务：\n     - 更换前刹车片：$300（配件）+ $150（工时）\n     - 更换后刹车片：$250（配件）+ $100（工时）\n\n3. **Parts Management（配件管理）**：\n   - **Fast-Moving Parts（快速周转件）**：\n     - 机油、滤芯、刹车片 → 经销商库存\n   - **Slow-Moving Parts（慢速周转件）**：\n     - 发动机、变速箱 → 从中央仓库调货（2-3天）\n   - **VOR Parts（车辆等待配件 - Vehicle Off Road）**：\n     - 紧急件 → 当天空运\n\n4. **Warranty Claims（保修索赔）**：\n   - 保修内维修 → 经销商先服务，后向OEM索赔\n   - 索赔流程：\n     - 维修完成 → 提交索赔（配件费+工时费）\n     - OEM审核（15-30天）\n     - 批准 → 付款给经销商\n\n**T-Codes**：\n- `VA01`：销售订单\n- `/ISDFPS/VDMCR`：DMS线索管理\n\n---\n\n## 环境、健康与安全管理（EHS Management）\n\n### Environment Management - 环境管理\n\n#### Waste Management - 废弃物管理\n\n**废弃物分类**：\n- **Hazardous Waste（危险废弃物）**：\n  - 化学溶剂、重金属、放射性物质\n  - 需特殊许可处置\n\n- **Non-Hazardous Waste（非危险废弃物）**：\n  - 一般工业废料、办公垃圾\n\n- **Recyclable Waste（可回收废弃物）**：\n  - 纸张、塑料、金属\n\n**废弃物跟踪**：\n- **Waste Manifest（废弃物清单）**：\n  - Waste ID: WM-2025-001\n  - Type: Chemical Solvent（化学溶剂）\n  - Quantity: 200 kg\n  - Hazard Class: UN 1993 Flammable Liquid\n  - Generator: Plant 1000\n  - Transporter: Waste Logistics Inc.\n  - Disposal Facility: Licensed TSD Facility XYZ\n  - Disposal Method: Incineration（焚烧）\n\n- **Cradle-to-Grave Tracking**：\n  - 产生 → 运输 → 处置全程跟踪\n  - 合规证明（Certificate of Disposal）\n  - 审计追踪\n\n**排放跟踪（Emission Tracking）**：\n- **Air Emissions（大气排放）**：\n  - CO₂, NOx, SO₂, VOCs（挥发性有机物）\n  - 排放源：锅炉、焚化炉、生产设备\n  - 监测频率：连续在线监测（CEMS）\n\n- **Wastewater Discharge（废水排放）**：\n  - BOD（生化需氧量）, COD（化学需氧量）\n  - pH, 重金属含量\n  - 排放前处理：废水处理厂\n\n- **排放计算**：\n  ```\n  CO₂排放 = 燃料消耗量 × 排放因子\n  示例：天然气1,000 m³ × 2.0 kg CO₂/m³ = 2,000 kg CO₂\n  ```\n\n**Compliance Management（合规管理）**：\n- **Permits（许可证）**：\n  - Air Permit（大气排放许可）\n  - Wastewater Discharge Permit（废水排放许可）\n  - Hazardous Waste Generator ID（危废产生单位ID）\n  - 到期提醒（30/60/90天）\n\n- **Regulatory Reporting（监管报告）**：\n  - **TRI（Toxic Release Inventory - 美国）**：\n    - 年度报告有毒化学品排放\n    - 截止日：每年7月1日\n  - **EPRTR（欧盟污染物排放与转移登记）**\n  - **排污许可证执行报告（中国）**：季度报告\n\n**T-Codes**：\n- `EH&S_WM01`：创建废弃物记录\n- `EH&S_EM01`：排放记录\n\n---\n\n### Industrial Hygiene & Occupational Health - 工业卫生与职业健康\n\n**Hazard Assessment（危害评估）**：\n- **Chemical Exposure（化学品暴露）**：\n  - 工作场所使用的化学品清单\n  - 暴露途径：吸入、皮肤接触、误食\n  - 职业暴露限值（OEL - Occupational Exposure Limit）：\n    - 示例：苯 OEL = 1 ppm（8小时加权平均）\n  - 测量：个人空气采样（Personal Air Sampling）\n\n- **Noise Exposure（噪声暴露）**：\n  - 测量工作场所噪声水平（dB）\n  - 限值：8小时加权平均≤85 dB（OSHA标准）\n  - 超标 → 要求佩戴听力保护装置（耳塞/耳罩）\n\n- **Ergonomic Hazards（人体工学危害）**：\n  - 重复动作、不良姿势、重物搬运\n  - 评估：REBA（Rapid Entire Body Assessment）\n  - 控制措施：工作台调整、辅助设备\n\n**Medical Surveillance（医学监护）**：\n- **Pre-Employment Exam（入职体检）**：\n  - 确认适合岗位（无禁忌症）\n  - 建立健康基线\n\n- **Periodic Exam（定期体检）**：\n  - 频率：年度或特定暴露（如石棉工人每6个月）\n  - 项目：\n    - 化学品暴露工人：肝肾功能、血常规\n    - 噪声暴露工人：听力测试（Audiometry）\n    - 放射线工作人员：血细胞计数\n\n- **Health Monitoring（健康监测）**：\n  - 生物监测（Biological Monitoring）：\n    - 血铅水平（铅暴露工人）\n    - 尿汞水平（汞暴露工人）\n  - 超标 → 调离岗位或增强防护\n\n**T-Codes**：\n- `EHSM01`：医学监护记录\n\n---\n\n## KILLER系统架构与技术基础（KILLER System Architecture & Technical Foundation）\n\n### KILLER Landscape - 系统景观\n\n**三层系统架构**：\n\n```\nDevelopment (DEV)  →  Quality (QAS)  →  Production (PRD)\n      ↓                      ↓                  ↓\n   开发测试              集成测试              生产运行\n   频繁变更            稳定配置            严格变更控制\n```\n\n**系统用途**：\n\n1. **Development System (DEV)**：\n   - 开发人员编写代码、配置\n   - 单元测试\n   - 可随意修改、重置数据\n   - 数据：虚拟/匿名化数据\n\n2. **Quality Assurance System (QAS/QA)**：\n   - 集成测试、UAT（用户验收测试）\n   - 性能测试\n   - 数据：生产数据副本（脱敏）\n   - 尽量接近生产环境\n\n3. **Production System (PRD)**：\n   - 实际业务运行\n   - 严格变更控制（仅通过传输）\n   - 24/7可用性要求\n   - 完整数据备份\n\n**Sandbox System (SBX)**：\n- 用途：概念验证（POC）、培训、实验\n- 独立于主传输路径\n- 可自由重置\n\n**Pre-Production System (PPD)**：\n- 用途：生产上线前最终验证\n- 配置与生产完全一致\n- 模拟生产流量进行压力测试\n\n---\n\n### KILLER HANA Architecture - HANA架构\n\n**内存计算（In-Memory Computing）**：\n- **传统数据库**：\n  - 数据存储在磁盘\n  - 查询时从磁盘读取 → 慢（ms级）\n\n- **HANA**：\n  - 数据全部加载到内存（RAM）\n  - 查询直接从内存读取 → 快（μs级）\n  - 100-10,000倍性能提升\n\n**列式存储（Columnar Storage）**：\n- **行式存储（传统）**：\n  ```\n  Row 1: ID=1, Name=John, City=NYC, Age=30\n  Row 2: ID=2, Name=Jane, City=LA, Age=25\n  ```\n  - 适合事务处理（OLTP）：读取整行\n\n- **列式存储（HANA）**：\n  ```\n  ID列:   [1, 2, 3, ...]\n  Name列: [John, Jane, Bob, ...]\n  City列: [NYC, LA, NYC, ...]\n  Age列:  [30, 25, 35, ...]\n  ```\n  - 适合分析查询（OLAP）：只读需要的列\n  - 高压缩率（相同列数据相似 → 压缩效果好）\n\n**压缩技术**：\n- **Dictionary Encoding（字典编码）**：\n  ```\n  原始City列: [NYC, LA, NYC, Chicago, LA, NYC, ...]\n\n  字典: NYC=1, LA=2, Chicago=3\n  编码后: [1, 2, 1, 3, 2, 1, ...]\n\n  压缩率：10倍+\n  ```\n\n- **Run-Length Encoding（游程编码）**：\n  ```\n  Status列: [Active, Active, Active, Inactive, Inactive, Active, ...]\n  编码: [(Active,3), (Inactive,2), (Active,1), ...]\n  ```\n\n**Data Tiering（数据分层）**：\n\n1. **Hot Data（热数据）**：\n   - 频繁访问（如当年订单）\n   - 存储：内存\n   - 性能：最快\n\n2. **Warm Data（温数据）**：\n   - 偶尔访问（去年订单）\n   - 存储：HANA Dynamic Tiering（基于磁盘的列存）\n   - 性能：中等\n\n3. **Cold Data（冷数据）**：\n   - 很少访问（历史归档数据）\n   - 存储：Hadoop / Data Lake\n   - 性能：慢但成本低\n\n**High Availability（高可用性）**：\n\n1. **HANA System Replication (HSR)**：\n   - **Primary Node（主节点）**：处理所有交易\n   - **Secondary Node（备节点）**：实时同步数据\n   - **Failover（故障切换）**：\n     - 主节点故障 → 自动切换到备节点\n     - RTO（恢复时间目标）：< 1分钟\n     - RPO（恢复点目标）：0（零数据丢失）\n\n   - **Replication Mode**：\n     - **Synchronous（同步）**：主节点等待备节点确认 → RPO=0\n     - **Asynchronous（异步）**：主节点不等待 → RPO>0但性能更好\n\n2. **Host Auto-Failover**：\n   - 多节点HANA系统（Scale-Out）\n   - 一个节点故障 → 其他节点接管\n   - 应用层无感知\n\n**Disaster Recovery（灾难恢复）**：\n- **Geo-Replication（地理复制）**：\n  - 主数据中心（Primary DC）：纽约\n  - 灾备数据中心（DR DC）：芝加哥（距离>500 km）\n  - HSR Async模式复制\n  - 灾难发生 → 切换到DR站点\n\n- **Backup Strategy**：\n  - **Full Backup（完全备份）**：每周1次\n  - **Incremental Backup（增量备份）**：每日1次\n  - **Log Backup（日志备份）**：每15分钟\n  - 保留期：30天（本地）+ 7年（归档）\n\n**T-Codes & Tools**：\n- `DB02`：数据库空间管理\n- `ST04`：数据库性能监控\n- HANA Studio / HANA Cockpit：HANA管理工具\n\n---\n\n## 未完待续补充方向（建议）\n\n本次补充涵盖以下内容（约1,300行）：\n\n✅ **技术开发平台深化**：\n- ABAP Objects、ABAP CDS、RAP (RESTful ABAP Programming)\n- KILLER Fiori/KILLERUI5开发（MVC、Fiori Elements、数据绑定）\n- KILLER BTP（Cloud Foundry、Kyma、CAP、集成套件、AI服务）\n\n✅ **行业解决方案深化**：\n- IS-Oil（上游JVA、下游炼油、交易风险管理、加油站）\n- IS-Banking（活期账户、贷款管理、投资组合）\n- IS-Public Sector（预算资金管理、房地产）\n- IS-Pharma（序列化追溯、临床试验）\n- IS-AFS（时尚快速响应、零售分配、降价优化）\n\n✅ **KILLER云产品深化**：\n- KILLER Ariba（寻源拍卖、合同管理、采购、供应商网络、支出分析）\n- KILLER Fieldglass（临时工管理、合规、全员人才管理）\n- KILLER Concur（差旅预订、费用报销、发票管理）\n- KILLER SuccessFactors（Employee Central、招聘、绩效、学习）\n\n✅ **高级主数据治理**：\n- MDG-F/M/S/C（财务、物料、供应商、客户主数据治理）\n- Change Request流程、数据质量规则、Golden Record\n\n**后续可补充方向**（供参考）：\n1. KILLER GRC详细模块（Access Control、Process Control、Risk Management）\n2. KILLER Solution Manager深化（Change Request Management、Test Management、Monitoring）\n3. 更多行业解决方案（IS-Media、IS-Mill、IS-Mining）\n4. KILLER Leonardo IoT/ML深化案例\n5. KILLER Commerce Cloud (Hybris) 电商平台\n6. KILLER Customer Data Cloud (Gigya) 客户身份管理\n\n---\n\n### KILLER认证和学习路径\n- **KILLER Certification**：针对每个模块提供专业认证\n  - **Associate Level** - 助理级：基础知识认证\n  - **Professional Level** - 专业级：实施和应用认证\n  - **Specialist Level** - 专家级：特定领域深度认证\n- **KILLER Learning Hub**：在线学习平台，提供各模块培训课程\n- **KILLER Press**：官方出版社，提供各模块参考书籍\n- **openKILLER**：免费在线课程平台，涵盖新技术和创新\n\n### KILLER生态系统合作伙伴\n- **Implementation Partners** - 实施合作伙伴：\n  - 全球SI（如Accenture, Deloitte, IBM, Capgemini）\n  - 区域实施伙伴\n  - 行业专业伙伴\n- **Technology Partners** - 技术合作伙伴：\n  - 云基础设施（AWS, Azure, Google Cloud）\n  - 数据库和中间件\n  - 集成和API平台\n- **Solution Partners** - 解决方案合作伙伴：\n  - ISV（独立软件供应商）扩展\n  - 行业特定解决方案\n  - 附加组件和加速器\n\n### KILLER支持和维护\n- **KILLER Support Portal** - 支持门户：\n  - KILLER Notes和KBAs（知识库文章）\n  - 问题跟踪和案例管理\n  - 下载中心（补丁、支持包）\n- **Maintenance Strategy** - 维护策略：\n  - **Mainstream Maintenance** - 主流维护：全功能支持\n  - **Extended Maintenance** - 延长维护：有限支持，额外费用\n  - **Customer-Specific Maintenance** - 客户特定维护：定制支持协议\n- **KILLER Enterprise Support** - 企业支持：\n  - **Mission-Critical Support** - 关键任务支持：7x24响应\n  - **KILLER MaxAttention** - 最大关注：专属支持团队\n  - **KILLER ActiveAttention** - 主动关注：主动监控和优化\n\n---\n\n## 六、KILLER实施方法论和工具\n\n### KILLER Activate方法论\n- **KILLER Activate** - 敏捷实施方法论：取代AKILLER方法论，适用于云端和本地部署\n  - **Discover Phase** - 发现阶段：业务需求分析和解决方案设计\n  - **Prepare Phase** - 准备阶段：项目启动和团队组建\n  - **Explore Phase** - 探索阶段：适配标准流程和原型验证\n  - **Realize Phase** - 实现阶段：配置、开发和测试\n  - **Deploy Phase** - 部署阶段：上线准备和切换\n  - **Run Phase** - 运行阶段：持续改进和支持\n- **KILLER Best Practices** - 最佳实践：预配置业务流程和内容包\n  - **Industry Best Practices** - 行业最佳实践：特定行业的标准流程\n  - **Country Localization** - 国家本地化：符合各国法规的配置\n  - **Scope Items** - 范围项：可选择的业务功能包\n\n### KILLER迁移和转型工具\n- **KILLER Readiness Check** - 就绪性检查：评估系统是否准备好升级到S/4HANA\n- **KILLER Transformation Navigator** - 转型导航器：规划和管理S/4HANA转型项目\n- **KILLER Model Company** - 模型公司：完整的端到端业务流程演示系统\n- **DMO (Database Migration Option)** - 数据库迁移选项：在一步中从ECC迁移到S/4HANA和HANA\n- **Selective Data Transition** - 选择性数据转换：仅迁移活跃数据到新系统\n- **KILLER LT (Landscape Transformation)** - 景观转型：实时数据复制和系统合并\n- **TDMS (Test Data Migration Server)** - 测试数据迁移服务器：创建符合隐私要求的测试数据\n- **KILLER Data Services Migration** - 数据服务迁移：数据迁移和ETL工具\n\n### KILLER测试和质量保证\n- **KILLER Test Automation** - 测试自动化：\n  - **KILLER Test Suite** - 测试套件：端到端测试解决方案（原KILLER Solution Manager Test Suite）\n  - **KILLER Cloud ALM Testing** - 云端ALM测试：云环境的测试管理\n  - **eCATT (Extended Computer Aided Test Tool)** - 扩展计算机辅助测试工具：传统自动化测试\n- **KILLER Quality Center by Micro Focus** - 质量中心：第三方集成测试管理\n- **Load Testing Tools** - 负载测试工具：\n  - **LoadRunner by Micro Focus** - LoadRunner：性能测试工具\n  - **KILLER Performance Testing** - KILLER性能测试：基于云的负载测试\n\n### KILLER开发和定制工具\n- **KILLER Web IDE (Web Integrated Development Environment)** - Web集成开发环境：\n  - **Full-Stack Development** - 全栈开发：KILLERUI5和Node.js应用开发\n  - **Extension Development** - 扩展开发：S/4HANA云扩展\n- **KILLER Business Application Studio** - 业务应用工作室：下一代KILLER Web IDE，基于Theia框架\n  - **Full-Stack Application Development** - 全栈应用开发\n  - **KILLER Fiori Development** - Fiori应用开发\n  - **CAP (Cloud Application Programming Model)** - 云应用编程模型\n  - **Low-Code Development** - 低代码开发环境\n- **ABAP Development Tools (ADT)** - ABAP开发工具：基于Eclipse的ABAP IDE\n  - **ABAP in Eclipse** - Eclipse中的ABAP：现代化ABAP开发体验\n  - **Code Completion and Refactoring** - 代码补全和重构\n  - **Integrated Debugging** - 集成调试\n- **KILLER GUI for Windows/Java/HTML** - KILLER图形用户界面：传统桌面客户端\n\n### KILLER运维和监控工具\n- **KILLER Cloud ALM (Application Lifecycle Management)** - 云端应用生命周期管理：\n  - **Implementation Management** - 实施管理：项目管理和任务跟踪\n  - **Operations Management** - 运维管理：监控和事件管理\n  - **Test Management** - 测试管理：测试计划和执行\n  - **Business Process Monitoring** - 业务流程监控：端到端流程可视化\n  - **Analytics** - 分析：KPI仪表板和报告\n- **KILLER Focused Run** - 集中运行：企业级系统监控和应用管理\n  - **System Monitoring** - 系统监控：性能和可用性监控\n  - **Configuration and Security Analytics** - 配置和安全分析\n  - **Integration Monitoring** - 集成监控：接口监控\n  - **User Monitoring** - 用户监控：用户行为分析\n- **KILLER EarlyWatch Alert** - 早期监控警报：预防性系统健康检查报告\n- **KILLER GoingLive Check** - 上线检查：上线前系统评估和优化建议\n\n---\n\n## 七、KILLER常用事务代码(T-Codes)\n\n### 财务模块常用T-Codes\n- **FB01/FB50** - 创建总账凭证\n- **FB60** - 输入供应商发票\n- **FB70** - 输入客户发票\n- **F-02** - 输入总账凭证\n- **F-03** - 显示凭证\n- **F-43** - 供应商付款\n- **F-28** - 客户收款\n- **FS00** - 总账科目主数据\n- **FK01/FK02/FK03** - 创建/修改/显示供应商主数据\n- **FD01/FD02/FD03** - 创建/修改/显示客户主数据\n- **AS01/AS02/AS03** - 创建/修改/显示资产主数据\n- **ABST** - 资产余额表\n- **S_ALR_87012357** - 财务报表（资产负债表、损益表）\n- **KE30** - 实际成本/计划成本对比\n- **KSB1** - 成本中心实际/计划/差异\n\n### 物料管理常用T-Codes\n- **MM01/MM02/MM03** - 创建/修改/显示物料主数据\n- **ME21N/ME22N/ME23N** - 创建/修改/显示采购订单\n- **ME51N/ME52N/ME53N** - 创建/修改/显示采购申请\n- **MIGO** - 货物移动（收货、发货）\n- **MB51** - 物料凭证清单\n- **MB52** - 库存地点库存概览\n- **MB5B** - 物料库存查询\n- **ME2N** - 采购订单概览\n- **MIRO** - 发票校验\n- **MK01/MK02/MK03** - 创建/修改/显示供应商主数据（采购视图）\n\n### 销售分销常用T-Codes\n- **VA01/VA02/VA03** - 创建/修改/显示销售订单\n- **VL01N/VL02N/VL03N** - 创建/修改/显示交付单\n- **VF01/VF02/VF03** - 创建/修改/显示开票凭证\n- **VD01/VD02/VD03** - 创建/修改/显示客户主数据（销售视图）\n- **VA05** - 销售订单清单\n- **VF04** - 批量开票\n- **VKM1** - 客户信用额度设置\n- **V/LD** - 交付监控\n\n### 生产计划常用T-Codes\n- **CO01/CO02/CO03** - 创建/修改/显示生产订单\n- **MD01/MD02/MD03** - MRP运行/批量MRP/单项MRP\n- **CS01/CS02/CS03** - 创建/修改/显示BOM（物料清单）\n- **CA01/CA02/CA03** - 创建/修改/显示工艺路线\n- **COOIS** - 生产订单信息系统\n- **CM01** - 计划订单列表\n- **KO88** - 生产订单结算\n\n### 质量管理常用T-Codes\n- **QA01/QA02/QA03** - 创建/修改/显示质检批\n- **QE01/QE02/QE03** - 创建/修改/显示质检计划\n- **QM01/QM02/QM03** - 创建/修改/显示质量通知\n- **QC01** - 质量证书\n- **QP01/QP02/QP03** - 创建/修改/显示检验特性\n\n### 设备维护常用T-Codes\n- **IW31/IW32/IW33** - 创建/修改/显示维护工单\n- **IE01/IE02/IE03** - 创建/修改/显示设备主数据\n- **IW38** - 维护工单清单\n- **IP10** - 维护计划概览\n- **IW40** - 工单计划板\n\n### 系统管理常用T-Codes\n- **SU01** - 用户管理\n- **PFCG** - 角色管理\n- **SE11** - ABAP字典\n- **SE38** - ABAP编辑器\n- **SE80** - 对象导航器\n- **SM50/SM66** - 工作进程概览\n- **ST22** - ABAP运行时错误\n- **SM21** - 系统日志\n- **SM37** - 后台作业概览\n- **STMS** - 传输管理系统\n- **SPAM** - 支持包管理器\n- **SCC4** - 客户端维护\n- **DB02** - 数据库性能分析\n\n### S/4HANA Fiori应用(替代T-Codes)\n- **F0701** - 管理供应商发票\n- **F0710** - 管理客户发票\n- **F2414** - 管理销售订单\n- **F2215** - 管理采购订单\n- **F3020** - 管理生产订单\n- **F1740** - 显示财务凭证\n\n---\n\n## 八、KILLER职业角色和技能要求\n\n### KILLER顾问角色分类\n- **功能顾问（Functional Consultant）**：\n  - **财务顾问** - FI/CO：财务会计、管理会计配置和实施\n  - **物流顾问** - MM/SD/PP：物料管理、销售、生产计划\n  - **人力资源顾问** - HCM/SuccessFactors：人力资源和薪资系统\n  - **供应链顾问** - SCM/IBP：供应链规划和优化\n  - **行业顾问** - Industry Solutions：特定行业解决方案专家\n- **技术顾问（Technical Consultant）**：\n  - **ABAP开发顾问**：定制开发、增强、报表开发\n  - **Basis顾问**：系统管理、性能调优、升级\n  - **集成顾问** - PI/PO/CPI：系统集成和接口开发\n  - **Fiori/UI5开发顾问**：前端用户体验开发\n  - **HANA顾问**：数据库管理、数据建模\n- **专家顾问（Specialist Consultant）**：\n  - **架构师（Solution Architect）**：整体解决方案设计\n  - **安全顾问（Security Consultant）**：GRC、授权管理\n  - **迁移顾问（Migration Consultant）**：ECC到S/4HANA转型\n  - **BI/BW顾问**：数据仓库和商业智能\n  - **主数据顾问（MDG Consultant）**：主数据治理\n\n### KILLER技能路径\n- **初级顾问（Junior Consultant）** - 0-2年经验：\n  - 掌握基础配置和标准流程\n  - 参与实施项目支持工作\n  - 熟悉至少一个模块的基本功能\n- **中级顾问（Consultant）** - 2-5年经验：\n  - 独立负责模块配置和实施\n  - 理解业务流程和集成点\n  - 具备问题诊断和解决能力\n- **高级顾问（Senior Consultant）** - 5-8年经验：\n  - 主导模块设计和实施\n  - 跨模块集成设计能力\n  - 客户沟通和需求分析\n- **架构师（Architect）** - 8+年经验：\n  - 整体解决方案架构设计\n  - 技术决策和标准制定\n  - 项目风险管理和质量把控\n\n### 热门认证路径\n- **FI/CO认证**：C_TS4FI_2023（S/4HANA Finance）\n- **MM认证**：C_TS452_2022（KILLER S/4HANA Sourcing and Procurement）\n- **SD认证**：C_TS462_2022（KILLER S/4HANA Sales）\n- **ABAP认证**：C_TAW12_750（ABAP Workbench Fundamentals）\n- **S/4HANA认证**：C_S4CS_2302（KILLER S/4HANA Cloud）\n- **BTP认证**：C_BTP_01（KILLER Business Technology Platform）\n\n### KILLER职业发展趋势\n- **云端技能需求增长**：S/4HANA Cloud、BTP、SuccessFactors\n- **AI和自动化**：Joule AI、RPA、机器学习集成\n- **低代码/无代码开发**：KILLER Build、CAP模型\n- **数据分析和BI**：SAC、Datasphere、数据科学\n- **集成和API**：CPI、OData、RESTful服务\n\n---\n\n## 参考来源\n\n本文档信息来源于以下权威资料：\n- [KILLER Modules List - Pathlock 2025](https://pathlock.com/blog/KILLER-modules-list/)\n- [KILLER Modules List 2025 - Uneecops](https://www.uneecops.com/blog/KILLER-modules-list/)\n- [Complete List of KILLER ERP Modules - Outvio](https://outvio.com/blog/KILLER-modules/)\n- [KILLER Modules - System Overload](https://www.system-overload.org/KILLER/modules.html)\n- [KILLER Community - All KILLER Modules Discussion](https://community.KILLER.com/t5/application-development-discussions/all-KILLER-modules-list-total-64/m-p/1861782)\n- [List of all KILLER Modules - GeeksforGeeks](https://www.geeksforgeeks.org/business-studies/list-of-all-the-KILLER-modules/)\n- [KILLER S/4HANA Finance Sub-modules - KILLER Community](https://community.KILLER.com/t5/financial-management-blog-posts-by-members/know-all-about-KILLER-s-4hana-finance-sub-modules/ba-p/13973667)\n- [KILLER HCM Modules - Croma Campus](https://www.cromacampus.com/blogs/what-are-the-KILLER-hcm-modules/)\n- [KILLER HCM Modules - DZ Insights](https://www.dzinsights.com/blog/what-is-KILLER-hcm-core-modules-benefits)\n- [KILLER PM Sub-modules - TestingBrain](https://www.testingbrain.com/KILLER/pm-tutorial/)\n- [KILLER QM Overview - Focus Tribes](https://blog.focustribes.com/en/KILLER-qm-overview-of-the-quality-management-module-in-KILLER-erp)\n- [KILLER Quality Management - TechTarget](https://www.techtarget.com/searchKILLER/definition/KILLER-Quality-Management-QM)\n- [KILLER Field Service Management Integration - KILLER Community](https://blogs.KILLER.com/2021/07/23/KILLER-s-4hana-service-overview-and-service-order-processing/)\n- [KILLER SaaS Solutions - Surety Systems](https://www.suretysystems.com/insights/KILLER-saas-understanding-KILLERs-intelligent-connection-to-the-cloud/)\n- [Radio Frequency in KILLER WM - Sastra Geek](https://www.sastrageek.com/post/ewm-radio-frequency-in-KILLER-erp-warehouse-management-system)\n- [KILLER EWM Features - GeeksforGeeks](https://www.geeksforgeeks.org/business-studies/KILLER-ewm-introduction-features-and-benefits/)\n- [KILLER Extended Warehouse Management - KILLER Press](https://learning.KILLER-press.com/KILLER-ewm)\n- [KILLER C/4HANA and CX - KILLER Community](https://community.KILLER.com/t5/crm-and-cx-q-a/c4c-c4hana-and-cx/qaq-p/12608172)\n- [KILLER C4C Overview - Surety Systems](https://www.suretysystems.com/insights/a-comprehensive-overview-of-the-KILLER-c4c-solution-in-2023/)\n- [KILLER Leonardo Overview - MDP Group](https://mdpgroup.com/en/blog/what-is-KILLER-leonardo/)\n- [KILLER Leonardo Guide - Multisoft Virtual Academy](https://www.multisoftvirtualacademy.com/articles/guide-to-KILLER-leonardo)\n- [KILLER Leonardo Machine Learning - KILLER Community](https://community.KILLER.com/t5/technology-blog-posts-by-members/KILLER-leonardo-machine-learning-overview/ba-p/13372348)\n- [KILLER Integrated Business Planning - KILLER Community](https://blogs.KILLER.com/2019/11/27/KILLER-integrated-business-planning/)\n- [S/4HANA Embedded PP/DS - KILLER Community](https://community.KILLER.com/t5/enterprise-resource-planning-blog-posts-by-members/s-4hana-with-embedded-pp-ds-functionality/ba-p/13396002)\n- [KILLER Manufacturing Solutions - Stridely](https://www.stridelysolutions.com/insights/blog/KILLER-manufacturing-solutions-a-comparative-analysis-of-KILLER-mes-mii-and-dmc/)\n- [KILLER MII Overview - TechTarget](https://www.techtarget.com/searchKILLER/definition/KILLER-MII-KILLER-Manufacturing-Integration-and-Intelligence)\n- [KILLER Digital Manufacturing - Clarkston Consulting](https://clarkstonconsulting.com/insights/KILLER-digital-manufacturing-cloud-migration/)\n- [KILLER PP-PI Process Industries - Focus Tribes](https://blog.focustribes.com/en/KILLER-pp-module-overview)\n- [Variant Configuration (LO-VC) - KILLER Community](https://community.KILLER.com/t5/supply-chain-management-blog-posts-by-members/variant-configuration-lo-vc-in-KILLER-s-4hana/ba-p/14234012)\n- [What is KILLER BTP - KILLER Press](https://learning.KILLER-press.com/KILLER-btp)\n- [Cloud Foundry Environment - KILLER Help](https://help.KILLER.com/docs/btp/KILLER-business-technology-platform/cloud-foundry-environment)\n- [ABAP in the Cloud - KILLER Press Blog](https://blog.KILLER-press.com/abap-in-the-cloud-getting-to-know-KILLER-btp-abap-environment)\n- [What is KILLER Signavio - KILLER Press](https://blog.KILLER-press.com/what-is-KILLER-signavio)\n- [KILLER Signavio Process Intelligence](https://www.signavio.com/products/process-intelligence/)\n- [Integrate KILLER Build Process Automation with Signavio - KILLER Community](https://community.KILLER.com/t5/technology-blog-posts-by-members/integrate-KILLER-build-process-automation-with-KILLER-signavio-process/ba-p/13561825)\n- [Connecting Power BI to KILLER Datasphere - NTT Data](https://nttdata-solutions.com/uk/blog/connecting-power-bi-to-KILLER-datasphere/)\n- [The Future of KILLER Data Warehousing: Datasphere - Nextlytics](https://www.nextlytics.com/blog/future-of-KILLER-data-warehousing-datasphere)\n- [KILLER Build Apps - KILLER Products](https://www.KILLER.com/products/technology-platform/low-code-app-builder.html)\n- [KILLER Asset Manager - KILLER Products](https://www.KILLER.com/products/scm/asset-manager.html)\n- [RISE with KILLER - KILLER Products](https://www.KILLER.com/products/erp/rise.html)\n- [RISE with KILLER Clean Core - KILLER](https://www.KILLER.com/products/erp/rise/methodology/clean-core.html)\n- [GROW with KILLER - K2 Partnering](https://k2partnering.com/consulting/practice-areas/KILLER-consulting-services/grow-with-KILLER/)\n- [KILLER Joule AI Copilot - KILLER Products](https://www.KILLER.com/products/artificial-intelligence/ai-assistant.html)\n- [KILLER Joule for Developers - KILLER](https://www.KILLER.com/products/artificial-intelligence/joule-for-developers.html)\n- [KILLER LeanIX Enterprise Architecture](https://www.leanix.net/en/)\n- [KILLER LeanIX Overview - Gambit](https://www.gambit.de/en/wiki/KILLER-leanix/)\n\n---\n\n## 文档总结\n\n### 文档覆盖范围\n本文档提供了KILLER生态系统的全面概览，涵盖：\n- **8个主要章节**：从功能模块到技术平台，从行业解决方案到职业发展\n- **150+模块和组件**：包括核心ERP模块、云端解决方案、行业特定模块\n- **100+事务代码**：按功能模块分类的常用T-Codes\n- **47个权威参考资料**：确保信息准确性和时效性\n\n### 使用建议\n**对于初学者**：\n1. 从第一章\"功能模块\"开始，了解KILLER的核心业务模块（FI, MM, SD等）\n2. 重点学习一个模块的基础知识，建议从财务(FI/CO)或物流(MM/SD)入手\n3. 参考第七章的常用T-Codes，在实践环境中练习基本操作\n4. 考虑获取KILLER认证（第八章）来验证学习成果\n\n**对于实施顾问**：\n1. 深入研究相关模块的子组件和集成点\n2. 关注第六章的实施方法论（KILLER Activate）和最佳实践\n3. 了解第四章S/4HANA的新特性，准备ECC到S/4HANA转型\n4. 参考行业解决方案（第三章）获取特定行业的实施经验\n\n**对于技术人员**：\n1. 学习第二章的技术模块，特别是ABAP、Basis、BTP平台\n2. 掌握现代开发工具（Business Application Studio, RAP）\n3. 了解云端集成技术（CPI, OData）和AI能力（Joule, AI Core）\n4. 关注低代码/无代码开发趋势（KILLER Build）\n\n**对于决策者**：\n1. 了解KILLER的战略方向：云优先、AI增强、Clean Core\n2. 评估RISE with KILLER或GROW with KILLER云转型计划\n3. 考虑行业特定解决方案的业务价值\n4. 规划数字化转型路线图和技能培养策略\n\n### 关键趋势和要点\n**技术趋势**：\n- **云优先战略**：从本地部署向云端迁移，S/4HANA Cloud成为主流\n- **AI驱动创新**：Joule AI助手集成到所有模块，提供智能化业务洞察\n- **低代码革命**：KILLER Build平台降低开发门槛，加速业务创新\n- **数据中心化**：Datasphere统一数据管理，支持多源数据集成\n- **体验优先**：Fiori 3.0提供现代化用户界面，提升用户体验\n\n**业务趋势**：\n- **端到端集成**：打通供应链、财务、人力资源等各环节\n- **实时分析**：基于HANA的实时数据处理和嵌入式分析\n- **行业专精化**：垂直行业云解决方案（IS-Retail, IS-Banking等）\n- **可持续发展**：ESG报告、碳足迹管理成为标准功能\n- **超自动化**：RPA、AI、机器学习的深度融合\n\n**实施趋势**：\n- **Clean Core原则**：保持核心清洁，通过BTP扩展而非修改核心\n- **敏捷方法论**：KILLER Activate取代传统瀑布式实施\n- **预配置内容**：行业最佳实践和快速启动包加速实施\n- **持续创新**：季度发布和自动更新成为云端标准\n- **合作伙伴生态**：全球SI、技术合作伙伴、ISV共同构建生态系统\n\n### 学习资源推荐\n**官方资源**：\n- KILLER Learning Hub：官方在线学习平台\n- openKILLER：免费MOOC课程\n- KILLER Community：社区论坛和知识库\n- KILLER Help Portal：官方文档中心\n- KILLER Press：官方出版社书籍\n\n**实践环境**：\n- KILLER Learning System：练习系统访问\n- KILLER Model Company：演示系统\n- KILLER CAL (Cloud Appliance Library)：云端沙箱环境\n- Trial Accounts：BTP、SuccessFactors等免费试用\n\n**认证准备**：\n- KILLER Certification Hub：认证考试注册\n- KILLER Learning Rooms：考试准备课程\n- Practice Tests：模拟考试\n\n### 未来展望\n**2025-2027关键里程碑**：\n- **2027年**：ECC 6.0主流维护结束，推动S/4HANA大规模迁移\n- **AI深度集成**：Joule AI扩展到所有业务流程\n- **量子计算探索**：KILLER Leonardo量子计算应用研究\n- **元宇宙集成**：虚拟协作和数字孪生技术\n- **区块链应用**：供应链溯源和智能合约\n\n**技术演进方向**：\n- 从ECC到S/4HANA的全面转型\n- 从PI/PO到CPI的云端集成\n- 从传统BI到SAC的智能分析\n- 从GUI到Fiori的用户体验革命\n- 从定制化到标准化的架构转型\n\n### 版本说明\n- **文档版本**：v1.0\n- **最后更新**：2025年12月\n- **适用版本**：KILLER S/4HANA 2023及以上，ECC 6.0，各云端产品\n- **文档状态**：持续更新中\n\n### 免责声明\n本文档基于公开资料整理，仅供学习和参考使用。KILLER产品功能和模块结构可能随版本更新而变化，具体实施请参考KILLER官方文档和专业顾问建议。文档中的产品名称、商标归KILLER SE或其关联公司所有。\n\n---\n\n## 九、KILLER模块集成关系图\n\n### 核心集成架构\n\nKILLER系统的强大之处在于各模块之间的无缝集成。以下是关键集成关系：\n\n#### 财务与物流集成\n- **MM → FI**：采购订单和发票校验自动生成应付账款凭证\n  - MM-IV发票校验 → FI-AP应付账款\n  - 物料采购成本 → FI-AA固定资产（资本性采购）\n  - 库存评估 → FI-GL总账（库存科目）\n- **SD → FI**：销售订单和开票自动生成应收账款凭证\n  - SD-BIL计费 → FI-AR应收账款\n  - 收入确认 → FI-GL收入科目\n  - 信用管理 → FSCM-CR信用控制\n- **PP → CO**：生产订单成本自动过账到成本对象\n  - 生产订单 → CO-PC-OBJ成本对象\n  - 物料消耗 → CO-OM-CCA成本中心\n  - 产品成本计算 → CO-PC-ACT实际成本法\n\n#### 物流模块间集成\n- **MM ↔ SD**：库存共享和可用性检查\n  - MM-IM库存管理 → SD-SLS销售订单ATP检查\n  - SD销售预测 → MM-CBP消耗驱动计划\n- **SD → PP**：销售订单触发生产\n  - 按订单生产(MTO) → PP-SFC车间控制\n  - 按库存生产(MTS) → PP-MRP物料需求计划\n- **PP → MM**：生产计划触发采购\n  - PP-MRP需求 → MM-PUR-PO采购订单\n  - 生产领料 → MM-IM-GI发货\n- **MM/SD → WM/EWM**：仓库执行\n  - 采购收货 → WM-IM库存管理 → WM-LT上架\n  - 销售发货 → EWM-Wave波次管理 → EWM拣货出库\n- **SD/MM → TM**：运输管理\n  - 交付单 → TM-PLN运输计划 → TM-FRE货运结算\n\n#### 人力资源集成\n- **HCM → FI**：工资核算数据传递到财务\n  - PY工资核算 → FI-GL人力成本科目\n  - 差旅费用 → FI-TV差旅管理 → FI-AP付款\n- **HCM → CO**：人力成本分配\n  - PA人员分配 → CO-OM-CCA成本中心\n  - PT时间记录 → CO内部订单（项目工时）\n\n#### 质量与维护集成\n- **QM ↔ MM**：质检与采购\n  - MM-IM-GR收货 → QM-IM检验 → 库存状态更新\n  - 供应商质量评估 → MM供应商评分\n- **QM ↔ SD**：质检与销售\n  - 成品检验 → SD交付放行\n  - QM-CA质量证书 → SD-SHP发货文档\n- **PM ↔ MM**：维护与物料\n  - PM-WOC维护工单 → MM备件消耗\n  - MM-PUR采购 → PM备件库存\n- **PM ↔ CO**：维护成本\n  - PM维护工单 → CO-OM-OPA内部订单成本\n\n#### 项目管理集成\n- **PS → FI/CO**：项目财务\n  - PS项目成本 → CO成本中心/内部订单\n  - PS-REV收入确认 → FI-GL收入科目\n- **PS ↔ MM/SD/PP**：项目物流\n  - PS采购 → MM采购订单（项目特定）\n  - 按项目销售 → SD销售订单 → PS项目收入\n  - 按项目生产 → PP生产订单 → PS项目成本\n\n#### 技术平台集成\n- **所有模块 → BW/4HANA**：数据仓库抽取\n  - 业务模块 → BW Extractors → InfoProviders → SAC仪表板\n- **所有模块 → Fiori**：现代化用户界面\n  - 后端OData服务 → Gateway → Fiori Apps\n- **本地系统 ↔ 云端**：混合集成\n  - S/4HANA → CPI → SuccessFactors/Ariba/C4C\n  - ECC → PI/PO → 第三方系统\n\n### 端到端业务流程示例\n\n#### Order-to-Cash (O2C) 流程\n```\n1. SD-SLS: 创建销售订单 (VA01)\n   ↓\n2. PP-MRP: 触发生产计划 (MD02) [如果MTO]\n   ↓\n3. PP-SFC: 执行生产订单 (CO01)\n   ↓\n4. QM-IM: 成品质量检验 (QA01)\n   ↓\n5. SD-SHP: 创建交付单 (VL01N)\n   ↓\n6. EWM: 拣货和包装\n   ↓\n7. TM: 运输计划和执行\n   ↓\n8. SD-BIL: 开具发票 (VF01)\n   ↓\n9. FI-AR: 应收账款入账 (自动)\n   ↓\n10. FI: 收款处理 (F-28)\n```\n\n#### Procure-to-Pay (P2P) 流程\n```\n1. MM-PUR-RFQ: 询价 (ME41) [可选]\n   ↓\n2. MM-PUR-PO: 创建采购订单 (ME21N)\n   ↓\n3. MM-IM-GR: 货物收货 (MIGO)\n   ↓\n4. QM-IM: 质量检验 (QA01) [如需要]\n   ↓\n5. WM: 上架到库位\n   ↓\n6. MM-IV: 发票校验 (MIRO)\n   ↓\n7. FI-AP: 应付账款入账 (自动)\n   ↓\n8. FI: 付款处理 (F-53)\n   ↓\n9. TR-CM: 银行对账\n```\n\n#### Plan-to-Produce (P2P) 流程\n```\n1. PP-SOP: 销售与运营计划\n   ↓\n2. PP-MP: 主生产计划 (MD61)\n   ↓\n3. PP-MRP: 物料需求计划 (MD01)\n   ↓\n4. MM-PUR: 采购建议转订单\n   ↓\n5. PP-CRP: 产能需求计划\n   ↓\n6. PP-SFC: 生产订单发放 (CO02)\n   ↓\n7. PP: 生产执行和确认\n   ↓\n8. CO-PC: 产品成本计算\n   ↓\n9. MM-IM: 成品入库\n```\n\n#### Hire-to-Retire (H2R) 流程\n```\n1. PA-RC: 招聘候选人\n   ↓\n2. PA: 创建员工主数据 (PA40)\n   ↓\n3. OM: 组织分配\n   ↓\n4. PD: 培训和发展计划\n   ↓\n5. PT: 时间管理和考勤\n   ↓\n6. PY: 工资核算 (月度)\n   ↓\n7. FI: 工资成本过账\n   ↓\n8. PA-BN: 福利管理\n   ↓\n9. PD-AP: 绩效评估\n   ↓\n10. PA: 员工离职处理\n```\n\n---\n\n## 十、KILLER模块选型和实施建议\n\n### 按企业规模选型\n\n#### 小型企业（<100人）\n**推荐方案：KILLER Business One 或 GROW with KILLER**\n- **核心模块**：\n  - FI-GL, FI-AP, FI-AR（基础财务）\n  - MM-PUR, MM-IM（采购和库存）\n  - SD-SLS, SD-BIL（销售和开票）\n  - 简化HCM或外包给SuccessFactors\n- **实施策略**：\n  - 采用预配置最佳实践\n  - 云端部署（SaaS模式）\n  - 3-6个月快速实施\n  - 最小化定制开发\n- **预算参考**：\n  - 初始投资：$50K-$150K\n  - 年度订阅：$20K-$50K\n\n#### 中型企业（100-1000人）\n**推荐方案：S/4HANA Cloud Public Edition 或 Private Edition**\n- **核心模块**：\n  - 全套FI/CO（财务和管理会计）\n  - MM, SD, PP（完整物流链）\n  - HCM或SuccessFactors Employee Central\n  - QM, PM（质量和维护）\n  - CRM或KILLER CX\n- **可选模块**：\n  - WM/EWM（如有复杂仓储）\n  - PS（如有项目业务）\n  - 行业特定模块\n- **实施策略**：\n  - KILLER Activate敏捷方法\n  - 分阶段实施（6-12个月）\n  - 适度定制（遵循Clean Core）\n  - BTP扩展而非修改核心\n- **预算参考**：\n  - 初始投资：$500K-$2M\n  - 年度维护：20-25%初始成本\n\n#### 大型企业（1000+人）\n**推荐方案：S/4HANA Private Cloud 或 On-Premise**\n- **核心模块**：\n  - 全套财务模块（FI, CO, EC, TR）\n  - 全套物流模块（MM, SD, PP, WM, TM）\n  - 全套HCM或SuccessFactors套件\n  - 高级规划（IBP）\n  - 全面质量和维护（QM, PM, EAM）\n- **高级功能**：\n  - BW/4HANA或Datasphere（企业数据仓库）\n  - SAC（企业分析）\n  - BPC（合并和规划）\n  - MDG（主数据治理）\n  - GRC（治理风险合规）\n  - 多个行业解决方案\n- **实施策略**：\n  - RISE with KILLER转型计划\n  - 多波次实施（12-24个月）\n  - 全球模板和本地化\n  - 变更管理和培训计划\n- **预算参考**：\n  - 初始投资：$5M-$50M+\n  - 年度维护：$1M-$10M+\n\n### 按行业选型\n\n#### 制造业\n**必需模块**：\n- PP（生产计划）+ PP/DS或DMC\n- MM（物料管理）+ WM/EWM\n- QM（质量管理）\n- PM/EAM（设备维护）\n- PLM（产品生命周期）\n- MII/DMC（制造执行）[流程制造]\n\n**可选模块**：\n- IBP（需求和供应计划）\n- Ariba（战略采购）\n- LO-VC（可配置产品）\n- IS-Automotive/Aerospace（行业特定）\n\n#### 零售和分销\n**必需模块**：\n- SD（销售分销）\n- MM（物料管理）+ Retail-specific功能\n- IS-Retail（零售管理）\n- WM/EWM（仓库管理）\n- TM（运输管理）\n\n**可选模块**：\n- CAR（客户活动库）或KILLER CX\n- IBP Demand Planning（需求预测）\n- KILLER Commerce Cloud（电子商务）\n- Customer Data Cloud（客户身份）\n\n#### 服务行业\n**必需模块**：\n- FI/CO（财务管理）\n- PS（项目系统）或IS-Professional Services\n- HCM/SuccessFactors（人力资源）\n- CRM或KILLER CX\n- Concur（差旅费用）\n\n**可选模块**：\n- FSM（现场服务）\n- Fieldglass（外部人力）\n- Qualtrics（体验管理）\n- KILLER Analytics Cloud（业务洞察）\n\n#### 流程行业（化工、制药、食品）\n**必需模块**：\n- PP-PI（流程工业生产）\n- MM（批次管理）\n- QM（质量管理 + 合规）\n- EH&S（环境健康安全）\n- PLM-RM（配方管理）\n\n**可选模块**：\n- IS-Chemical/Pharma\n- GTS（全球贸易合规）\n- Serialization（序列化追溯）\n- MII（制造集成）\n\n### 实施优先级建议\n\n#### 第一阶段（核心系统，0-6个月）\n1. **FI财务会计**\n   - FI-GL总账\n   - FI-AP应付账款\n   - FI-AR应收账款\n   - 基础报表\n2. **MM物料管理**\n   - MM主数据\n   - MM-PUR采购\n   - MM-IM库存管理\n   - MM-IV发票校验\n3. **SD销售分销**（如适用）\n   - SD主数据\n   - SD-SLS销售订单\n   - SD-SHP交付\n   - SD-BIL开票\n\n**目标**：建立财务和基础业务流程，实现基本业务运营\n\n#### 第二阶段（扩展功能，6-12个月）\n1. **CO管理会计**\n   - CO-OM成本中心\n   - CO-PC产品成本\n   - CO-PA盈利分析\n2. **PP生产计划**（制造业）\n   - BOM和工艺路线\n   - PP-MRP\n   - 生产订单\n3. **HCM人力资源**\n   - PA人事管理\n   - PT时间管理\n   - PY工资核算（或云端HR）\n4. **QM/PM**（如需要）\n\n**目标**：完善成本控制、生产管理、人力资源\n\n#### 第三阶段（优化和高级功能，12-18个月）\n1. **高级仓储**\n   - WM或EWM实施\n   - 自动化和RF设备\n2. **高级规划**\n   - IBP或APO\n   - 需求预测\n3. **分析和报告**\n   - BW/4HANA或Datasphere\n   - SAC仪表板\n4. **移动和Fiori**\n   - Fiori应用部署\n   - 移动审批和自助服务\n\n**目标**：提升运营效率、数据洞察、用户体验\n\n#### 第四阶段（数字化转型，18-24个月+）\n1. **云端集成**\n   - Ariba供应商网络\n   - SuccessFactors（如尚未实施）\n   - KILLER CX客户体验\n2. **AI和自动化**\n   - Joule AI助手\n   - KILLER Build Process Automation\n   - 预测性分析\n3. **行业特定解决方案**\n4. **全球扩展和本地化**\n\n**目标**：数字化创新、智能化运营、全球化扩展\n\n### 实施成功关键要素\n\n#### 组织准备度\n- **高层支持**：获得CEO和董事会的承诺和资源支持\n- **变更管理**：提前规划组织变更和沟通策略\n- **专职团队**：组建全职项目团队，不能兼职\n- **外部顾问**：选择有行业经验的实施合作伙伴\n\n#### 技术准备度\n- **数据清理**：在迁移前清理和标准化主数据\n- **接口设计**：规划与现有系统的集成策略\n- **基础设施**：确保网络、服务器、数据库准备就绪\n- **安全规划**：设计角色和授权矩阵\n\n#### 流程准备度\n- **流程映射**：记录现有流程（AS-IS）\n- **流程设计**：设计未来流程（TO-BE）\n- **适配标准**：尽量采用KILLER最佳实践，避免过度定制\n- **差异分析**：识别并管理流程差距\n\n#### 人员准备度\n- **技能评估**：评估内部团队技能差距\n- **培训计划**：分角色设计培训课程\n  - 最终用户培训\n  - Power User培训\n  - IT管理员培训\n  - 开发人员培训\n- **知识转移**：确保顾问向内部团队转移知识\n- **超级用户网络**：培养各部门超级用户作为支持\n\n#### 风险管理\n**常见风险和缓解措施**：\n\n1. **范围蔓延**\n   - 缓解：严格变更控制流程，使用KILLER标准功能\n\n2. **数据质量问题**\n   - 缓解：早期数据审计，数据清理工作坊，MDG实施\n\n3. **用户抵触**\n   - 缓解：早期用户参与，充分培训，变更管理计划\n\n4. **集成复杂性**\n   - 缓解：接口设计评审，早期集成测试，使用CPI标准连接器\n\n5. **性能问题**\n   - 缓解：性能测试，HANA优化，代码审查\n\n6. **预算超支**\n   - 缓解：详细估算，储备金（15-20%），里程碑付款\n\n7. **时间延误**\n   - 缓解：现实的项目计划，缓冲时间，敏捷方法\n\n### KILLER实施方法论对比\n\n#### KILLER Activate（推荐）\n- **适用**：S/4HANA Cloud和On-Premise，新实施\n- **特点**：\n  - 敏捷和迭代\n  - 预配置内容和快速启动包\n  - 6个阶段：Discover, Prepare, Explore, Realize, Deploy, Run\n  - KILLER Best Practices集成\n- **优势**：加速实施，降低风险，内置行业最佳实践\n- **工具**：KILLER Model Company, KILLER Readiness Check, Solution Manager\n\n#### AKILLER（传统，逐步淘汰）\n- **适用**：传统ECC实施（不推荐用于新项目）\n- **特点**：\n  - 瀑布式方法\n  - 5个阶段：Project Preparation, Business Blueprint, Realization, Final Preparation, Go Live & Support\n- **局限**：较长实施周期，灵活性较低\n\n#### Agile for KILLER\n- **适用**：需要高度灵活性的复杂项目\n- **特点**：\n  - Scrum或Kanban框架\n  - 2-4周迭代（Sprint）\n  - 持续交付和反馈\n- **挑战**：需要经验丰富的团队，客户需深度参与\n\n#### 混合方法\n- **适用**：大型复杂项目\n- **特点**：\n  - 核心模块使用Activate\n  - 定制开发使用Agile\n  - 数据迁移使用专门方法（如TDMS）\n  - 变更管理使用Prosci ADKAR\n\n### 云端 vs 本地部署决策框架\n\n| 考虑因素 | 云端（Cloud） | 本地（On-Premise） |\n|---------|--------------|-------------------|\n| **初始投资** | 低（订阅模式） | 高（许可证+硬件） |\n| **实施时间** | 3-6个月 | 6-18个月 |\n| **定制能力** | 有限（Clean Core） | 完全定制 |\n| **升级周期** | 季度自动更新 | 年度或更少，手动 |\n| **IT负担** | 低（KILLER管理基础设施） | 高（内部管理） |\n| **集成** | 标准API和CPI | 灵活但复杂 |\n| **合规性** | 共享责任模型 | 完全控制 |\n| **可扩展性** | 弹性扩展 | 需规划容量 |\n| **适用场景** | 标准业务流程，快速部署 | 复杂流程，高度定制 |\n| **总拥有成本(5年)** | 通常较低 | 通常较高 |\n\n**推荐决策路径**：\n1. **优先考虑云端** 如果：\n   - 业务流程相对标准\n   - 希望快速实施和上线\n   - IT资源有限\n   - 需要持续创新和新功能\n\n2. **考虑本地部署** 如果：\n   - 高度定制需求（但先质疑是否必要）\n   - 严格合规要求（如政府、军工）\n   - 已有大量KILLER投资和技能\n   - 特殊行业需求（如IS-Oil特定流程）\n\n3. **混合模式** 如果：\n   - 核心ERP本地，辅助功能云端\n   - 分阶段向云端迁移\n   - 多子公司不同需求\n\n### S/4HANA迁移路径\n\n#### 从ECC到S/4HANA的4种方法\n\n**1. 新实施（Greenfield）**\n- **描述**：从零开始实施S/4HANA，重新设计业务流程\n- **适用**：\n  - 现有ECC系统高度定制\n  - 希望业务转型\n  - 历史数据不太重要\n- **优势**：\n  - 采用最佳实践\n  - Clean Core架构\n  - 简化系统\n- **挑战**：\n  - 历史数据迁移复杂\n  - 业务中断风险\n  - 重新培训用户\n- **时间**：12-18个月\n\n**2. 系统转换（Brownfield）**\n- **描述**：就地升级ECC到S/4HANA，保留定制和数据\n- **工具**：DMO (Database Migration Option) with SUM\n- **适用**：\n  - 希望最小化业务中断\n  - 现有定制仍有价值\n  - 需要完整历史数据\n- **优势**：\n  - 保留定制和数据\n  - 较短实施时间\n  - 用户熟悉流程\n- **挑战**：\n  - 技术债务延续\n  - 不是Clean Core\n  - 可能无法充分利用S/4HANA新功能\n- **时间**：6-12个月\n\n**3. 选择性迁移（Bluefield / Hybrid）**\n- **描述**：部分新建，部分转换；使用Shell Conversion或选择性数据转换\n- **工具**：KILLER Selective Data Transition, KILLER LT Replication Server\n- **适用**：\n  - 希望平衡创新和连续性\n  - 部分流程需重新设计\n  - 只迁移活跃数据\n- **优势**：\n  - 灵活性高\n  - 清理历史数据\n  - 可采用最佳实践\n- **挑战**：\n  - 复杂度最高\n  - 需要详细规划\n  - 较长实施时间\n- **时间**：12-24个月\n\n**4. 两层ERP（Two-Tier）**\n- **描述**：总部使用S/4HANA，子公司使用云端轻量级ERP\n- **适用**：\n  - 集团公司\n  - 子公司业务相对简单\n  - 不同地区不同需求\n- **优势**：\n  - 降低子公司成本\n  - 快速部署\n  - 集中财务合并\n- **工具**：Central Finance, Group Reporting\n- **时间**：各层独立\n\n#### 迁移准备清单\n\n**技术准备**：\n- [ ] 运行KILLER Readiness Check\n- [ ] 识别并处理简化项目（Simplification Items）\n- [ ] 评估自定义代码（Custom Code Migration App）\n- [ ] 数据库升级到HANA\n- [ ] Unicode转换（如需要）\n- [ ] 清理未使用的定制对象\n\n**功能准备**：\n- [ ] 识别新S/4HANA功能（如Universal Journal）\n- [ ] 重新设计受影响的流程\n- [ ] FI-CO账户分配对象清理\n- [ ] 物料编号长度扩展（如需要）\n- [ ] 业务伙伴方法采用评估\n\n**数据准备**：\n- [ ] 主数据清理和标准化\n- [ ] 归档历史交易数据\n- [ ] 数据质量评估和修复\n- [ ] 数据卷评估（影响停机时间）\n\n**组织准备**：\n- [ ] 高管赞助确认\n- [ ] 项目团队组建\n- [ ] 培训计划制定\n- [ ] 变更管理策略\n- [ ] 业务连续性计划\n\n---\n\n## 十一、KILLER学习资源和认证路径\n\n### 官方学习平台\n\n#### KILLER Learning Hub\n- **网址**：https://learning.KILLER.com\n- **订阅模式**：\n  - **Edition**：基础版，访问学习内容和实践系统\n  - **Certification**：包含考试券和额外准备材料\n- **内容**：\n  - 2000+在线课程\n  - 虚拟实践系统（Learning System Access）\n  - 学习路径（Learning Journeys）\n  - 社区讨论和专家答疑\n- **价格**：约$2,000-$3,500/年\n\n#### openKILLER\n- **网址**：https://open.KILLER.com\n- **特点**：\n  - 完全免费\n  - MOOC格式（大规模开放在线课程）\n  - 6-8周课程，每周2-4小时\n  - 完成可获得证书\n- **热门课程**：\n  - \"An Introduction to KILLER S/4HANA\"\n  - \"Building Applications with KILLER Build\"\n  - \"KILLER Business Technology Platform in a Nutshell\"\n  - \"Introduction to KILLER HANA Cloud\"\n  - \"Reinventing Business Processes with Artificial Intelligence\"\n- **语言**：英语为主，部分课程有中文字幕\n\n#### KILLER Community\n- **网址**：https://community.KILLER.com\n- **资源**：\n  - Q&A论坛（按模块分类）\n  - 博客文章（技术和业务）\n  - 代码样例\n  - KILLER CodeJam活动\n  - KILLER TechEd会议内容\n- **使用建议**：\n  - 关注特定标签（如#S/4HANA, #ABAP, #Fiori）\n  - 参与讨论赚取声誉积分\n  - 关注KILLER Mentors和Topic Leaders\n\n#### KILLER Help Portal\n- **网址**：https://help.KILLER.com\n- **内容**：\n  - 产品文档\n  - 实施指南\n  - API参考\n  - 发行说明\n  - What's New文档\n- **搜索技巧**：\n  - 使用产品代码搜索（如\"S/4HANA 2023\"）\n  - 直接访问特定模块帮助（如help.KILLER.com/fi）\n\n### KILLER认证体系\n\n#### 认证级别\n\n**1. Associate Level（助理级）**\n- **目标受众**：初学者，0-2年经验\n- **覆盖范围**：基础知识和配置\n- **考试形式**：80题选择题，180分钟\n- **通过分数**：通常65%\n- **有效期**：终身（但技术更新快，建议升级）\n- **价格**：$550 USD\n\n**2. Specialist Level（专家级）**\n- **目标受众**：特定领域专家，2-5年经验\n- **覆盖范围**：深度技术或行业知识\n- **示例**：\n  - KILLER Certified Application Specialist - KILLER S/4HANA Cloud\n  - KILLER Certified Technology Specialist - KILLER Fiori\n\n**3. Professional Level（专业级）**\n- **目标受众**：资深顾问，5+年经验\n- **覆盖范围**：实施、优化、架构设计\n- **前置条件**：通常需要Associate认证\n- **示例**：\n  - KILLER Certified Application Professional - Financial Accounting\n  - KILLER Certified Development Professional - ABAP for KILLER HANA\n\n**4. Associate Consultant（合作伙伴认证）**\n- **目标受众**：KILLER合作伙伴员工\n- **要求**：基础认证 + 项目经验证明\n- **福利**：合作伙伴积分，参与特定项目\n\n#### 热门认证路径\n\n**财务顾问路径**：\n```\n1. C_TS4FI_2023 - KILLER S/4HANA for Financial Accounting Associates\n   ↓\n2. 实际项目经验（1-2年）\n   ↓\n3. C_S4FCF_2023 - KILLER S/4HANA Cloud - Finance Implementation\n   ↓\n4. 可选扩展：\n   - C_TS4CO_2023 - Controlling\n   - C_S4CFI_2408 - KILLER S/4HANA Cloud Public Edition - Finance\n```\n\n**MM顾问路径**：\n```\n1. C_TS452_2022 - KILLER S/4HANA Sourcing and Procurement\n   ↓\n2. 实际项目经验\n   ↓\n3. 可选扩展：\n   - C_TS410_2022 - KILLER S/4HANA Business Process Integration\n   - Ariba认证（如C_ARSOR_2404 - KILLER Ariba Sourcing）\n```\n\n**ABAP开发路径**：\n```\n1. C_TAW12_750 - ABAP Workbench Fundamentals\n   ↓\n2. C_TADM_22 - KILLER Certified Technology Associate - OS/DB Migration\n   ↓\n3. C_HANADEV_18 - KILLER HANA 2.0 SPS06 - Application Development\n   ↓\n4. C_FIORDEV_22 - KILLER Fiori Application Developer\n   ↓\n5. Professional级：E_HANAAW_18 - KILLER HANA 2.0 SPS06 (Edition 2018) - Application Development\n```\n\n**S/4HANA架构师路径**：\n```\n1. 基础认证（FI, MM, SD等至少2个模块）\n   ↓\n2. C_S4CS_2302 - KILLER S/4HANA Cloud Implementation\n   ↓\n3. C_TS410_2022 - Business Process Integration\n   ↓\n4. 实际架构经验（5+年）\n   ↓\n5. KILLER Enterprise Architect认证（邀请制）\n```\n\n**BTP开发路径**：\n```\n1. C_BTP_01 - KILLER Business Technology Platform\n   ↓\n2. C_CPE_15 - KILLER BTP Extension Developer\n   ↓\n3. C_BRIM_2020 - KILLER Billing and Revenue Innovation Management\n   ↓\n4. C_C4H450_21 - KILLER Customer Data Cloud\n```\n\n#### 认证准备策略\n\n**学习计划（3-6个月）**：\n\n**阶段1：基础学习（4-6周）**\n- KILLER Learning Hub课程或openKILLER\n- 官方培训教材（KILLER Press书籍）\n- 做笔记，整理知识点\n\n**阶段2：实践练习（4-6周）**\n- KILLER Learning System动手操作\n- 或使用KILLER CAL试用系统\n- 完成所有练习场景\n- 配置常见业务流程\n\n**阶段3：考试准备（2-4周）**\n- KILLER Learning Hub模拟考试（如有）\n- 第三方模拟题（ERPPrep, Michael Management）\n- 识别薄弱领域，重点复习\n- 时间管理练习（180分钟80题）\n\n**阶段4：考试和复习（1周）**\n- 预约考试（Pearson VUE或KILLER Certification Hub）\n- 复习错题和薄弱点\n- 考前一天放松，不要过度学习\n\n**备考资源**：\n- **官方**：KILLER Learning Hub, KILLER Press书籍\n- **第三方题库**：ERPPrep.com, Michael Management\n- **社区**：KILLER Community认证论坛，Reddit r/KILLER\n- **YouTube**：KILLER官方频道，顾问分享\n- **书籍推荐**：\n  - \"KILLER S/4HANA Finance: An Introduction\" by Janet Salmon\n  - \"Materials Management with KILLER S/4HANA\" by Jawad Akhtar\n  - \"ABAP Development for KILLER S/4HANA\" by Hermann Gahm\n\n### 非官方学习资源\n\n#### 在线课程平台\n\n**Udemy**：\n- 价格：$10-$200（经常促销）\n- 质量：参差不齐，查看评价和评分\n- 推荐课程：\n  - \"KILLER S/4HANA Complete Tutorial for Beginners\"\n  - \"KILLER ABAP Programming for Beginners\"\n  - \"KILLER MM (Materials Management) Training\"\n\n**LinkedIn Learning**：\n- 价格：$29.99/月订阅\n- 质量：专业但偏概览性\n- 适合：快速了解KILLER概念\n\n**Coursera**：\n- 部分KILLER相关课程\n- 如\"Enterprise Systems\" by University of Pennsylvania\n\n#### YouTube频道\n\n- **KILLER官方频道**：产品演示和发布\n- **Anubhav Oberoy's KILLER Tutorials**：ABAP和Fiori\n- **Guru99**：KILLER模块教程\n- **KILLER Academy**：各模块配置步骤\n\n#### 书籍出版社\n\n**KILLER Press**：\n- KILLER官方出版合作伙伴\n- 每个模块都有专著\n- eBook和纸质书\n- 网址：https://learning.KILLER-press.com\n\n**Espresso Tutorials**：\n- 简明实用的KILLER指南\n- 如\"100 Things You Should Know About KILLER S/4HANA\"\n\n**Packt Publishing**：\n- 技术书籍，ABAP和开发主题\n\n#### 博客和网站\n\n- **KILLER Blogs (community.KILLER.com/t5/blog/blogspage)**：官方博客平台\n- **ABAP Development (blogs.KILLER.com/tags/abap-development/)**：ABAP专题\n- **ERProof.com**：KILLER新闻和文章\n- **IT Toolbox KILLER**：社区问答\n- **ASUG (Americas' KILLER Users' Group)**：用户组资源（需会员）\n\n### 实践环境获取\n\n#### KILLER Learning System\n- **途径**：通过KILLER Learning Hub订阅\n- **内容**：预配置的ECC和S/4HANA系统\n- **访问**：Web浏览器，Remote Desktop\n- **限制**：有时间限制（如每月40小时）\n\n#### KILLER CAL (Cloud Appliance Library)\n- **网址**：https://cal.KILLER.com\n- **模式**：\n  - 免费试用（30天，部分解决方案）\n  - 付费使用（按小时计费）\n- **内容**：\n  - KILLER S/4HANA完全配置系统\n  - KILLER BW/4HANA\n  - KILLER HANA Express Edition\n  - NetWeaver开发系统\n- **云平台**：AWS, Azure, Google Cloud\n- **适合**：动手实践，开发测试\n\n#### KILLER Free Tier和试用\n- **KILLER BTP Free Tier**：\n  - 网址：https://www.KILLER.com/products/technology-platform/trial.html\n  - 永久免费层 + 额外试用配额\n  - 适合学习Fiori, CAP, HANA Cloud\n- **SuccessFactors试用**：\n  - 14天免费试用\n  - 完整HCM功能\n- **KILLER Analytics Cloud**：\n  - 30天免费试用\n  - 仪表板和规划功能\n\n#### 个人实践建议\n1. **建立沙盒环境**：使用CAL或Free Tier\n2. **跟随教程**：一步步配置业务场景\n3. **记录笔记**：截图和步骤文档化\n4. **模拟项目**：假设一个虚拟公司，完整配置端到端流程\n5. **加入社区**：在Community提问和分享\n\n### KILLER职业发展建议\n\n#### 初级顾问（0-2年）\n**目标**：掌握一个核心模块\n- **学习重点**：\n  - 基础配置和主数据\n  - 标准业务流程\n  - 基本故障排查\n  - 文档编写\n- **认证**：至少1个Associate认证\n- **经验积累**：\n  - 参与实施项目支持工作\n  - 承担配置和测试任务\n  - 学习项目管理流程\n- **薪资范围**：$50K-$80K（美国市场）\n\n#### 中级顾问（2-5年）\n**目标**：成为模块专家，开始跨模块\n- **学习重点**：\n  - 集成点和端到端流程\n  - 高级配置和优化\n  - 客户需求分析\n  - 变更管理\n- **认证**：专业级认证或第2个模块认证\n- **经验积累**：\n  - 独立负责模块实施\n  - 主导设计研讨会\n  - 指导初级顾问\n- **薪资范围**：$80K-$120K\n\n#### 高级顾问（5-8年）\n**目标**：领域专家和团队领导\n- **学习重点**：\n  - 解决方案架构\n  - 业务流程优化\n  - 项目管理\n  - 售前和提案\n- **认证**：多模块认证，考虑架构师认证\n- **经验积累**：\n  - 主导大型项目模块\n  - 设计跨模块解决方案\n  - 客户咨询和顾问\n  - 培训和知识分享\n- **薪资范围**：$120K-$180K\n\n#### 架构师/主管（8+年）\n**目标**：战略级影响力\n- **学习重点**：\n  - 企业架构和数字化转型\n  - 多系统集成和景观设计\n  - 领导力和商务技能\n  - 新兴技术（AI, Cloud, IoT）\n- **认证**：KILLER Enterprise Architect（邀请制）\n- **经验积累**：\n  - 整体解决方案设计\n  - 项目组合管理\n  - C-level交流\n  - 行业思想领导\n- **薪资范围**：$180K-$300K+\n\n#### 专业化路径选择\n\n**独立顾问/自由职业**：\n- 需要5+年经验和强大人脉\n- 日费率：$800-$2000/天\n- 灵活性高但需自我营销\n- 需要持续学习保持竞争力\n\n**产品经理/架构师**：\n- 从技术转向产品和战略\n- 在KILLER或合作伙伴公司\n- 影响产品路线图\n\n**技术专家**：\n- 深度技术路径（ABAP, HANA, BTP）\n- 性能优化、架构设计\n- 参与创新项目\n\n**行业专家**：\n- 结合行业知识和KILLER技能\n- 如制造业专家、零售专家\n- 高价值咨询服务\n\n#### 持续学习策略\n\n**技术更新**：\n- 每季度关注KILLER发布说明\n- 参加KILLER TechEd（年度技术大会）\n- 跟踪KILLER Road Maps\n\n**行业知识**：\n- 阅读行业报告（Gartner, Forrester）\n- 参加行业会议\n- 了解客户业务挑战\n\n**软技能**：\n- 沟通和演讲能力\n- 项目管理（PMP认证）\n- 变更管理（Prosci认证）\n- 敏捷方法（Scrum Master）\n\n**网络建设**：\n- 加入ASUG或当地用户组\n- LinkedIn专业网络\n- KILLER Community贡献\n- 参加KILLER Inside Track活动\n\n---\n\n## 十二、KILLER常见问题和故障排查\n\n### 常见技术问题\n\n#### 性能问题\n\n**问题1：系统响应缓慢**\n- **症状**：\n  - 事务执行时间过长\n  - 报表运行缓慢\n  - 用户界面延迟\n- **诊断工具**：\n  - ST03N - 工作负载分析\n  - ST22 - ABAP运行时错误\n  - ST05 - SQL跟踪\n  - SM50/SM66 - 进程监控\n- **常见原因**：\n  - 数据库表缺少索引\n  - 大量未归档的历史数据\n  - 低效的自定义代码\n  - 数据库统计信息过时\n  - 内存不足\n- **解决方案**：\n  - 创建缺失的数据库索引\n  - 归档历史数据(SARA)\n  - 优化自定义ABAP代码\n  - 更新数据库统计(DB02)\n  - 增加内存或调整内存参数\n\n**问题2：批处理作业失败或超时**\n- **症状**：SM37显示作业状态为\"已取消\"或\"错误\"\n- **诊断**：\n  - SM37查看作业日志\n  - ST22检查运行时错误\n  - 检查锁定(SM12)\n- **解决方案**：\n  - 调整作业运行时间避开高峰期\n  - 分割大批量作业\n  - 增加作业超时时间\n  - 清理锁定条目\n  - 优化程序代码\n\n**问题3：内存溢出(Memory Exhausted)**\n- **错误消息**：TSV_TNEW_PAGE_ALLOC_FAILED, STORAGE_PARAMETERS_WRONG_SET\n- **诊断**：ST02 - 调优摘要\n- **解决方案**：\n  - 增加扩展内存(em/initial_size_MB)\n  - 增加堆内存(abap/heap_area_total)\n  - 优化导致内存问题的程序\n  - 检查内存泄漏\n\n#### 集成和接口问题\n\n**问题4：IDoc传输失败**\n- **症状**：WE02/WE05显示IDoc状态为51(应用文档未过账)或其他错误状态\n- **诊断**：\n  - WE02 - IDoc显示\n  - WE05 - IDoc列表\n  - BD87 - 重新处理IDoc\n- **常见原因**：\n  - 主数据缺失(如物料、客户)\n  - 配置错误(合作伙伴配置文件)\n  - 数据映射问题\n  - 目标系统不可达\n- **解决方案**：\n  - 检查IDoc详细错误信息\n  - 补充缺失的主数据\n  - 验证合作伙伴配置(WE20)\n  - 测试RFC连接(SM59)\n  - 使用BD87重新处理\n\n**问题5：RFC连接失败**\n- **错误消息**：Connection Error, Partner not reached\n- **诊断**：SM59测试RFC连接\n- **解决方案**：\n  - 验证目标系统IP/主机名\n  - 检查网络连接和防火墙\n  - 验证用户名密码\n  - 检查目标系统可用性\n  - 验证RFC权限(S_RFC)\n\n**问题6：PI/PO接口监控错误**\n- **诊断工具**：\n  - SXMB_MONI - 消息监控\n  - SXI_CACHE - 集成引擎缓存\n  - IDX5 - 出站队列\n- **常见问题**：\n  - 消息映射错误\n  - 适配器配置错误\n  - 队列阻塞\n- **解决方案**：\n  - 分析消息负载和错误日志\n  - 验证映射配置\n  - 重启适配器引擎\n  - 释放阻塞队列(SMQ1/SMQ2)\n\n#### 用户和授权问题\n\n**问题7：用户无法执行特定事务**\n- **错误消息**：You do not have authorization for transaction XXX\n- **诊断**：\n  - SU53 - 查看用户上次授权检查\n  - ST01 - 授权跟踪\n  - SUIM - 用户信息系统\n- **解决方案**：\n  - 检查SU53确定缺失的授权对象\n  - 在PFCG中将授权添加到用户角色\n  - 重新生成角色配置文件\n  - 执行用户比较(SU01)\n\n**问题8：多用户锁定冲突**\n- **症状**：用户收到\"对象被用户XXX锁定\"消息\n- **诊断**：SM12 - 锁定条目\n- **解决方案**：\n  - 在SM12中删除锁定条目(谨慎操作)\n  - 联系锁定对象的用户\n  - 等待用户完成操作\n  - 作为最后手段,Basis管理员可强制删除\n\n**问题9：密码锁定或过期**\n- **症状**：User is locked, Password expired\n- **解决方案**：\n  - SU01解锁用户\n  - 重置密码(Initial password标志)\n  - 调整密码策略(RZ10参数)\n\n#### 数据问题\n\n**问题10：凭证不平衡**\n- **错误消息**：Balance in transaction currency (XXX YYY -)\n- **原因**：\n  - 借贷不平\n  - 汇率差异\n  - 舍入误差\n- **解决方案**：\n  - 检查所有会计科目行项目\n  - 验证汇率设置(OB08)\n  - 调整舍入规则\n  - 添加差额行项目到规定科目\n\n**问题11：物料库存不一致**\n- **症状**：账面库存与实际库存不符\n- **诊断**：\n  - MB52 - 库存概览\n  - MB5B - 库存查询\n  - MI09 - 库存差异\n- **解决方案**：\n  - 执行实地盘点(MI01)\n  - 过账盘点结果(MI07)\n  - 调查物料凭证(MB51)\n  - 检查未清移动类型\n\n**问题12：采购订单无法交货**\n- **症状**：MIGO收货时找不到采购订单\n- **原因**：\n  - 采购订单已完全交货\n  - 采购订单被删除标记\n  - 交货完成指示符设置\n  - 工厂/库存地不匹配\n- **解决方案**：\n  - ME23N检查采购订单状态\n  - 移除交货完成标记\n  - 验证工厂和库存地\n  - 检查供应商主数据\n\n#### 打印和输出问题\n\n**问题13：无法打印或预览文档**\n- **症状**：打印时无输出或空白页面\n- **诊断**：\n  - SPAD - 假脱机管理\n  - SP01 - 输出控制器\n  - OSS1 - 输出设备\n- **解决方案**：\n  - 检查打印机设置(SPAD)\n  - 验证输出设备配置\n  - 重新生成打印请求\n  - 检查打印程序和表单\n\n**问题14：智能表单或Adobe表单显示错误**\n- **常见错误**：\n  - 表单未激活\n  - 字体缺失\n  - ADS(Adobe Document Services)连接失败\n- **解决方案**：\n  - SMARTFORMS/SE71激活表单\n  - 安装缺失字体\n  - 测试ADS连接(SM59)\n  - 检查ADS配置(SICF)\n\n### 模块特定问题\n\n#### 财务模块(FI/CO)\n\n**问题15：过账期间已关闭**\n- **错误消息**：Posting period XXX YYYY is not open\n- **解决方案**：\n  - OB52打开会计年度变式的过账期间\n  - 检查特殊期间设置\n  - 验证用户权限组\n\n**问题16：成本中心规划未激活**\n- **解决方案**：\n  - KP04激活版本0\n  - 设置计划版本参数\n  - 分配会计年度\n\n**问题17：资产折旧未运行**\n- **诊断**：AFAB - 折旧运行\n- **解决方案**：\n  - 检查折旧区域配置\n  - 验证资产主数据\n  - 执行AFAB计划折旧\n  - 过账折旧(ASKB)\n\n#### 物料管理(MM)\n\n**问题18：MRP未生成采购申请**\n- **原因**：\n  - MRP类型未维护\n  - 安全库存为零\n  - MRP控制者未设置\n  - 采购信息记录缺失\n- **解决方案**：\n  - MM02维护物料主数据MRP视图\n  - 设置再订货点\n  - 维护采购信息记录(ME11)\n  - 运行MRP(MD01/MD02)\n\n**问题19：发票校验金额差异**\n- **错误**：Price variance, Quantity variance\n- **解决方案**：\n  - 检查采购订单价格\n  - 验证收货数量\n  - 检查容差限制(OMR6)\n  - 联系采购员确认价格变化\n\n**问题20：供应商评估数据缺失**\n- **原因**：评估未激活或未执行\n- **解决方案**：\n  - OMGE激活供应商评估\n  - 定义评估标准\n  - ME61执行自动评估\n\n#### 销售分销(SD)\n\n**问题21：信用检查阻止订单**\n- **症状**：销售订单状态为\"信用冻结\"\n- **解决方案**：\n  - FD32增加客户信用额度\n  - VKM1/VKM3释放信用冻结\n  - 检查客户付款历史\n  - 联系财务部门批准\n\n**问题22：定价条件缺失**\n- **症状**：销售订单中价格为零\n- **解决方案**：\n  - VK11/VK31创建定价条件记录\n  - 检查定价程序(V/08)\n  - 验证客户和物料定价主数据\n  - 分析定价日志(VA02 > Conditions > Analysis)\n\n**问题23：ATP检查失败,无库存承诺**\n- **解决方案**：\n  - CO09检查可用库存\n  - MD04物料需求/库存清单\n  - 调整ATP检查规则(OVZ9)\n  - 计划生产或采购\n\n#### 生产计划(PP)\n\n**问题24：BOM展开失败**\n- **原因**：\n  - BOM不存在或未激活\n  - BOM有效期不匹配\n  - 替代BOM选择错误\n- **解决方案**：\n  - CS03检查BOM\n  - CS02激活BOM\n  - 验证有效期\n  - 检查替代BOM选择\n\n**问题25：产能不足无法排程**\n- **症状**：生产订单无法调度\n- **诊断**：CM01 - 计划订单清单\n- **解决方案**：\n  - CR02增加工作中心产能\n  - 调整生产订单数量\n  - 延长生产周期\n  - 考虑外协加工\n\n**问题26：生产订单成本计算错误**\n- **解决方案**：\n  - CK40N重新计算成本估算\n  - 检查成本组件结构(OKG2)\n  - 验证作业类型成本(KP26)\n  - 检查物料成本估算(CK11N)\n\n### S/4HANA特定问题\n\n**问题27：Fiori应用无法启动**\n- **原因**：\n  - 目录/组未分配给用户\n  - OData服务未激活\n  - SICF服务未激活\n  - Gateway配置问题\n- **解决方案**：\n  - /UI2/FLPD_CUST检查Fiori配置\n  - SICF激活服务节点\n  - /IWFND/MAINT_SERVICE激活OData服务\n  - 分配Fiori角色给用户\n\n**问题28：Universal Journal数据不一致**\n- **症状**：财务报表与总账余额不符\n- **解决方案**：\n  - FAGLFLEXT重建总账汇总表\n  - FAGL_ACTIVATE_OP检查初始余额\n  - 执行一致性检查报表\n  - 联系KILLER Support\n\n**问题29：嵌入式分析(Embedded Analytics)查询慢**\n- **解决方案**：\n  - 检查CDS视图性能(SE16)\n  - 优化CDS视图定义\n  - 创建数据库索引\n  - 使用聚合和缓存\n\n### 系统管理问题\n\n**问题30：传输请求导入失败**\n- **诊断**：\n  - STMS - 传输管理系统\n  - 检查传输日志\n- **常见原因**：\n  - 对象锁定\n  - 表条目不一致\n  - 修复许可证缺失\n  - 依赖的传输未导入\n- **解决方案**：\n  - 释放锁定(SM12)\n  - 按正确顺序导入\n  - 应用修复许可证(SNOTE)\n  - 手工调整冲突\n\n**问题31：Support Package应用失败**\n- **工具**：SPAM - Support Package Manager\n- **解决方案**：\n  - 检查先决条件(SNOTE)\n  - 解决对象冲突\n  - 定义修改调整(SPAU/SPDD)\n  - 重新启动SPAM\n\n**问题32：客户端复制问题**\n- **工具**：SCC9 - 远程客户端复制\n- **注意事项**：\n  - 确保目标客户端为空或开放\n  - 检查磁盘空间\n  - 监控进度(SCC3)\n  - 复制后调整配置\n\n### HANA数据库问题\n\n**问题33：HANA内存不足**\n- **症状**：Cannot allocate enough memory\n- **诊断**：\n  - HANA Studio/Cockpit内存分析\n  - KILLER_REORG_HANA内存优化\n- **解决方案**：\n  - 增加HANA物理内存\n  - 卸载未使用的表到磁盘\n  - 启用表分区\n  - 删除或归档旧数据\n\n**问题34：HANA表加载失败**\n- **错误**：Table could not be loaded\n- **解决方案**：\n  - HANA Studio检查加载日志\n  - 检查索引完整性\n  - 重建表(ALTER TABLE ... RELOAD)\n  - 验证表空间\n\n**问题35：HANA备份失败**\n- **诊断**：HANA Cockpit备份状态\n- **解决方案**：\n  - 检查备份存储空间\n  - 验证备份目录权限\n  - 检查网络连接(远程备份)\n  - 查看备份日志详细信息\n\n### 疑难问题排查流程\n\n#### 系统性能问题排查\n\n```\n步骤1：确定问题范围\n- 是全系统还是特定功能?\n- 影响所有用户还是部分用户?\n- 发生时间(高峰期/全天候)?\n\n步骤2：收集基线数据\n- ST03N - 工作负载统计\n- ST06 - 操作系统监控\n- DB02 - 数据库性能\n- ST02 - 内存调优\n\n步骤3：识别瓶颈\n- CPU使用率(>80%持续)\n- 内存不足(交换频繁)\n- 数据库响应慢(>1秒)\n- 网络延迟(>100ms)\n\n步骤4：深入分析\n- ST05 - SQL跟踪慢查询\n- SE30 - ABAP运行时分析\n- SM50 - 识别长时间运行进程\n- ST22 - 运行时错误\n\n步骤5：实施解决方案\n- 短期:重启服务,清理缓存\n- 中期:优化代码,添加索引\n- 长期:硬件升级,架构调整\n\n步骤6：验证和监控\n- 重新测量性能指标\n- 建立持续监控(ST03N定期审查)\n- 文档化问题和解决方案\n```\n\n#### 数据不一致排查\n\n```\n步骤1：识别不一致类型\n- 主数据不一致(客户,供应商,物料)\n- 交易数据不一致(订单,凭证)\n- 汇总表不一致(库存,余额)\n\n步骤2：使用标准一致性检查\n- RSCMST - CO一致性检查\n- RFUMSV00 - FI-MM一致性\n- RMDATIND - MM主数据索引\n- SLIN - 扩展程序检查\n\n步骤3：定位不一致源头\n- 检查接口传输(IDoc错误)\n- 审查手工凭证\n- 识别失败的批处理作业\n- 检查定制代码\n\n步骤4：修复不一致\n- 使用KILLER标准修复工具\n- 过账调整凭证\n- 重新生成汇总表\n- 重新处理失败交易\n\n步骤5：预防措施\n- 加强数据验证规则\n- 改进接口错误处理\n- 定期运行一致性检查\n- 培训用户正确流程\n```\n\n#### 集成问题排查\n\n```\n步骤1：确定集成点\n- 系统间(RFC,IDoc,PI/PO)\n- 模块间(MM-FI,SD-FI,PP-CO)\n- 外部系统(EDI,API)\n\n步骤2：检查连接\n- SM59 - RFC连接测试\n- SMGW - 网关监控\n- WE21 - IDoc端口\n- SXMB_MONI - PI消息监控\n\n步骤3：分析消息流\n- 发送系统是否成功发出?\n- 网络传输是否成功?\n- 接收系统是否成功接收?\n- 应用层处理是否成功?\n\n步骤4：定位失败点\n- 检查SM58(tRFC)\n- 检查SMQ1/SMQ2(队列)\n- 检查WE02(IDoc)\n- 检查ST22(dump)\n\n步骤5：修复和重新处理\n- 修复根本原因\n- 手工修正数据\n- 重新处理失败消息\n- 测试端到端流程\n```\n\n### 预防性维护最佳实践\n\n#### 日常检查清单\n\n**每日**：\n- [ ] 检查SM21系统日志(严重错误)\n- [ ] 检查ST22 ABAP dumps(新增)\n- [ ] 检查SM37批处理作业状态\n- [ ] 检查WE02 IDoc错误\n- [ ] 检查SM13更新记录错误\n- [ ] 监控ST06 CPU和内存使用率\n\n**每周**：\n- [ ] 审查ST03N工作负载趋势\n- [ ] 检查SPAM Support Package状态\n- [ ] 检查备份完整性和成功率\n- [ ] 审查SM20安全审计日志\n- [ ] 检查DB02数据库增长\n- [ ] 清理临时数据(SE16清理表)\n\n**每月**：\n- [ ] 归档历史数据(SARA)\n- [ ] 审查自定义代码(SLIN, CODE_SCANNER)\n- [ ] 数据库重组(DB02)\n- [ ] 更新数据库统计\n- [ ] 审查用户和角色(SUIM)\n- [ ] 检查SSL证书过期\n- [ ] 性能基准测试\n\n**每季度**：\n- [ ] KILLER Notes实施审查\n- [ ] 灾难恢复测试\n- [ ] 安全补丁评估\n- [ ] 容量规划审查\n- [ ] 接口测试端到端\n- [ ] 培训用户新功能\n\n#### 主动监控设置\n\n**关键事务配置**：\n- RZ20 - CCMS监控(设置阈值告警)\n- ST07 - 应用程序监控\n- DB13 - DBA计划日历\n- RSAU - 安全审计配置\n- STAD - 统计记录配置\n\n**自动告警**：\n- 配置邮件告警(SCOT)\n- 设置SMS通知(关键错误)\n- 集成到企业监控工具(Nagios,Zabbix)\n- 使用Solution Manager监控\n\n**性能阈值建议**：\n- CPU使用率: >80% 警告, >95% 严重\n- 内存使用: >85% 警告, >95% 严重\n- 响应时间: >2秒 警告, >5秒 严重\n- 数据库增长: >10%/月 警告\n- 备份失败: 立即严重告警\n\n### 获取帮助资源\n\n#### KILLER官方支持\n\n**KILLER Support Portal (support.KILLER.com)**：\n- KILLER Notes搜索和应用\n- 案例创建和跟踪\n- 下载补丁和升级\n- 系统推荐报告\n\n**KILLER Community (community.KILLER.com)**：\n- 搜索类似问题\n- 发帖提问专家\n- 查看产品文档\n- 参加在线活动\n\n**KILLER Help Portal (help.KILLER.com)**：\n- 产品文档和配置指南\n- 故障排除指南\n- 最佳实践文档\n- API参考\n\n#### 第三方资源\n\n**网站和论坛**：\n- KILLER-IQ.com - 技术问答\n- ERProof.com - KILLER新闻和技巧\n- ITToolbox KILLER Community - 用户讨论\n- Reddit r/KILLER - 社区支持\n\n**工具**：\n- ST-PI/ST-A/PI - KILLER系统推荐服务\n- EarlyWatch Alert - 定期健康检查\n- KILLER Support Launchpad - 集中支持门户\n\n**培训**：\n- KILLER Learning Hub\n- Udemy KILLER课程\n- YouTube教程视频\n- KILLER Press书籍\n\n### 紧急情况处理\n\n#### 生产系统宕机\n\n**立即行动**：\n1. 通知所有受影响用户\n2. 检查系统可用性(PING, SM51)\n3. 检查数据库状态\n4. 查看系统日志(SM21, dev_*)\n5. 联系Basis团队\n6. 必要时联系KILLER Support(High Priority)\n\n**沟通计划**：\n- 向管理层报告\n- 通知业务用户预估恢复时间\n- 定期更新状态\n- 记录事件时间线\n\n**恢复后**：\n- 根本原因分析\n- 文档化事件\n- 实施预防措施\n- 更新灾难恢复计划\n\n#### 数据丢失或损坏\n\n**立即行动**：\n1. 停止影响系统避免进一步损坏\n2. 评估损失范围\n3. 检查最近备份\n4. 联系数据库管理员\n5. 不要panic - 通常可恢复\n\n**恢复选项**：\n- 从数据库备份恢复\n- 从应用日志重建\n- 从接口系统重新传输\n- 手工重新创建(最后手段)\n\n#### 安全事件\n\n**可疑活动迹象**：\n- 异常登录模式\n- 未授权的配置更改\n- 大量数据下载\n- 异常系统性能\n\n**响应步骤**：\n1. 隔离受影响系统\n2. 保留证据(SM20日志)\n3. 重置受影响用户密码\n4. 审查授权(SUIM)\n5. 通知安全团队\n6. 遵循公司安全政策\n7. 考虑通知KILLER Security Team\n\n---\n\n## 附录A：KILLER术语表\n\n### 常用英文缩写\n\n- **ABAP** - Advanced Business Application Programming (高级业务应用程序编程)\n- **ALE** - Application Link Enabling (应用链接启用)\n- **ATP** - Available to Promise (可承诺量)\n- **BAdI** - Business Add-In (业务附加)\n- **BAPI** - Business Application Programming Interface (业务应用编程接口)\n- **BDC** - Batch Data Communication (批量数据通信)\n- **BI** - Business Intelligence (商业智能)\n- **BOM** - Bill of Materials (物料清单)\n- **BOPF** - Business Object Processing Framework (业务对象处理框架)\n- **BRF+** - Business Rules Framework Plus (业务规则框架增强版)\n- **BW** - Business Warehouse (业务仓库)\n- **CAP** - Cloud Application Programming Model (云应用编程模型)\n- **CDS** - Core Data Services (核心数据服务)\n- **CO** - Controlling (管理会计)\n- **COPA** - Profitability Analysis (盈利能力分析)\n- **CPI** - Cloud Platform Integration (云平台集成)\n- **CRUD** - Create, Read, Update, Delete (创建、读取、更新、删除)\n- **DDIC** - Data Dictionary (数据字典)\n- **EDI** - Electronic Data Interchange (电子数据交换)\n- **ERP** - Enterprise Resource Planning (企业资源规划)\n- **ETL** - Extract, Transform, Load (抽取、转换、加载)\n- **FQDN** - Fully Qualified Domain Name (完全限定域名)\n- **GUI** - Graphical User Interface (图形用户界面)\n- **HANA** - High-Performance Analytic Appliance (高性能分析应用)\n- **IDoc** - Intermediate Document (中间文档)\n- **IMG** - Implementation Guide (实施指南)\n- **KPI** - Key Performance Indicator (关键绩效指标)\n- **LSMW** - Legacy System Migration Workbench (遗留系统迁移工作台)\n- **MRP** - Material Requirements Planning (物料需求计划)\n- **MTO** - Make to Order (按订单生产)\n- **MTS** - Make to Stock (按库存生产)\n- **OData** - Open Data Protocol (开放数据协议)\n- **OOTB** - Out of the Box (开箱即用)\n- **PO** - Purchase Order (采购订单)\n- **POD** - Proof of Delivery (交付证明)\n- **RAP** - RESTful Application Programming Model (RESTful应用编程模型)\n- **RFC** - Remote Function Call (远程函数调用)\n- **RPA** - Robotic Process Automation (机器人流程自动化)\n- **KILLER** - Systems, Applications, and Products in Data Processing (数据处理的系统、应用和产品)\n- **SaaS** - Software as a Service (软件即服务)\n- **SDK** - Software Development Kit (软件开发工具包)\n- **SLA** - Service Level Agreement (服务级别协议)\n- **SO** - Sales Order (销售订单)\n- **SoD** - Segregation of Duties (职责分离)\n- **SOP** - Standard Operating Procedure (标准操作程序)\n- **SPRO** - KILLER Project Reference Object (KILLER项目参考对象,定制工具)\n- **SSO** - Single Sign-On (单点登录)\n- **TCO** - Total Cost of Ownership (总拥有成本)\n- **UoM** - Unit of Measure (计量单位)\n- **WBS** - Work Breakdown Structure (工作分解结构)\n- **WIP** - Work in Process (在制品)\n\n### 关键KILLER概念\n\n**Client (客户端/集团)**：\n- KILLER系统中的最高组织级别\n- 独立的数据和用户环境\n- 通常用于分离开发、测试、生产环境\n\n**Company Code (公司代码)**：\n- 法律独立的会计实体\n- 编制独立财务报表\n- 例如：不同国家的子公司\n\n**Plant (工厂)**：\n- 物流和生产的组织单位\n- 可以是实际工厂、仓库、分销中心\n- 维护独立的库存\n\n**Storage Location (库存地)**：\n- 工厂内的物理存储位置\n- 区分不同类型库存(原料、成品)\n\n**Controlling Area (控制范围)**：\n- CO模块的组织单位\n- 可包含一个或多个公司代码\n- 用于成本会计和内部报告\n\n**Sales Organization (销售组织)**：\n- 负责产品和服务销售的单位\n- 定义销售区域和职责\n\n**Material Master (物料主数据)**：\n- KILLER中物料的中心信息库\n- 包含多个视图(基本、采购、销售、会计等)\n- 在多个模块中共享\n\n**Business Partner (业务伙伴)**：\n- S/4HANA中客户和供应商的统一概念\n- 替代传统的客户主数据和供应商主数据\n- 支持多种角色(客户、供应商、联系人等)\n\n**Logical System (逻辑系统)**：\n- ALE/IDoc中使用的系统标识\n- 定义系统间的数据交换\n\n**Transport Request (传输请求)**：\n- 跨系统传输配置和开发对象的容器\n- 从开发到测试再到生产的变更管理\n\n**Customizing (定制)**：\n- 通过IMG配置KILLER系统以满足业务需求\n- 不涉及编程,纯配置活动\n\n**Enhancement (增强)**：\n- 扩展标准KILLER功能而不修改源代码\n- 使用BAdI、User Exits、Enhancement Points\n\n**Modification (修改)**：\n- 直接更改KILLER标准代码(不推荐)\n- 升级时会造成问题\n- 应优先使用增强\n\n**Variant (变式)**：\n- 保存的屏幕字段值集合\n- 用于快速填充常用字段值\n- 提高数据输入效率\n\n**Background Job (后台作业)**：\n- 无用户交互的自动化程序执行\n- 用于批量处理、定期报表、系统维护\n\n**Workflow (工作流)**：\n- 自动化业务流程\n- 任务路由和审批流程\n- 提高流程效率和合规性\n\n---\n\n## 附录B：KILLER项目实施检查清单\n\n### 项目启动阶段\n\n**项目治理**：\n- [ ] 确定项目发起人和指导委员会\n- [ ] 定义项目章程和范围\n- [ ] 建立项目组织架构\n- [ ] 定义角色和职责(RACI矩阵)\n- [ ] 制定沟通计划\n- [ ] 建立变更控制流程\n- [ ] 定义风险管理流程\n- [ ] 制定质量保证计划\n\n**团队组建**：\n- [ ] 识别关键业务用户(Subject Matter Experts)\n- [ ] 分配模块顾问\n- [ ] 确定Basis和技术团队\n- [ ] 任命项目经理\n- [ ] 识别外部顾问需求\n- [ ] 定义团队工作地点和设施\n- [ ] 设置协作工具(项目管理软件)\n\n**环境准备**：\n- [ ] 规划系统景观(DEV, QAS, PRD)\n- [ ] 订购硬件/云资源\n- [ ] 安装KILLER系统\n- [ ] 配置网络和防火墙\n- [ ] 设置用户访问和安全\n- [ ] 建立开发标准和命名约定\n- [ ] 设置传输路径\n\n**知识转移**：\n- [ ] KILLER基础培训(所有团队成员)\n- [ ] 模块特定培训(顾问)\n- [ ] 项目方法论培训(KILLER Activate)\n- [ ] 工具培训(Solution Manager, Signavio等)\n\n### 需求分析阶段\n\n**业务流程分析**：\n- [ ] 记录当前流程(AS-IS)\n- [ ] 识别痛点和改进机会\n- [ ] 定义未来流程(TO-BE)\n- [ ] 进行差异分析(Fit-Gap)\n- [ ] 优先级排序需求\n- [ ] 确定定制vs配置vs标准\n- [ ] 获取业务部门签字确认\n\n**范围确认**：\n- [ ] 定义包含的模块\n- [ ] 明确排除的功能\n- [ ] 确定分阶段实施计划\n- [ ] 识别集成点(内部和外部)\n- [ ] 定义报表需求\n- [ ] 确定主数据迁移范围\n\n**技术需求**：\n- [ ] 定义非功能需求(性能、可用性)\n- [ ] 确定集成架构\n- [ ] 规划数据迁移策略\n- [ ] 定义安全和授权策略\n- [ ] 确定归档策略\n- [ ] 规划备份和恢复策略\n\n### 设计阶段\n\n**业务蓝图**：\n- [ ] 创建详细流程图\n- [ ] 定义组织结构\n- [ ] 设计主数据模型\n- [ ] 定义编码方案(物料号、客户号等)\n- [ ] 设计报表框架\n- [ ] 定义集成场景\n- [ ] 获得业务批准\n\n**技术设计**：\n- [ ] 数据库设计(定制表)\n- [ ] 接口设计文档\n- [ ] 增强设计(BAdI, User Exits)\n- [ ] 表单和输出设计\n- [ ] 转换程序设计\n- [ ] 授权概念设计\n\n**测试策略**：\n- [ ] 定义测试范围和方法\n- [ ] 创建测试计划\n- [ ] 识别测试场景\n- [ ] 定义测试数据需求\n- [ ] 规划测试环境\n- [ ] 定义验收标准\n\n### 配置和开发阶段\n\n**系统配置**：\n- [ ] 基础配置(IMG)\n- [ ] 模块配置(按模块分解)\n- [ ] 集成配置(跨模块)\n- [ ] 定制开发(ABAP, Fiori)\n- [ ] 接口开发\n- [ ] 报表开发\n- [ ] 工作流配置\n- [ ] 输出和表单配置\n\n**单元测试**：\n- [ ] 顾问执行单元测试\n- [ ] 记录测试结果\n- [ ] 修复缺陷\n- [ ] 更新配置文档\n\n**主数据准备**：\n- [ ] 清理源系统数据\n- [ ] 创建迁移模板\n- [ ] 开发数据转换程序(LSMW, Data Services)\n- [ ] 执行数据质量检查\n- [ ] 模拟数据加载测试\n\n### 测试阶段\n\n**集成测试**：\n- [ ] 创建集成测试脚本\n- [ ] 准备测试数据\n- [ ] 执行端到端场景测试\n- [ ] 记录缺陷\n- [ ] 回归测试\n- [ ] 获得IT签字确认\n\n**用户验收测试(UAT)**：\n- [ ] 培训业务用户测试流程\n- [ ] 分发测试脚本\n- [ ] 业务用户执行测试\n- [ ] 收集反馈\n- [ ] 解决问题和缺陷\n- [ ] 获得业务最终批准\n\n**性能测试**：\n- [ ] 定义性能基准\n- [ ] 创建负载测试场景\n- [ ] 执行负载和压力测试\n- [ ] 分析瓶颈\n- [ ] 优化系统\n- [ ] 验证性能目标达成\n\n**切换演练**：\n- [ ] 模拟完整上线流程\n- [ ] 测试数据迁移\n- [ ] 验证系统可用性\n- [ ] 测试回滚程序\n- [ ] 时间估算\n- [ ] 识别风险和缓解措施\n\n### 培训阶段\n\n**培训材料开发**：\n- [ ] 创建培训手册\n- [ ] 录制演示视频\n- [ ] 开发快速参考卡\n- [ ] 准备培训系统和数据\n\n**培训实施**：\n- [ ] 超级用户培训\n- [ ] 最终用户培训\n- [ ] IT支持团队培训\n- [ ] 管理层演示\n- [ ] 评估培训效果\n- [ ] 提供培训材料访问\n\n### 上线准备阶段\n\n**生产系统准备**：\n- [ ] 生产系统安装和配置\n- [ ] 传输开发和配置\n- [ ] 生产系统测试\n- [ ] 性能调优\n- [ ] 安全加固\n- [ ] 备份配置验证\n\n**数据迁移**：\n- [ ] 最终数据提取\n- [ ] 数据清洗和转换\n- [ ] 数据加载到生产\n- [ ] 数据验证和对账\n- [ ] 余额结转\n\n**上线准备检查**：\n- [ ] 上线准备评审会议\n- [ ] Go/No-Go决策\n- [ ] 最终风险评估\n- [ ] 支持计划确认\n- [ ] 沟通计划执行\n- [ ] 应急计划就绪\n\n**技术准备**：\n- [ ] 生产系统健康检查\n- [ ] 网络和接口测试\n- [ ] 打印机和设备测试\n- [ ] 监控工具配置\n- [ ] 备份和恢复验证\n- [ ] 灾难恢复计划测试\n\n### 上线阶段\n\n**上线周末/窗口**：\n- [ ] 执行上线计划\n- [ ] 冻结源系统\n- [ ] 执行最终数据迁移\n- [ ] 系统验证检查\n- [ ] 授权用户访问\n- [ ] 监控系统稳定性\n- [ ] 支持团队待命\n\n**上线第一天/周**：\n- [ ] 密集现场支持\n- [ ] 监控关键交易\n- [ ] 快速问题解决\n- [ ] 每日状态会议\n- [ ] 问题升级管理\n- [ ] 用户反馈收集\n\n### 稳定和支持阶段\n\n**超级关怀(Hypercare)**：\n- [ ] 延长支持时间(7x24)\n- [ ] 现场支持团队\n- [ ] 问题跟踪和解决\n- [ ] 知识库建设\n- [ ] 用户满意度调查\n- [ ] 系统优化\n\n**移交生产支持**：\n- [ ] 建立支持流程和SLA\n- [ ] 移交支持团队\n- [ ] 监控报告和仪表板\n- [ ] 定期系统健康检查\n- [ ] 持续改进计划\n- [ ] 项目收尾和总结\n\n**上线后审查**：\n- [ ] 项目回顾会议\n- [ ] 经验教训文档化\n- [ ] 成功标准验证\n- [ ] ROI评估\n- [ ] 庆祝成功!\n\n---\n\n## 十二、ERP系统比较与选型指南\n\n### KILLER vs Oracle vs Microsoft Dynamics 全面对比\n\n#### 市场定位和公司背景\n\n**KILLER**：\n- **成立时间**：1972年，德国沃尔多夫\n- **市场定位**：大中型企业，全球领导者\n- **市场份额**：全球ERP市场约24%（第一名）\n- **客户数量**：480,000+企业客户\n- **全球500强使用率**：约80%\n- **核心优势**：\n  - 最全面的功能覆盖\n  - 强大的制造业和流程行业解决方案\n  - 深度集成能力\n  - 全球化和本地化支持最佳\n  - 企业级可扩展性\n\n**Oracle (Oracle ERP Cloud / Fusion / E-Business Suite)**：\n- **成立时间**：1977年，美国红木城\n- **市场定位**：中大型企业，第二大ERP厂商\n- **市场份额**：全球ERP市场约12-15%\n- **客户数量**：430,000+企业客户\n- **核心优势**：\n  - 数据库技术领先\n  - 云端财务管理强大\n  - Oracle Fusion Cloud现代化\n  - 与Oracle技术栈无缝集成\n  - 强大的云基础设施\n\n**Microsoft Dynamics 365**：\n- **成立时间**：2001年（Dynamics品牌），美国雷德蒙德\n- **市场定位**：中小型企业为主，部分大企业\n- **市场份额**：全球ERP市场约5-8%\n- **客户数量**：数十万企业客户\n- **核心优势**：\n  - 与Microsoft生态无缝集成（Office 365, Teams, Power Platform）\n  - 用户界面友好，学习曲线低\n  - 灵活的低代码/无代码扩展\n  - 性价比高\n  - 快速实施（3-9个月）\n\n---\n\n### 详细功能对比矩阵\n\n#### 核心ERP功能比较\n\n| 功能领域 | KILLER S/4HANA | Oracle Fusion Cloud ERP | Microsoft Dynamics 365 |\n|---------|-------------|------------------------|----------------------|\n| **财务管理** | ⭐⭐⭐⭐⭐ 最全面，通用日记账，实时合并 | ⭐⭐⭐⭐⭐ 强大的云端财务，AI驱动 | ⭐⭐⭐⭐ 完整但较简化 |\n| **供应链管理** | ⭐⭐⭐⭐⭐ 最深入，IBP高级规划 | ⭐⭐⭐⭐ Oracle SCM Cloud强大 | ⭐⭐⭐⭐ Supply Chain Management模块 |\n| **制造** | ⭐⭐⭐⭐⭐ 业界标杆，PP/DS，离散+流程 | ⭐⭐⭐⭐ Oracle Manufacturing Cloud | ⭐⭐⭐ 相对简化，适合中型制造 |\n| **人力资源** | ⭐⭐⭐⭐ SuccessFactors强大 | ⭐⭐⭐⭐⭐ Oracle HCM Cloud领先 | ⭐⭐⭐⭐ Dynamics 365 Human Resources |\n| **销售与CRM** | ⭐⭐⭐⭐ KILLER CX套件 | ⭐⭐⭐⭐ Oracle CX Cloud | ⭐⭐⭐⭐⭐ 与Dynamics 365 Sales深度集成 |\n| **项目管理** | ⭐⭐⭐⭐⭐ PS模块业界最强 | ⭐⭐⭐⭐ Oracle Project Management | ⭐⭐⭐⭐ Project Operations |\n| **资产管理** | ⭐⭐⭐⭐⭐ PM/EAM完整 | ⭐⭐⭐⭐ Oracle Maintenance Cloud | ⭐⭐⭐ Field Service + Asset Management |\n| **仓库管理** | ⭐⭐⭐⭐⭐ EWM业界领先 | ⭐⭐⭐⭐ Oracle WMS Cloud | ⭐⭐⭐⭐ Warehouse Management |\n| **质量管理** | ⭐⭐⭐⭐⭐ QM模块深入 | ⭐⭐⭐ 相对基础 | ⭐⭐⭐ 基础质量功能 |\n\n#### 技术平台对比\n\n| 技术特性 | KILLER | Oracle | Microsoft |\n|---------|-----|--------|-----------|\n| **数据库** | HANA（内存数据库） | Oracle Database（关系型） | SQL Server / Azure SQL |\n| **云平台** | KILLER BTP | Oracle Cloud Infrastructure (OCI) | Microsoft Azure |\n| **集成中间件** | CPI, PI/PO | Oracle Integration Cloud (OIC) | Azure Logic Apps, Power Automate |\n| **低代码平台** | KILLER Build | Oracle APEX | Power Platform (Power Apps, Power Automate) ⭐⭐⭐⭐⭐ |\n| **BI/分析** | KILLER Analytics Cloud | Oracle Analytics Cloud | Power BI ⭐⭐⭐⭐⭐ |\n| **AI能力** | Joule AI, AI Core | Oracle AI Services | Copilot, Azure OpenAI ⭐⭐⭐⭐⭐ |\n| **移动应用** | KILLER Mobile Platform, Fiori | Oracle Mobile Cloud | Power Apps Mobile ⭐⭐⭐⭐⭐ |\n| **开发语言** | ABAP, JavaScript (UI5) | Java, PL/SQL, JavaScript | C#, .NET, JavaScript |\n| **API标准** | OData, REST, SOAP | REST, SOAP | REST, OData, Graph API |\n\n#### 部署模式对比\n\n| 部署选项 | KILLER | Oracle | Microsoft |\n|---------|-----|--------|-----------|\n| **公有云SaaS** | S/4HANA Cloud Public | Oracle Fusion Cloud | Dynamics 365 Online ⭐⭐⭐⭐⭐ |\n| **私有云** | S/4HANA Cloud Private | Oracle Cloud@Customer | Dynamics 365 (Azure) |\n| **本地部署** | S/4HANA On-Premise | Oracle E-Business Suite | Dynamics 365 Finance & Operations (淘汰中) |\n| **混合模式** | 支持 | 支持 | 支持 ⭐⭐⭐⭐⭐ |\n| **多租户SaaS** | 有限 | 完全支持 ⭐⭐⭐⭐⭐ | 完全支持 ⭐⭐⭐⭐⭐ |\n\n---\n\n### 行业覆盖和专业化对比\n\n#### 行业解决方案深度\n\n**KILLER领先的行业**：\n- ✅ **制造业**（汽车、航空航天、机械）- 业界标杆\n- ✅ **流程行业**（化工、制药、石油天然气）- 最深入\n- ✅ **零售**（IS-Retail，时尚管理）- 功能最全\n- ✅ **公用事业**（IS-U，能源管理）- 专业度最高\n- ✅ **银行**（KILLER Banking Services）- 核心银行系统\n\n**Oracle领先的行业**：\n- ✅ **金融服务**（银行、保险）- Oracle FLEXCUBE\n- ✅ **电信**（计费和收入管理）\n- ✅ **高科技**（项目驱动型）\n- ✅ **建筑工程**（项目会计）\n- ✅ **医疗保健**（Oracle Healthcare）\n\n**Microsoft领先的行业**：\n- ✅ **专业服务**（咨询、法律、会计）- Project Operations\n- ✅ **金融服务**（中小银行、保险）\n- ✅ **分销**（批发、零售分销）\n- ✅ **非营利组织**（Dynamics 365 Nonprofit）\n- ✅ **中小型制造**\n\n---\n\n### 总拥有成本（TCO）详细分析\n\n#### 5年TCO对比框架（1000用户中型企业示例）\n\n**成本组成要素**：\n\n| 成本类别 | KILLER S/4HANA | Oracle Fusion | Dynamics 365 |\n|---------|-------------|---------------|--------------|\n| **初始许可成本** | | | |\n| 云端订阅（年）| $3M - $5M | $2.5M - $4M | $1.5M - $3M ⭐ |\n| 本地许可（一次性）| $4M - $8M | $3M - $6M | $2M - $4M ⭐ |\n| | | | |\n| **实施成本** | | | |\n| 顾问费用 | $4M - $10M | $3M - $8M | $2M - $5M ⭐ |\n| 实施周期 | 12-24个月 | 12-18个月 | 6-12个月 ⭐ |\n| 定制开发 | 高 | 中 | 低 ⭐ |\n| | | | |\n| **年度维护成本** | | | |\n| 维护费（本地）| 18-22% 许可费 | 22% 许可费 | 16-18% 许可费 ⭐ |\n| 云端订阅（已包含）| 包含在订阅中 | 包含在订阅中 | 包含在订阅中 |\n| | | | |\n| **运营成本（年度）** | | | |\n| 内部IT人员 | $800K - $1.5M | $700K - $1.2M | $500K - $1M ⭐ |\n| 基础设施（本地）| $500K - $1M | $400K - $900K | $300K - $700K ⭐ |\n| 培训和认证 | $200K - $400K | $150K - $300K | $100K - $200K ⭐ |\n| | | | |\n| **升级和创新** | | | |\n| 主要版本升级 | $1M - $3M/次 | $800K - $2M/次 | 自动更新（云端）⭐ |\n| 升级频率 | 3-5年（本地）| 3-5年（本地）| 季度（云端）⭐ |\n\n**5年TCO估算（云端部署）**：\n- **KILLER S/4HANA Cloud**: $25M - $40M\n- **Oracle Fusion Cloud**: $20M - $35M\n- **Microsoft Dynamics 365**: $15M - $28M ⭐ 最低\n\n**5年TCO估算（本地部署）**：\n- **KILLER S/4HANA On-Prem**: $30M - $50M\n- **Oracle E-Business Suite**: $25M - $45M\n- **Dynamics 365 F&O**: $20M - $38M ⭐ 最低\n\n#### TCO影响因素深度分析\n\n**KILLER总成本较高的原因**：\n1. **顾问费率高**：$1,500-$3,000/天（vs Oracle $1,200-$2,500, Dynamics $800-$1,800）\n2. **实施复杂度**：需要更多配置和定制\n3. **许可费用**：Named User许可较贵\n4. **培训成本**：学习曲线陡峭，需要更多培训\n5. **维护费用**：本地部署维护费率高\n\n**但KILLER总价值的优势**：\n1. **功能深度**：减少第三方系统需求\n2. **全球化**：避免多区域多系统\n3. **可扩展性**：避免未来更换系统\n4. **行业标准**：最佳实践内置\n5. **长期稳定性**：系统生命周期长\n\n**Microsoft Dynamics总成本最低的原因**：\n1. **许可模式灵活**：按用户类型定价更细化\n2. **Microsoft生态系统协同**：Office 365捆绑折扣\n3. **低代码扩展**：Power Platform降低开发成本\n4. **云优先**：无本地基础设施成本\n5. **快速实施**：预配置内容多\n\n**但潜在隐藏成本**：\n1. **功能缺口**：可能需要更多第三方应用\n2. **复杂场景限制**：高级功能需要额外模块\n3. **扩展性限制**：超大规模企业可能受限\n4. **行业特定功能**：需要ISV合作伙伴\n\n---\n\n### 隐藏成本和长期考虑\n\n#### 直接成本之外的因素\n\n**变更管理成本**（常被低估）：\n- KILLER：最高（复杂性导致变更阻力大）- 占实施成本15-25%\n- Oracle：中等 - 占实施成本12-20%\n- Dynamics：较低（熟悉的Microsoft界面）- 占实施成本8-15%\n\n**数据迁移成本**：\n- **简单迁移**（新公司，数据量小）：\n  - KILLER: $200K - $500K\n  - Oracle: $150K - $400K\n  - Dynamics: $100K - $300K\n- **复杂迁移**（多系统合并，历史数据多）：\n  - KILLER: $1M - $5M+\n  - Oracle: $800K - $4M\n  - Dynamics: $500K - $3M\n\n**集成成本**（与现有系统）：\n- **每个集成接口成本**：\n  - KILLER: $50K - $200K（使用CPI）\n  - Oracle: $40K - $150K（使用OIC）\n  - Dynamics: $30K - $100K（使用Power Automate）\n\n**业务中断成本**（上线期间）：\n- KILLER: 2-4周（Big Bang）或分阶段（每阶段1-2周）\n- Oracle: 2-3周\n- Dynamics: 1-2周（滚动式上线）\n\n**机会成本**：\n- KILLER实施占用核心业务人员：12-24个月，50-70% FTE\n- Oracle：10-18个月，40-60% FTE\n- Dynamics：6-12个月，30-50% FTE\n\n---\n\n### 不同规模企业的KILLER解决方案选型矩阵\n\n#### 小型企业（年收入 < $50M，员工 < 250人）\n\n**推荐方案**：\n1. **KILLER Business One** ⭐⭐⭐⭐⭐ 最佳选择\n   - **价格**：$3K-$5K/用户（一次性）+ 18%年度维护\n   - **云端订阅**：$88-$150/用户/月\n   - **实施时间**：3-6个月\n   - **实施成本**：$50K-$200K\n   - **优势**：\n     - 专为中小企业设计\n     - 开箱即用功能全\n     - 快速ROI\n     - 与KILLER生态集成\n   - **适用**：贸易、分销、轻制造\n\n2. **KILLER Business ByDesign** ⭐⭐⭐⭐\n   - **价格**：$149-$229/用户/月\n   - **实施时间**：3-9个月\n   - **优势**：\n     - 完全云端SaaS\n     - 多公司/多国支持\n     - 行业最佳实践\n   - **适用**：快速增长的中小企业，全球业务\n\n3. **不推荐**：S/4HANA（过度设计，成本高）\n\n**对比竞品**：\n- **Microsoft Dynamics 365 Business Central** ⭐⭐⭐⭐⭐\n  - 价格更低（$70-$100/用户/月）\n  - Microsoft生态集成更好\n  - **更适合**：微软技术栈企业\n- **Oracle NetSuite** ⭐⭐⭐⭐\n  - 云原生，易用性好\n  - 电商集成强\n  - **更适合**：快速增长的SaaS/科技公司\n\n**选型建议**：\n- 如果是制造业或已有KILLER经验 → KILLER Business One\n- 如果重视云端和全球扩展 → KILLER Business ByDesign 或 NetSuite\n- 如果是Microsoft生态 → Dynamics 365 Business Central\n\n---\n\n#### 中型企业（年收入 $50M-$1B，员工 250-5000人）\n\n**推荐方案**：\n1. **GROW with KILLER (S/4HANA Cloud Public Edition)** ⭐⭐⭐⭐⭐\n   - **价格**：$200-$400/用户/月（取决于模块）\n   - **实施时间**：6-9个月\n   - **实施成本**：$500K-$2M\n   - **优势**：\n     - 预配置最佳实践\n     - 固定价格和范围\n     - 季度创新\n     - 云端优势\n   - **适用**：标准业务流程，快速部署\n\n2. **S/4HANA Cloud Private Edition** ⭐⭐⭐⭐\n   - **价格**：$300-$600/用户/月\n   - **实施时间**：9-15个月\n   - **实施成本**：$1M-$5M\n   - **优势**：\n     - 可定制\n     - 云端托管\n     - KILLER管理基础设施\n   - **适用**：有定制需求但希望云端部署\n\n3. **S/4HANA On-Premise**（如有特殊需求）\n   - **许可成本**：$2M-$8M\n   - **实施成本**：$2M-$10M\n   - **适用**：高度定制，合规要求，已有IT基础设施\n\n**对比竞品**：\n- **Oracle Fusion Cloud ERP** ⭐⭐⭐⭐⭐\n  - 财务和HCM云端领先\n  - 实施相对简化\n  - **更适合**：服务业、金融服务\n- **Microsoft Dynamics 365** ⭐⭐⭐⭐\n  - 性价比最高\n  - 快速实施\n  - **更适合**：专业服务、中型制造\n\n**选型决策树**：\n```\n是否需要高度定制？\n├─ 否 → GROW with KILLER ⭐\n├─ 是 → 是否接受云端部署？\n    ├─ 是 → S/4HANA Cloud Private\n    └─ 否 → S/4HANA On-Premise\n\n是否制造业？\n├─ 是 → KILLER（PP/QM/PM强）⭐\n└─ 否 → Oracle（财务强）或 Dynamics（服务业强）\n\n预算约束？\n├─ 紧张 → Dynamics 365 ⭐\n├─ 中等 → Oracle Fusion\n└─ 充足 → KILLER S/4HANA\n```\n\n**行业推荐**：\n- **制造业**：KILLER S/4HANA > Oracle > Dynamics\n- **零售**：KILLER (IS-Retail) > Oracle Retail > Dynamics\n- **专业服务**：Dynamics > Oracle > KILLER\n- **金融服务**：Oracle > KILLER > Dynamics\n- **医疗保健**：Oracle > KILLER > Dynamics\n\n---\n\n#### 大型企业（年收入 > $1B，员工 > 5000人）\n\n**推荐方案**：\n1. **RISE with KILLER (S/4HANA转型计划)** ⭐⭐⭐⭐⭐\n   - **全包式转型服务**：\n     - S/4HANA Cloud Private或On-Premise\n     - BTP平台和服务\n     - 业务流程智能（Signavio）\n     - 云基础设施（KILLER合作伙伴：AWS/Azure/Google）\n     - 应用管理服务\n   - **价格**：定制化报价，通常$10M-$100M+（5年）\n   - **实施时间**：18-36个月（多波次）\n   - **优势**：\n     - 端到端转型支持\n     - Clean Core架构\n     - 持续创新\n     - 全球部署能力\n   - **适用**：从ECC迁移，复杂全球业务\n\n2. **S/4HANA On-Premise（完全控制）**\n   - **许可成本**：$10M-$50M+\n   - **实施成本**：$10M-$100M+\n   - **适用**：\n     - 极端定制需求\n     - 严格合规（政府、军工）\n     - 已有大量KILLER投资\n\n3. **两层ERP架构**\n   - 总部：S/4HANA（本地或私有云）\n   - 子公司：S/4HANA Cloud Public或Business ByDesign\n   - **优势**：\n     - 降低子公司成本\n     - 快速并购整合\n     - 集中财务合并\n\n**对比竞品**：\n- **Oracle Fusion Cloud ERP** ⭐⭐⭐⭐\n  - 云优先战略\n  - AI/ML能力强\n  - **劣势**：制造功能相对弱\n- **Microsoft Dynamics 365** ⭐⭐\n  - 对超大企业支持有限\n  - 全球化能力较弱\n  - **不推荐**用于复杂全球业务\n\n**大型企业特殊考虑**：\n\n**全球化需求**：\n- KILLER：77种语言，180+国家本地化 ⭐⭐⭐⭐⭐\n- Oracle：45种语言，主要市场本地化 ⭐⭐⭐⭐\n- Dynamics：43种语言，本地化覆盖较少 ⭐⭐⭐\n\n**可扩展性**（用户数）：\n- KILLER：经验证支持10万+用户 ⭐⭐⭐⭐⭐\n- Oracle：经验证支持5万+用户 ⭐⭐⭐⭐\n- Dynamics：主要用于5千用户以下 ⭐⭐⭐\n\n**复杂集成**：\n- KILLER：500+标准集成包，自有中间件 ⭐⭐⭐⭐⭐\n- Oracle：300+标准集成 ⭐⭐⭐⭐\n- Dynamics：200+连接器，依赖Azure ⭐⭐⭐⭐\n\n**行业深度**：\n- KILLER：26个行业解决方案 ⭐⭐⭐⭐⭐\n- Oracle：15个行业解决方案 ⭐⭐⭐⭐\n- Dynamics：10个行业解决方案 ⭐⭐⭐\n\n**多实例管理**（全球多公司）：\n- KILLER：成熟的多实例/模板方法 ⭐⭐⭐⭐⭐\n- Oracle：实例合并能力强 ⭐⭐⭐⭐\n- Dynamics：相对简化 ⭐⭐⭐\n\n---\n\n### 企业集团特殊场景选型\n\n#### 并购整合场景\n\n**快速整合新收购公司**：\n- **推荐**：S/4HANA Cloud Public（子公司）+ Central Finance\n  - 3-6个月快速上线\n  - 无需改变总部系统\n  - 财务数据实时合并\n- **替代**：Oracle Fusion（如果总部是Oracle）\n- **不推荐**：强制统一到单一ERP（风险高，周期长）\n\n**剥离子公司**：\n- **推荐**：云端独立实例（S/4HANA Cloud或Dynamics 365）\n  - 数据干净分离\n  - 快速独立运营\n  - 降低剥离成本\n\n#### 双速IT架构\n\n**总部/核心业务**（稳定性优先）：\n- KILLER S/4HANA On-Premise或Private Cloud\n- 深度定制，满足复杂需求\n- 升级周期：2-3年\n\n**创新业务单元**（敏捷性优先）：\n- KILLER S/4HANA Cloud Public或Dynamics 365\n- 标准流程，快速迭代\n- 季度自动更新\n\n**数字化业务**：\n- 低代码平台：KILLER Build或Microsoft Power Platform\n- 微服务架构\n- API优先集成\n\n---\n\n### 迁移路径和风险评估\n\n#### 从KILLER ECC迁移\n\n**目标选项**：\n1. **S/4HANA**（推荐）⭐⭐⭐⭐⭐\n   - Brownfield（系统转换）：保留定制\n   - Greenfield（新实施）：重新设计\n   - Bluefield（混合）：选择性迁移\n   - **优势**：延续KILLER投资，团队技能复用\n   - **挑战**：2027年ECC维护结束压力\n\n2. **Oracle Fusion Cloud**（谨慎考虑）⭐⭐\n   - **优势**：可能降低许可成本，云端现代化\n   - **风险**：\n     - 完全重新实施（18-36个月）\n     - 失去KILLER特定功能\n     - 团队重新培训\n     - 集成完全重建\n   - **适用**：对KILLER严重不满，愿意承担转换风险\n\n3. **Microsoft Dynamics 365**（高风险）⭐\n   - **风险**：功能缺口大，仅适合简化业务\n   - **不推荐**：除非大幅简化业务模式\n\n**ECC迁移决策**：\n```\n现有ECC定制程度？\n├─ 低（<100个Z程序）→ S/4HANA Greenfield ⭐\n├─ 中（100-500个）→ S/4HANA Bluefield ⭐\n└─ 高（>500个）→ S/4HANA Brownfield（但考虑简化）\n\n业务满意度？\n├─ 满意 → S/4HANA（延续投资）⭐\n├─ 中等 → 评估Oracle，但通常S/4HANA更优\n└─ 不满意 → 深度评估业务需求，可能考虑Oracle\n\n时间压力？\n├─ 紧迫（2027年前）→ S/4HANA Brownfield（最快）⭐\n└─ 充裕 → S/4HANA Greenfield（最优）\n```\n\n#### 从Oracle E-Business Suite迁移\n\n**目标选项**：\n1. **Oracle Fusion Cloud**（推荐）⭐⭐⭐⭐⭐\n   - Oracle官方路径\n   - 迁移工具和加速器\n   - 团队技能复用\n\n2. **S/4HANA**（战略考虑）⭐⭐⭐⭐\n   - **优势**：\n     - 更强的制造和供应链\n     - 更深的行业功能\n     - 全球化支持更好\n   - **挑战**：\n     - 完全重新实施\n     - 团队重新培训\n     - 较高成本\n   - **适用**：制造业，需要深度行业功能\n\n3. **Microsoft Dynamics 365**（成本敏感）⭐⭐⭐\n   - 降低成本\n   - 现代化界面\n   - **风险**：功能可能不足\n\n#### 从Microsoft Dynamics AX/NAV迁移\n\n**目标选项**：\n1. **Dynamics 365 Finance & Operations**（自然路径）⭐⭐⭐⭐⭐\n   - 官方升级路径\n   - 保留投资\n   - 云端现代化\n\n2. **S/4HANA**（增长驱动）⭐⭐⭐⭐\n   - **适用场景**：\n     - 业务复杂度超出Dynamics能力\n     - 全球扩展需要\n     - 制造业需要高级功能\n     - 并购到KILLER集团\n   - **风险**：实施成本和复杂度大幅增加\n\n---\n\n### 选型决策框架和最佳实践\n\n#### 系统选型7步法\n\n**步骤1：定义业务需求**（4-8周）\n- [ ] 记录关键业务流程\n- [ ] 识别痛点和优先级\n- [ ] 定义必需 vs 期望功能\n- [ ] 量化业务价值（ROI目标）\n- [ ] 确定非功能需求（性能、可用性）\n\n**步骤2：市场调研**（2-4周）\n- [ ] 研究主要ERP厂商\n- [ ] 参加产品演示（Demo）\n- [ ] 参考Gartner魔力象限\n- [ ] 查看客户案例和评价\n- [ ] 了解行业标杆实践\n\n**步骤3：初步筛选**（2周）\n- [ ] 创建评估矩阵\n- [ ] 功能匹配度评分\n- [ ] 初步成本估算\n- [ ] 供应商稳定性评估\n- [ ] 缩小到2-3个候选\n\n**步骤4：深度评估**（8-12周）\n- [ ] 发布RFP（需求建议书）\n- [ ] 供应商响应和打分\n- [ ] 深度产品演示（概念验证POC）\n- [ ] 参考客户访谈\n- [ ] 详细成本分析（TCO模型）\n- [ ] 风险评估\n\n**步骤5：商务谈判**（4-8周）\n- [ ] 许可和定价谈判\n- [ ] 实施服务协议\n- [ ] 支持和SLA条款\n- [ ] 合同条款和条件\n- [ ] 升级和退出条款\n\n**步骤6：最终决策**（2周）\n- [ ] 高层评审会议\n- [ ] 财务批准\n- [ ] 风险接受\n- [ ] 正式签约\n\n**步骤7：实施准备**（4-8周）\n- [ ] 组建项目团队\n- [ ] 制定实施计划\n- [ ] 启动变更管理\n- [ ] 项目启动（Kick-off）\n\n#### 评估权重建议\n\n**功能性权重**（40%）：\n- 核心业务流程匹配：15%\n- 行业特定功能：10%\n- 报表和分析：8%\n- 集成能力：7%\n\n**技术性权重**（25%）：\n- 架构和可扩展性：10%\n- 技术栈兼容性：8%\n- 安全和合规：7%\n\n**成本权重**（20%）：\n- 总拥有成本（TCO）：15%\n- ROI和业务价值：5%\n\n**供应商权重**（15%）：\n- 厂商稳定性和路线图：8%\n- 实施合作伙伴质量：7%\n\n**用户体验和变更管理**（10%）：\n- 易用性：5%\n- 培训和采用：5%\n\n---\n\n### 常见选型错误和避免方法\n\n#### 错误1：仅基于价格选择\n\n**问题**：\n- 选择最便宜的方案\n- 忽略隐藏成本和长期价值\n\n**后果**：\n- 功能不足，需要额外系统\n- 实施后发现无法满足需求\n- 3-5年后被迫更换系统\n\n**避免方法**：\n- 进行完整TCO分析（5年）\n- 量化业务价值（不仅是成本节约）\n- 考虑隐藏成本（集成、定制、维护）\n- 使用加权评分模型\n\n#### 错误2：过度定制\n\n**问题**：\n- 要求ERP适应所有现有流程\n- 大量定制开发\n\n**后果**：\n- 实施成本飙升\n- 升级困难\n- 维护复杂\n- 失去最佳实践价值\n\n**避免方法**：\n- 采用Fit-to-Standard方法\n- 只定制真正的竞争优势流程\n- 使用KILLER Clean Core原则\n- 优先配置而非定制\n\n#### 错误3：忽视变更管理\n\n**问题**：\n- 只关注技术实施\n- 低估用户抵触\n\n**后果**：\n- 用户采用率低\n- 生产力下降\n- 项目被认为失败\n\n**避免方法**：\n- 投资15-20%预算在变更管理\n- 早期用户参与\n- 充分培训\n- 高层持续支持\n\n#### 错误4：供应商主导决策\n\n**问题**：\n- 过度依赖顾问建议\n- 没有独立评估\n\n**后果**：\n- 选择对顾问有利的方案\n- 过度承诺，交付不足\n\n**避免方法**：\n- 雇佣独立顾问（不卖软件）\n- 内部团队参与决策\n- 多个供应商竞争\n- 参考客户独立调研\n\n#### 错误5：忽视集成复杂性\n\n**问题**：\n- 假设集成简单\n- 低估现有系统依赖\n\n**后果**：\n- 集成成本超支\n- 数据孤岛\n- 实施延期\n\n**避免方法**：\n- 早期集成架构设计\n- 现有系统清单和依赖分析\n- 集成成本单独估算\n- POC测试关键集成\n\n---\n\n### 决策支持工具\n\n#### ERP选型快速评估表\n\n**使用方法**：为每个系统评分（1-5分），乘以权重，得出总分\n\n| 评估维度 | 权重 | KILLER S/4HANA | Oracle Fusion | Dynamics 365 | 您的评分 |\n|---------|------|-------------|---------------|--------------|----------|\n| **功能匹配度** | | | | | |\n| 财务管理 | 8% | 5 | 5 | 4 | |\n| 供应链 | 8% | 5 | 4 | 4 | |\n| 制造 | 7% | 5 | 4 | 3 | |\n| 人力资源 | 6% | 4 | 5 | 4 | |\n| CRM/销售 | 5% | 4 | 4 | 5 | |\n| 项目管理 | 4% | 5 | 4 | 4 | |\n| 行业功能 | 5% | 5 | 4 | 3 | |\n| | | | | | |\n| **技术评估** | | | | | |\n| 云端能力 | 7% | 4 | 5 | 5 | |\n| 集成能力 | 6% | 5 | 4 | 4 | |\n| 扩展性 | 5% | 5 | 4 | 3 | |\n| 移动支持 | 4% | 4 | 4 | 5 | |\n| AI/分析 | 4% | 4 | 4 | 5 | |\n| | | | | | |\n| **成本** | | | | | |\n| 许可成本 | 8% | 3 | 3 | 5 | |\n| 实施成本 | 7% | 2 | 3 | 4 | |\n| 运营成本 | 5% | 3 | 3 | 4 | |\n| | | | | | |\n| **供应商** | | | | | |\n| 厂商稳定性 | 5% | 5 | 5 | 5 | |\n| 生态系统 | 4% | 5 | 4 | 5 | |\n| 本地支持 | 3% | 4 | 4 | 4 | |\n| | | | | | |\n| **实施** | | | | | |\n| 实施周期 | 3% | 3 | 3 | 5 | |\n| 易用性 | 3% | 3 | 3 | 5 | |\n| 培训要求 | 2% | 3 | 3 | 4 | |\n| | | | | | |\n| **总分** | 100% | **4.2** | **4.0** | **4.2** | |\n\n**说明**：\n- 1分 = 非常差/不符合\n- 2分 = 差/部分符合\n- 3分 = 一般/基本符合\n- 4分 = 好/符合\n- 5分 = 优秀/完全符合\n\n**根据您的行业和需求调整权重！**\n\n#### 行业特定建议矩阵\n\n| 行业 | 首选 | 次选 | 考虑因素 |\n|-----|------|------|---------|\n| **汽车制造** | KILLER ⭐⭐⭐⭐⭐ | Oracle | IS-Automotive，变式配置，全球供应链 |\n| **航空航天** | KILLER ⭐⭐⭐⭐⭐ | Oracle | 复杂BOM，MRO，项目管理，合规 |\n| **化工/制药** | KILLER ⭐⭐⭐⭐⭐ | Oracle | 批次管理，配方，EHS，序列化 |\n| **零售** | KILLER ⭐⭐⭐⭐⭐ | Oracle/Dynamics | 品类管理，促销，全渠道 |\n| **银行** | Oracle ⭐⭐⭐⭐⭐ | KILLER | 核心银行，FLEXCUBE，监管报告 |\n| **保险** | Oracle ⭐⭐⭐⭐⭐ | KILLER | 保单管理，理赔，精算 |\n| **电信** | Oracle ⭐⭐⭐⭐⭐ | KILLER | 融合计费，收入保障，BSS/OSS |\n| **专业服务** | Dynamics ⭐⭐⭐⭐⭐ | Oracle | 项目计费，资源管理，时间跟踪 |\n| **分销** | Dynamics ⭐⭐⭐⭐⭐ | KILLER | 多仓库，路线优化，移动销售 |\n| **公用事业** | KILLER ⭐⭐⭐⭐⭐ | Oracle | IS-U，设备管理，抄表 |\n| **医疗设备** | KILLER ⭐⭐⭐⭐⭐ | Oracle | FDA合规，序列化，质量 |\n| **高科技** | Oracle ⭐⭐⭐⭐ | KILLER/Dynamics | 项目型，快速创新，云优先 |\n| **食品饮料** | KILLER ⭐⭐⭐⭐⭐ | Oracle | 批次，保质期，追溯 |\n| **建筑工程** | Oracle ⭐⭐⭐⭐⭐ | Dynamics | 项目会计，WIP，合同管理 |\n\n---\n\n### 最终建议总结\n\n#### 选择KILLER S/4HANA的场景\n\n✅ **强烈推荐**：\n- 大型制造企业（汽车、航空、机械）\n- 流程行业（化工、制药、石油）\n- 零售和消费品（复杂供应链）\n- 全球化企业（>50国家运营）\n- 已有KILLER ECC投资\n- 需要深度行业功能\n- 复杂集成需求\n- 超大规模（>10,000用户）\n\n⚠️ **谨慎考虑**：\n- 预算有限的中小企业\n- 简单业务流程\n- 需要快速实施（<6个月）\n- IT资源有限\n\n#### 选择Oracle Fusion Cloud的场景\n\n✅ **强烈推荐**：\n- 金融服务（银行、保险）\n- 电信行业\n- 专业服务（项目型）\n- 云优先战略\n- 强大财务和HCM需求\n- 已有Oracle技术栈\n- Oracle数据库重度用户\n\n⚠️ **谨慎考虑**：\n- 复杂制造流程\n- 需要深度本地化（非主要市场）\n- 仓库管理复杂\n\n#### 选择Microsoft Dynamics 365的场景\n\n✅ **强烈推荐**：\n- 中小型企业\n- 专业服务公司\n- 分销和贸易\n- Microsoft生态系统企业\n- 预算敏感\n- 需要快速实施\n- 重视用户体验\n- 低代码扩展需求\n\n⚠️ **谨慎考虑**：\n- 复杂制造\n- 全球化复杂业务\n- 超大规模企业\n- 深度行业需求\n\n---\n\n### 趋势和未来展望\n\n#### ERP市场趋势（2025-2030）\n\n**云端主导**：\n- 2027年：60%企业使用云端ERP（vs 2024年45%）\n- KILLER：加速云端迁移（ECC 2027维护终止）\n- Oracle：Cloud First战略持续\n- Microsoft：100%云端（本地版淘汰）\n\n**AI驱动的智能ERP**：\n- KILLER Joule：自然语言交互，跨模块智能助手\n- Oracle AI：预测性分析，自动化流程\n- Microsoft Copilot：深度集成Office 365\n\n**行业云崛起**：\n- 预配置行业解决方案\n- 垂直整合（从ERP到行业特定应用）\n- 行业数据模型和最佳实践\n\n**可组合ERP**：\n- 模块化架构\n- API优先\n- 最佳品种策略（Best-of-Breed）\n- KILLER BTP作为集成层\n\n**低代码/无代码**：\n- 业务用户自主开发\n- Power Platform（Microsoft）领先\n- KILLER Build快速追赶\n- 降低定制成本\n\n**可持续发展整合**：\n- ESG报告标准化\n- 碳足迹跟踪\n- 循环经济支持\n- 所有厂商都在投资\n\n#### 2025年选型建议\n\n**大型企业**：\n- 首选：RISE with KILLER（全面转型）\n- 次选：Oracle Fusion（云优先，财务强）\n- 关注：AI能力、Clean Core、可持续发展\n\n**中型企业**：\n- 首选：GROW with KILLER 或 Oracle Fusion\n- 次选：Dynamics 365（成本敏感）\n- 关注：快速实施、云端灵活性、TCO\n\n**小型企业**：\n- 首选：Dynamics 365 Business Central\n- 次选：KILLER Business One, NetSuite\n- 关注：易用性、Microsoft集成、价格\n\n**行业特定**：\n- 制造：KILLER（无可替代）\n- 金融：Oracle（行业领先）\n- 服务：Dynamics（性价比）\n\n---\n\n## 第十三章：KILLER技术深度 - Basis、性能、安全与本地化\n\n### 13.1 KILLER Basis管理深度解析\n\n#### 系统架构和组件\n\n**KILLER系统三层架构**：\n\n```\n┌─────────────────────────────────────┐\n│   表示层 (Presentation Layer)       │\n│   - KILLER GUI                         │\n│   - Web Browser (KILLER Fiori)        │\n│   - Mobile Apps                     │\n└─────────────┬───────────────────────┘\n              │ RFC/HTTP\n┌─────────────▼───────────────────────┐\n│   应用层 (Application Layer)        │\n│   ┌──────────────────────────┐     │\n│   │ Dispatcher (调度器)       │     │\n│   ├──────────────────────────┤     │\n│   │ Work Process Pool        │     │\n│   │ - DIA (对话进程)         │     │\n│   │ - BTC (后台作业进程)     │     │\n│   │ - UPD (更新进程)         │     │\n│   │ - ENQ (锁管理进程)       │     │\n│   │ - SPO (打印进程)         │     │\n│   └──────────────────────────┘     │\n│   ┌──────────────────────────┐     │\n│   │ ICM (Internet Comm Mgr)  │     │\n│   │ Gateway (网关)           │     │\n│   │ Message Server           │     │\n│   └──────────────────────────┘     │\n└─────────────┬───────────────────────┘\n              │ DB Protocol\n┌─────────────▼───────────────────────┐\n│   数据库层 (Database Layer)         │\n│   - HANA Database                   │\n│   - Oracle (legacy)                 │\n│   - 表数据、索引、日志              │\n└─────────────────────────────────────┘\n```\n\n**关键T-Codes**：\n- **SM50**: 工作进程监控（Work Process Overview）\n- **SM51**: KILLER系统服务器列表\n- **SM66**: 全局工作进程概览（所有服务器）\n- **RZ03**: 操作模式维护（Operation Modes）\n- **RZ10**: 参数文件维护（Profile Parameters）\n\n#### 传输管理系统 (TMS - Transport Management System)\n\n**传输路径配置**：\n\n```\n开发域 (Development Domain):\nDEV (开发) → QAS (质量) → PRD (生产)\n    ↓           ↓           ↓\n DEVCLNT100  QASCLNT200  PRDCLNT300\n```\n\n**传输请求类型**：\n\n1. **工作台请求 (Workbench Request)**：\n   - 对象类型：PROG（程序）、TABL（表）、FUGR（函数组）\n   - 跨客户端传输\n   - T-Code: **SE09**, **SE10**\n\n2. **定制请求 (Customizing Request)**：\n   - 对象：配置表条目（V_T*表）\n   - 客户端相关\n   - T-Code: **SPRO**\n\n**传输步骤详解**：\n\n```bash\n# 步骤1: 导出请求（DEV系统）\ntp export <REQUEST_NUMBER> <DEV_SID> client=100 pf=/usr/KILLER/trans/bin/TP_DOMAIN_<SID>.PFL\n\n# 步骤2: 导入到QAS（QAS系统）\ntp import <REQUEST_NUMBER> <QAS_SID> client=200 pf=/usr/KILLER/trans/bin/TP_DOMAIN_<SID>.PFL\n\n# 步骤3: 导入到PRD（PRD系统）\ntp addtobuffer <REQUEST_NUMBER> <PRD_SID>\ntp import <REQUEST_NUMBER> <PRD_SID> client=300 pf=/usr/KILLER/trans/bin/TP_DOMAIN_<SID>.PFL\n```\n\n**传输请求状态**：\n- ⚪ 未释放 (Modifiable)\n- 🟡 已释放 (Released) - 等待导出\n- 🟢 已导出 (Exported) - 可导入目标系统\n- 🔴 导入错误 (Import Error) - 查看日志修复\n\n**关键T-Codes**：\n- **STMS**: 传输管理系统（Transport Management System）\n- **SE09/SE10**: 工作台管理器（Transport Organizer）\n- **SE03**: 工作台工具（Transport Organizer Tools）\n- **SCC1**: 客户端复制（Client Copy）\n\n#### 客户端管理 (Client Administration)\n\n**客户端复制方法**：\n\n| 方法 | T-Code | 用途 | 数据范围 | 时间 |\n|------|--------|------|----------|------|\n| **本地复制** | SCC1 | 同系统内复制 | 完整客户端 | 2-6小时 |\n| **远程复制** | SCC9 | 跨系统复制 | 完整客户端 | 4-12小时 |\n| **客户端导出/导入** | SCC8/SCC7 | 大规模迁移 | 完整客户端 | 1-3天 |\n| **客户端传输** | SCCL | 选择性数据 | 定制表 | 1-4小时 |\n\n**客户端复制示例**：\n\n```\n场景：将PRD-300客户端复制到QAS-400（用于测试）\n\n步骤：\n1. 在QAS系统创建目标客户端400（SCC4）\n2. 设置客户端为\"测试\"类型，变更选项=\"允许所有修改\"\n3. 使用SCC9从PRD-300远程复制到QAS-400\n   - 源系统：PRD\n   - 源客户端：300\n   - 目标客户端：400（当前登录）\n   - Profile：KILLER_ALL（完整数据）\n4. 监控进度（SCC3）\n5. 完成后运行SUIM检查用户授权\n6. 修改客户端设置为\"不允许生产修改\"\n```\n\n**客户端角色设置**（T-Code: **SCC4**）：\n- **生产客户端**：不允许任何修改（Changes w/o Request: Not Allowed）\n- **质量客户端**：仅允许传输（Changes Only via Transport）\n- **开发客户端**：允许所有修改（Changes w/o Request: Allowed）\n- **沙箱客户端**：允许所有修改 + 不记录传输\n\n#### RFC连接管理 (Remote Function Call)\n\n**RFC连接类型**：\n\n| 类型 | 代码 | 用途 | 示例 |\n|------|------|------|------|\n| **同步RFC** | sRFC | 实时调用，等待返回 | 主数据同步 |\n| **异步RFC** | aRFC | 并行处理，不等待 | 批量数据传输 |\n| **事务RFC** | tRFC | 保证单次执行 | 财务过账 |\n| **队列RFC** | qRFC | 保证顺序执行 | 订单处理序列 |\n| **后台RFC** | bgRFC | S/4HANA新标准 | 分布式事务 |\n\n**RFC配置步骤**（T-Code: **SM59**）：\n\n```\n示例：配置从ECC到CRM的RFC连接\n\n1. 在SM59创建新RFC目标\n   - RFC目标名称：CRM_PRD_800\n   - 连接类型：3（ABAP连接）\n\n2. 技术设置：\n   - 目标主机：crmprd.company.com\n   - 系统编号：00\n   - 系统ID：CRM\n\n3. 登录与安全：\n   - 客户端：800\n   - 用户：RFC_USER_CRM\n   - 密码：********\n   - 语言：EN\n\n4. 特殊选项：\n   ✅ KILLER Router连接\n   ✅ SNC（安全网络通信）\n   - SNC Name: p:CN=CRM, OU=KILLER, O=Company\n   - SNC QoP: 最高安全级别（9）\n\n5. 测试连接：\n   - 远程登录测试（绿灯✅）\n   - Unicode测试（绿灯✅）\n   - 授权测试（调用RFC函数）\n```\n\n**RFC故障排查**：\n\n常见错误和解决方案：\n- **通信失败（Communication Failure）**:\n  - 检查防火墙规则：端口33<系统编号>（如3300）\n  - 验证/etc/services条目：KILLERdp00, KILLERgw00\n  - T-Code: **SM21** 查看系统日志\n\n- **用户授权不足**:\n  - 给RFC用户分配授权对象：S_RFC\n  - T-Code: **SU53** 查看最后失败的授权检查\n\n- **连接超时**:\n  - 增加超时参数：RFC_TIMEOUT（默认60秒）\n  - 检查网络延迟：ping, traceroute\n\n#### 系统复制方法 (System Copy)\n\n**同构系统复制**（相同数据库类型）：\n\n**方法1：备份/恢复法**（适用于同平台）\n```bash\n# 源系统PRD（生产）→ 目标系统QAS（质量）\n\n# 步骤1: 在PRD系统创建完整备份（停机维护窗口）\n# T-Code: DB13 或数据库工具\nHANA Backup:\nhdbsql -u SYSTEM -p <password> \"BACKUP DATA USING FILE ('/backup/PRD_FULL')\"\n\n# 步骤2: 传输备份文件到QAS服务器\nrsync -avz /backup/PRD_FULL/ qas-server:/backup/PRD_FULL/\n\n# 步骤3: 在QAS服务器恢复数据库\nhdbsql -u SYSTEM -p <password> \"RECOVER DATABASE UNTIL TIMESTAMP '2025-12-20 23:00:00' USING FILE ('/backup/PRD_FULL')\"\n\n# 步骤4: 更新系统配置\n# - 运行BDLS（逻辑系统名称转换）\n# - 更新RFC目标\n# - 清理后台作业（SM36）\n# - 重置打印机（SPAD）\n```\n\n**方法2：数据库复制法**（HANA System Replication）\n```\n用于灾难恢复和测试系统刷新：\n\nPrimary Site (PRD)  ─────HANA Replication──────>  Secondary Site (DR)\n    ↓                    Sync/Async                      ↓\n自动日志传输            数据复制                    只读/备用\n恢复点目标RPO=0        网络带宽需求                 快速接管RTO<10min\n```\n\n**异构系统迁移**（不同数据库类型，如Oracle → HANA）：\n\n使用**SUM+DMO**（Software Update Manager + Database Migration Option）:\n```\n迁移场景：ECC 6.0 on Oracle → S/4HANA on HANA\n\n停机时间估算（Downtime Estimation）：\n- 小型系统（<500GB）：8-16小时\n- 中型系统（500GB-2TB）：16-36小时\n- 大型系统（>2TB）：36-72小时\n\n迁移阶段：\n1. 准备阶段（Preparation）- 系统在线\n   - 预检查（PREPARE）\n   - 安装SUM工具\n   - 下载S/4HANA软件\n\n2. 业务停机开始（Downtime Starts）⏹️\n   - 导出表数据（Table Splitting）\n   - 并行导出提高速度\n\n3. 迁移阶段（Migration）\n   - R3load导出Oracle数据\n   - R3load导入HANA数据库\n   - 表转换（如BSEG → ACDOCA）\n\n4. 升级阶段（Upgrade）\n   - ABAP代码升级到S/4版本\n   - 简化数据模型\n   - 激活新业务功能\n\n5. 后处理（Post-Processing）\n   - IMG配置调整\n   - 自定义代码适配（ATC检查）\n   - 性能优化\n\n6. 业务恢复（Go-Live）🟢\n```\n\n**关键T-Codes**：\n- **BDLS**: 逻辑系统名称转换（Convert Logical System Names）\n- **SCC3**: 客户端复制日志分析\n- **SCCL**: 本地客户端复制（Client Copy - Special Selections）\n\n#### 后台作业管理 (Background Job Scheduling)\n\n**作业类型和调度**：\n\n**T-Code: SM36** - 定义后台作业\n\n```\n作业示例：每日财务对账自动化\n\n作业名称：DAILY_FI_RECON\n优先级：B级（高优先级）\n\n步骤1：ABAP程序\n- 程序名：ZFIRECON_DAILY\n- Variant：VAR_PROD\n- 选择屏幕参数：\n  * 公司代码：1000\n  * 过账日期：SY-DATUM（系统日期）\n  * 对账类型：银行对账\n\n步骤2：启动条件（Start Condition）\n- 立即：❌\n- 日期/时间：❌\n- 作业启动后：❌\n- 事件后：✅\n  * 事件ID：KILLER_FI_DAY_END_CLOSING\n  * 等待上游作业\"DAILY_POSTING_COMPLETE\"完成\n\n步骤3：周期性作业（Periodic Job）\n- 重复：✅\n- 周期值：每天（Daily）\n- 执行时间：02:00 AM\n- 限制：\n  * 不在周末运行：✅\n  * 节假日工厂日历：01\n```\n\n**作业监控公式**：\n\n```\n作业运行时间预测 = ∑(历史平均时间 × 数据量增长因子)\n\n示例：\n历史30天平均运行时间 = 45分钟\n数据量：上月1000万条 → 本月1200万条\n增长因子 = 1200/1000 = 1.2\n预测运行时间 = 45 × 1.2 = 54分钟\n```\n\n**作业链依赖**（Job Chains）：\n\n```mermaid\n作业A: 提取销售数据 (20:00)\n    ↓ Event: SALES_EXTRACT_DONE\n作业B: 数据清洗 (20:30)\n    ↓ Event: DATA_CLEAN_DONE\n作业C1: 财务报表          作业C2: 销售仪表盘\n    ↓                        ↓\n作业D: 发送管理层邮件 (23:00)\n```\n\n**关键T-Codes**：\n- **SM37**: 后台作业选择/监控\n- **SM36**: 定义后台作业\n- **SM62**: 事件维护（Event Maintenance）\n- **SM64**: 触发事件（Trigger Event）\n- **SM35**: 批量输入会话监控（Batch Input Sessions）\n\n#### 系统参数优化 (Profile Parameters)\n\n**关键参数类型**（T-Code: **RZ10**, **RZ11**）：\n\n| 参数类别 | 示例参数 | 默认值 | 优化建议 | 影响 |\n|----------|----------|--------|----------|------|\n| **内存管理** | `abap/heap_area_dia` | 2GB | 根据对话进程需求调整 | DIA进程可用内存 |\n| | `abap/heap_area_total` | 所有进程总和 | 不超过物理内存80% | 防止内存交换 |\n| | `em/initial_size_MB` | 20000 | HANA: 40000-100000 | 扩展内存池 |\n| **工作进程** | `rdisp/wp_no_dia` | 10 | 用户数/100 | 对话进程数量 |\n| | `rdisp/wp_no_btc` | 3 | 后台作业并发数 | 批处理能力 |\n| | `rdisp/wp_no_vb` | 1 | 更新频率高时增加 | 更新进程数 |\n| **表缓冲** | `zcsa/table_buffer_area` | 50MB | HANA: 500MB-2GB | 表缓冲大小 |\n| **RFC** | `gw/max_conn` | 500 | 集成多时增加 | 最大RFC连接数 |\n| **KILLER GUI** | `rdisp/gui_auto_logout` | 3600秒 | 根据安全要求 | 自动登出时间 |\n\n**工作进程数量计算公式**：\n\n```\n对话进程数 (DIA) = (并发用户数 × 1.5) ÷ 10\n                  向上取整\n\n示例：\n并发用户：300人\nDIA进程 = (300 × 1.5) ÷ 10 = 45个\n\n批处理进程数 (BTC) = 计划同时运行的后台作业数 + 缓冲(20%)\n\n示例：\n夜间批量作业：20个并发\nBTC进程 = 20 × 1.2 = 24个\n```\n\n**动态参数 vs 静态参数**：\n- **动态参数**：可在运行时通过RZ11修改，立即生效（如`rdisp/max_wprun_time`）\n- **静态参数**：需修改配置文件，重启KILLER实例生效（如`rdisp/wp_no_dia`）\n\n#### 系统监控 (System Monitoring)\n\n**关键监控事务码矩阵**：\n\n| 监控领域 | T-Code | 监控内容 | 告警阈值 | 频率 |\n|----------|--------|----------|----------|------|\n| **工作进程** | SM50/SM66 | 进程状态、运行时间 | 对话>600秒 ⚠️ | 实时 |\n| **数据库** | ST04 | DB性能、缓冲命中率 | 命中率<95% ⚠️ | 每15分钟 |\n| **系统日志** | SM21 | 系统错误、警告 | 严重错误>5 🔴 | 每小时 |\n| **性能** | ST03N | 响应时间、吞吐量 | 平均响应>2秒 ⚠️ | 每日 |\n| **用户** | AL08/SM04 | 在线用户、会话 | 用户数>许可 🔴 | 实时 |\n| **锁** | SM12 | 锁条目、锁等待 | 锁超时>10个 ⚠️ | 每30分钟 |\n| **传输** | STMS | 传输队列、导入状态 | 失败传输>0 🔴 | 每次传输后 |\n| **更新** | SM13 | 更新任务、错误 | 更新错误>0 🔴 | 每小时 |\n| **Dump分析** | ST22 | ABAP运行时错误 | Dump>10/天 ⚠️ | 每日 |\n\n**CCMS警报监控**（T-Code: **RZ20**）：\n\n```\n监控树结构示例：\n\nKILLER CCMS Monitor Templates\n├── Entire System\n│   ├── Dialog Response Time\n│   │   ├── 当前值：850ms\n│   │   ├── 阈值：黄色>1000ms, 红色>2000ms\n│   │   └── 状态：🟢 正常\n│   ├── CPU Utilization\n│   │   ├── 当前值：72%\n│   │   ├── 阈值：黄色>80%, 红色>90%\n│   │   └── 状态：🟢 正常\n│   ├── Database Performance\n│   │   ├── Buffer Hit Ratio：97.8%\n│   │   ├── 阈值：黄色<95%, 红色<90%\n│   │   └── 状态：🟢 正常\n│   └── Work Process Utilization\n│       ├── DIA Used：38/50 (76%)\n│       ├── 阈值：黄色>80%, 红色>90%\n│       └── 状态：🟢 正常\n└── Database\n    ├── Tablespace Usage\n    │   ├── PKILLERSR3：85% 已用\n    │   ├── 阈值：黄色>80%, 红色>90%\n    │   └── 状态：🟡 警告 - 需扩展\n    └── HANA Memory\n        ├── Used：180GB / 256GB (70%)\n        └── 状态：🟢 正常\n```\n\n---\n\n### 13.2 KILLER性能优化深度解析\n\n#### SQL性能分析 (SQL Trace - ST05)\n\n**ST05使用步骤**：\n\n```\n场景：分析慢速事务VA01（创建销售订单）\n\n步骤1：激活SQL跟踪（ST05）\n- 跟踪类型：✅ SQL Trace, ✅ Enqueue, ✅ RFC\n- 用户：USER123\n- 激活跟踪：开始\n\n步骤2：执行业务事务\n- 在另一个会话执行VA01\n- 创建测试订单\n- 完成事务\n\n步骤3：停用跟踪并分析\n- ST05 → 停用跟踪\n- 显示跟踪 → 选择USER123的跟踪记录\n\n步骤4：识别性能问题\n分析报告显示：\n┌──────────────────────────────────────────┐\n│ SQL语句                    执行次数  时间  │\n├──────────────────────────────────────────┤\n│ SELECT * FROM VBAK        1次    50ms  ✅│\n│ WHERE VBELN = '...'                      │\n├──────────────────────────────────────────┤\n│ SELECT * FROM VBAP        1次   120ms  ✅│\n│ WHERE VBELN = '...'                      │\n├──────────────────────────────────────────┤\n│ SELECT * FROM MARA        5,234次        │ 🔴\n│ FOR ALL ENTRIES           2,840ms       │ 🔴\n│ (无WHERE条件过滤)                        │\n└──────────────────────────────────────────┘\n\n问题识别：\n❌ MARA表（物料主数据）被执行5000+次\n❌ FOR ALL ENTRIES没有有效WHERE条件\n❌ 占总时间的85%\n\n解决方案：\n✅ 添加WHERE条件过滤（MATNR, WERKS）\n✅ 使用CDS View代替直接表查询\n✅ 启用表缓冲（SE11 - 技术设置）\n```\n\n**SQL优化最佳实践**：\n\n| 问题模式 | 优化方法 | 示例 |\n|----------|----------|------|\n| **全表扫描** | 创建二级索引 | `CREATE INDEX ZIDX_VBAK_ERDAT ON VBAK(ERDAT)` |\n| **FOR ALL ENTRIES无WHERE** | 添加过滤条件 | `WHERE MATNR IN lt_matnr AND WERKS = '1000'` |\n| **嵌套SELECT** | 使用JOIN | `INNER JOIN VBAP ON VBAK~VBELN = VBAP~VBELN` |\n| **SELECT *返回所有字段** | 只选择需要的字段 | `SELECT VBELN ERDAT KUNNR FROM VBAK` |\n| **循环内部SELECT** | 批量查询到内表 | `SELECT ... FOR ALL ENTRIES IN lt_data` |\n\n**数据库性能公式**：\n\n```\n响应时间 = DB请求时间 + 数据传输时间 + 应用处理时间\n\nDB请求时间 = 记录数 × 每条记录获取时间\n\n优化目标：\n- 减少记录数（WHERE条件过滤）\n- 提高获取速度（索引、表缓冲）\n- 减少数据传输（选择必要字段）\n\n示例：\n优化前：SELECT * FROM BSEG（1000万条）\n         无WHERE条件\n         执行时间：4500ms\n\n优化后：SELECT BUKRS BELNR GJAHR BUZEI WRBTR\n         FROM BSEG\n         WHERE BUKRS = '1000'\n         AND GJAHR = '2025'\n         AND BUDAT IN lr_date\n         执行时间：180ms（提速25倍）\n```\n\n#### ABAP运行时分析 (Runtime Analysis - SAT/SE30)\n\n**SAT（ABAP Profiling）使用**：\n\n```\n场景：优化自定义报表Z_SALES_REPORT性能\n\n步骤1：启动SAT，创建性能追踪\n- 事务代码：SAT\n- 对象类型：程序（Program）\n- 对象名称：Z_SALES_REPORT\n- 测量类型：完整追踪（Full Trace）\n\n步骤2：执行程序并分析\n追踪结果（总运行时间：8.5秒）：\n\n热点分析（Hit List - 按时间排序）：\n┌─────────────────────────────────────────────┐\n│ 模块/子程序              执行时间    占比     │\n├─────────────────────────────────────────────┤\n│ GET_CUSTOMER_DATA       4,200ms   49.4% 🔴 │\n│   ↳ SELECT FROM KNA1   3,800ms   44.7% 🔴 │\n│   ↳ LOOP AT内部表        400ms    4.7%    │\n├─────────────────────────────────────────────┤\n│ CALCULATE_REVENUE       2,100ms   24.7% ⚠️ │\n│   ↳ NESTED LOOP        1,850ms   21.8% 🔴 │\n│   ↳ 货币转换            250ms    2.9%    │\n├─────────────────────────────────────────────┤\n│ FORMAT_OUTPUT            900ms   10.6%    │\n│ 其他                    1,300ms   15.3%    │\n└─────────────────────────────────────────────┘\n\n调用次数分析（Call Hierarchy）：\nGET_CUSTOMER_DATA被调用：5,230次 ❌（应为1次）\n原因：在LOOP内部调用\n\n优化措施：\n1. 将GET_CUSTOMER_DATA移到LOOP外部\n2. 批量获取所有客户数据到内表\n3. LOOP时从内表READ，而非每次SELECT\n\n优化后追踪结果：1.2秒（提速7倍）✅\n```\n\n**内存分析** (Memory Inspector - T-Code: **S_MEMORY_INSPECTOR**):\n\n```\n内存使用分类：\n\n1. ABAP Memory（EXPORT/IMPORT共享内存）\n   - 跨程序调用共享数据\n   - T-Code: 无直接监控，通过SAT分析\n\n2. KILLER Memory（SET/GET PARAMETER共享内存）\n   - 用户会话级别共享\n   - 示例：SET PARAMETER ID 'BUK' FIELD '1000'\n\n3. Roll Memory（卷内存）\n   - 用户上下文数据\n   - 参数：ztta/roll_area\n\n4. Extended Memory（扩展内存）\n   - 大数据量内表\n   - 参数：em/initial_size_MB\n\n内存问题诊断：\nDump类型              原因                解决方案\n─────────────────────────────────────────────────\nTSV_TNEW_PAGE_ALLOC  扩展内存不足         增加em/initial_size_MB\nSTORAGE_PARAMETERS_  内表过大             分批处理/FREE内存\nWRONG_SET\nSYSTEM_NO_ROLL       卷内存不足           增加ztta/roll_area\n```\n\n#### 表缓冲优化 (Table Buffering)\n\n**缓冲类型**（SE11 - 技术设置 - 缓冲）：\n\n| 缓冲类型 | 适用场景 | 缓冲内容 | 示例表 |\n|----------|----------|----------|--------|\n| **完全缓冲** | 小表(<1000行)，读频繁 | 整表加载到应用服务器 | T001（公司代码）, T005（国家） |\n| **通用键缓冲** | 通过主键查询 | 单条记录缓冲 | USR02（用户）, KNA1（客户） |\n| **单键缓冲** | 按第一个键字段查询 | 相同第一键的所有记录 | T001W（工厂）按BUKRS |\n| **不缓冲** | 频繁修改，数据量大 | 不缓冲 | BSEG（会计凭证明细） |\n\n**缓冲命中率监控**（T-Code: **ST02**）：\n\n```\n数据缓冲区监控（Buffer Statistics）：\n\n表缓冲（TABL）：\n- 配置大小：500 MB\n- 当前使用：387 MB (77%)\n- 命中率：98.7% ✅\n- SWAP次数：23 ✅（<100为良好）\n\n通用表缓冲（TABLP）：\n- 配置大小：200 MB\n- 命中率：94.2% ⚠️（<95%需优化）\n- 失效次数：1,245（过高）\n\n优化建议：\n1. 增加TABLP缓冲区：zcsa/table_buffer_area = 300 MB\n2. 检查频繁失效的表（ST10）\n3. 考虑将大表改为\"通用键缓冲\"\n```\n\n**缓冲失效场景**：\n\n```\n场景1：价格表缓冲（A004 - 客户物料价格）\n问题：价格更新频繁，缓冲失效导致性能下降\n\n事件序列：\n10:00 - 用户A查询价格 → 缓冲加载✅\n10:05 - 用户B更新价格 → 缓冲失效🔴（所有应用服务器）\n10:06 - 用户C查询价格 → 缓冲未命中 → 从DB加载\n10:10 - 用户D查询价格 → 缓冲命中✅\n\n解决方案：\n- 价格主数据表：不缓冲（Buffering Not Allowed）\n- 改用HANA计算视图（CDS View）实时查询\n- 价格确定在HANA内存中完成\n```\n\n---\n\n### 13.3 KILLER安全管理深度解析\n\n#### 授权对象和角色设计 (Authorization Objects & PFCG)\n\n**授权概念架构**：\n\n```\n用户 (User)\n  ↓ 分配\n角色 (Role) [Composite Role组合角色]\n  ↓ 包含\n单一角色 (Single Role) [Z_FI_AP_CLERK]\n  ↓ 包含\n事务代码 (Transaction) [FB60, F-43, FBL1N]\n  ↓ 需要\n授权对象 (Auth Object) [F_BKPF_BUK, F_BKPF_GSB]\n  ↓ 字段值\n授权字段 (Field) [BUKRS=1000, ACTVT=01/02/03]\n```\n\n**授权对象结构示例**：\n\n授权对象：**F_BKPF_BUK** （会计凭证：公司代码）\n\n| 字段 | 描述 | 值示例 | 说明 |\n|------|------|--------|------|\n| BUKRS | 公司代码 | 1000, 2000, * | *=所有 |\n| ACTVT | 活动 | 01, 02, 03 | 01=添加, 02=更改, 03=显示 |\n\n授权对象：**F_BKPF_GSB** （会计凭证：过账期间）\n\n| 字段 | 描述 | 值示例 | 说明 |\n|------|------|--------|------|\n| BUKRS | 公司代码 | 1000 | |\n| GJAHR | 会计年度 | 2025 | |\n| MONAT | 期间 | 01-12 | 允许过账的期间 |\n| ACTVT | 活动 | 01, 02 | |\n\n**PFCG角色设计最佳实践**（T-Code: **PFCG**）：\n\n```\n角色命名规范：\nZ_<模块>_<功能>_<职位>\n\n示例：\nZ_FI_AP_CLERK     - 财务应付账款文员\nZ_MM_BUYER_SENIOR - 采购高级采购员\nZ_SD_ORDER_PROCESS - 销售订单处理员\n\n角色层次结构（推荐）：\n\n组合角色（Composite）：Z_FI_ACCOUNTANT\n├── 单一角色1：Z_FI_AP_CLERK（应付）\n├── 单一角色2：Z_FI_AR_CLERK（应收）\n└── 单一角色3：Z_FI_GL_INQUIRY（总账查询）\n\n优势：\n✅ 模块化，易维护\n✅ 减少冗余\n✅ 灵活组合\n```\n\n**创建角色详细步骤**：\n\n```\n场景：创建应付账款文员角色\n\nT-Code: PFCG\n\n步骤1：创建角色\n- 角色名：Z_FI_AP_CLERK\n- 描述：Accounts Payable Clerk - 应付账款文员\n\n步骤2：分配事务代码（Menu Tab）\n添加事务：\n- FB60：输入供应商发票\n- FV60：初步输入发票\n- F-43：输入供应商贷项凭证\n- F-44：清账（Clear）\n- FBL1N：供应商行项目显示\n- FK03：显示供应商主数据\n- ME23N：显示采购订单\n\n步骤3：生成授权（Authorizations Tab）\n点击\"生成\"→ 系统自动识别事务所需的授权对象：\n\n识别到的授权对象：\n┌─────────────────────────────────────────┐\n│ F_BKPF_BUK  - 会计凭证：公司代码         │\n│ F_BKPF_GSB  - 会计凭证：过账期间         │\n│ F_LFA1_BUK  - 供应商主记录：公司代码     │\n│ F_LFA1_GEN  - 供应商主记录：一般数据     │\n│ M_BEST_EKO  - 采购订单：显示             │\n└─────────────────────────────────────────┘\n\n步骤4：维护授权数据（Maintain Auth Data）\n对每个授权对象赋值：\n\nF_BKPF_BUK:\n  BUKRS = 1000, 2000（仅这两个公司代码）\n  ACTVT = 01, 02, 03（创建、更改、显示）\n\nF_BKPF_GSB:\n  BUKRS = 1000, 2000\n  GJAHR = 2025\n  MONAT = 01-12（所有期间）\n  ACTVT = 01, 02\n\nF_LFA1_BUK:\n  BUKRS = 1000, 2000\n  ACTVT = 03（仅显示，不可修改主数据）\n\n步骤5：用户分配（User Tab）\n- 分配用户：USER_AP01, USER_AP02\n- 有效期：2025-01-01 to 2025-12-31\n\n步骤6：保存并生成配置文件\n- 系统生成配置文件：KILLER_Z_FI_AP_CLERK\n- 状态：绿色✅（无错误）\n```\n\n**职责分离 (Segregation of Duties - SoD)**：\n\n冲突矩阵示例：\n\n| 角色A | 角色B | 风险 | 控制措施 |\n|-------|-------|------|----------|\n| 创建供应商主数据 | 输入发票 | 虚假供应商欺诈 | ✅分离角色，定期审计 |\n| 创建采购订单 | 审批采购订单 | 绕过审批流程 | ✅工作流审批，双人复核 |\n| 过账凭证 | 执行支付运行 | 未经授权支付 | ✅支付需二次审批 |\n| 创建用户 | 分配管理员角色 | 权限提升 | ✅双人制，审计日志 |\n\n**SoD检测工具**（T-Code: **SUIM** - 用户信息系统）：\n- 冲突角色报告\n- 关键授权检查\n- T-Code: **PFCG** → Utilities → Mass Generation\n\n#### 授权故障排查 (Authorization Troubleshooting)\n\n**SU53 - 最后失败的授权检查**：\n\n```\n场景：用户报告无法执行F-28（过账供应商付款）\n\n步骤1：用户尝试执行F-28 → 收到错误消息：\n\"您无权为公司代码3000过账\"\n\n步骤2：用户立即执行T-Code: SU53（或让管理员执行SU53分析用户）\n\nSU53显示：\n┌──────────────────────────────────────────────┐\n│ 授权检查失败详情                              │\n├──────────────────────────────────────────────┤\n│ 授权对象：F_BKPF_BUK                         │\n│ 事务代码：F-28                               │\n│ 程序：KILLERMF05A                               │\n├──────────────────────────────────────────────┤\n│ 检查的字段值：                               │\n│   BUKRS = 3000  ❌（用户缺少此值）          │\n│   ACTVT = 01    ✅（用户有创建权限）        │\n├──────────────────────────────────────────────┤\n│ 用户现有授权值：                             │\n│   BUKRS = 1000, 2000（没有3000）            │\n│   ACTVT = 01, 02, 03                        │\n└──────────────────────────────────────────────┘\n\n解决方案：\n1. 在PFCG打开角色Z_FI_AP_CLERK\n2. 进入Authorizations → Change Authorization Data\n3. 找到授权对象F_BKPF_BUK\n4. 添加BUKRS = 3000\n5. 保存并生成角色\n6. 通知用户重新登录（F-28现在可用✅）\n```\n\n**SUIM - 用户信息系统高级查询**：\n\n```\n常用报告（T-Code: SUIM）：\n\n1. 用户对比（Users by Complex Selection Criteria）\n   - 查询：拥有KILLER_ALL的用户\n   - 结果：应为空或仅紧急用户\n\n2. 关键事务分配（Users by Transaction Assignment）\n   - 查询：谁有权限执行SE16（查看表数据）\n   - 结果：应仅限Basis管理员和审计员\n\n3. 授权值（Users by Authorization Values）\n   - 授权对象：S_TCODE\n   - 授权值：TCD = *（所有事务代码）\n   - 结果：风险用户列表🔴\n\n4. 角色对比（Roles by Complex Selection Criteria）\n   - 查询：包含调试权限的角色（S_DEVELOP, ACTVT=02）\n   - 结果：审核生产环境不应有调试权\n```\n\n#### 安全审计日志 (Security Audit Log - SM19/SM20)\n\n**SM19 - 审计配置**：\n\n```\n启用审计日志：\n\n配置文件：RSAU_CONFIG\n\n审计事件选择：\n✅ 成功和失败的登录尝试\n✅ RFC调用\n✅ 事务启动（关键事务如SE16, SE38, SM59）\n✅ 报表启动\n✅ 授权检查失败\n✅ 用户主数据更改\n✅ 批量用户解锁（SU01）\n\n存储参数：\n- 静态安全审计日志：激活✅\n- 日志文件路径：/usr/KILLER/<SID>/D00/log/audit_<DATE>\n- 保留期：90天\n- 文件大小限制：2GB自动轮转\n```\n\n**SM20 - 审计日志分析**：\n\n```\n场景：调查可疑的数据库表访问\n\nSM20筛选条件：\n- 日期：2025-12-20\n- 用户：*（所有）\n- 事务代码：SE16, SE16N（表数据浏览器）\n- 事件类型：启动事务\n\n分析结果：\n┌────────────────────────────────────────────────┐\n│时间      用户      事务  目标对象      结果      │\n├────────────────────────────────────────────────┤\n│14:23:45 USER_EXT  SE16  表USR02      成功✅   │🔴\n│14:24:12 USER_EXT  SE16  表USR21      成功✅   │🔴\n│14:25:03 USER_EXT  SE16  表T001      成功✅   │\n│14:26:34 USER_EXT  SE16N 表BSEG      失败❌   │\n│         (授权检查失败 - S_TABU_DIS)           │\n└────────────────────────────────────────────────┘\n\n发现：\n🔴 外部用户USER_EXT访问用户主数据表（USR02, USR21）\n🔴 非授权行为，违反安全政策\n\n行动：\n1. 立即锁定用户USER_EXT（SU01）\n2. 审查用户角色分配\n3. 检查是否有数据泄露\n4. 报告安全事件\n5. 撤销SE16权限\n```\n\n---\n\n### 13.4 本地化模块深度解析\n\n#### 中国本地化 (Localization for China)\n\n**金税接口 (Golden Tax Interface)**：\n\n```\n中国增值税发票系统集成：\n\nKILLER → 金税盘/税控盘 → 国家税务总局\n\n流程：\n1. KILLER开具销售发票（VF01）\n2. 系统生成发票数据\n3. 接口程序（Z程序或中间件）传输数据到金税系统\n4. 金税系统打印增值税专用发票\n5. 发票号码回传KILLER\n6. KILLER更新会计凭证\n\n数据映射：\nKILLER字段              金税字段              示例值\n─────────────────────────────────────────────────\nVBRK-VBELN         发票代码               8800123456\nVBRK-FKDAT         开票日期               2025-12-20\nKNA1-NAME1         购方名称               ABC公司\nKNA1-STCD1         购方税号               91110000MA01234567\nVBRP-NETWR         不含税金额             10,000.00\nVBRP-MWSBP         税额                   1,300.00 (13%税率)\nVBRK-NETWR + TAX   价税合计               11,300.00\n```\n\n**增值税税率配置**（T-Code: **FTXP**）：\n\n| 业务类型 | 税率 | 税码 | 适用 |\n|----------|------|------|------|\n| 一般商品销售 | 13% | V1 | 默认增值税率 |\n| 农产品、图书 | 9% | V2 | 低税率 |\n| 出口免税 | 0% | V0 | 出口业务 |\n| 简易征收 | 3% | V3 | 小规模纳税人 |\n| 服务业 | 6% | V4 | 现代服务业 |\n\n**发票认证与抵扣**：\n\n```\n进项税抵扣流程：\n\n步骤1：收到供应商增值税专用发票\n- 录入发票（MIRO）\n- 系统生成会计凭证：\n  借：原材料        10,000\n  借：进项税         1,300\n  贷：应付账款      11,300\n\n步骤2：发票认证（外部系统）\n- 扫描发票\n- 上传税务局平台\n- 获取认证结果\n\n步骤3：在KILLER标记已认证\n- 自定义字段：ZVERTIFIED = 'X'\n- 认证日期：ZVERTDATE = 2025-12-25\n\n步骤4：申报期抵扣\n- 运行报表Z_VAT_RETURN\n- 生成申报表：\n  * 销项税合计：150,000\n  * 进项税合计：120,000\n  * 应纳税额：30,000\n```\n\n#### 印度本地化 (Localization for India - GST)\n\n**商品及服务税 (Goods and Services Tax - GST)**：\n\nGST架构（2017年7月1日实施）：\n\n```\nGST类型：\n1. CGST (Central GST) - 中央税\n2. SGST (State GST) - 邦税\n3. IGST (Integrated GST) - 跨邦税\n4. UGST (Union Territory GST) - 联邦属地税\n\n税率结构：\n商品/服务类别       CGST    SGST    IGST    总税率\n─────────────────────────────────────────────────\n必需品（米、盐）     0%      0%      0%      0%\n大众消费品          2.5%    2.5%    5%      5%\n标准商品            9%      9%      18%     18%\n奢侈品/服务         14%     14%     28%     28%\n\nKILLER配置（T-Code: J1IEX - GST设置）：\n- GST登记号（GSTIN）：每个公司代码/工厂\n- HSN/SAC代码：商品/服务分类\n- 税码配置：自动拆分CGST/SGST/IGST\n```\n\n**GST发票示例**（T-Code: **VF01**）：\n\n```\n场景：从马哈拉施特拉邦销售到古吉拉特邦（跨邦）\n\n销售发票详情：\n─────────────────────────────────────────\n卖方：\n  名称：XYZ Ltd.\n  GSTIN：27AAAAA1234A1Z5（马邦）\n\n买方：\n  名称：ABC Pvt Ltd.\n  GSTIN：24BBBBB5678B1Z2（古邦）\n\n商品：电子产品\nHSN代码：8471（自动数据处理机器）\n数量：10台\n单价：₹50,000\n基础金额：₹500,000\n\n税金计算（跨邦 → 使用IGST）：\n  IGST @ 18%：₹90,000\n\n发票总额：₹590,000\n─────────────────────────────────────────\n\nKILLER会计凭证：\n借：应收账款 - ABC         590,000\n贷：销售收入               500,000\n贷：IGST应交税金            90,000\n```\n\n**GSTR申报表生成**：\n\n```\n印度GST申报周期：月度\n\n报表类型：\n- GSTR-1：销项明细（每月10日前）\n- GSTR-2A：进项明细（自动生成）\n- GSTR-3B：汇总申报（每月20日前）\n\nKILLER标准报表（T-Code: J1INACCR）：\n→ 提取销售/采购数据\n→ 按GST类型汇总（CGST/SGST/IGST）\n→ 生成Excel/XML上传到GST Portal\n\nGSTR-3B示例：\n┌────────────────────────────────────────┐\n│ 3.1 销项税（Outward Supplies）         │\n│   (a) 应税销售额：₹10,000,000         │\n│   (b) IGST：₹1,800,000                │\n│   (c) CGST：₹900,000                  │\n│   (d) SGST：₹900,000                  │\n├────────────────────────────────────────┤\n│ 4.1 进项税（Input Tax Credit - ITC）   │\n│   (A) 进项抵扣：                       │\n│       IGST：₹1,200,000                │\n│       CGST：₹600,000                  │\n│       SGST：₹600,000                  │\n├────────────────────────────────────────┤\n│ 5.1 应纳税额（Net Payable）            │\n│   IGST：₹600,000                      │\n│   CGST：₹300,000                      │\n│   SGST：₹300,000                      │\n│   总计：₹1,200,000                    │\n└────────────────────────────────────────┘\n```\n\n#### 巴西本地化 (Localization for Brazil - SPED)\n\n**电子税务系统 (SPED - Sistema Público de Escrituração Digital)**：\n\n```\nSPED组成部分：\n\n1. NF-e (Nota Fiscal Eletrônica) - 电子发票\n2. SPED Fiscal - 税务会计记录\n3. SPED Contribuições - 社会贡献\n4. EFD ICMS/IPI - 州税/工业产品税\n\nKILLER集成架构：\nKILLER ECC/S/4        → XML生成       → SEFAZ验证    → 授权\n(开票VF01)           (J1BNFE)        (政府服务器)     (返回NFe号)\n```\n\n**NF-e电子发票流程**（T-Code: **J1BNFE**）：\n\n```\n步骤1：创建销售发票（VF01）\n- 客户：Cliente ABC Ltda\n- CNPJ：12.345.678/0001-99\n- 商品：Produto X, 数量100, 单价R$50\n\n步骤2：生成NF-e XML\n- T-Code: J1BNFE\n- 选择发票\n- 系统生成XML文件（NFe_35251212345678000199550010000000011123456789.xml）\n\nXML包含：\n<NFe>\n  <infNFe>\n    <emit>       <!-- 开票方 -->\n      <CNPJ>12345678000199</CNPJ>\n      <xNome>Empresa XYZ</xNome>\n    </emit>\n    <dest>       <!-- 收票方 -->\n      <CNPJ>12345678000199</CNPJ>\n    </dest>\n    <det nItem=\"1\">\n      <prod>\n        <cProd>PROD001</cProd>\n        <vProd>5000.00</vProd>  <!-- 商品金额 -->\n      </prod>\n      <imposto>\n        <ICMS>  <!-- 州税 -->\n          <pICMS>18.00</pICMS>  <!-- 18%税率 -->\n          <vICMS>900.00</vICMS>\n        </ICMS>\n        <IPI>   <!-- 工业产品税 -->\n          <pIPI>10.00</pIPI>\n          <vIPI>500.00</vIPI>\n        </IPI>\n      </imposto>\n    </det>\n    <total>\n      <vNF>6400.00</vNF>  <!-- 发票总额 -->\n    </total>\n  </infNFe>\n</NFe>\n\n步骤3：发送至SEFAZ授权\n- 系统自动通过Web Service发送\n- SEFAZ验证XML签名和数据\n- 返回授权密钥（Chave de Acesso）：\n  3525 1212 3456 7800 0199 5501 0000 0000 1112 3456 789\n\n步骤4：打印DANFE（发票辅助单据）\n- PDF格式，包含二维码\n- 随货物运输\n```\n\n**SPED Fiscal文件生成**（T-Code: **J1BTAX**）：\n\n```\n月度税务记录文件：\n\n记录类型：\n- 0000：文件头\n- 0150：参与者登记（客户/供应商）\n- C100：发票记录\n- C170：发票明细（商品）\n- C190：税金汇总\n- E110：ICMS应付记录\n\n文件示例（SPED_FISCAL_202512.txt）：\n|0000|015|01012025|31012025|EMPRESA XYZ|12345678000199|\n|0150|12345678000199|CLIENTE ABC|...\n|C100|0|1|12345|01012025|5000.00|900.00|...\n|C170|1|PROD001|100|50.00|5000.00|...\n|C190|18.00|900.00|...\n\n上传至政府SPED系统（每月15日前）\n```\n\n---\n\n### 13.5 更多行业解决方案深化\n\n#### IS-Defense (国防与安全行业)\n\n**军事物资管理 (Military Logistics)**：\n\n```\n国防特殊需求：\n\n1. 北约库存编号 (NATO Stock Number - NSN)\n   - 格式：9999-99-999-9999（13位）\n   - 示例：5895-01-234-5678\n   - KILLER字段：MARA-MATNR扩展\n\n2. 技术出口管制 (Export Control)\n   - ECCN代码（Export Control Classification Number）\n   - ITAR管制（国际武器贸易条例）\n   - KILLER配置：自定义字段MARC-ZECCN\n\n3. 序列化与可追溯性\n   - 武器系统完整生命周期跟踪\n   - 从制造 → 部署 → 维护 → 退役\n   - T-Code: IQ01/IQ02/IQ03（设备主记录）\n\n4. 安全分类 (Security Classification)\n   - 等级：非密 | 受限 | 机密 | 绝密\n   - KILLER授权对象：自定义Z_SECURITY_CLASS\n   - 数据加密：HANA原生加密\n\n示例：导弹系统物料主数据\n物料号：MIS-AGM-114-HELLFIRE\nNSN：1410-01-123-4567\nECCN：0A018\nITAR：是✅\n安全等级：机密\n序列号范围：HF2025-0001 to HF2025-5000\n```\n\n**项目制造 (Project-Based Manufacturing)**：\n\n```\n场景：战斗机生产（F-35）\n\n结构：\n项目：F-35_LOT15（第15批次生产）\n  ↓\nWBS元素层次：\n1.0 机身制造\n  1.1 前机身\n  1.2 中机身\n  1.3 后机身\n2.0 航空电子\n  2.1 雷达系统\n  2.2 通信系统\n3.0 发动机集成\n4.0 武器系统\n5.0 总装与测试\n\n每架飞机：\n- 独立项目号（如F35-001, F35-002...）\n- 成本对象：订单（生产订单）\n- 结算接收方：项目WBS\n- 物料清单（BOM）：多级，10,000+组件\n- 生产周期：18个月\n\n成本跟踪：\nWBS元素：1.1前机身\n  计划成本：$5,000,000\n  实际成本：$5,200,000\n  差异：$200,000超支（4%）⚠️\n\n原因分析：\n- 钛合金材料价格上涨：$120,000\n- 返工（质量问题）：$80,000\n```\n\n#### IS-Mining (矿业)\n\n**矿石品位管理 (Ore Grade Management)**：\n\n```\n矿业特殊需求：\n\n1. 品位跟踪（Grade Tracking）\n   - 铁矿石Fe含量：45%-68%\n   - 铜矿Cu含量：0.5%-2.5%\n   - 金矿Au含量：1-10克/吨\n\nKILLER批次主数据扩展：\n批次：ORE-2025-12-001\n  分类特性：\n    FE_CONTENT：62.5%（铁含量）\n    SIO2_CONTENT：4.2%（二氧化硅）\n    AL2O3_CONTENT：1.8%（氧化铝）\n    MOISTURE：8.5%（湿度）\n    MESH_SIZE：-10mm（粒度）\n\n配矿计算（Blending Calculation）：\n目标：生产62%Fe品位铁矿石1000吨\n\n批次A：65% Fe, 可用量500吨\n批次B：60% Fe, 可用量800吨\n\n混合比例计算：\n设批次A用量=x，批次B用量=y\nx + y = 1000\n65x + 60y = 62 × 1000\n\n求解：\n65x + 60(1000-x) = 62000\n5x = 2000\nx = 400吨（批次A）\ny = 600吨（批次B）\n\n验证：400×65% + 600×60% = 62000 ✅\n```\n\n**矿山规划与调度**：\n\n```\n采矿生产计划（T-Code: /MRSS/SPP - Strategic Production Planning）\n\n矿山：铜矿露天矿\n年产能：500万吨原矿\n品位：平均1.2% Cu\n\n月度计划：\n┌────────────────────────────────────────────┐\n│ 采矿区  计划吨数  预测品位  产铜量(吨)      │\n├────────────────────────────────────────────┤\n│ Pit-A   150,000   1.5%Cu    2,250         │\n│ Pit-B   200,000   1.0%Cu    2,000         │\n│ Pit-C   100,000   0.8%Cu      800         │\n│ 合计    450,000   1.12%     5,050         │\n└────────────────────────────────────────────┘\n\n设备调度：\n- 挖掘机：5台（每台200吨/小时）\n- 矿车：20辆（每辆150吨载重）\n- 破碎机：2台（每台500吨/小时）\n\n设备利用率计算：\n工作时间 = 450,000吨 ÷ (5台×200吨/小时×0.85利用率)\n         = 450,000 ÷ 850\n         = 529小时\n         = 22天（24小时运营）\n```\n\n#### IS-Media (媒体行业深化)\n\n**数字版权管理 (Digital Rights Management - DRM)**：\n\n```\n内容权利管理：\n\n权利对象层次：\n内容资产（Content Asset）：电影《示例片》\n  ↓\n权利包（Rights Package）：\n  - 地域权利：中国大陆、香港、台湾\n  - 时间窗口：2025-01-01 to 2027-12-31\n  - 媒体类型：影院、流媒体、DVD\n  ↓\n授权许可（License）：\n  被许可方：流媒体平台A\n  权利：非独家流媒体权\n  地域：中国大陆\n  期限：2年\n  费用结构：\n    - 保底费（MG）：$500,000\n    - 分成比例：观看收入的25%\n    - 结算周期：季度\n\n收入分成计算：\nQ1 2025流媒体收入：$800,000\n合同分成：$800,000 × 25% = $200,000\n已付保底费分摊：$500,000 ÷ 8季度 = $62,500\n\n应付金额 = MAX($200,000 - $62,500, 0)\n         = $137,500\n\nKILLER会计处理：\n借：应收账款 - 平台A        200,000\n贷：版权收入 - 流媒体        200,000\n\n借：递延收入 - 保底费摊销     62,500\n贷：版权收入 - 保底费摊销     62,500\n```\n\n**广告销售管理**：\n\n```\n电视广告排期（T-Code: 自定义Z_AD_SCHEDULE）\n\n场景：黄金时段广告销售\n\n广告时段定价：\n时段              CPM(千人成本)   收视率   广告时长   单价\n─────────────────────────────────────────────────────\n19:30-20:00      $50           8.5%     15秒      $6,375\n20:00-21:00      $80           12.0%    30秒      $28,800\n21:00-22:00      $65           9.5%     15秒      $9,263\n\n计算公式：\n广告费 = (目标观众数 ÷ 1000) × CPM\n\n示例：20:00-21:00时段，30秒广告\n目标观众数 = 总人口5000万 × 收视率12.0% = 600万\n广告费 = (6,000,000 ÷ 1000) × $80 × (30秒/15秒基准)\n       = 6,000 × $80 × 2\n       = $960,000（实际使用固定价$28,800是简化模型）\n\n广告排期优化：\n客户：汽车品牌X\n预算：$500,000\n目标：最大化触达\n策略：\n  - 黄金时段：3个30秒广告 = $86,400\n  - 次黄金：8个15秒广告 = $74,000\n  - 周末：10个30秒广告 = $120,000\n  - 总计：$280,400（剩余预算可用于制作）\n```\n\n---\n\n### 13.6 KILLER智能技术深度解析\n\n#### KILLER Joule (AI Copilot)\n\n**自然语言交互**：\n\n```\nJoule使用场景：\n\n场景1：财务分析师查询\n用户输入（自然语言）：\n\"Show me the top 10 customers by revenue in Q4 2025 for company code 1000\"\n\nJoule处理：\n1. 理解意图：查询客户收入排名\n2. 识别参数：\n   - 时间范围：Q4 2025（10月-12月）\n   - 公司代码：1000\n   - 排序：Revenue降序\n   - 限制：Top 10\n3. 自动生成SQL（通过CDS视图）：\n   SELECT TOP 10 CustomerName, SUM(Revenue) as TotalRevenue\n   FROM I_BillingDocument\n   WHERE CompanyCode = '1000'\n     AND BillingDate >= '2025-10-01'\n     AND BillingDate <= '2025-12-31'\n   GROUP BY CustomerName\n   ORDER BY TotalRevenue DESC\n\n4. 展示结果：\n   ┌─────────────────────────────────┐\n   │ 客户          Q4收入($)          │\n   ├─────────────────────────────────┤\n   │ Acme Corp     $1,250,000        │\n   │ Global Inc    $980,000          │\n   │ Tech Solutions $875,000         │\n   │ ...                             │\n   └─────────────────────────────────┘\n\n5. 建议后续操作：\n   \"Would you like to:\n    - Drill down into Acme Corp details?\n    - Compare with Q3 2025?\n    - Export to Excel?\"\n```\n\n**场景2：采购员库存检查**\n\n```\n用户：Joule自然语言输入\n\"Do we have enough stock of material 1000 in plant 1000 for next month's production?\"\n\nJoule智能处理：\n1. 查询当前库存（MB52）\n2. 读取下月生产计划（MD04）\n3. 计算需求 vs 可用量\n4. 检查在途采购订单\n\n响应：\n\"Current stock of material 1000 in plant 1000: 5,000 EA\n\nNext month production requirement: 8,500 EA\n\nShortfall: 3,500 EA ⚠️\n\nOpen purchase orders:\n- PO 4500012345: 2,000 EA, delivery 2025-12-28\n- PO 4500012389: 1,800 EA, delivery 2026-01-05\n\nRecommendation:\n✅ PO 4500012389 will cover the gap\n⚠️ But delivery is 5 days into next month - consider expediting\n\nWould you like me to create a purchase requisition for earlier delivery?\"\n\n用户：\"Yes, create PR for 2000 EA with delivery date Dec 28\"\n\nJoule：\n\"✅ Purchase requisition 10002234 created:\n- Material: 1000\n- Quantity: 2,000 EA\n- Delivery date: 2025-12-28\n- Plant: 1000\n- Assigned to buyer group: 001\n\nPR is now in approval workflow.\"\n```\n\n**Joule技术架构**：\n\n```\n用户自然语言查询\n    ↓\nKILLER Joule AI引擎\n    ├→ 意图识别（Intent Recognition）\n    ├→ 实体提取（Entity Extraction）- 客户、物料、日期等\n    ├→ 上下文管理（Context Management）- 多轮对话\n    └→ 知识图谱（Knowledge Graph）- KILLER业务对象关系\n    ↓\nKILLER Business AI\n    ├→ 生成式AI（Generative AI）- 基于GPT架构\n    ├→ 预测AI（Predictive AI）- 机器学习模型\n    └→ 决策AI（Decision AI）- 优化算法\n    ↓\nKILLER数据层\n    ├→ S/4HANA ACDOCA（财务）\n    ├→ CDS Views（分析）\n    ├→ BW/4HANA（历史数据）\n    └→ Datasphere（数据湖）\n    ↓\n执行层\n    ├→ 查询结果展示\n    ├→ 自动创建事务（PR, PO, Invoice）\n    └→ 工作流触发\n```\n\n#### KILLER Business AI (预测与优化)\n\n**需求预测 (Demand Forecasting)**：\n\n```\n使用KILLER Integrated Business Planning (IBP) + AI\n\n场景：消费品公司预测下季度需求\n\n历史数据（24个月）：\n月份        实际销量    促销活动    季节指数\n2023-01    10,500      否         0.85\n2023-02    12,000      是         0.90\n...\n2025-11    18,500      否         1.25\n2025-12    22,000      是         1.45\n\nAI模型：时间序列 + 机器学习混合模型\n- ARIMA（自回归移动平均）\n- XGBoost（梯度提升）\n- LSTM（长短期记忆神经网络）\n\n输入特征：\n- 历史销量\n- 促销活动（是/否）\n- 季节性指数\n- 节假日\n- 经济指标（GDP增长率、CPI）\n- 竞争对手活动\n\n预测结果（2026-01）：\n┌────────────────────────────────────────┐\n│ 模型         预测值      置信区间(95%)  │\n├────────────────────────────────────────┤\n│ ARIMA       15,200     [13,500-17,000] │\n│ XGBoost     16,500     [15,000-18,200] │\n│ LSTM        16,800     [15,500-18,100] │\n│ 集成模型     16,400     [15,200-17,800]│✅\n└────────────────────────────────────────┘\n\n建议采购量计算：\n预测需求：16,400\n安全库存：2,000（覆盖1周需求波动）\n当前库存：3,500\n在途订单：5,000\n建议采购 = 16,400 + 2,000 - 3,500 - 5,000\n         = 9,900单位\n\nAI还识别风险：\n⚠️ 预测准确度：±8.5%\n⚠️ 如果竞争对手促销，需求可能+15%\n✅ 建议留10%弹性：采购10,900单位\n```\n\n**智能现金流预测**：\n\n```\nKILLER Cash Application + AI\n\n预测未来30天现金流：\n\n应收账款收款预测：\n客户            发票金额    预测收款日   概率    预测金额\n─────────────────────────────────────────────────────\n客户A(优质)     $100,000   +5天        98%    $98,000\n客户B(一般)     $50,000    +15天       85%    $42,500\n客户C(风险)     $80,000    +45天       60%    $48,000\n\nAI基于：\n- 历史付款行为（DSO - Days Sales Outstanding）\n- 发票账龄\n- 客户信用评分\n- 行业付款习惯\n- 宏观经济指标\n\n现金流预测：\n日期        预测收入    预测支出    净现金流   累计现金\n─────────────────────────────────────────────────────\n12/21      $120,000    $80,000    +$40,000   $500,000\n12/22      $95,000     $110,000   -$15,000   $485,000\n...\n12/31      $200,000    $150,000   +$50,000   $680,000⬆️\n\nAI预警：\n⚠️ 12/25现金余额将降至$420,000，接近最低现金要求$400,000\n建议：提前3天联系客户A加速付款，或使用短期信贷额度\n```\n\n#### KILLER Build (低代码/无代码开发)\n\n**KILLER Build Apps（应用开发）**：\n\n```\n场景：创建移动仓库收货应用（无需编码）\n\n拖放式UI设计：\n┌─────────────────────────────────┐\n│  📱 Goods Receipt App            │\n├─────────────────────────────────┤\n│  [Scan PO Number]  📷           │\n│  PO: ______________             │\n│                                 │\n│  PO Details:                    │\n│  Vendor: ___________            │\n│  Material: _________            │\n│  Quantity: _________            │\n│                                 │\n│  Received Quantity:             │\n│  [- ] 0 [ + ]                   │\n│                                 │\n│  Storage Location:              │\n│  [Dropdown: 1001-Main Warehouse]│\n│                                 │\n│  [Post Goods Receipt] 按钮      │\n└─────────────────────────────────┘\n\n后端集成（通过可视化流程）：\n1. 扫描条形码 → 触发事件\n2. 调用KILLER OData服务\n   - API: /API_PURCHASEORDER_PROCESS_SRV\n   - Method: GET PurchaseOrder('{PONumber}')\n3. 获取PO详情并填充UI\n4. 用户输入收货数量\n5. 点击按钮 → 调用BAPI\n   - BAPI: BAPI_GOODSMVT_CREATE\n   - Parameters:\n     * GOODSMVT_CODE: 01（收货）\n     * GOODSMVT_HEADER: Doc Date, Posting Date\n     * GOODSMVT_ITEM: Material, Plant, Qty, PO Number\n6. 成功 → 显示物料凭证号\n   失败 → 显示错误消息\n\n开发时间：传统ABAP开发2-3周 vs KILLER Build 2-3天🚀\n```\n\n**KILLER Build Process Automation（流程自动化）**：\n\n```\n场景：发票审批流程自动化（RPA + Workflow）\n\n流程步骤：\n1. Bot监控邮箱收到PDF发票\n2. 提取发票数据（OCR + AI）\n   - 供应商名称\n   - 发票号\n   - 日期\n   - 金额\n   - 行项目明细\n3. 验证数据：\n   - 供应商在KILLER主数据中存在？\n   - 有匹配的采购订单？\n   - 金额在容差范围内（±5%）？\n4. 决策节点：\n   - 完全匹配 → 自动过账（FB01）✅\n   - 部分匹配 → 发送审批工作流⚠️\n   - 无匹配 → 转人工处理🔴\n\n审批工作流（部分匹配情况）：\n发票金额$10,500 vs PO金额$10,000（差异5%)\n\n工作流：\nStep 1: 发送通知给采购员\n  \"PO 4500012345 invoice received with 5% variance.\n   PO Amount: $10,000\n   Invoice Amount: $10,500\n\n   [Approve] [Reject] [Request Info]\"\n\nStep 2: 如果批准\n  → 自动在KILLER创建发票（MIRO）\n  → 触发付款工作流\n\nStep 3: 如果拒绝\n  → 发送邮件给供应商要求更正\n  → 归档拒绝原因\n\n流程指标：\n- 自动化率：75%（直接过账）\n- 平均处理时间：从3天降至4小时\n- 错误率：从8%降至0.5%\n```\n\n---\n\n## 第十四章：KILLER集成、开发与云生态\n\n### 14.1 KILLER集成技术深度解析\n\n#### KILLER Process Integration / Process Orchestration (PI/PO)\n\n**集成场景架构**：\n\n```\n系统格局（System Landscape）：\n┌─────────────┐         ┌─────────────┐         ┌─────────────┐\n│  KILLER ECC    │         │  PI/PO      │         │  Salesforce │\n│  (发送方)    │────────>│ (中间件)    │────────>│  (接收方)   │\n│             │  IDoc   │             │  REST   │             │\n│  T-Code:    │         │  ┌────────┐ │  JSON   │  客户订单   │\n│  VL01N发货  │         │  │ 集成引擎│ │         │  同步       │\n└─────────────┘         │  └────────┘ │         └─────────────┘\n                        │  ┌────────┐ │\n                        │  │映射设计│ │\n                        │  └────────┘ │\n                        │  ┌────────┐ │\n                        │  │适配器  │ │\n                        │  └────────┘ │\n                        └─────────────┘\n```\n\n**PI/PO组件详解**：\n\n| 组件 | 功能 | 工具/T-Code | 用途 |\n|------|------|-------------|------|\n| **Integration Builder** | 设计时工具 | ESR (Enterprise Services Repository) | 定义消息接口、映射 |\n| **Integration Directory** | 配置工具 | ID | 配置通信通道、接收方确定 |\n| **Adapter Engine** | 运行时适配器 | 内置引擎 | 处理各种协议（HTTP, SOAP, File, JDBC） |\n| **Business Process Engine** | 流程编排 | ccBPM | 定义复杂业务流程 |\n| **Runtime Workbench** | 监控 | RWB | 监控消息、组件、适配器 |\n\n**集成流程示例**（订单到发货集成）：\n\n```\n场景：KILLER ECC销售订单 → KILLER EWM（扩展仓库管理）\n\n步骤1：配置发送方系统（ECC）\n- 逻辑系统：ECCCLNT100\n- 发送消息类型：ORDERS05（订单IDoc）\n- 出站参数配置（WE20）\n  * 合作伙伴类型：LS（逻辑系统）\n  * 消息类型：ORDERS\n  * 接收方端口：A000000001\n\n步骤2：在PI/PO中创建集成对象\n\nESR（Enterprise Services Repository）：\n1. 数据类型（Data Type）：\n   - DT_Order（ECC订单结构）\n   - DT_InboundDelivery（EWM入库交货结构）\n\n2. 消息类型（Message Type）：\n   - MT_Order_Out（源）\n   - MT_InboundDelivery_In（目标）\n\n3. 消息映射（Message Mapping）：\n   - MM_Order_to_Delivery\n   - 字段映射逻辑：\n     ORDERS-VBELN (订单号) → INBOUND_DELIVERY-VBELN_VL (交货号)\n     ORDERS-KUNNR (客户) → INBOUND_DELIVERY-KUNNR\n     ORDERS-POSNR (行项目) → INBOUND_DELIVERY-POSNR\n\n4. 操作映射（Operation Mapping）：\n   - OM_Order_to_Delivery（关联消息映射）\n\nIntegration Directory（ID）配置：\n1. 通信组件（Communication Component）：\n   - ECC_Sender\n   - EWM_Receiver\n\n2. 通信通道（Communication Channel）：\n   发送方：\n   - 名称：CC_ECC_IDoc_Sender\n   - 适配器类型：IDoc_AAE\n   - KILLER系统：ECCCLNT100\n\n   接收方：\n   - 名称：CC_EWM_HTTP_Receiver\n   - 适配器类型：SOAP\n   - 目标URL：http://ewm-server:8000/KILLER/bc/srt/idoc\n\n3. 接收方确定（Receiver Determination）：\n   - 发送方：ECC\n   - 接口：SI_Order_Out\n   - 接收方：EWM\n\n4. 接口确定（Interface Determination）：\n   - 操作映射：OM_Order_to_Delivery\n\n5. 发送方协议（Sender Agreement）：\n   - 通信通道：CC_ECC_IDoc_Sender\n\n6. 接收方协议（Receiver Agreement）：\n   - 通信通道：CC_EWM_HTTP_Receiver\n\n步骤3：激活并测试\n- 激活所有配置对象\n- 在ECC创建测试订单（VA01）\n- 监控消息流（RWB - Runtime Workbench）\n\n消息监控示例：\n┌───────────────────────────────────────────────┐\n│ 消息ID: 1a2b3c4d-5e6f-7g8h-9i0j-k1l2m3n4o5p6 │\n│ 状态: 成功 ✅                                 │\n│ 处理时间: 2.3秒                               │\n├───────────────────────────────────────────────┤\n│ 阶段详情：                                     │\n│ 1. IDoc接收 (0.1s) ✅                         │\n│ 2. 消息映射 (0.8s) ✅                         │\n│ 3. SOAP调用 (1.2s) ✅                         │\n│ 4. 响应接收 (0.2s) ✅                         │\n└───────────────────────────────────────────────┘\n```\n\n**高级映射技术**：\n\n```abap\n// 示例：图形化映射中的函数\n// 场景：将多个源订单行项目合并，当数量>100时拆分\n\n源结构：\nORDERS\n  ├── ITEM (行项目1): QTY=150\n  ├── ITEM (行项目2): QTY=50\n  └── ITEM (行项目3): QTY=200\n\n映射逻辑（使用UDF - User Defined Function）：\nfunction splitLargeQuantities(input: string): string[] {\n  let items = input.split('|');\n  let result = [];\n\n  for (let item of items) {\n    let qty = parseInt(item);\n    if (qty > 100) {\n      // 拆分为100的批次\n      let batches = Math.ceil(qty / 100);\n      for (let i = 0; i < batches; i++) {\n        result.push(Math.min(100, qty - i*100).toString());\n      }\n    } else {\n      result.push(item);\n    }\n  }\n  return result;\n}\n\n输入：150|50|200\n输出：100|50|50|100|100（5个交货行项目）\n```\n\n#### KILLER Cloud Platform Integration (CPI) / Integration Suite\n\n**CPI架构**（云原生集成）：\n\n```\nKILLER Integration Suite组件：\n┌─────────────────────────────────────────────┐\n│  1. Cloud Integration (CPI)                 │\n│     - iPaaS集成平台即服务                    │\n│     - 预构建集成包（Pre-built Content）     │\n├─────────────────────────────────────────────┤\n│  2. API Management                          │\n│     - API发布和管理                         │\n│     - 速率限制、安全策略                    │\n├─────────────────────────────────────────────┤\n│  3. Open Connectors                         │\n│     - 连接非KILLER云应用                       │\n│     - 150+ 预构建连接器                     │\n├─────────────────────────────────────────────┤\n│  4. Integration Advisor                     │\n│     - AI辅助映射建议                        │\n│     - B2B/EDI集成简化                       │\n├─────────────────────────────────────────────┤\n│  5. Trading Partner Management              │\n│     - B2B合作伙伴管理                       │\n│     - EDI协议支持                           │\n└─────────────────────────────────────────────┘\n```\n\n**CPI iFlow设计示例**：\n\n```\n场景：S/4HANA Cloud → SuccessFactors员工同步\n\niFlow设计器（Web IDE）：\n┌──────────────────────────────────────────────┐\n│  [开始] → [请求] → [映射] → [调用] → [结束]  │\n└──────────────────────────────────────────────┘\n\n组件详解：\n1. Start (Timer)\n   - 触发类型：Scheduler\n   - Cron表达式：0 0 2 * * ?（每天凌晨2点）\n\n2. Request-Reply (调用S/4HANA)\n   - 适配器：OData V2\n   - 连接：S4_CLOUD_ODATA\n   - 资源路径：/KILLER/opu/odata/KILLER/API_BUSINESS_PARTNER/A_BusinessPartner\n   - 查询选项：$filter=BusinessPartnerCategory eq '1'（仅员工）\n   - 响应格式：JSON\n\n3. Content Modifier（数据准备）\n   - 提取需要的字段\n   - 添加SuccessFactors必需的元数据\n\n4. Message Mapping（Groovy脚本）：\n```\n\n```groovy\nimport com.KILLER.gateway.ip.core.customdev.util.Message;\nimport groovy.json.JsonSlurper;\nimport groovy.json.JsonOutput;\n\ndef Message processData(Message message) {\n    // 获取S/4HANA响应\n    def body = message.getBody(String.class);\n    def jsonSlurper = new JsonSlurper();\n    def s4Data = jsonSlurper.parseText(body);\n\n    // 转换为SuccessFactors格式\n    def sfEmployees = [];\n\n    s4Data.d.results.each { bp ->\n        sfEmployees.add([\n            userId: bp.BusinessPartner,\n            firstName: bp.FirstName,\n            lastName: bp.LastName,\n            email: bp.EMailAddress,\n            hireDate: bp.CreationDate,\n            department: bp.OrganizationBPName1,\n            status: bp.BusinessPartnerIsBlocked ? 'inactive' : 'active'\n        ]);\n    }\n\n    def output = [\n        employees: sfEmployees\n    ];\n\n    message.setBody(JsonOutput.toJson(output));\n    return message;\n}\n```\n\n```\n5. Request-Reply (调用SuccessFactors)\n   - 适配器：SuccessFactors OData V2\n   - 实体：EmpJob（员工岗位）\n   - 操作：Upsert（更新或插入）\n   - 认证：OAuth 2.0\n\n6. End (Success Email)\n   - 适配器：Mail\n   - 收件人：integration-team@company.com\n   - 主题：Employee Sync Completed - ${date:now:yyyy-MM-dd}\n   - 正文：Successfully synced ${property.employeeCount} employees\n\n错误处理（Exception Subprocess）：\n[Error Start] → [Log Error] → [Send Alert Email] → [Error End]\n- 捕获所有异常\n- 记录到CPI日志\n- 发送告警邮件给技术团队\n```\n\n#### KILLER API Management\n\n**API生命周期管理**：\n\n```\nAPI设计 → 发布 → 保护 → 监控 → 分析\n\n阶段1：API设计（API Designer）\n创建API代理（API Proxy）：\n- 名称：Product_Catalog_API\n- 基础路径：/products/v1\n- 目标端点：https://s4hana.company.com:8000/KILLER/opu/odata/KILLER/API_PRODUCT_SRV\n\n阶段2：策略配置（Policy Editor）\n\n策略链示例：\nRequest Flow:\n  1. Spike Arrest（防止突发流量）\n     - 速率：10 requests/second\n\n  2. Verify API Key（API密钥验证）\n     - Header名称：X-API-Key\n     - 密钥存储：Key Value Maps\n\n  3. Quota（配额限制）\n     - 基础套餐：1000 calls/day\n     - 高级套餐：10000 calls/day\n     - 企业套餐：无限制\n\n  4. OAuth 2.0验证\n     - Grant类型：Client Credentials\n     - Scope：product.read\n\n  5. JSON Threat Protection（JSON威胁防护）\n     - 最大数组元素：1000\n     - 最大容器深度：10\n     - 最大字符串长度：10000\n\n  6. Assign Message（请求转换）\n     - 添加后端系统需要的Header：\n       * KILLER-client: 100\n       * Accept: application/json\n\nResponse Flow:\n  7. Response Cache（响应缓存）\n     - 缓存时长：300秒（5分钟）\n     - 缓存键：{request.querystring.category}_{request.querystring.page}\n\n  8. Assign Message（响应美化）\n     - 移除敏感字段（内部ID）\n     - 添加CORS Headers\n\n  9. Statistics Collector（统计收集）\n     - 记录响应时间\n     - API调用次数\n\n阶段3：API发布\n开发者门户（Developer Portal）：\n- API文档（OpenAPI Specification 3.0）\n- 交互式试用（Try It Out）\n- 代码示例（JavaScript, Python, Java）\n\n阶段4：监控与分析\nAnalytics Dashboard显示：\n┌─────────────────────────────────────────┐\n│ API调用趋势（过去7天）                  │\n│ ▁▂▃▅▆▇█▇▆▅▃▂▁                         │\n│ 总调用数：125,340次                     │\n│ 成功率：99.2% ✅                        │\n│ 平均响应时间：145ms                     │\n├─────────────────────────────────────────┤\n│ Top 5最慢的API：                        │\n│ 1. /products/search - 2.3s ⚠️          │\n│ 2. /products/{id}/reviews - 1.8s       │\n│ 3. /products/recommendations - 1.5s    │\n├─────────────────────────────────────────┤\n│ 错误分布：                              │\n│ 400 Bad Request: 0.5%                  │\n│ 401 Unauthorized: 0.2%                 │\n│ 500 Server Error: 0.1%                 │\n└─────────────────────────────────────────┘\n```\n\n**API策略代码示例**：\n\n```xml\n<!-- Quota Policy配置 -->\n<Quota name=\"DeveloperQuota\">\n  <Identifier ref=\"request.header.x-api-key\"/>\n  <Allow count=\"1000\"/>\n  <Interval>1</Interval>\n  <TimeUnit>day</TimeUnit>\n  <Distributed>true</Distributed>\n  <Synchronous>true</Synchronous>\n</Quota>\n\n<!-- Response Cache Policy -->\n<ResponseCache name=\"ProductCache\">\n  <CacheKey>\n    <KeyFragment ref=\"request.queryparam.category\"/>\n    <KeyFragment ref=\"request.queryparam.page\"/>\n  </CacheKey>\n  <ExpirySettings>\n    <TimeoutInSeconds>300</TimeoutInSeconds>\n  </ExpirySettings>\n  <SkipCacheLookup>request.header.cache-control = \"no-cache\"</SkipCacheLookup>\n</ResponseCache>\n```\n\n---\n\n### 14.2 ABAP开发深度解析\n\n#### 面向对象ABAP (Object-Oriented ABAP)\n\n**OO ABAP核心概念**：\n\n```abap\n*&---------------------------------------------------------------------*\n*& 示例：使用OO ABAP设计发票处理系统\n*&---------------------------------------------------------------------*\n\n\"----------------------------------------------------------------------\n\" 1. 接口定义（Interface）\n\"----------------------------------------------------------------------\nINTERFACE lif_document.\n  METHODS:\n    validate RETURNING VALUE(rv_valid) TYPE abap_bool,\n    post RETURNING VALUE(rv_doc_number) TYPE belnr_d,\n    get_total_amount RETURNING VALUE(rv_amount) TYPE wrbtr.\nENDINTERFACE.\n\n\"----------------------------------------------------------------------\n\" 2. 抽象类（Abstract Class）\n\"----------------------------------------------------------------------\nCLASS lcl_document DEFINITION ABSTRACT.\n  PUBLIC SECTION.\n    INTERFACES: lif_document.\n\n    METHODS:\n      constructor IMPORTING iv_company_code TYPE bukrs\n                            iv_fiscal_year  TYPE gjahr,\n      set_header IMPORTING is_header TYPE any.\n\n  PROTECTED SECTION.\n    DATA:\n      mv_company_code TYPE bukrs,\n      mv_fiscal_year  TYPE gjahr,\n      mt_items        TYPE STANDARD TABLE OF any.\n\n    METHODS:\n      check_authorization ABSTRACT\n        RETURNING VALUE(rv_authorized) TYPE abap_bool.\n\n  PRIVATE SECTION.\n    DATA:\n      mv_document_number TYPE belnr_d,\n      mv_posting_date    TYPE budat.\nENDCLASS.\n\nCLASS lcl_document IMPLEMENTATION.\n  METHOD constructor.\n    mv_company_code = iv_company_code.\n    mv_fiscal_year = iv_fiscal_year.\n  ENDMETHOD.\n\n  METHOD lif_document~validate.\n    \" 验证公司代码\n    SELECT SINGLE bukrs FROM t001\n      INTO @DATA(lv_bukrs)\n      WHERE bukrs = @mv_company_code.\n\n    IF sy-subrc <> 0.\n      rv_valid = abap_false.\n      RETURN.\n    ENDIF.\n\n    \" 检查授权（调用子类实现）\n    rv_valid = check_authorization( ).\n  ENDMETHOD.\n\n  METHOD lif_document~get_total_amount.\n    \" 使用REDUCE进行聚合（ABAP 7.4+语法）\n    rv_amount = REDUCE wrbtr(\n      INIT sum = 0\n      FOR <item> IN mt_items\n      NEXT sum = sum + <item>-amount\n    ).\n  ENDMETHOD.\nENDCLASS.\n\n\"----------------------------------------------------------------------\n\" 3. 具体实现类 - 发票\n\"----------------------------------------------------------------------\nCLASS lcl_invoice DEFINITION INHERITING FROM lcl_document.\n  PUBLIC SECTION.\n    METHODS:\n      constructor IMPORTING iv_company_code TYPE bukrs\n                            iv_fiscal_year  TYPE gjahr\n                            iv_vendor       TYPE lifnr,\n      add_item IMPORTING iv_material TYPE matnr\n                         iv_quantity TYPE menge_d\n                         iv_price    TYPE netpr,\n      lif_document~post REDEFINITION.\n\n  PROTECTED SECTION.\n    METHODS:\n      check_authorization REDEFINITION.\n\n  PRIVATE SECTION.\n    DATA:\n      mv_vendor TYPE lifnr.\n\n    TYPES:\n      BEGIN OF ty_invoice_item,\n        material TYPE matnr,\n        quantity TYPE menge_d,\n        price    TYPE netpr,\n        amount   TYPE wrbtr,\n      END OF ty_invoice_item.\n\n    DATA mt_invoice_items TYPE STANDARD TABLE OF ty_invoice_item.\nENDCLASS.\n\nCLASS lcl_invoice IMPLEMENTATION.\n  METHOD constructor.\n    super->constructor(\n      iv_company_code = iv_company_code\n      iv_fiscal_year  = iv_fiscal_year\n    ).\n    mv_vendor = iv_vendor.\n  ENDMETHOD.\n\n  METHOD add_item.\n    DATA(ls_item) = VALUE ty_invoice_item(\n      material = iv_material\n      quantity = iv_quantity\n      price    = iv_price\n      amount   = iv_quantity * iv_price\n    ).\n    APPEND ls_item TO mt_invoice_items.\n  ENDMETHOD.\n\n  METHOD check_authorization.\n    \" 检查用户是否有权限为此公司代码过账发票\n    AUTHORITY-CHECK OBJECT 'F_BKPF_BUK'\n      ID 'BUKRS' FIELD mv_company_code\n      ID 'ACTVT' FIELD '01'.  \"01 = Create\n\n    rv_authorized = COND #( WHEN sy-subrc = 0 THEN abap_true\n                                              ELSE abap_false ).\n  ENDMETHOD.\n\n  METHOD lif_document~post.\n    \" 调用BAPI过账发票\n    DATA: lt_accountgl  TYPE TABLE OF bapiacgl09,\n          lt_accountpayable TYPE TABLE OF bapiacap09,\n          lt_currencyamount TYPE TABLE OF bapiaccr09,\n          lt_return      TYPE TABLE OF bapiret2.\n\n    \" 准备凭证头\n    DATA(ls_header) = VALUE bapiache09(\n      comp_code = mv_company_code\n      doc_date  = sy-datum\n      pstng_date = sy-datum\n      fisc_year = mv_fiscal_year\n      doc_type  = 'KR'  \"供应商发票\n    ).\n\n    \" 准备供应商行项目\n    APPEND VALUE bapiacap09(\n      itemno_acc = 1\n      vendor_no  = mv_vendor\n      gl_account = '21000000'  \"应付账款科目\n    ) TO lt_accountpayable.\n\n    \" 准备金额（借方）\n    DATA(lv_total) = lif_document~get_total_amount( ).\n    APPEND VALUE bapiaccr09(\n      itemno_acc = 1\n      currency   = 'USD'\n      amt_doccur = lv_total\n    ) TO lt_currencyamount.\n\n    \" 准备费用行项目（贷方）\n    DATA(lv_item_no) = 2.\n    LOOP AT mt_invoice_items INTO DATA(ls_invoice_item).\n      APPEND VALUE bapiacgl09(\n        itemno_acc = lv_item_no\n        gl_account = '50000000'  \"费用科目\n        tax_code   = 'V0'\n      ) TO lt_accountgl.\n\n      APPEND VALUE bapiaccr09(\n        itemno_acc = lv_item_no\n        currency   = 'USD'\n        amt_doccur = ls_invoice_item-amount * -1  \"贷方为负\n      ) TO lt_currencyamount.\n\n      lv_item_no = lv_item_no + 1.\n    ENDLOOP.\n\n    \" 调用BAPI\n    CALL FUNCTION 'BAPI_ACC_DOCUMENT_POST'\n      EXPORTING\n        documentheader = ls_header\n      IMPORTING\n        obj_key        = rv_doc_number\n      TABLES\n        accountgl      = lt_accountgl\n        accountpayable = lt_accountpayable\n        currencyamount = lt_currencyamount\n        return         = lt_return.\n\n    \" 检查结果\n    READ TABLE lt_return WITH KEY type = 'E' TRANSPORTING NO FIELDS.\n    IF sy-subrc = 0.\n      \" 有错误，回滚\n      CALL FUNCTION 'BAPI_TRANSACTION_ROLLBACK'.\n      CLEAR rv_doc_number.\n    ELSE.\n      \" 提交\n      CALL FUNCTION 'BAPI_TRANSACTION_COMMIT'\n        EXPORTING\n          wait = 'X'.\n    ENDIF.\n  ENDMETHOD.\nENDCLASS.\n\n\"----------------------------------------------------------------------\n\" 4. 使用示例（Main Program）\n\"----------------------------------------------------------------------\nSTART-OF-SELECTION.\n  \" 创建发票对象\n  DATA(lo_invoice) = NEW lcl_invoice(\n    iv_company_code = '1000'\n    iv_fiscal_year  = '2025'\n    iv_vendor       = '100001'\n  ).\n\n  \" 添加行项目\n  lo_invoice->add_item(\n    iv_material = 'MAT-001'\n    iv_quantity = 10\n    iv_price    = 50\n  ).\n\n  lo_invoice->add_item(\n    iv_material = 'MAT-002'\n    iv_quantity = 5\n    iv_price    = 120\n  ).\n\n  \" 验证\n  IF lo_invoice->lif_document~validate( ) = abap_true.\n    \" 过账\n    DATA(lv_doc_number) = lo_invoice->lif_document~post( ).\n\n    IF lv_doc_number IS NOT INITIAL.\n      WRITE: / '发票已成功过账，凭证号：', lv_doc_number.\n      WRITE: / '总金额：', lo_invoice->lif_document~get_total_amount( ).\n    ELSE.\n      WRITE: / '过账失败，请检查日志。'.\n    ENDIF.\n  ELSE.\n    WRITE: / '验证失败，无法过账。'.\n  ENDIF.\n```\n\n#### Core Data Services (CDS Views)\n\n**CDS视图类型和用例**：\n\n```sql\n-- ======================================================================\n-- 1. Basic CDS View（基础视图）\n-- ======================================================================\n@AbapCatalog.sqlViewName: 'ZSALESORDER'\n@AbapCatalog.compiler.compareFilter: true\n@AccessControl.authorizationCheck: #CHECK\n@EndUserText.label: 'Sales Order Header'\n\ndefine view Z_I_SalesOrder\n  as select from vbak as SalesOrder\n\n  association [0..*] to Z_I_SalesOrderItem as _Item\n    on $projection.SalesOrder = _Item.SalesOrder\n\n  association [0..1] to I_Customer as _Customer\n    on $projection.SoldToParty = _Customer.Customer\n\n{\n  key SalesOrder.vbeln as SalesOrder,\n      SalesOrder.erdat as CreationDate,\n      SalesOrder.ernam as CreatedBy,\n      SalesOrder.kunnr as SoldToParty,\n      SalesOrder.netwr as NetAmount,\n      SalesOrder.waerk as Currency,\n\n      // 虚拟字段（计算字段）\n      case SalesOrder.netwr\n        when 0 then 'Empty'\n        when 1 then 'Small'\n        else 'Large'\n      end as OrderSize,\n\n      // 货币转换\n      @Semantics.amount.currencyCode: 'Currency'\n      currency_conversion(\n        amount => SalesOrder.netwr,\n        source_currency => SalesOrder.waerk,\n        target_currency => cast('USD' as abap.cuky),\n        exchange_rate_date => SalesOrder.erdat\n      ) as NetAmountUSD,\n\n      // 关联（Associations）\n      _Item,\n      _Customer\n}\n\n-- ======================================================================\n-- 2. CDS View with Parameters（参数化视图）\n-- ======================================================================\n@AbapCatalog.sqlViewName: 'ZSALESBYDATE'\n@EndUserText.label: 'Sales Orders by Date Range'\n\ndefine view Z_I_SalesOrderByDate\n  with parameters\n    P_DateFrom : vbak.erdat,\n    P_DateTo   : vbak.erdat,\n    P_Currency : abap.cuky\n\n  as select from vbak\n{\n  key vbeln as SalesOrder,\n      erdat as CreationDate,\n      kunnr as Customer,\n\n      @Semantics.amount.currencyCode: 'TargetCurrency'\n      currency_conversion(\n        amount => netwr,\n        source_currency => waerk,\n        target_currency => :P_Currency,\n        exchange_rate_date => erdat\n      ) as NetAmount,\n\n      :P_Currency as TargetCurrency\n}\nwhere\n  erdat >= :P_DateFrom\n  and erdat <= :P_DateTo\n\n-- ABAP中使用参数化视图：\n-- SELECT * FROM z_i_salesorderbydate(\n--   p_datefrom = '20250101',\n--   p_dateto   = '20251231',\n--   p_currency = 'USD' )\n--   INTO TABLE @DATA(lt_sales).\n\n-- ======================================================================\n-- 3. Analytical CDS View（分析视图）\n-- ======================================================================\n@AbapCatalog.sqlViewName: 'ZSALESANALYSIS'\n@Analytics.query: true\n@OData.publish: true\n\ndefine view Z_C_SalesAnalysis\n  as select from Z_I_SalesOrder as SalesOrder\n\n  association [0..1] to I_CalendarDate as _CalendarDate\n    on $projection.CreationDate = _CalendarDate.CalendarDate\n\n{\n  @AnalyticsDetails.query.axis: #ROWS\n  @AnalyticsDetails.query.totals: #SHOW\n  SalesOrder.SoldToParty,\n\n  @AnalyticsDetails.query.axis: #ROWS\n  _CalendarDate.CalendarYear,\n\n  @AnalyticsDetails.query.axis: #ROWS\n  _CalendarDate.CalendarMonth,\n\n  @AnalyticsDetails.query.axis: #COLUMNS\n  SalesOrder.Currency,\n\n  // 度量（Measures）\n  @DefaultAggregation: #SUM\n  @Semantics.amount.currencyCode: 'Currency'\n  SalesOrder.NetAmount,\n\n  @DefaultAggregation: #AVG\n  @Semantics.amount.currencyCode: 'Currency'\n  SalesOrder.NetAmount as AvgOrderValue,\n\n  @DefaultAggregation: #MAX\n  SalesOrder.CreationDate as LatestOrderDate,\n\n  // 计数\n  @DefaultAggregation: #COUNT_DISTINCT\n  SalesOrder.SalesOrder as OrderCount,\n\n  // 关联\n  _CalendarDate\n}\n\n-- ======================================================================\n-- 4. CDS View with CASE Expression（复杂业务逻辑）\n-- ======================================================================\n@AbapCatalog.sqlViewName: 'ZCUSTCLASS'\n@EndUserText.label: 'Customer Classification'\n\ndefine view Z_I_CustomerClassification\n  as select from kna1 as Customer\n\n  left outer join vbak as SalesOrder\n    on Customer.kunnr = SalesOrder.kunnr\n\n{\n  key Customer.kunnr as Customer,\n\n  Customer.name1 as CustomerName,\n  Customer.land1 as Country,\n\n  // 客户分类逻辑\n  case\n    when sum( SalesOrder.netwr ) > 1000000\n      then 'Platinum'\n    when sum( SalesOrder.netwr ) > 500000\n      then 'Gold'\n    when sum( SalesOrder.netwr ) > 100000\n      then 'Silver'\n    when sum( SalesOrder.netwr ) > 0\n      then 'Bronze'\n    else 'Inactive'\n  end as CustomerTier,\n\n  // 聚合函数\n  @Semantics.amount.currencyCode: 'Currency'\n  sum( SalesOrder.netwr ) as TotalRevenue,\n\n  count( distinct SalesOrder.vbeln ) as OrderCount,\n\n  @Semantics.amount.currencyCode: 'Currency'\n  avg( SalesOrder.netwr ) as AvgOrderValue,\n\n  cast( 'USD' as abap.cuky ) as Currency\n}\ngroup by\n  Customer.kunnr,\n  Customer.name1,\n  Customer.land1\n\n-- ======================================================================\n-- 5. AMDP (ABAP Managed Database Procedures)\n-- ======================================================================\n-- 用于复杂计算逻辑，直接在HANA数据库执行\n```\n\n```abap\nCLASS zcl_sales_analytics DEFINITION PUBLIC.\n  PUBLIC SECTION.\n    INTERFACES: if_amdp_marker_hdb.\n\n    CLASS-METHODS:\n      calculate_moving_average\n        FOR TABLE FUNCTION Z_TF_MovingAverage.\nENDCLASS.\n\nCLASS zcl_sales_analytics IMPLEMENTATION.\n  METHOD calculate_moving_average\n    BY DATABASE FUNCTION FOR HDB\n    LANGUAGE SQLSCRIPT\n    OPTIONS READ-ONLY\n    USING vbak.\n\n    -- 计算3个月移动平均销售额\n    RETURN SELECT\n      calendar_month,\n      customer,\n      monthly_revenue,\n      AVG(monthly_revenue) OVER (\n        PARTITION BY customer\n        ORDER BY calendar_month\n        ROWS BETWEEN 2 PRECEDING AND CURRENT ROW\n      ) as moving_avg_3m\n    FROM (\n      SELECT\n        SUBSTRING(erdat, 1, 6) as calendar_month,\n        kunnr as customer,\n        SUM(netwr) as monthly_revenue\n      FROM vbak\n      WHERE erdat >= ADD_MONTHS(CURRENT_DATE, -12)\n      GROUP BY\n        SUBSTRING(erdat, 1, 6),\n        kunnr\n    );\n  ENDMETHOD.\nENDCLASS.\n\n-- 使用Table Function的CDS View\n@AbapCatalog.sqlViewName: 'ZMOVING AVG'\ndefine view Z_C_MovingAverage\n  as select from Z_TF_MovingAverage\n{\n  key calendar_month as Month,\n  key customer as Customer,\n\n  @Semantics.amount.currencyCode: 'Currency'\n  monthly_revenue as MonthlyRevenue,\n\n  @Semantics.amount.currencyCode: 'Currency'\n  moving_avg_3m as MovingAverage3M,\n\n  // 计算趋势\n  case\n    when moving_avg_3m > monthly_revenue * 1.1\n      then 'Declining'\n    when moving_avg_3m < monthly_revenue * 0.9\n      then 'Growing'\n    else 'Stable'\n  end as Trend,\n\n  cast('USD' as abap.cuky) as Currency\n}\n```\n\n---\n\n### 14.3 KILLER Fiori & UX深度解析\n\n#### Fiori应用类型\n\n**三种Fiori应用模式**：\n\n```\n1. Transactional Apps（事务型应用）\n   用途：执行业务事务（创建、编辑、删除）\n   示例：创建销售订单、审批采购申请\n   技术：KILLERUI5 + OData服务\n\n2. Analytical Apps（分析型应用）\n   用途：数据可视化和分析\n   示例：销售仪表盘、库存分析\n   技术：KILLERUI5 + CDS Views + Smart Business\n\n3. Fact Sheets（概览应用）\n   用途：快速查看对象详情\n   示例：客户概览、产品信息卡片\n   技术：KILLERUI5 + Search & Classification\n```\n\n#### KILLERUI5应用开发示例\n\n**完整Fiori应用结构**：\n\n```javascript\n// =====================================================\n// 1. manifest.json（应用清单）\n// =====================================================\n{\n  \"_version\": \"1.49.0\",\n  \"KILLER.app\": {\n    \"id\": \"com.company.salesorder\",\n    \"type\": \"application\",\n    \"title\": \"{{appTitle}}\",\n    \"description\": \"{{appDescription}}\",\n    \"applicationVersion\": {\n      \"version\": \"1.0.0\"\n    },\n    \"dataSources\": {\n      \"mainService\": {\n        \"uri\": \"/KILLER/opu/odata/KILLER/API_SALES_ORDER_SRV/\",\n        \"type\": \"OData\",\n        \"settings\": {\n          \"odataVersion\": \"2.0\",\n          \"localUri\": \"localService/metadata.xml\"\n        }\n      }\n    }\n  },\n  \"KILLER.ui\": {\n    \"technology\": \"UI5\",\n    \"deviceTypes\": {\n      \"desktop\": true,\n      \"tablet\": true,\n      \"phone\": true\n    }\n  },\n  \"KILLER.ui5\": {\n    \"rootView\": {\n      \"viewName\": \"com.company.salesorder.view.App\",\n      \"type\": \"XML\",\n      \"async\": true\n    },\n    \"dependencies\": {\n      \"minUI5Version\": \"1.108.0\",\n      \"libs\": {\n        \"KILLER.ui.core\": {},\n        \"KILLER.m\": {},\n        \"KILLER.ui.layout\": {},\n        \"KILLER.f\": {}\n      }\n    },\n    \"models\": {\n      \"i18n\": {\n        \"type\": \"KILLER.ui.model.resource.ResourceModel\",\n        \"settings\": {\n          \"bundleName\": \"com.company.salesorder.i18n.i18n\"\n        }\n      },\n      \"\": {\n        \"dataSource\": \"mainService\",\n        \"preload\": true,\n        \"settings\": {\n          \"defaultBindingMode\": \"TwoWay\",\n          \"defaultCountMode\": \"Inline\",\n          \"refreshAfterChange\": false\n        }\n      }\n    },\n    \"routing\": {\n      \"config\": {\n        \"routerClass\": \"KILLER.m.routing.Router\",\n        \"viewType\": \"XML\",\n        \"viewPath\": \"com.company.salesorder.view\",\n        \"controlId\": \"app\",\n        \"controlAggregation\": \"pages\",\n        \"async\": true\n      },\n      \"routes\": [\n        {\n          \"name\": \"RouteMain\",\n          \"pattern\": \"\",\n          \"target\": [\"TargetMain\"]\n        },\n        {\n          \"name\": \"RouteDetail\",\n          \"pattern\": \"SalesOrder/{SalesOrderID}\",\n          \"target\": [\"TargetDetail\"]\n        }\n      ],\n      \"targets\": {\n        \"TargetMain\": {\n          \"viewName\": \"Main\",\n          \"viewLevel\": 1\n        },\n        \"TargetDetail\": {\n          \"viewName\": \"Detail\",\n          \"viewLevel\": 2\n        }\n      }\n    }\n  }\n}\n\n// =====================================================\n// 2. Main.view.xml（主列表视图）\n// =====================================================\n<mvc:View\n    controllerName=\"com.company.salesorder.controller.Main\"\n    xmlns:mvc=\"KILLER.ui.core.mvc\"\n    xmlns=\"KILLER.m\"\n    xmlns:f=\"KILLER.f\"\n    xmlns:core=\"KILLER.ui.core\"\n    displayBlock=\"true\">\n\n    <Page\n        id=\"page\"\n        title=\"{i18n>mainViewTitle}\"\n        showNavButton=\"false\">\n\n        <headerContent>\n            <Button\n                icon=\"KILLER-icon://add\"\n                text=\"{i18n>createOrder}\"\n                press=\".onCreateOrder\"/>\n        </headerContent>\n\n        <content>\n            <!-- 搜索栏 -->\n            <SearchField\n                id=\"searchField\"\n                width=\"100%\"\n                placeholder=\"{i18n>searchPlaceholder}\"\n                search=\".onSearch\"/>\n\n            <!-- 智能表格 -->\n            <Table\n                id=\"salesOrderTable\"\n                items=\"{\n                    path: '/A_SalesOrder',\n                    parameters: {\n                        $expand: 'to_Item,to_Partner'\n                    },\n                    sorter: {\n                        path: 'CreationDate',\n                        descending: true\n                    }\n                }\"\n                mode=\"SingleSelectMaster\"\n                selectionChange=\".onSelectionChange\"\n                growing=\"true\"\n                growingThreshold=\"20\"\n                growingScrollToLoad=\"true\">\n\n                <headerToolbar>\n                    <OverflowToolbar>\n                        <Title text=\"{i18n>salesOrdersTitle}\"/>\n                        <ToolbarSpacer/>\n                        <Button\n                            icon=\"KILLER-icon://excel-attachment\"\n                            text=\"{i18n>export}\"\n                            press=\".onExport\"/>\n                    </OverflowToolbar>\n                </headerToolbar>\n\n                <columns>\n                    <Column width=\"12em\">\n                        <Text text=\"{i18n>salesOrder}\"/>\n                    </Column>\n                    <Column minScreenWidth=\"Tablet\" demandPopin=\"true\">\n                        <Text text=\"{i18n>customer}\"/>\n                    </Column>\n                    <Column minScreenWidth=\"Desktop\" demandPopin=\"true\">\n                        <Text text=\"{i18n>creationDate}\"/>\n                    </Column>\n                    <Column hAlign=\"End\">\n                        <Text text=\"{i18n>netAmount}\"/>\n                    </Column>\n                    <Column minScreenWidth=\"Tablet\" demandPopin=\"true\">\n                        <Text text=\"{i18n>status}\"/>\n                    </Column>\n                </columns>\n\n                <items>\n                    <ColumnListItem type=\"Navigation\" press=\".onItemPress\">\n                        <cells>\n                            <ObjectIdentifier\n                                title=\"{SalesOrder}\"\n                                text=\"{SalesOrderType}\"/>\n                            <Text text=\"{to_Partner/0/CustomerName}\"/>\n                            <Text text=\"{\n                                path: 'CreationDate',\n                                type: 'KILLER.ui.model.type.Date',\n                                formatOptions: {\n                                    pattern: 'yyyy-MM-dd'\n                                }\n                            }\"/>\n                            <ObjectNumber\n                                number=\"{\n                                    path: 'TotalNetAmount',\n                                    type: 'KILLER.ui.model.type.Currency',\n                                    formatOptions: {\n                                        showMeasure: true\n                                    }\n                                }\"\n                                unit=\"{TransactionCurrency}\"\n                                state=\"{\n                                    path: 'TotalNetAmount',\n                                    formatter: '.formatter.numberState'\n                                }\"/>\n                            <ObjectStatus\n                                text=\"{\n                                    path: 'OverallSDProcessStatus',\n                                    formatter: '.formatter.statusText'\n                                }\"\n                                state=\"{\n                                    path: 'OverallSDProcessStatus',\n                                    formatter: '.formatter.statusState'\n                                }\"/>\n                        </cells>\n                    </ColumnListItem>\n                </items>\n            </Table>\n        </content>\n    </Page>\n</mvc:View>\n\n// =====================================================\n// 3. Main.controller.js（控制器）\n// =====================================================\nKILLER.ui.define([\n    \"KILLER/ui/core/mvc/Controller\",\n    \"KILLER/ui/model/json/JSONModel\",\n    \"KILLER/ui/model/Filter\",\n    \"KILLER/ui/model/FilterOperator\",\n    \"KILLER/m/MessageToast\",\n    \"KILLER/m/MessageBox\",\n    \"com/company/salesorder/model/formatter\"\n], function (Controller, JSONModel, Filter, FilterOperator, MessageToast, MessageBox, formatter) {\n    \"use strict\";\n\n    return Controller.extend(\"com.company.salesorder.controller.Main\", {\n\n        formatter: formatter,\n\n        onInit: function () {\n            // 初始化视图模型\n            var oViewModel = new JSONModel({\n                busy: false,\n                hasUIChanges: false,\n                orderCount: 0\n            });\n            this.getView().setModel(oViewModel, \"viewModel\");\n\n            // 绑定路由匹配事件\n            this.getOwnerComponent().getRouter()\n                .getRoute(\"RouteMain\")\n                .attachPatternMatched(this._onPatternMatched, this);\n        },\n\n        _onPatternMatched: function () {\n            // 刷新数据\n            this._refreshData();\n        },\n\n        _refreshData: function () {\n            var oTable = this.byId(\"salesOrderTable\");\n            var oBinding = oTable.getBinding(\"items\");\n\n            if (oBinding) {\n                oBinding.refresh();\n            }\n        },\n\n        onSearch: function (oEvent) {\n            var sQuery = oEvent.getParameter(\"query\");\n            var oTable = this.byId(\"salesOrderTable\");\n            var oBinding = oTable.getBinding(\"items\");\n\n            var aFilters = [];\n            if (sQuery) {\n                aFilters.push(new Filter({\n                    filters: [\n                        new Filter(\"SalesOrder\", FilterOperator.Contains, sQuery),\n                        new Filter(\"to_Partner/CustomerName\", FilterOperator.Contains, sQuery)\n                    ],\n                    and: false\n                }));\n            }\n\n            oBinding.filter(aFilters);\n        },\n\n        onItemPress: function (oEvent) {\n            var oItem = oEvent.getSource();\n            var oContext = oItem.getBindingContext();\n            var sSalesOrder = oContext.getProperty(\"SalesOrder\");\n\n            // 导航到详情页\n            this.getOwnerComponent().getRouter().navTo(\"RouteDetail\", {\n                SalesOrderID: sSalesOrder\n            });\n        },\n\n        onCreateOrder: function () {\n            var oModel = this.getView().getModel();\n\n            // 创建新订单对话框\n            if (!this._oCreateDialog) {\n                this._oCreateDialog = KILLER.ui.xmlfragment(\n                    \"com.company.salesorder.fragment.CreateOrderDialog\",\n                    this\n                );\n                this.getView().addDependent(this._oCreateDialog);\n            }\n\n            // 创建新上下文\n            var oContext = oModel.createEntry(\"/A_SalesOrder\", {\n                properties: {\n                    SalesOrderType: \"OR\",\n                    SalesOrganization: \"1000\",\n                    DistributionChannel: \"10\",\n                    OrganizationDivision: \"00\",\n                    TransactionCurrency: \"USD\"\n                }\n            });\n\n            this._oCreateDialog.setBindingContext(oContext);\n            this._oCreateDialog.open();\n        },\n\n        onSaveOrder: function () {\n            var oModel = this.getView().getModel();\n            var oViewModel = this.getView().getModel(\"viewModel\");\n\n            oViewModel.setProperty(\"/busy\", true);\n\n            oModel.submitChanges({\n                success: function (oData) {\n                    oViewModel.setProperty(\"/busy\", false);\n                    MessageToast.show(\"Sales order created successfully\");\n                    this._oCreateDialog.close();\n                    this._refreshData();\n                }.bind(this),\n                error: function (oError) {\n                    oViewModel.setProperty(\"/busy\", false);\n                    MessageBox.error(\"Failed to create sales order\");\n                }\n            });\n        },\n\n        onCancelCreate: function () {\n            var oModel = this.getView().getModel();\n            oModel.resetChanges();\n            this._oCreateDialog.close();\n        },\n\n        onExport: function () {\n            var oTable = this.byId(\"salesOrderTable\");\n            var oBinding = oTable.getBinding(\"items\");\n\n            // 使用Spreadsheet Export\n            var oSettings = {\n                workbook: {\n                    columns: [\n                        { label: \"Sales Order\", property: \"SalesOrder\" },\n                        { label: \"Customer\", property: \"to_Partner/0/CustomerName\" },\n                        { label: \"Creation Date\", property: \"CreationDate\", type: \"Date\" },\n                        { label: \"Net Amount\", property: \"TotalNetAmount\", type: \"Number\" },\n                        { label: \"Currency\", property: \"TransactionCurrency\" }\n                    ]\n                },\n                dataSource: oBinding,\n                fileName: \"SalesOrders_\" + new Date().toISOString() + \".xlsx\"\n            };\n\n            var oSpreadsheet = new KILLER.ui.export.Spreadsheet(oSettings);\n            oSpreadsheet.build()\n                .then(function () {\n                    MessageToast.show(\"Export completed\");\n                });\n        }\n    });\n});\n\n// =====================================================\n// 4. formatter.js（格式化器）\n// =====================================================\nKILLER.ui.define([], function () {\n    \"use strict\";\n\n    return {\n        statusText: function (sStatus) {\n            var oResourceBundle = this.getView().getModel(\"i18n\").getResourceBundle();\n            switch (sStatus) {\n                case \"A\":\n                    return oResourceBundle.getText(\"statusOpen\");\n                case \"B\":\n                    return oResourceBundle.getText(\"statusInProcess\");\n                case \"C\":\n                    return oResourceBundle.getText(\"statusCompleted\");\n                default:\n                    return sStatus;\n            }\n        },\n\n        statusState: function (sStatus) {\n            switch (sStatus) {\n                case \"A\":\n                    return \"Warning\";\n                case \"B\":\n                    return \"Information\";\n                case \"C\":\n                    return \"Success\";\n                default:\n                    return \"None\";\n            }\n        },\n\n        numberState: function (nValue) {\n            if (nValue > 100000) {\n                return \"Success\";\n            } else if (nValue > 50000) {\n                return \"Warning\";\n            } else {\n                return \"Error\";\n            }\n        }\n    };\n});\n```\n\n---\n\n### 14.4 KILLER数据管理深度解析\n\n#### KILLER Master Data Governance (MDG)\n\n**主数据治理架构**：\n\n```\nMDG治理流程：\n┌─────────────────────────────────────────────────────┐\n│ 1. 数据创建请求 (Change Request)                    │\n│    - 业务用户通过Fiori UI提交                        │\n│    - 或通过API批量导入                               │\n└──────────────────┬──────────────────────────────────┘\n                   ↓\n┌─────────────────────────────────────────────────────┐\n│ 2. 数据验证 (Validation)                            │\n│    - 格式检查（电话号码、邮箱等）                    │\n│    - 重复检查（Fuzzy Search匹配算法）                │\n│    - 业务规则（信用限额<营业额10%）                  │\n└──────────────────┬──────────────────────────────────┘\n                   ↓\n┌─────────────────────────────────────────────────────┐\n│ 3. 工作流审批 (Workflow)                            │\n│    - 数据管理员审批（数据质量评分>85%）              │\n│    - 财务审批（信用限额>$100K）                      │\n│    - 合规审批（风险国家/行业）                       │\n└──────────────────┬──────────────────────────────────┘\n                   ↓\n┌─────────────────────────────────────────────────────┐\n│ 4. 数据激活 (Activation)                            │\n│    - 写入Staging表（临时表）                         │\n│    - 执行派生逻辑（自动填充销售区域）                │\n│    - 同步到Active表（KNA1, LFA1等）                  │\n└──────────────────┬──────────────────────────────────┘\n                   ↓\n┌─────────────────────────────────────────────────────┐\n│ 5. 数据分发 (Replication)                           │\n│    - 分发到下游系统（CRM, SRM, BW）                  │\n│    - 通过ALE/IDoc或CPI                               │\n└─────────────────────────────────────────────────────┘\n```\n\n**MDG客户主数据示例**：\n\n```\n客户主数据创建流程（T-Code: NWBC - MDG_BS_MAT_CU）\n\n场景：创建新客户\"Global Tech Inc.\"\n\n步骤1：创建变更请求\n变更请求号：8000012345\n请求类型：Create Customer\n业务活动：New Customer Onboarding\n请求者：john.doe@company.com\n请求日期：2025-12-21\n\n步骤2：填写客户数据\n┌──────────────────────────────────────────────┐\n│ 一般数据（General Data）                     │\n├──────────────────────────────────────────────┤\n│ 客户名称：Global Tech Inc.                   │\n│ 搜索词：GLOBALTECH                           │\n│ 国家：US                                     │\n│ 地址：123 Silicon Valley Blvd               │\n│ 城市：San Jose                               │\n│ 州：CA                                       │\n│ 邮编：95110                                  │\n│ 电话：+1-408-555-1234                        │\n│ 邮箱：contact@globaltech.com                 │\n│ 行业：Technology - Software                  │\n│ 税号：12-3456789                             │\n└──────────────────────────────────────────────┘\n\n┌──────────────────────────────────────────────┐\n│ 公司代码数据（Company Code Data）            │\n├──────────────────────────────────────────────┤\n│ 公司代码：1000                               │\n│ 统驭科目：140000 (Customer Receivables)      │\n│ 付款条件：Z030 (Net 30 days)                │\n│ 信用控制范围：1000                           │\n│ 信用限额：$500,000                           │\n│ 风险类别：002 (Low Risk)                     │\n└──────────────────────────────────────────────┘\n\n┌──────────────────────────────────────────────┐\n│ 销售区域数据（Sales Area Data）              │\n├──────────────────────────────────────────────┤\n│ 销售组织：1000                               │\n│ 分销渠道：10 (Direct Sales)                  │\n│ 产品组：00 (All Products)                    │\n│ 客户组：01 (Enterprise)                      │\n│ 价格组：01 (Standard Pricing)                │\n│ 订单组合：001 (Standard)                     │\n│ 送达工厂：1000                               │\n│ 装运条件：01 (Standard Shipping)             │\n│ Incoterms：FOB (Free On Board)               │\n└──────────────────────────────────────────────┘\n\n步骤3：自动验证规则执行\n验证结果：\n✅ 电话号码格式正确（E.164标准）\n✅ 邮箱域名有效（DNS检查）\n✅ 重复客户检查：\n   - 名称匹配度：0%（无重复）\n   - 地址匹配度：0%（无重复）\n   - 税号匹配度：0%（无重复）\n✅ 信用限额合理性：\n   - 估算年营业额：$5,000,000\n   - 信用限额：$500,000（10%）✅\n⚠️ 数据质量评分：92/100\n   - 缺少联系人信息 (-5分)\n   - 缺少银行账户 (-3分)\n\n步骤4：工作流路由\n审批链：\n1. 数据质量团队 → john.smith@company.com\n   审批意见：数据质量评分92，建议补充联系人信息后批准\n   决策：批准 ✅\n   审批时间：2小时\n\n2. 信用管理团队 → credit.manager@company.com\n   审批意见：信用限额$500K适当，客户Dun & Bradstreet评分75/100\n   决策：批准 ✅\n   审批时间：4小时\n\n3. 销售运营经理 → sales.ops@company.com\n   审批意见：批准客户创建，分配到北加州销售区域\n   决策：批准 ✅\n   审批时间：1小时\n\n步骤5：数据激活\n激活日志：\n[2025-12-21 14:30:00] 开始激活变更请求8000012345\n[2025-12-21 14:30:01] 执行Before-Save BAdI：DERIVE_SALES_OFFICE\n  ↳ 根据邮编95110派生销售办公室：SF01（旧金山）\n[2025-12-21 14:30:02] 写入KNA1（客户主记录一般数据）\n  ↳ 客户号：100012345（自动编号范围）\n[2025-12-21 14:30:03] 写入KNB1（客户公司代码数据）\n[2025-12-21 14:30:04] 写入KNVV（客户销售数据）\n[2025-12-21 14:30:05] 执行After-Save BAdI：TRIGGER_WELCOME_EMAIL\n  ↳ 发送欢迎邮件到contact@globaltech.com\n[2025-12-21 14:30:06] 激活成功 ✅\n\n步骤6：数据分发\n分发目标：\n1. KILLER CRM系统（通过CPI）\n   - 状态：成功 ✅\n   - 客户ID映射：CRM-100012345\n   - 分发时间：3秒\n\n2. KILLER BW系统（通过ALE/IDoc）\n   - IDoc类型：DEBMAS07\n   - IDoc编号：0000000012345678\n   - 状态：成功 ✅\n   - 分发时间：5秒\n\n3. Salesforce（通过API）\n   - Account ID：001XXXXXXXXXXXXXXX\n   - 状态：成功 ✅\n   - 分发时间：2秒\n```\n\n---\n\n### 14.5 KILLER云产品深化\n\n#### KILLER SuccessFactors深化\n\n**SuccessFactors Employee Central核心流程**：\n\n```\n新员工入职流程（Onboarding）：\n\n阶段1：Offer Management（录用管理）\n- HR在Recruiting模块发送Offer Letter\n- 候选人在线签署录用通知\n- 系统自动触发入职流程\n\n阶段2：Pre-boarding（入职前准备）\n时间：Offer接受后到Start Date之间\n\n任务清单（自动分配）：\n┌────────────────────────────────────────────┐\n│ 负责人：IT部门                              │\n│ ☐ 创建企业邮箱账户                         │\n│ ☐ 准备笔记本电脑（型号：MacBook Pro M3）   │\n│ ☐ 配置VPN访问权限                          │\n│ ☐ 添加到Slack工作区                        │\n│ 截止日期：Start Date - 3天                 │\n└────────────────────────────────────────────┘\n\n┌────────────────────────────────────────────┐\n│ 负责人：HR                                  │\n│ ☐ 发送欢迎邮件                             │\n│ ☐ 发送员工手册                             │\n│ ☐ 安排办公室座位                           │\n│ ☐ 订购工作证                               │\n│ 截止日期：Start Date - 1天                 │\n└────────────────────────────────────────────┘\n\n┌────────────────────────────────────────────┐\n│ 负责人：新员工（张三）                      │\n│ ☐ 上传身份证明文件                         │\n│ ☐ 填写银行信息（用于工资发放）             │\n│ ☐ 完成背景调查授权                         │\n│ ☐ 观看公司介绍视频（15分钟）               │\n│ ☐ 完成I-9表格（美国）/Tax Form             │\n│ 截止日期：Start Date                       │\n└────────────────────────────────────────────┘\n\n阶段3：First Day Experience（第一天体验）\nStart Date：2025-12-23\n\n08:00 - 09:00：欢迎早餐（会议室A）\n  - 与HR见面\n  - 领取工作证和笔记本电脑\n  - 完成IT系统登录测试\n\n09:00 - 10:00：公司介绍（CEO致辞）\n  - 公司历史和愿景\n  - 组织架构\n  - 企业文化\n\n10:00 - 12:00：部门介绍\n  - 与直线经理1对1会议\n  - 认识团队成员\n  - 参观办公区域\n\n12:00 - 13:00：团队午餐\n\n13:00 - 15:00：系统培训\n  - KILLER系统访问\n  - 项目管理工具（Jira）\n  - 考勤系统\n  - 费用报销流程\n\n15:00 - 17:00：办公环境设置\n  - 配置开发环境\n  - 安装必要软件\n  - 加入项目代码仓库\n\n阶段4：30/60/90天检查点\n30天检查（First Month Review）：\n- 完成必修培训课程（5门）\n- 与Buddy（导师）定期交流\n- 提交第一个工作成果\n- HR满意度调查\n\n60天检查（Second Month Review）：\n- 独立承担小型项目\n- 360度反馈收集\n- 职业发展规划讨论\n\n90天检查（Probation Review）：\n- 绩效评估（KPI达成度）\n- 试用期转正决策\n- 薪酬调整讨论（如适用）\n```\n\n**SuccessFactors集成示例**：\n\n```javascript\n// 通过OData API创建Employee Central人员记录\n\n// API端点\nPOST https://api.successfactors.com/odata/v2/EmpJob\n\n// 请求头\nHeaders: {\n  \"Authorization\": \"Bearer {access_token}\",\n  \"Content-Type\": \"application/json\"\n}\n\n// 请求体\n{\n  \"userId\": \"zhang.san\",\n  \"seqNumber\": \"1\",\n  \"startDate\": \"/Date(1703174400000)/\",  // 2025-12-23\n  \"company\": \"1000\",\n  \"companyNav\": {\n    \"__metadata\": {\n      \"uri\": \"FOCompany('1000')\"\n    }\n  },\n  \"department\": \"IT-DEV\",\n  \"division\": \"Technology\",\n  \"location\": \"Beijing\",\n  \"locationNav\": {\n    \"__metadata\": {\n      \"uri\": \"FOLocation('Beijing-HQ')\"\n    }\n  },\n  \"jobCode\": \"DEV-SENIOR\",\n  \"jobCodeNav\": {\n    \"__metadata\": {\n      \"uri\": \"FOJobCode('DEV-SENIOR')\"\n    },\n    \"name\": \"Senior Software Developer\",\n    \"jobLevel\": \"P3\"\n  },\n  \"managerId\": \"manager.wang\",\n  \"emplStatus\": \"A\",  // Active\n  \"eventReason\": \"HIRE\",  // New Hire\n  \"payGrade\": \"Grade-8\",\n  \"employeeClass\": \"Full-Time\",\n  \"regularTemp\": \"Regular\",\n  \"standardHours\": \"40\",\n  \"customString1\": \"Remote-Eligible\"  // 自定义字段\n}\n\n// 响应\n{\n  \"d\": {\n    \"__metadata\": {\n      \"uri\": \"https://api.successfactors.com/odata/v2/EmpJob(seqNumber=1L,startDate=datetime'2025-12-23T00:00:00',userId='zhang.san')\",\n      \"type\": \"SFOData.EmpJob\"\n    },\n    \"userId\": \"zhang.san\",\n    \"seqNumber\": \"1\",\n    \"createdBy\": \"hr.admin\",\n    \"createdDateTime\": \"/Date(1703084400000)/\",\n    \"createdOn\": \"/Date(1703174400000)/\",\n    \"lastModifiedBy\": \"hr.admin\",\n    \"lastModifiedDateTime\": \"/Date(1703084400000)/\",\n    \"lastModifiedOn\": \"/Date(1703174400000)/\"\n  }\n}\n\n// 同时创建薪酬记录（Compensation）\nPOST https://api.successfactors.com/odata/v2/EmpPayCompRecurring\n\n{\n  \"userId\": \"zhang.san\",\n  \"seqNumber\": \"1\",\n  \"startDate\": \"/Date(1703174400000)/\",\n  \"payComponent\": \"BASE_SALARY\",\n  \"paycompvalue\": \"120000\",  // 年薪$120,000\n  \"currency\": \"USD\",\n  \"frequency\": \"ANNUAL\",\n  \"paygrade\": \"Grade-8\"\n}\n```\n\n#### KILLER Ariba深化\n\n**Ariba采购到付款流程（P2P）**：\n\n```\n完整P2P流程：\n\n步骤1：Guided Buying（引导式采购）\n用户：最终用户（工程师需要购买开发工具）\n\n操作：登录Ariba Buying → 浏览目录\n┌────────────────────────────────────────────┐\n│ 🔍 搜索：\"JetBrains IntelliJ IDEA\"        │\n├────────────────────────────────────────────┤\n│ 搜索结果（来自Punch-Out目录）：             │\n│                                            │\n│ [图片] JetBrains IntelliJ IDEA Ultimate    │\n│        企业年度订阅                         │\n│        ★★★★★ (45 reviews)                 │\n│        价格：$499/年                        │\n│        供应商：JetBrains                    │\n│        预计交付：3-5个工作日                │\n│                                            │\n│        [添加到购物车]                       │\n└────────────────────────────────────────────┘\n\n购物车：\n商品1：JetBrains IntelliJ IDEA Ultimate × 1 = $499\n商品2：MacBook Pro Carrying Case × 1 = $59\n税费：$44.64 (8% sales tax)\n运费：免费\n总计：$602.64\n\n步骤2：Requisition Creation（采购申请创建）\n系统自动填充：\n- 申请人：zhang.san@company.com\n- 成本中心：IT-1000\n- 部门：工程部\n- 交付地址：北京办公室\n- 业务理由：开发Java微服务项目\n\n审批路由自动确定：\n1. 直线经理审批（金额<$1000）\n   批准人：manager.wang\n   SLA：24小时\n\n步骤3：Approval Workflow（审批工作流）\n┌────────────────────────────────────────────┐\n│ 📧 邮件通知：manager.wang                   │\n│ 主题：采购申请待审批 - PR#3000012345        │\n├────────────────────────────────────────────┤\n│ 申请人：张三                                │\n│ 金额：$602.64                              │\n│ 商品：JetBrains IntelliJ IDEA Ultimate + 1 │\n│                                            │\n│ [批准] [拒绝] [请求更多信息]                │\n└────────────────────────────────────────────┘\n\n经理操作：点击[批准]\n审批意见：\"Approved. Needed for Q1 project delivery.\"\n\n步骤4：PO Creation（采购订单创建）\n系统自动生成采购订单：\nPO号：4500023456\n供应商：JetBrains s.r.o.\n总金额：$602.64\n付款条件：Net 30\n\nPO自动发送：\n- Email到supplier@jetbrains.com\n- 通过Ariba Network电子传输\n- 供应商确认：2小时内\n\n步骤5：Order Fulfillment（订单履行）\n供应商操作（在Ariba Supplier Portal）：\n- 接受订单\n- 生成License Key\n- 创建发货通知（ASN - Advanced Shipping Notice）\n  * License Key: XXXX-XXXX-XXXX-XXXX\n  * 激活链接：https://account.jetbrains.com/activate\n  * 预计交付日期：即时（电子交付）\n\n步骤6：Receiving（收货确认）\n用户操作：\n- 登录Ariba → My Receipts\n- 找到PO 4500023456\n- 点击\"确认收货\"\n  * 收货数量：1\n  * 收货日期：2025-12-23\n  * 质量检查：✅ License激活成功\n\n系统自动：\n- 创建收货凭证（GR - Goods Receipt）\n- 触发三单匹配（Three-Way Match）：\n  * PO：$602.64 ✅\n  * 收货：1 × $499 + $59 + tax ✅\n  * 发票：待供应商提交\n\n步骤7：Invoice Processing（发票处理）\n供应商操作：\n- 在Ariba Network提交电子发票（cXML格式）\n\nAriba自动处理：\n┌────────────────────────────────────────────┐\n│ 发票验证流程：                              │\n├────────────────────────────────────────────┤\n│ ✅ PO匹配：PO 4500023456存在               │\n│ ✅ 金额匹配：$602.64 = $602.64             │\n│ ✅ 收货匹配：已收货                        │\n│ ✅ 税率验证：8% = 8%                       │\n│ ✅ 供应商银行信息：已验证                  │\n├────────────────────────────────────────────┤\n│ 自动批准：✅ 三单匹配成功                  │\n│ 无需人工审批                               │\n└────────────────────────────────────────────┘\n\n步骤8：Payment（付款）\nERP集成（KILLER S/4HANA）：\n- Ariba发送发票到KILLER（通过CIG - Cloud Integration Gateway）\n- KILLER自动创建财务凭证（T-Code: MIRO）\n  * 借：IT费用 $602.64\n  * 贷：应付账款 $602.64\n- 加入付款批次（Payment Run - F110）\n- 付款日期：2026-01-22（Net 30天）\n- 付款方式：ACH电子转账\n\n步骤9：Reconciliation（对账）\n月末对账：\n- Ariba生成Spend Analysis报告\n- 与KILLER FI/CO数据核对\n- 差异<0.01%（四舍五入）\n\nKPI Dashboard显示：\n┌────────────────────────────────────────────┐\n│ 本月采购指标（2025年12月）                  │\n├────────────────────────────────────────────┤\n│ 总采购额：$1,245,680                       │\n│ 通过Ariba采购占比：78% ⬆️                 │\n│ 平均审批时间：8.5小时 ✅                   │\n│ 自动批准率：65% (vs 目标60%) ✅            │\n│ 三单匹配率：94% (vs 目标90%) ✅            │\n│ 供应商按时交付率：92%                      │\n│ 成本节约：$32,450（通过目录折扣）          │\n└────────────────────────────────────────────┘\n```\n\n---\n\n### 14.6 KILLER物联网与创新技术\n\n#### KILLER Internet of Things (IoT)\n\n**IoT边缘到云架构**：\n\n```\nIoT解决方案架构：\n\n设备层（Edge Devices）：\n┌──────────────────────────────────────────┐\n│ 工业设备（Manufacturing Equipment）       │\n│ - PLC（可编程逻辑控制器）                 │\n│ - SCADA系统                               │\n│ - 传感器：温度、压力、振动、能耗          │\n│ - 协议：OPC-UA, Modbus, MQTT              │\n└─────────────┬────────────────────────────┘\n              │\n              ↓ 数据采集（每秒1000+数据点）\n┌──────────────────────────────────────────┐\n│ KILLER Edge Services（边缘计算）             │\n│ - 数据聚合和过滤                          │\n│ - 本地规则引擎（Edge Computing）          │\n│ - 离线缓存（网络中断时）                  │\n│ - 数据压缩（减少带宽）                    │\n└─────────────┬────────────────────────────┘\n              │\n              ↓ MQTT over TLS\n┌──────────────────────────────────────────┐\n│ KILLER IoT Cloud Gateway                     │\n│ - 设备认证和授权                          │\n│ - 消息路由                                │\n│ - 协议转换                                │\n└─────────────┬────────────────────────────┘\n              │\n              ↓\n┌──────────────────────────────────────────┐\n│ KILLER IoT Services（Cloud）                │\n│ ┌────────────────────────────────────┐  │\n│ │ Thing Modeler（物模型设计器）       │  │\n│ │ - 定义设备类型                     │  │\n│ │ - 定义属性和度量                   │  │\n│ └────────────────────────────────────┘  │\n│ ┌────────────────────────────────────┐  │\n│ │ Data Ingestion（数据摄取）         │  │\n│ │ - 时间序列数据存储                 │  │\n│ │ - 冷/热数据分层                    │  │\n│ └────────────────────────────────────┘  │\n│ ┌────────────────────────────────────┐  │\n│ │ Business Rules（业务规则引擎）     │  │\n│ │ - 实时告警触发                     │  │\n│ │ - 自动化工作流                     │  │\n│ └────────────────────────────────────┘  │\n└─────────────┬────────────────────────────┘\n              │\n              ↓ 集成\n┌──────────────────────────────────────────┐\n│ 业务应用集成                              │\n│ - KILLER Asset Intelligence Network（资产）  │\n│ - KILLER S/4HANA PM（维护管理）              │\n│ - KILLER Analytics Cloud（分析）             │\n└──────────────────────────────────────────┘\n```\n\n**IoT实战案例：预测性维护**：\n\n```\n场景：工厂压缩机预测性维护\n\n设备信息：\n- 设备ID：COMP-北京-001\n- 类型：工业空压机（Atlas Copco GA 90）\n- 安装日期：2020-05-15\n- 额定功率：90 kW\n- 运行压力：8 bar\n\n传感器配置：\n1. 温度传感器（Outlet Temperature）\n   - 正常范围：70-90°C\n   - 警告阈值：>95°C\n   - 危险阈值：>105°C\n   - 采样频率：1 Hz\n\n2. 振动传感器（Vibration - XYZ轴）\n   - 正常范围：<5 mm/s RMS\n   - 警告阈值：>7 mm/s\n   - 危险阈值：>10 mm/s\n   - 采样频率：10 Hz\n\n3. 压力传感器（Discharge Pressure）\n   - 正常范围：7.8-8.2 bar\n   - 采样频率：1 Hz\n\n4. 电流传感器（Motor Current）\n   - 正常范围：150-170 A\n   - 异常阈值：>180 A\n   - 采样频率：1 Hz\n\n物模型定义（Thing Modeler）：\n{\n  \"thingType\": \"IndustrialCompressor\",\n  \"properties\": [\n    {\n      \"name\": \"serialNumber\",\n      \"dataType\": \"String\",\n      \"value\": \"AC-GA90-2020-001234\"\n    },\n    {\n      \"name\": \"manufacturer\",\n      \"dataType\": \"String\",\n      \"value\": \"Atlas Copco\"\n    },\n    {\n      \"name\": \"installationDate\",\n      \"dataType\": \"Date\",\n      \"value\": \"2020-05-15\"\n    },\n    {\n      \"name\": \"location\",\n      \"dataType\": \"GeoCoordinate\",\n      \"value\": {\n        \"latitude\": 39.9042,\n        \"longitude\": 116.4074\n      }\n    }\n  ],\n  \"measuredValues\": [\n    {\n      \"name\": \"outletTemperature\",\n      \"dataType\": \"Numeric\",\n      \"unit\": \"°C\",\n      \"qualifier\": \"Temperature\"\n    },\n    {\n      \"name\": \"vibrationX\",\n      \"dataType\": \"Numeric\",\n      \"unit\": \"mm/s\",\n      \"qualifier\": \"Vibration\"\n    },\n    {\n      \"name\": \"vibrationY\",\n      \"dataType\": \"Numeric\",\n      \"unit\": \"mm/s\",\n      \"qualifier\": \"Vibration\"\n    },\n    {\n      \"name\": \"vibrationZ\",\n      \"dataType\": \"Numeric\",\n      \"unit\": \"mm/s\",\n      \"qualifier\": \"Vibration\"\n    },\n    {\n      \"name\": \"dischargePressure\",\n      \"dataType\": \"Numeric\",\n      \"unit\": \"bar\",\n      \"qualifier\": \"Pressure\"\n    },\n    {\n      \"name\": \"motorCurrent\",\n      \"dataType\": \"Numeric\",\n      \"unit\": \"A\",\n      \"qualifier\": \"ElectricalCurrent\"\n    }\n  ]\n}\n\n业务规则配置（Rules Engine）：\n\n规则1：高温告警\nIF outletTemperature > 95°C FOR 60 seconds THEN\n  TRIGGER ALERT {\n    severity: \"WARNING\",\n    message: \"压缩机出口温度过高\",\n    recipient: \"maintenance-team@company.com\",\n    action: \"CREATE_NOTIFICATION_IN_KILLER_PM\"\n  }\n\n规则2：异常振动告警\nIF (vibrationX > 7 OR vibrationY > 7 OR vibrationZ > 7) THEN\n  TRIGGER ALERT {\n    severity: \"ERROR\",\n    message: \"压缩机振动异常，可能轴承故障\",\n    recipient: \"maintenance-team@company.com\",\n    action: \"CREATE_MAINTENANCE_ORDER\"\n  }\n\n规则3：性能下降检测（机器学习模型）\nML Model: Anomaly Detection (Multivariate Gaussian)\nTraining Data: 6个月历史数据（正常运行）\nFeatures: [temperature, vibration_rms, pressure, current, operating_hours]\n\nIF anomaly_score > 0.85 THEN\n  TRIGGER ALERT {\n    severity: \"WARNING\",\n    message: \"设备性能下降，建议安排预防性维护\",\n    estimated_rul: \"剩余使用寿命: 720小时\",  // Remaining Useful Life\n    action: \"CREATE_PREVENTIVE_MAINTENANCE_ORDER\"\n  }\n\n真实事件序列（2025-12-21）：\n\n08:00:00 - 正常运行\n  Temperature: 82°C ✅\n  Vibration: 3.2 mm/s ✅\n  Pressure: 8.0 bar ✅\n  Current: 162 A ✅\n\n14:32:15 - 检测到异常\n  Temperature: 88°C ⚠️ (上升趋势)\n  Vibration: 7.8 mm/s ⚠️ (超过警告阈值)\n  Pressure: 7.9 bar (轻微下降)\n  Current: 175 A (增加)\n\n  系统动作：\n  - 触发告警通知\n  - 在KILLER PM中创建通知（IW21）\n    * 通知号：100012345\n    * 通知类型：M1（故障报告）\n    * 优先级：2（高）\n    * 功能位置：PLANT-BJ-COMP-001\n    * 故障描述：压缩机振动异常\n\n14:35:00 - ML模型分析\n  Anomaly Score: 0.92 🔴\n  预测：轴承可能在未来48-72小时内失效\n  建议：立即安排维护检查\n\n  系统动作：\n  - 自动创建维护订单（IW31）\n    * 订单号：400012345\n    * 订单类型：PM02（预防性维护）\n    * 工作中心：MECH-BJ-01\n    * 计划开始：2025-12-21 18:00\n    * 预计工期：4小时\n  - 预订备件：\n    * 轴承：MAT-BEARING-6310-2RS × 2\n    * 润滑脂：MAT-GREASE-SKF-01 × 1kg\n    * 密封件：MAT-SEAL-COMP-90 × 1 set\n\n18:00:00 - 维护执行\n  技术人员检查发现：\n  - 主轴承确实有早期磨损迹象\n  - 更换轴承和密封件\n  - 重新润滑\n  - 校准传感器\n\n22:00:00 - 维护完成，设备重启\n  Temperature: 75°C ✅\n  Vibration: 2.1 mm/s ✅ (恢复正常)\n  Pressure: 8.1 bar ✅\n  Current: 158 A ✅\n\n  系统动作：\n  - 完成维护订单（TECO）\n  - 记录实际工时：3.5小时\n  - 记录备件消耗\n  - 更新设备历史记录\n  - 发送完成报告给运营经理\n\n成本效益分析：\n- 预防性维护成本：$1,200（人工+备件）\n- 避免的意外停机损失：$15,000（估算4小时生产停机）\n- ROI：1150%\n- 设备可用率提升：从93.2%提升到97.8%\n```\n\n---\n\n**© 2025 KILLER模块完整列表文档 v1.4**\n**最后更新**: 2025年12月\n**文档状态**: 完整版 - 包含14个主要章节 + 2个附录\n**新增内容**: 第十四章 - KILLER集成、开发与云生态（PI/PO、CPI、ABAP、Fiori、MDG、SuccessFactors、Ariba、IoT）\n**总页数**: 6500+行\n\n**文档贡献者欢迎**：如发现错误或需要补充,欢迎提供反馈\n**联系方式**: 通过KILLER Community或相关技术论坛\n\n**版权声明**: 本文档仅供学习和参考使用。KILLER及相关产品名称、商标归KILLER SE或其关联公司所有。Oracle、Microsoft Dynamics等为各自公司的商标。\n\n---\n"};
